<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","build.rs"],"content":"extern crate cbindgen;\nextern crate regex;\nextern crate serde;\nextern crate serde_json;\n\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\n\nuse regex::Regex;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Constant {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    value: usize,\n}\n\n#[derive(Serialize)]\nstruct Alias {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    typename: String,\n}\n\n#[derive(Serialize)]\nstruct Param {\n    name: String,\n    typename: String,\n}\n\n#[derive(Serialize)]\nstruct Function {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    return_param: String,\n    input_params: Vec\u003cParam\u003e,\n}\n\n#[derive(Serialize)]\nstruct Data {\n    constants: Vec\u003cConstant\u003e,\n    aliases: Vec\u003cAlias\u003e,\n    callbacks: Vec\u003cFunction\u003e,\n    functions: Vec\u003cFunction\u003e,\n}\n\nfn parse_param(params_raw: \u0026str) -\u003e Vec\u003cParam\u003e {\n    // function param\n    let param_pattern = Regex::new(r\"(?m)(?P\u003ctype\u003e(\\w+ \\**)+)(?P\u003cname\u003e\\w+)\").unwrap();\n    // pattern for our gosling structs\n    let struct_gosling_pattern = Regex::new(r\"(?m)struct (?P\u003cname\u003egosling_[\\w]+) \").unwrap();\n\n    let mut params: Vec\u003cParam\u003e = Default::default();\n    for param in param_pattern.captures_iter(params_raw) {\n        let t = \u0026param[\"type\"];\n        let t = match struct_gosling_pattern.captures(t) {\n            Some(cap) =\u003e struct_gosling_pattern.replace(t, \u0026cap[\"name\"]).to_string(),\n            None =\u003e t.to_string(),\n        };\n        let t = t.replace(\" *\", \"*\");\n        let n = \u0026param[\"name\"];\n\n        params.push(Param {\n            name: n.to_string(),\n            typename: t.trim().to_string(),\n        });\n    }\n    params\n}\n\nfn parse_header(mut file: File, source: \u0026str) {\n    // hacky-preprocess to exclude relevant platform-specific declarations\n    #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n    let platform_pattern =\n        Regex::new(r\"(?m)#if defined\\(GOSLING_PLATFORM_WINDOWS\\)([^#].*\\n)+#endif\").unwrap();\n    #[cfg(target_os = \"windows\")]\n    let platform_pattern = Regex::new(r\"(?m)#if \\(defined\\(GOSLING_PLATFORM_LINUX\\) \\|\\| defined\\(GOSLING_PLATFORM_MACOS\\)\\)([^#].*\\n)+#endif\").unwrap();\n\n    let source = platform_pattern.replace_all(source, \"\").to_string();\n    let source = source.as_str();\n\n    // all of the lines we cre about have this general form of muliple // style comments,\n    // followed by a single source line we care about\n    let commented_source_pattern =\n        Regex::new(r\"(?m)(?\u003ccomments\u003e(?:\\/\\/.*\\n)+)(?\u003csource\u003e.+)\").unwrap();\n    let comment_pattern =\n        Regex::new(r\"(?m)^\\/\\/[ ]?\").unwrap();\n\n    // constant pattern\n    let constant_pattern =\n        Regex::new(r\"^#define (?P\u003cname\u003e[A-Z0-9_]+) (?P\u003cvalue\u003e[0-9]+)$\").unwrap();\n    // primitive types\n    let typedef_pattern =\n        Regex::new(r\"^typedef (?P\u003ctype\u003e[\\w \\*]+) (?P\u003cname\u003egosling_[\\w]+);$\").unwrap();\n    // callback types\n    let callback_pattern =\n        Regex::new(r\"^typedef (?P\u003creturn\u003e[\\w \\*]+) \\(\\*(?P\u003cname\u003egosling_[\\w]+_t)\\)\\((?P\u003cparams\u003e[\\w ,\\*]*)\\);$\").unwrap();\n    // function declaration\n    let function_pattern =\n        Regex::new(r\"^(?P\u003creturn\u003e[\\w \\*]+( | \\*))(?P\u003cname\u003egosling_[\\w]+)\\((?P\u003cparams\u003e[\\w ,\\*]*)\\);$\").unwrap();\n\n    let mut constants: Vec\u003cConstant\u003e = Default::default();\n    let mut aliases: Vec\u003cAlias\u003e = Default::default();\n    let mut callbacks: Vec\u003cFunction\u003e = Default::default();\n    let mut functions: Vec\u003cFunction\u003e = Default::default();\n\n    for commmented_source in commented_source_pattern.captures_iter(source) {\n        let comments = \u0026commmented_source[\"comments\"];\n        let comments = comment_pattern.replace_all(comments, \"\");\n        let comments = comments.trim();\n        let comments = comments.split('\\n').map(|s| s.to_string()).collect();\n\n        let source = \u0026commmented_source[\"source\"];\n\n        // try parse constant\n        if let Some(constant) = constant_pattern.captures(source) {\n            let name = constant[\"name\"].to_lowercase();\n            let value = constant[\"value\"].parse::\u003cusize\u003e().unwrap();\n            constants.push(Constant {\n                name,\n                value,\n                comments,\n            });\n        // try parse alias\n        } else if let Some(alias) = typedef_pattern.captures(source) {\n            let t = \u0026alias[\"type\"];\n            let n = \u0026alias[\"name\"];\n\n            if t == format!(\"struct {}\", n) {\n                aliases.push(Alias {\n                    name: n.to_string(),\n                    typename: \"uintptr_t\".to_string(),\n                    comments,\n                });\n            } else {\n                aliases.push(Alias {\n                    name: n.to_string(),\n                    typename: t.trim().to_string(),\n                    comments,\n                });\n            }\n        // try parse callback declaration\n        } else if let Some(callback) = callback_pattern.captures(source) {\n            let r = \u0026callback[\"return\"];\n            let n = \u0026callback[\"name\"];\n            let p = \u0026callback[\"params\"];\n\n            // move the pointer char next to the type\n            let r = r.trim().replace(\" *\", \"*\");\n\n            let params = parse_param(p);\n            callbacks.push(Function {\n                name: n.to_string(),\n                return_param: r,\n                input_params: params,\n                comments,\n            });\n        // try parse function declaration\n        } else if let Some(function) = function_pattern.captures(source) {\n            let r = \u0026function[\"return\"];\n            let n = \u0026function[\"name\"];\n            let p = \u0026function[\"params\"];\n\n            // move the pointer char next to the type\n            let r = r.trim().replace(\" *\", \"*\");\n\n            let params = parse_param(p);\n            functions.push(Function {\n                name: n.to_string(),\n                return_param: r,\n                input_params: params,\n                comments,\n            });\n        }\n    }\n\n    let data = Data {\n        constants,\n        aliases,\n        callbacks,\n        functions,\n    };\n    writeln!(file, \"{}\", serde_json::to_string_pretty(\u0026data).unwrap()).unwrap();\n}\n\nfn main() {\n\n    if cfg! (not(feature = \"impl-lib\")) {\n        // set by cargo\n        let crate_dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n        // Set by the user or by cmake.\n        let target_dir = match std::env::var(\"CARGO_TARGET_DIR\") {\n            Ok(target) =\u003e PathBuf::from(target),\n            Err(_) =\u003e Path::new(\u0026crate_dir).join(\"target\"),\n        };\n\n        let header_file_path = target_dir.join(\"include\").join(\"cgosling.h\");\n        println!(\"cargo:rerun-if-changed={}\",header_file_path.display());\n\n        // generate libgosling.h C header\n        match cbindgen::generate(\u0026crate_dir) {\n            Ok(bindings) =\u003e bindings.write_to_file(header_file_path.clone().into_os_string()),\n            Err(cbindgen::Error::ParseSyntaxError { .. }) =\u003e return, // ignore in favor of cargo's syntax check\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        };\n\n        // convert generated header to json IDL\n        let json_file_path = target_dir.join(\"cgosling.json\");\n        println!(\"cargo:rerun-if-changed={}\",json_file_path.display());\n        let json_file = match File::create(json_file_path) {\n            Ok(file) =\u003e file,\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        };\n        let source = std::fs::read_to_string(header_file_path).unwrap();\n\n        parse_header(json_file, source.as_str());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","fuzz","fuzz_targets","fuzz_cgosling.rs"],"content":"#![no_main]\n\nuse std::ffi::{c_char, c_int};\nuse std::ptr;\n\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nuse cgosling::ffi::*;\n\n#[derive(Arbitrary, Debug)]\nenum Handle {\n    Null,\n    Valid(usize),\n    Invalid(usize),\n}\n\n#[derive(Arbitrary, Debug)]\nenum PHandle {\n    Null,\n    Valid,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Callback {\n    Null,\n    Valid,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Buffer\u003cT\u003e {\n    Null,\n    Valid(Vec\u003cT\u003e),\n}\n\n#[derive(Arbitrary, Debug)]\nenum Primitive\u003cT\u003e {\n    Valid(T),\n    Invalid(T),\n}\n\n#[derive(Arbitrary, Debug)]\nenum Function {\n    ErrorGetMessage{\n        error: Handle,\n    },\n    ErrorClone{\n        error_copy: PHandle,\n        orig_error: Handle,\n        out_error: PHandle,\n    },\n    ErrorFree{\n        error: Handle,\n    },\n    Ed25519PrivateKeyFree{\n        private_key: Handle,\n    },\n    X25519PrivateKeyFree{\n        private_key: Handle,\n    },\n    X25519PublicKeyFree{\n        public_key: Handle,\n    },\n    V3OnionServiceIdFree{\n        service_id: Handle,\n    },\n    ContextFree{\n        context: Handle,\n    },\n    TorProviderFree{\n        tor_provider: Handle,\n    },\n    LibraryInit{\n        out_library: PHandle,\n        out_error: PHandle,\n    },\n    LibraryFree{\n        library: Handle,\n    },\n    // Ed25519 Priavate Key Functions\n    Ed25519PrivateKeyGenerate{\n        out_private_key: PHandle,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyClone{\n        out_private_key: PHandle,\n        private_key: Handle,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyFromKeyblob{\n        out_private_key: PHandle,\n        key_blob: Buffer\u003cc_char\u003e,\n        key_blob_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyToKeyblob{\n        private_key: Handle,\n        out_key_blob: Buffer\u003cc_char\u003e,\n        key_blob_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // X25519 Private Key Functions\n    X25519PrivateKeyClone{\n        out_private_key: PHandle,\n        private_key: Handle,\n        out_error: PHandle,\n    },\n    X25519PrivateKeyFromBase64{\n        out_private_key: PHandle,\n        base64: Buffer\u003cc_char\u003e,\n        base64_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    X25519PrivateKeyToBase64{\n        private_key: Handle,\n        out_base64: Buffer\u003cc_char\u003e,\n        base64_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // X25519 Public Key Functions\n    X25519PublicKeyClone{\n        out_public_key: PHandle,\n        public_key: Handle,\n        out_error: PHandle,\n    },\n    X25519PublicKeyFromBase32{\n        out_public_key: PHandle,\n        base32: Buffer\u003cc_char\u003e,\n        base32_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    X25519PublicKeyToBase32{\n        public_key: Handle,\n        out_base32: Buffer\u003cc_char\u003e,\n        base32_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // V3 Onion Service Id Functions\n    V3OnionServiceIdClone{\n        out_service_id: PHandle,\n        service_id: Handle,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdFromString{\n        out_service_id: PHandle,\n        service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdFromEd25519PrivateKey{\n        out_service_id: PHandle,\n        ed25519_private_key: Handle,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdToString{\n        service_id: Handle,\n        out_service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    StringIsValidV3OnionServiceId{\n        service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // TorProvider Functions\n    TorProviderNewMockClient{\n        out_tor_provider: PHandle,\n        out_error: PHandle,\n    },\n    // Context Functions\n    ContextInit{\n        out_context: PHandle,\n        tor_provider: Handle,\n        identity_port: u16,\n        endpoint_port: u16,\n        identity_private_key: Handle,\n        out_error: PHandle,\n    },\n    ContextBootstrapTor{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStartIdentityServer{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStopIdentityServer{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStartEndpointServer{\n        context: Handle,\n        endpoint_private_key: Handle,\n        endpoint_name: Buffer\u003cc_char\u003e,\n        endpoint_name_length: Primitive\u003cusize\u003e,\n        client_identity: Handle,\n        client_auth_public_key: Handle,\n        out_error: PHandle,\n    },\n    ContextStopEndpointServer{\n        context: Handle,\n        endpoint_private_key: Handle,\n        out_error: PHandle,\n    },\n    ContextBeginIdentityHandshake{\n        context: Handle,\n        identity_service_id: Handle,\n        endpoint_name: Buffer\u003cc_char\u003e,\n        endpoint_name_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextAbortIdentityClientHandshake{\n        context: Handle,\n        handshake_handle: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextBeginEndpointHandshake{\n        context: Handle,\n        endpoint_service_id: Handle,\n        client_auth_private_key: Handle,\n        channel_name: Buffer\u003cc_char\u003e,\n        channel_name_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextAbortEndpointClientHandshake{\n        context: Handle,\n        handshake_handle: Primitive\u003cusize\u003e,\n        out_error: PHandle\n    },\n    ContextPollEvents{\n        context: Handle,\n        out_error: PHandle,\n    },\n    // Callback Setters\n    ContextSetTorBootstrapStatusReceivedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetTorBootstrapCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetTorLogReceivedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientChallengeResponseSizeCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientBuildChallengeResponseCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerPublishedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeStartedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerClientAllowedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerEndpointSupportedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerChallengeSizeCallack{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerBuildChallengeCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerVerifyChallengeResponseCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeRejectedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointClientHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointClientHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerPublishedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeStartedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerChannelSupportedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeRejectedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n}\n\nfn handle_as_pointer\u003cT\u003e(value: Handle, handles: \u0026Vec\u003c*mut T\u003e) -\u003e *mut T {\n    let result: *mut T = match value {\n        Handle::Null =\u003e ptr::null_mut(),\n        Handle::Valid(value) =\u003e if !handles.is_empty() {\n            let index = value % handles.len();\n            handles[index]\n        } else {\n            ptr::null_mut()\n        },\n        Handle::Invalid(value) =\u003e if !handles.contains(\u0026(value as *mut T)) {\n            value as *mut T\n        } else {\n            ptr::null_mut()\n        }\n    };\n    result\n}\n\nfn handle_to_pointer\u003cT\u003e(value: Handle, handles: \u0026mut Vec\u003c*mut T\u003e) -\u003e *mut T {\n    let result: *mut T = match value {\n        Handle::Null =\u003e ptr::null_mut(),\n        Handle::Valid(value) =\u003e if !handles.is_empty() {\n            let index = value % handles.len();\n            handles.remove(index) as *mut T\n        } else {\n            ptr::null_mut()\n        },\n        Handle::Invalid(value) =\u003e if !handles.contains(\u0026(value as *mut T)) {\n            value as *mut T\n        } else {\n            ptr::null_mut()\n        },\n    };\n    result\n}\n\nfn phandle_to_out_pointer\u003cT\u003e(value: PHandle, out_pointer: *mut *mut T) -\u003e *mut *mut T {\n    match value {\n        PHandle::Null =\u003e ptr::null_mut(),\n        PHandle::Valid =\u003e out_pointer,\n    }\n}\n\nfn buffer_to_size\u003cT\u003e(buffer: \u0026Buffer\u003cT\u003e, buffer_size: \u0026Primitive\u003cusize\u003e) -\u003e usize {\n    let size: usize = match (buffer, buffer_size) {\n        (Buffer::Null, Primitive::Valid(_)) =\u003e 0usize,\n        (Buffer::Null, Primitive::Invalid(value)) =\u003e *value,\n        (Buffer::Valid(buffer), Primitive::Valid(_)) =\u003e buffer.len(),\n        (Buffer::Valid(buffer), Primitive::Invalid(value)) =\u003e std::cmp::min(*value, buffer.len()),\n    };\n    size\n}\n\nfn buffer_as_pointer\u003cT\u003e(buffer: \u0026Buffer\u003cT\u003e) -\u003e *const T {\n    let pointer: *const T = match buffer {\n        Buffer::Null =\u003e ptr::null(),\n        Buffer::Valid(value) =\u003e value.as_ptr(),\n    };\n    pointer\n}\n\nfn buffer_as_mut_pointer\u003cT\u003e(buffer: \u0026mut Buffer\u003cT\u003e) -\u003e *mut T {\n    let pointer: *mut T = match buffer {\n        Buffer::Null =\u003e ptr::null_mut(),\n        Buffer::Valid(value) =\u003e value.as_mut_ptr(),\n    };\n    pointer\n}\n\nmacro_rules! impl_set_callback {\n    ($context:ident, $callback:ident, $out_error:ident, $contexts:ident, $errors:ident,$setter:ident, $func:ident) =\u003e {\n        let context = handle_as_pointer($context, \u0026$contexts);\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n        let out_error = phandle_to_out_pointer($out_error, \u0026mut error);\n        match $callback {\n            Callback::Null =\u003e $setter(context, None, out_error),\n            Callback::Valid =\u003e $setter(context, Some($func), out_error),\n        }\n        if !error.is_null() {\n            $errors.push(error);\n        }\n    }\n}\n\n// no-op (or minimal op) callbacks for setters\n\nextern \"C\" fn bootstrap_status_received(_context: *mut GoslingContext, _progress: u32, _tag: *const c_char, _tag_length: usize, _summary: *const c_char, _summary_length: usize) {\n\n}\n\nextern \"C\" fn bootstrap_complete(_context: *mut GoslingContext) -\u003e () {\n\n}\n\nextern \"C\" fn tor_log_received(_context: *mut GoslingContext, _line: *const c_char, _line_length: usize) {\n\n}\n\nextern \"C\" fn identity_client_handshake_challenge_response_size(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_buffer: *const u8, _challenge_buffer_size: usize) -\u003e usize {\n    return 0;\n}\n\nextern \"C\" fn identity_client_handshake_build_challenge_response(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_buffer: *const u8, _challenge_buffer_size: usize, _out_challenge_response_buffer: *mut u8, _challenge_response_buffer_size: usize) {\n\n}\n\nextern \"C\" fn identity_client_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _identity_service_id: *const GoslingV3OnionServiceId, _endpoint_service_id: *const GoslingV3OnionServiceId, _endpoint_name: *const c_char, _endpoint_name_length: usize, _client_auth_private_key: *const GoslingX25519PrivateKey) {\n\n}\n\nextern \"C\" fn identity_client_handshake_failed(_context: *mut GoslingContext, _handshake_handle: usize, _error: *const GoslingFFIError) {\n\n}\n\nextern \"C\" fn identity_server_published(_context: *mut GoslingContext) {\n\n}\n\nextern \"C\" fn identity_server_handshake_started(_context: *mut GoslingContext, _handshake_handle: usize) {\n\n}\n\nextern \"C\" fn identity_server_handshake_client_allowed(_context: *mut GoslingContext, _handshake_handle: usize, _client_service_id: *const GoslingV3OnionServiceId) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_endpoint_supported(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_name: *const c_char, _endpoint_name_length: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_handshake_challenge_size(_context: *mut GoslingContext, _handshake_handle: usize) -\u003e usize {\n    0usize\n}\n\nextern \"C\" fn identity_server_handshake_build_challenge(_context: *mut GoslingContext, _handshake_handle: usize, _out_challenge_buffer: *mut u8, _challenge_buffer_size: usize) {\n\n}\n\nextern \"C\" fn identity_server_handshake_verify_challenge_response(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_response_buffer: *const u8, _challenge_response_buffer_size: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_private_key: *const GoslingEd25519PrivateKey, _endpoint_name: *const c_char, _endpoint_name_length: usize, _client_service_id: *const GoslingV3OnionServiceId, _client_auth_public_key: *const GoslingX25519PublicKey) {\n\n}\n\nextern \"C\" fn identity_server_handshake_rejected(_context: *mut GoslingContext, _handshake_handle: usize, _client_allowed: bool, _client_requested_endpoint_valid: bool, _client_proof_signature_valid: bool, _client_auth_signature_valid: bool, _challenge_response_valid: bool) {\n\n}\n\nextern \"C\" fn identity_server_handshake_failed(_cntext: *mut GoslingContext, _handshake_handle: usize, _error: *const GoslingFFIError) {\n\n}\n\nextern \"C\" fn endpoint_client_handhsake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize, _stream: c_int) {\n\n}\n\nextern \"C\" fn endpoint_client_handshake_failed(_context: *mut GoslingContext,\n    _handshake_handle: usize, _error: *const GoslingFFIError) {\n\n}\n\nextern \"C\" fn endpoint_server_published(_context: *mut GoslingContext, _endpoint_service_id: *const GoslingV3OnionServiceId, _endpoint_name: *const c_char, _endpoint_name_length: usize) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_started(_context: *mut GoslingContext, _handshake_handle: usize) {\n\n}\n\nextern \"C\" fn endpoint_server_channel_supported(_context: *mut GoslingContext,\n_handshake_handle: usize, _client_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn endpoint_server_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_service_id: *const GoslingV3OnionServiceId, _client_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize, _stream: c_int) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_rejected(_context: *mut GoslingContext, _handshake_handle: usize, _client_allowed: bool, _client_requested_channel_valid: bool, _client_proof_signature_valid: bool) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_failed(_context: *mut GoslingContext,\n    _handshake_handle: usize, _error: *const GoslingFFIError) {\n\n}\n\n#[derive(Arbitrary, Debug)]\nstruct Data {\n    functions: Vec\u003cFunction\u003e,\n}\n\nfuzz_target!(|data: Data| {\n    let mut libraries: Vec\u003c*mut GoslingLibrary\u003e = Default::default();\n    let mut errors: Vec\u003c*mut GoslingFFIError\u003e = Default::default();\n    let mut contexts: Vec\u003c*mut GoslingContext\u003e = Default::default();\n    let mut ed25519_private_keys: Vec\u003c*mut GoslingEd25519PrivateKey\u003e = Default::default();\n    let mut v3_onion_service_ids: Vec\u003c*mut GoslingV3OnionServiceId\u003e = Default::default();\n    let mut x25519_private_keys: Vec\u003c*mut GoslingX25519PrivateKey\u003e = Default::default();\n    let mut x25519_public_keys : Vec\u003c*mut GoslingX25519PublicKey\u003e = Default::default();\n    let mut tor_providers: Vec\u003c*mut GoslingTorProvider\u003e = Default::default();\n    let mut identity_handshakes: Vec\u003cusize\u003e = Default::default();\n    let mut endpoint_handshakes: Vec\u003cusize\u003e = Default::default();\n\n    for function in data.functions {\n        match function {\n            Function::ErrorGetMessage{error} =\u003e {\n                let error = handle_as_pointer(error, \u0026errors);\n                gosling_error_get_message(error);\n            },\n            Function::ErrorClone{error_copy, orig_error, out_error} =\u003e {\n                let mut dest: *mut GoslingFFIError = ptr::null_mut();\n                let error_copy = phandle_to_out_pointer(error_copy, \u0026mut dest);\n                let orig_error = handle_as_pointer(orig_error, \u0026errors);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_error_clone(error_copy, orig_error, out_error) };\n                if !dest.is_null() {\n                    errors.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ErrorFree{error} =\u003e {\n                let error = handle_to_pointer(error, \u0026mut errors);\n                gosling_error_free(error);\n            },\n            Function::Ed25519PrivateKeyFree{private_key} =\u003e {\n                let private_key = handle_to_pointer(private_key, \u0026mut ed25519_private_keys);\n                gosling_ed25519_private_key_free(private_key);\n            },\n            Function::X25519PrivateKeyFree{private_key} =\u003e {\n                let private_key = handle_to_pointer(private_key, \u0026mut x25519_private_keys);\n                gosling_x25519_private_key_free(private_key);\n            },\n            Function::X25519PublicKeyFree{public_key} =\u003e {\n                let public_key = handle_to_pointer(public_key, \u0026mut x25519_public_keys);\n                gosling_x25519_public_key_free(public_key);\n            },\n            Function::V3OnionServiceIdFree{service_id} =\u003e {\n               let service_id = handle_to_pointer(service_id, \u0026mut v3_onion_service_ids);\n               gosling_v3_onion_service_id_free(service_id);\n            },\n            Function::ContextFree{context} =\u003e {\n                let context = handle_to_pointer(context, \u0026mut contexts);\n                gosling_context_free(context);\n            },\n            Function::TorProviderFree{tor_provider} =\u003e {\n                let tor_provider = handle_to_pointer(tor_provider, \u0026mut tor_providers);\n                gosling_tor_provider_free(tor_provider);\n            },\n            Function::LibraryInit{out_library, out_error} =\u003e {\n                let mut library: *mut GoslingLibrary = ptr::null_mut();\n                let out_library = phandle_to_out_pointer(out_library, \u0026mut library);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_library_init(out_library, out_error) };\n                if !library.is_null() {\n                    libraries.push(library);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::LibraryFree{library} =\u003e {\n                let library = handle_to_pointer(library, \u0026mut libraries);\n                gosling_library_free(library);\n            },\n            Function::Ed25519PrivateKeyGenerate{out_private_key, out_error} =\u003e {\n                let mut private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_generate(out_private_key, out_error) };\n                if !private_key.is_null() {\n                    ed25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyClone{out_private_key, private_key, out_error} =\u003e {\n                let mut dest: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut dest);\n                let private_key = handle_as_pointer(private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_clone(out_private_key, private_key, out_error) };\n                if !dest.is_null() {\n                    ed25519_private_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyFromKeyblob{out_private_key, key_blob, key_blob_length, out_error} =\u003e {\n                let mut private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let key_blob_length = buffer_to_size(\u0026key_blob, \u0026key_blob_length);\n                let key_blob = buffer_as_pointer(\u0026key_blob);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_from_keyblob(out_private_key, key_blob, key_blob_length, out_error) };\n                if !private_key.is_null() {\n                    ed25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyToKeyblob{private_key, mut out_key_blob, key_blob_size, out_error} =\u003e {\n                let private_key = handle_as_pointer(private_key, \u0026ed25519_private_keys);\n                let key_blob_size = buffer_to_size(\u0026out_key_blob, \u0026key_blob_size);\n                let out_key_blob = buffer_as_mut_pointer(\u0026mut out_key_blob);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_ed25519_private_key_to_keyblob(private_key, out_key_blob, key_blob_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyClone{out_private_key, private_key, out_error} =\u003e {\n                let mut dest: *mut GoslingX25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut dest);\n                let private_key = handle_as_pointer(private_key, \u0026x25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_private_key_clone(out_private_key, private_key, out_error) };\n                if !dest.is_null() {\n                    x25519_private_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyFromBase64{out_private_key, base64, base64_length, out_error} =\u003e {\n                let mut private_key: *mut GoslingX25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let base64_length = buffer_to_size(\u0026base64, \u0026base64_length);\n                let base64 = buffer_as_pointer(\u0026base64);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_private_key_from_base64(out_private_key, base64, base64_length, out_error) };\n                if !private_key.is_null() {\n                    x25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyToBase64{private_key, mut out_base64, base64_size, out_error} =\u003e {\n                let private_key = handle_as_pointer(private_key, \u0026x25519_private_keys);\n                let base64_size = buffer_to_size(\u0026out_base64, \u0026base64_size);\n                let out_base64 = buffer_as_mut_pointer(\u0026mut out_base64);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_x25519_private_key_to_base64(private_key, out_base64, base64_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyClone{out_public_key, public_key, out_error} =\u003e {\n                let mut dest: *mut GoslingX25519PublicKey = ptr::null_mut();\n                let out_public_key = phandle_to_out_pointer(out_public_key, \u0026mut dest);\n                let public_key = handle_as_pointer(public_key, \u0026x25519_public_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_public_key_clone(out_public_key, public_key, out_error) };\n                if !dest.is_null() {\n                    x25519_public_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyFromBase32{out_public_key, base32, base32_length, out_error} =\u003e {\n                let mut public_key: *mut GoslingX25519PublicKey = ptr::null_mut();\n                let out_public_key = phandle_to_out_pointer(out_public_key, \u0026mut public_key);\n                let base32_length = buffer_to_size(\u0026base32, \u0026base32_length);\n                let base32 = buffer_as_pointer(\u0026base32);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_public_key_from_base32(out_public_key, base32, base32_length, out_error) };\n                if !out_public_key.is_null() {\n                    x25519_public_keys.push(public_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyToBase32{public_key, mut out_base32, base32_size, out_error} =\u003e {\n                let public_key = handle_as_pointer(public_key, \u0026x25519_public_keys);\n                let base32_size = buffer_to_size(\u0026out_base32, \u0026base32_size);\n                let out_base32 = buffer_as_mut_pointer(\u0026mut out_base32);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_x25519_public_key_to_base32(public_key, out_base32, base32_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdClone{out_service_id, service_id, out_error} =\u003e {\n                let mut dest: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut dest);\n                let service_id = handle_as_pointer(service_id, \u0026v3_onion_service_ids);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_clone(out_service_id, service_id, out_error) };\n                if !dest.is_null() {\n                    v3_onion_service_ids.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdFromString{out_service_id, service_id_string, service_id_string_length, out_error} =\u003e {\n                let mut service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut service_id);\n                let service_id_string_length = buffer_to_size(\u0026service_id_string, \u0026service_id_string_length);\n                let service_id_string = buffer_as_pointer(\u0026service_id_string);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_from_string(out_service_id, service_id_string, service_id_string_length, out_error) };\n                if !out_service_id.is_null() {\n                    v3_onion_service_ids.push(service_id);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdFromEd25519PrivateKey{out_service_id, ed25519_private_key, out_error} =\u003e {\n                let mut service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut service_id);\n                let ed25519_private_key = handle_as_pointer(ed25519_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_from_ed25519_private_key(out_service_id, ed25519_private_key, out_error) };\n                if !out_service_id.is_null() {\n                    v3_onion_service_ids.push(service_id);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdToString{service_id, mut out_service_id_string, service_id_string_size, out_error} =\u003e {\n                let service_id = handle_as_pointer(service_id, \u0026v3_onion_service_ids);\n                let service_id_string_size = buffer_to_size(\u0026out_service_id_string, \u0026service_id_string_size);\n                let out_service_id_string = buffer_as_mut_pointer(\u0026mut out_service_id_string);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_v3_onion_service_id_to_string(service_id, out_service_id_string, service_id_string_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::StringIsValidV3OnionServiceId{service_id_string, service_id_string_length, out_error} =\u003e {\n                let service_id_string_length = buffer_to_size(\u0026service_id_string, \u0026service_id_string_length);\n                let service_id_string = buffer_as_pointer(\u0026service_id_string);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_string_is_valid_v3_onion_service_id(service_id_string, service_id_string_length, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            }\n            Function::TorProviderNewMockClient{out_tor_provider, out_error} =\u003e {\n                let mut tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n                let out_tor_provider = phandle_to_out_pointer(out_tor_provider, \u0026mut tor_provider);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_tor_provider_new_mock_client(out_tor_provider, out_error) };\n                if !tor_provider.is_null() {\n                    tor_providers.push(tor_provider);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextInit{out_context, tor_provider, identity_port, endpoint_port, identity_private_key, out_error} =\u003e {\n                let mut context: *mut GoslingContext = ptr::null_mut();\n                let out_context = phandle_to_out_pointer(out_context, \u0026mut context);\n                let tor_provider = handle_as_pointer(tor_provider, \u0026tor_providers);\n                let identity_private_key = handle_as_pointer(identity_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_context_init(out_context, tor_provider, identity_port, endpoint_port, identity_private_key, out_error) };\n                if !context.is_null() {\n                    contexts.push(context);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBootstrapTor{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_bootstrap_tor(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStartIdentityServer{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_start_identity_server(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStopIdentityServer{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_stop_identity_server(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStartEndpointServer{context, endpoint_private_key, endpoint_name, endpoint_name_length, client_identity, client_auth_public_key, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_private_key = handle_as_pointer(endpoint_private_key, \u0026ed25519_private_keys);\n                let endpoint_name_length = buffer_to_size(\u0026endpoint_name, \u0026endpoint_name_length);\n                let endpoint_name = buffer_as_pointer(\u0026endpoint_name);\n                let client_identity = handle_as_pointer(client_identity, \u0026v3_onion_service_ids);\n                let client_auth_public_key = handle_as_pointer(client_auth_public_key, \u0026x25519_public_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_start_endpoint_server(context, endpoint_private_key, endpoint_name, endpoint_name_length, client_identity, client_auth_public_key, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            }\n            Function::ContextStopEndpointServer{context, endpoint_private_key, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_private_key = handle_as_pointer(endpoint_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_stop_endpoint_server(context, endpoint_private_key, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBeginIdentityHandshake{context, identity_service_id, endpoint_name, endpoint_name_length, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let identity_service_id = handle_as_pointer(identity_service_id, \u0026v3_onion_service_ids);\n                let endpoint_name_length = buffer_to_size(\u0026endpoint_name, \u0026endpoint_name_length);\n                let endpoint_name = buffer_as_pointer(\u0026endpoint_name);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                let handshake_handle = gosling_context_begin_identity_handshake(context, identity_service_id, endpoint_name, endpoint_name_length, out_error);\n                if handshake_handle != !0usize {\n                    identity_handshakes.push(handshake_handle);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextAbortIdentityClientHandshake{context, handshake_handle, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let handshake_handle = match handshake_handle {\n                    Primitive::Valid(value) =\u003e if !identity_handshakes.is_empty() {\n                        let index = value % identity_handshakes.len();\n                        identity_handshakes[index]\n                    } else {\n                        !0usize\n                    },\n                    Primitive::Invalid(value) =\u003e if !identity_handshakes.contains(\u0026value) {\n                        value\n                    } else {\n                        !0usize\n                    }\n                };\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_abort_identity_client_handshake(context, handshake_handle, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBeginEndpointHandshake{context, endpoint_service_id, client_auth_private_key, channel_name, channel_name_length, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_service_id = handle_as_pointer(endpoint_service_id, \u0026v3_onion_service_ids);\n                let client_auth_private_key = handle_as_pointer(client_auth_private_key, \u0026x25519_private_keys);\n                let channel_name_length = buffer_to_size(\u0026channel_name, \u0026channel_name_length);\n                let channel_name = buffer_as_pointer(\u0026channel_name);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                let handshake_handle = gosling_context_begin_endpoint_handshake(context, endpoint_service_id, client_auth_private_key, channel_name, channel_name_length, out_error);\n                if handshake_handle != !0usize {\n                    endpoint_handshakes.push(handshake_handle);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextAbortEndpointClientHandshake{context, handshake_handle, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let handshake_handle = match handshake_handle {\n                    Primitive::Valid(value) =\u003e if !endpoint_handshakes.is_empty() {\n                        let index = value % endpoint_handshakes.len();\n                        endpoint_handshakes[index]\n                    } else {\n                        !0usize\n                    },\n                    Primitive::Invalid(value) =\u003e if !endpoint_handshakes.contains(\u0026value) {\n                        value\n                    } else {\n                        !0usize\n                    }\n                };\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_abort_endpoint_client_handshake(context, handshake_handle, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextPollEvents{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_poll_events(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextSetTorBootstrapStatusReceivedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_bootstrap_status_received_callback, bootstrap_status_received);\n            },\n            Function::ContextSetTorBootstrapCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_bootstrap_completed_callback, bootstrap_complete);\n            },\n            Function::ContextSetTorLogReceivedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_log_received_callback, tor_log_received);\n            },\n            Function::ContextSetIdentityClientChallengeResponseSizeCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_challenge_response_size_callback, identity_client_handshake_challenge_response_size);\n            },\n            Function::ContextSetIdentityClientBuildChallengeResponseCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_build_challenge_response_callback, identity_client_handshake_build_challenge_response);\n            },\n            Function::ContextSetIdentityClientHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_handshake_completed_callback, identity_client_handshake_completed);\n            },\n            Function::ContextSetIdentityClientHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_handshake_failed_callback, identity_client_handshake_failed);\n            },\n            Function::ContextSetIdentityServerPublishedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_published_callback, identity_server_published);\n            },\n            Function::ContextSetIdentityServerHandshakeStartedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_started_callback, identity_server_handshake_started);\n            },\n            Function::ContextSetIdentityServerClientAllowedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_client_allowed_callback, identity_server_handshake_client_allowed);\n            },\n            Function::ContextSetIdentityServerEndpointSupportedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_endpoint_supported_callback, identity_server_endpoint_supported);\n            },\n            Function::ContextSetIdentityServerChallengeSizeCallack{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_challenge_size_callback, identity_server_handshake_challenge_size);\n            },\n            Function::ContextSetIdentityServerBuildChallengeCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_build_challenge_callback, identity_server_handshake_build_challenge);\n            },\n            Function::ContextSetIdentityServerVerifyChallengeResponseCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_verify_challenge_response_callback, identity_server_handshake_verify_challenge_response);\n            },\n            Function::ContextSetIdentityServerHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_completed_callback, identity_server_handshake_completed);\n            },\n            Function::ContextSetIdentityServerHandshakeRejectedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_rejected_callback, identity_server_handshake_rejected);\n            },\n            Function::ContextSetIdentityServerHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_failed_callback, identity_server_handshake_failed);\n            },\n            Function::ContextSetEndpointClientHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_client_handshake_completed_callback, endpoint_client_handhsake_completed);\n            },\n            Function::ContextSetEndpointClientHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_client_handshake_failed_callback, endpoint_client_handshake_failed);\n            },\n            Function::ContextSetEndpointServerPublishedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_published_callback, endpoint_server_published);\n            },\n            Function::ContextSetEndpointServerHandshakeStartedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_started_callback, endpoint_server_handshake_started);\n            },\n            Function::ContextSetEndpointServerChannelSupportedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_channel_supported_callback, endpoint_server_channel_supported);\n            },\n            Function::ContextSetEndpointServerHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_completed_callback, endpoint_server_handshake_completed);\n            },\n            Function::ContextSetEndpointServerHandshakeRejectedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_rejected_callback, endpoint_server_handshake_rejected);\n            },\n            Function::ContextSetEndpointServerHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_failed_callback, endpoint_server_handshake_failed);\n            },\n        }\n    }\n});\n","traces":[{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":43},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","ffi.rs"],"content":"// standard\nuse std::boxed::Box;\nuse std::collections::VecDeque;\nuse std::ffi::CString;\nuse std::io::Cursor;\nuse std::os::raw::c_char;\n#[cfg(unix)]\nuse std::os::unix::io::{IntoRawFd, RawFd};\n#[cfg(windows)]\nuse std::os::windows::io::{IntoRawSocket, RawSocket};\nuse std::panic;\nuse std::path::Path;\nuse std::ptr;\nuse std::str;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Mutex;\nuse std::time::Duration;\n\n// extern crates\nuse anyhow::anyhow;\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\nuse gosling::context::*;\nuse tor_interface::legacy_tor_client::*;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::*;\n\n// internal crates\nuse crate::object_registry::*;\n\n// tags used for types we put in ObjectRegistrys\nconst ERROR_TAG: usize = 0x1;\nconst ED25519_PRIVATE_KEY_TAG: usize = 0x2;\nconst X25519_PRIVATE_KEY_TAG: usize = 0x3;\nconst X25519_PUBLIC_KEY_TAG: usize = 0x4;\nconst V3_ONION_SERVICE_ID_TAG: usize = 0x5;\nconst TOR_PROVIDER_TAG: usize = 0x6;\nconst CONTEXT_TUPLE_TAG: usize = 0x7;\n\n\n// empty bson document layout:\n// {\n//     // document length 5 == 0x00000005\n//     0x05, 0x00, 0x00, 0x00,\n//     // document null-terminator\n//     0x00\n// };\nconst SMALLEST_BSON_DOC_SIZE: usize = 5;\n\n\nmacro_rules! define_registry {\n    ($type:ty) =\u003e {\n        paste::paste! {\n            // ensure tag fits in 3 bits\n            static_assertions::const_assert!([\u003c$type:snake:upper _TAG\u003e] \u003c= 0b111);\n\n            static [\u003c$type:snake:upper _REGISTRY\u003e]: Mutex\u003cObjectRegistry\u003c$type, { [\u003c$type:snake:upper _TAG\u003e] }, 3\u003e\u003e = Mutex::new(ObjectRegistry::new());\n\n            pub fn [\u003cget_ $type:snake _registry\u003e]\u003c'a\u003e() -\u003e std::sync::MutexGuard\u003c'a, ObjectRegistry\u003c$type, { [\u003c$type:snake:upper _TAG\u003e] }, 3\u003e\u003e {\n                match [\u003c$type:snake:upper _REGISTRY\u003e].lock() {\n                    Ok(registry) =\u003e registry,\n                    Err(_) =\u003e unreachable!(\"another thread panicked while holding this registry's mutex\"),\n                }\n            }\n\n            pub fn [\u003cclear_ $type:snake _registry\u003e]() {\n                match [\u003c$type:snake:upper _REGISTRY\u003e].lock() {\n                    Ok(mut registry) =\u003e *registry = ObjectRegistry::new(),\n                    Err(_) =\u003e unreachable!(\"another thread panicked while holding this registry's mutex\"),\n                }\n            }\n        }\n    }\n}\n\n/// Error Handling\n#[derive(Clone)]\npub struct Error {\n    message: CString,\n}\n\nimpl Error {\n    pub fn new(message: \u0026str) -\u003e Error {\n        Error {\n            message: CString::new(message).unwrap_or_default(),\n        }\n    }\n}\n\ndefine_registry! {Error}\n\n/// A wrapper object containing an error message\npub struct GoslingFFIError;\n\n\n/// Get error message from gosling_error\n///\n/// @param error: the error object to get the message from\n/// @return null-terminated string with error message whose\n///  lifetime is tied to the source\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_error_get_message(error: *const GoslingFFIError) -\u003e *const c_char {\n    if !error.is_null() {\n        let key = error as usize;\n\n        let registry = get_error_registry();\n        if registry.contains_key(key) {\n            if let Some(x) = registry.get(key) {\n                return x.message.as_ptr();\n            }\n        }\n    }\n\n    ptr::null()\n}\n\n/// Copy method for gosling_error\n///\n/// @param out_error: returned copy\n/// @param orig_error: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_error_clone(\n    out_error: *mut *mut GoslingFFIError,\n    orig_error: *const GoslingFFIError,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_error.is_null() {\n            bail!(\"out_error must not be null\");\n        }\n        if orig_error.is_null() {\n            bail!(\"orig_error must not be null\");\n        }\n\n        let orig_error = match get_error_registry().get(orig_error as usize) {\n            Some(orig_error) =\u003e orig_error.clone(),\n            None =\u003e bail!(\"error is invalid\"),\n        };\n        let handle = get_error_registry().insert(orig_error);\n        *out_error = handle as *mut GoslingFFIError;\n\n        Ok(())\n    })\n}\n\n// macro for defining the implementation of freeing objects\n// owned by an ObjectRegistry\nmacro_rules! impl_registry_free {\n    ($obj:expr, $type:ty) =\u003e {\n        if $obj.is_null() {\n            return;\n        }\n\n        let key = $obj as usize;\n        paste::paste! {\n            [\u003cget_ $type:snake _registry\u003e]().remove(key);\n        }\n    };\n}\n\n/// Frees gosling_error and invalidates any message strings\n/// returned by gosling_error_get_message() from the given\n/// error object.\n///\n/// @param error: the error object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_error_free(error: *mut GoslingFFIError) {\n    impl_registry_free!(error, Error);\n}\n\n/// A handle for the gosling library\npub struct GoslingLibrary;\n/// An ed25519 private key used to create a v3 onion service\npub struct GoslingEd25519PrivateKey;\n/// An x25519 private key used to decrypt v3 onion service descriptors\npub struct GoslingX25519PrivateKey;\n/// An x25519 public key used to encrypt v3 onoin service descriptors\npub struct GoslingX25519PublicKey;\n/// A v3 onion service id\npub struct GoslingV3OnionServiceId;\n/// A tor provider object used by a context to connect to the tor network\npub struct GoslingTorProvider;\n/// A context object associated with a single peer identity\npub struct GoslingContext;\n/// A handle for an in-progress identity handhskae\npub type GoslingHandshakeHandle = usize;\n#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n/// A native TCP socket handle\npub type GoslingTcpSocket = RawFd;\n#[cfg(any(target_os = \"windows\"))]\n/// A native TCP socket handle\npub type GoslingTcpSocket = RawSocket;\n\ndefine_registry! {Ed25519PrivateKey}\ndefine_registry! {X25519PrivateKey}\ndefine_registry! {X25519PublicKey}\ndefine_registry! {V3OnionServiceId}\n/// cbindgen:ignore\ntype TorProvider = Box\u003cdyn tor_provider::TorProvider\u003e;\ndefine_registry! {TorProvider}\n\n/// cbindgen:ignore\ntype ContextTuple = (Context, EventCallbacks, Option\u003cVecDeque\u003cContextEvent\u003e\u003e);\n\ndefine_registry! {ContextTuple}\n\n/// Frees a gosling_ed25519_private_key object\n///\n/// @param in_private_key: the private key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_ed25519_private_key_free(in_private_key: *mut GoslingEd25519PrivateKey) {\n    impl_registry_free!(in_private_key, Ed25519PrivateKey);\n}\n\n/// Frees a gosling_x25519_private_key object\n///\n/// @param in_private_key: the private key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_private_key_free(in_private_key: *mut GoslingX25519PrivateKey) {\n    impl_registry_free!(in_private_key, X25519PrivateKey);\n}\n/// Frees a gosling_x25519_public_key object\n///\n/// @param public_key: the public key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_public_key_free(in_public_key: *mut GoslingX25519PublicKey) {\n    impl_registry_free!(in_public_key, X25519PublicKey);\n}\n/// Frees a gosling_v3_onion_service_id object\n///\n/// @param in_service_id: the service id object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_v3_onion_service_id_free(in_service_id: *mut GoslingV3OnionServiceId) {\n    impl_registry_free!(in_service_id, V3OnionServiceId);\n}\n/// Frees a gosling_tor_provider object\n///\n/// @param in_tor_provider: the tor provider object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_tor_provider_free(in_tor_provider: *mut GoslingTorProvider) {\n    impl_registry_free!(in_tor_provider, ContextTuple);\n}\n/// Frees a gosling_context object\n///\n/// @param in_context: the context object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_free(in_context: *mut GoslingContext) {\n    impl_registry_free!(in_context, ContextTuple);\n}\n\n/// Wrapper around rust code which may panic or return a failing Result to be used at FFI boundaries.\n/// Converts panics or error Results into GoslingErrors if a memory location is provided.\n///\n/// @param default: The default value to return in the event of failure\n/// @param out_error: A pointer to pointer to GoslingError 'struct' for the C FFI\n/// @param closure: The functionality we need to encapsulate behind the error handling logic\n/// @return The result of closure() on success, or the value of default on failure.\nfn translate_failures\u003cR, F\u003e(default: R, out_error: *mut *mut GoslingFFIError, closure: F) -\u003e R\nwhere\n    F: FnOnce() -\u003e anyhow::Result\u003cR\u003e + panic::UnwindSafe,\n{\n    match panic::catch_unwind(closure) {\n        // handle success\n        Ok(Ok(retval)) =\u003e retval,\n        // handle runtime error\n        Ok(Err(err)) =\u003e {\n            if !out_error.is_null() {\n                // populate error with runtime error message\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", err).as_str()));\n                unsafe {\n                    *out_error = key as *mut GoslingFFIError;\n                };\n            }\n            default\n        }\n        // handle panic\n        Err(_) =\u003e {\n            if !out_error.is_null() {\n                // populate error with panic message\n                let key = get_error_registry().insert(Error::new(\"panic occurred\"));\n                unsafe {\n                    *out_error = key as *mut GoslingFFIError;\n                };\n            }\n            default\n        }\n    }\n}\n\nstatic GOSLING_LIBRARY_INITED: AtomicBool = AtomicBool::new(false);\nconst GOSLING_LIBRARY_HANDLE: usize = {\n    // integer constant in the form 0x6000..5E (GOOOOOSE)\n    (0x60 \u003c\u003c ((std::mem::size_of::\u003cusize\u003e() - 1) * 8)) + 0x5E\n};\n\n/// Initializes the Gosling library. This function must be called before using any of the\n/// other Gosling functions.\n///\n/// @return: returns 0 on success\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_library_init(\n    out_library: *mut *mut GoslingLibrary,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_library.is_null() {\n            bail!(\"out_library may not be null\");\n        }\n\n        if GOSLING_LIBRARY_INITED.load(Ordering::Relaxed) {\n            // error handling\n            bail!(\"gosling is already initialized\");\n        } else {\n            GOSLING_LIBRARY_INITED.store(true, Ordering::Relaxed);\n            *out_library = GOSLING_LIBRARY_HANDLE as *mut GoslingLibrary;\n        }\n        Ok(())\n    })\n}\n\n/// Frees all resources associated with the Gosling library. No-op if the library\n/// is not initialized or if it has already been freed\n#[no_mangle]\n#[allow(unused_variables)]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_library_free(in_library: *mut GoslingLibrary) {\n    if GOSLING_LIBRARY_INITED.load(Ordering::Relaxed) {\n        clear_error_registry();\n\n        clear_ed25519_private_key_registry();\n        clear_x25519_private_key_registry();\n        clear_x25519_public_key_registry();\n        clear_v3_onion_service_id_registry();\n\n        clear_context_tuple_registry();\n\n        GOSLING_LIBRARY_INITED.store(false, Ordering::Relaxed);\n    }\n}\n\n/// Creation method for securely generating a new gosling_ed25510_private_key\n///\n/// @param out_private_key: returned generated ed25519 private key\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_generate(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n\n        let private_key = Ed25519PrivateKey::generate();\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_ed25519_private_key\n///\n/// @param out_private_key: returned copy\n/// @param private_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_clone(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n        if private_key.is_null() {\n            bail!(\"private_key must not be null\");\n        }\n\n        let private_key = match get_ed25519_private_key_registry().get(private_key as usize) {\n            Some(private_key) =\u003e private_key.clone(),\n            None =\u003e bail!(\"private key is invalid\"),\n        };\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting the KeyBlob string returned by ADD_ONION\n/// command into a gosling_ed25519_private_key\n///\n/// @param out_private_key: returned ed25519 private key\n/// @param key_blob: an ed25519 KeyBlob string in the form\n///  \"ED25519-V3:abcd1234...\"\n/// @param key_blob_length: number of chars in key_blob not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_from_keyblob(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    key_blob: *const c_char,\n    key_blob_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n        if key_blob.is_null() {\n            bail!(\"key_blob must not be null\");\n        }\n\n        if key_blob_length != ED25519_PRIVATE_KEY_KEYBLOB_LENGTH {\n            bail!(\"key_blob_length must be exactly ED25519_PRIVATE_KEY_KEYBLOB_LENGTH ({}); received '{}'\", ED25519_PRIVATE_KEY_KEYBLOB_LENGTH, key_blob_length);\n        }\n\n        let key_blob_view = std::slice::from_raw_parts(key_blob as *const u8, key_blob_length);\n        let key_blob_str = std::str::from_utf8(key_blob_view)?;\n        let private_key = Ed25519PrivateKey::from_key_blob(key_blob_str)?;\n\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an ed25519 private key to a null-\n/// terminated KeyBlob string for use with ADD_ONION command\n///\n/// @param private_key: the private key to encode\n/// @param out_key_blob: buffer to be filled with ed25519 KeyBlob in\n///  the form \"ED25519-V3:abcd1234...\\0\"\n/// @param key_blob_size: size of out_key_blob buffer in bytes, must be at\n///  least 100 characters (99 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_ed25519_private_key_to_keyblob(\n    private_key: *const GoslingEd25519PrivateKey,\n    out_key_blob: *mut c_char,\n    key_blob_size: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if private_key.is_null() {\n            bail!(\"private_key must not be null\");\n        }\n        if out_key_blob.is_null() {\n            bail!(\"out_key_blob must not be null\");\n        }\n\n        if key_blob_size \u003c ED25519_PRIVATE_KEY_KEYBLOB_SIZE {\n            bail!(\n                \"key_blob_size must be at least ED25519_PRIVATE_KEY_KEYBLOB_SIZE ('{}'), received '{}'\",\n                ED25519_PRIVATE_KEY_KEYBLOB_SIZE,\n                key_blob_size\n            );\n        }\n\n        let registry = get_ed25519_private_key_registry();\n        match registry.get(private_key as usize) {\n            Some(private_key) =\u003e {\n                let private_key_blob = private_key.to_key_blob();\n                unsafe {\n                    // copy keyblob into output buffer\n                    let key_blob_view =\n                        std::slice::from_raw_parts_mut(out_key_blob as *mut u8, key_blob_size);\n                    std::ptr::copy(\n                        private_key_blob.as_ptr(),\n                        key_blob_view.as_mut_ptr(),\n                        ED25519_PRIVATE_KEY_KEYBLOB_LENGTH,\n                    );\n                    // add final null-terminator\n                    key_blob_view[ED25519_PRIVATE_KEY_KEYBLOB_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail!(\"private_key is invalid\");\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_x25519_private_key\n///\n/// @param out_private_key: returned copy\n/// @param private_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_private_key_clone(\n    out_private_key: *mut *mut GoslingX25519PrivateKey,\n    private_key: *const GoslingX25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n        if private_key.is_null() {\n            bail!(\"private_key must not be null\");\n        }\n\n        let private_key = match get_x25519_private_key_registry().get(private_key as usize) {\n            Some(private_key) =\u003e private_key.clone(),\n            None =\u003e bail!(\"private key is invalid\"),\n        };\n        let handle = get_x25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingX25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting a base64-encoded string used by the\n/// ONION_CLIENT_AUTH_ADD command into a gosling_x25519_private_key\n///\n/// @param out_private_key: returned x25519 private key\n/// @param base64: an x25519 private key encoded as a base64 string\n/// @param base64_length: the number of chars in base64 not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_private_key_from_base64(\n    out_private_key: *mut *mut GoslingX25519PrivateKey,\n    base64: *const c_char,\n    base64_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n        if base64.is_null() {\n            bail!(\"base64 must not be null\");\n        }\n\n        if base64_length != X25519_PRIVATE_KEY_BASE64_LENGTH {\n            bail!(\"base64_length must be exactly X25519_PRIVATE_KEY_BASE64_LENGTH ({}); received '{}'\", X25519_PRIVATE_KEY_BASE64_LENGTH, base64_length);\n        }\n\n        let base64_view = std::slice::from_raw_parts(base64 as *const u8, base64_length);\n        let base64_str = std::str::from_utf8(base64_view)?;\n        let private_key = X25519PrivateKey::from_base64(base64_str)?;\n\n        let handle = get_x25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingX25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an x25519 private key to a null-\n/// terminated base64 string for use with ONION_CLIENT_AUTH_ADD command\n///\n/// @param private_key: the private key to encode\n/// @param out_base64: buffer to be filled with x25519 key encoded as base64\n/// @param base64_size: size of out_base64 buffer in bytes, must be at\n///  least 45 characters (44 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_private_key_to_base64(\n    private_key: *const GoslingX25519PrivateKey,\n    out_base64: *mut c_char,\n    base64_size: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if private_key.is_null() {\n            bail!(\"private_key must not be null\");\n        }\n        if out_base64.is_null() {\n            bail!(\"out_base64 must not be null\");\n        }\n\n        if base64_size \u003c X25519_PRIVATE_KEY_BASE64_SIZE {\n            bail!(\n                \"base64_size must be at least '{}', received '{}'\",\n                X25519_PRIVATE_KEY_BASE64_SIZE,\n                base64_size\n            );\n        }\n\n        let registry = get_x25519_private_key_registry();\n        match registry.get(private_key as usize) {\n            Some(private_key) =\u003e {\n                let private_key_blob = private_key.to_base64();\n                unsafe {\n                    // copy base64 into output buffer\n                    let base64_view =\n                        std::slice::from_raw_parts_mut(out_base64 as *mut u8, base64_size);\n                    std::ptr::copy(\n                        private_key_blob.as_ptr(),\n                        base64_view.as_mut_ptr(),\n                        X25519_PRIVATE_KEY_BASE64_LENGTH,\n                    );\n                    // add final null-terminator\n                    base64_view[X25519_PRIVATE_KEY_BASE64_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail!(\"private_key is invalid\");\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_x25519_public_key\n///\n/// @param out_public_key: returned copy\n/// @param public_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_public_key_clone(\n    out_public_key: *mut *mut GoslingX25519PublicKey,\n    public_key: *const GoslingX25519PublicKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_public_key.is_null() {\n            bail!(\"out_public_key must not be null\");\n        }\n        if public_key.is_null() {\n            bail!(\"public_key must not be null\");\n        }\n\n        let public_key = match get_x25519_public_key_registry().get(public_key as usize) {\n            Some(public_key) =\u003e public_key.clone(),\n            None =\u003e bail!(\"public key is invalid\"),\n        };\n        let handle = get_x25519_public_key_registry().insert(public_key);\n        *out_public_key = handle as *mut GoslingX25519PublicKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting a base32-encoded string used by the\n/// ADD_ONION command into a gosling_x25519_public_key\n///\n/// @param out_public_key: returned x25519 public key\n/// @param base32: an x25519 public key encoded as a base32 string\n/// @param base32_length: the number of chars in base32 not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_public_key_from_base32(\n    out_public_key: *mut *mut GoslingX25519PublicKey,\n    base32: *const c_char,\n    base32_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_public_key.is_null() {\n            bail!(\"out_public_key must not be null\");\n        }\n        if base32.is_null() {\n            bail!(\"bas32 must not be null\");\n        }\n\n        if base32_length != X25519_PUBLIC_KEY_BASE32_LENGTH {\n            bail!(\"base32_length must be exactly X25519_PUBLIC_KEY_BASE32_LENGTH ({}); received '{}'\", X25519_PUBLIC_KEY_BASE32_LENGTH, base32_length);\n        }\n\n        let base32_view = std::slice::from_raw_parts(base32 as *const u8, base32_length);\n        let base32_str = std::str::from_utf8(base32_view)?;\n        let public_key = X25519PublicKey::from_base32(base32_str)?;\n\n        let handle = get_x25519_public_key_registry().insert(public_key);\n        *out_public_key = handle as *mut GoslingX25519PublicKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an x25519 public key to a null-\n/// terminated base64 string for use with ADD_ONION command\n///\n/// @param public_key: the public key to encode\n/// @param out_base32: buffer to be filled with x25519 key encoded as base32\n/// @param base32_size: size of out_base32 buffer in bytes, must be at\n///  least 53 characters (52 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_public_key_to_base32(\n    public_key: *const GoslingX25519PublicKey,\n    out_base32: *mut c_char,\n    base32_size: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if public_key.is_null() {\n            bail!(\"public_key must not be null\");\n        }\n        if out_base32.is_null() {\n            bail!(\"out_base32 must not be null\");\n        }\n\n        if base32_size \u003c X25519_PUBLIC_KEY_BASE32_SIZE {\n            bail!(\n                \"base32_size must be at least '{}', received '{}'\",\n                X25519_PUBLIC_KEY_BASE32_SIZE,\n                base32_size\n            );\n        }\n\n        let registry = get_x25519_public_key_registry();\n        match registry.get(public_key as usize) {\n            Some(public_key) =\u003e {\n                let public_base32 = public_key.to_base32();\n                unsafe {\n                    // copy base32 into output buffer\n                    let base32_view =\n                        std::slice::from_raw_parts_mut(out_base32 as *mut u8, base32_size);\n                    std::ptr::copy(\n                        public_base32.as_ptr(),\n                        base32_view.as_mut_ptr(),\n                        X25519_PUBLIC_KEY_BASE32_LENGTH,\n                    );\n                    // add final null-terminator\n                    base32_view[X25519_PUBLIC_KEY_BASE32_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail!(\"public_key is invalid\");\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_v3_onion_service_id\n///\n/// @param out_service_id: returned copy\n/// @param service_id: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_clone(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    service_id: *const GoslingV3OnionServiceId,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_service_id.is_null() {\n            bail!(\"out_service_id must not be null\");\n        }\n        if service_id.is_null() {\n            bail!(\"service_id must not be null\");\n        }\n\n        let service_id = match get_v3_onion_service_id_registry().get(service_id as usize) {\n            Some(service_id) =\u003e service_id.clone(),\n            None =\u003e bail!(\"service_id is invalid\"),\n        };\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting a v3 onion service string into a\n/// gosling_v3_onion_service_id object\n///\n/// @param out_service_id: returned service id object\n/// @param service_id_string: a v3 onion service id string\n/// @param service_id_string_length: the number of chars in service_id_string not including any\n///  null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_from_string(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    service_id_string: *const c_char,\n    service_id_string_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_service_id.is_null() {\n            bail!(\"out_service_id must not be null\");\n        }\n        if service_id_string.is_null() {\n            bail!(\"service_id_string must not be null\");\n        }\n\n        if service_id_string_length != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            bail!(\"service_id_string_length must be exactly V3_ONION_SERVICE_ID_STRING_LENGTH ({}); received '{}'\", V3_ONION_SERVICE_ID_STRING_LENGTH, service_id_string_length);\n        }\n\n        let service_id_view =\n            std::slice::from_raw_parts(service_id_string as *const u8, service_id_string_length);\n        let service_id_str = std::str::from_utf8(service_id_view)?;\n        let service_id = V3OnionServiceId::from_string(service_id_str)?;\n\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an ed25519 private key  into a\n/// gosling_v3_onion_service_id object\n///\n/// @param out_service_id: returned service id object\n/// @param ed25519_private_key: an e25519 private key\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_from_ed25519_private_key(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    ed25519_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_service_id.is_null() {\n            bail!(\"out_service_id must not be null\");\n        }\n        if ed25519_private_key.is_null() {\n            bail!(\"ed25519_private_key must not be null\");\n        }\n\n        let service_id = {\n            let ed25519_private_key_registry = get_ed25519_private_key_registry();\n            let ed25519_private_key =\n                match ed25519_private_key_registry.get(ed25519_private_key as usize) {\n                    Some(ed25519_private_key) =\u003e ed25519_private_key,\n                    None =\u003e bail!(\"ed25519_private_key is invalid\"),\n                };\n            V3OnionServiceId::from_private_key(ed25519_private_key)\n        };\n\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting v3 onion service id to a null-terminated\n/// string\n///\n/// @param service_id: the service id to encode\n/// @param out_service_id_string: buffer to be filled with x25519 key encoded as base32\n/// @param service_id_string_size: size of out_service_id_string buffer in bytes,\n///  must be at least 57 characters (56 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_v3_onion_service_id_to_string(\n    service_id: *const GoslingV3OnionServiceId,\n    out_service_id_string: *mut c_char,\n    service_id_string_size: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if service_id.is_null() {\n            bail!(\"service_id must not be null\");\n        }\n        if out_service_id_string.is_null() {\n            bail!(\"out_service_id_string must not be null\");\n        }\n\n        if service_id_string_size \u003c V3_ONION_SERVICE_ID_STRING_SIZE {\n            bail!(\n                \"service_id_string_size must be at least '{}', received '{}'\",\n                V3_ONION_SERVICE_ID_STRING_SIZE,\n                service_id_string_size\n            );\n        }\n\n        let registry = get_v3_onion_service_id_registry();\n        match registry.get(service_id as usize) {\n            Some(service_id) =\u003e {\n                let service_id_string = service_id.to_string();\n                unsafe {\n                    // copy service_id_string into output buffer\n                    let service_id_string_view = std::slice::from_raw_parts_mut(\n                        out_service_id_string as *mut u8,\n                        service_id_string_size,\n                    );\n                    std::ptr::copy(\n                        service_id_string.as_ptr(),\n                        service_id_string_view.as_mut_ptr(),\n                        V3_ONION_SERVICE_ID_STRING_LENGTH,\n                    );\n                    // add final null-terminator\n                    service_id_string_view[V3_ONION_SERVICE_ID_STRING_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail!(\"service_id is invalid\");\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Checks if a service id string is valid per tor rend spec:\n/// https://gitweb.torproject.org/torspec.git/tree/rend-spec-v3.txt\n///\n/// @param service_id_string: string containing the v3 service id to be validated\n/// @param service_id_string_length: the number of chars in service_id_string not including any\n///  null-terminator; must be V3_ONION_SERVICE_ID_STRING_LENGTH (56)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_string_is_valid_v3_onion_service_id(\n    service_id_string: *const c_char,\n    service_id_string_length: usize,\n    error: *mut *mut GoslingFFIError,\n) -\u003e bool {\n    translate_failures(false, error, || -\u003e anyhow::Result\u003cbool\u003e {\n        if service_id_string.is_null() {\n            bail!(\"service_id_string must not be null\");\n        }\n\n        if service_id_string_length != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            bail!(\n                \"service_id_string_length must be V3_ONION_SERVICE_ID_STRING_LENGTH (56); received '{}'\",\n                service_id_string_length\n            );\n        }\n\n        let service_id_string_slice = unsafe {\n            std::slice::from_raw_parts(service_id_string as *const u8, service_id_string_length)\n        };\n        Ok(V3OnionServiceId::is_valid(str::from_utf8(\n            service_id_string_slice,\n        )?))\n    })\n}\n\n/// Create a new tor provider which uses the legacy tor daemon client.\n///\n/// @param out_tor_provider: returned tor provider\n/// @param tor_bin_path: the file system path to the tor binary; if this is null the tor executable\n///  found in the system PATH variable is used\n/// @param tor_bin_path_length: the number of chars in tor_bin_path not including any null terminator\n/// @param tor_working_directory: the file system path to store tor's data\n/// @param tor_working_directory_length: the number of chars in tor_working_directory not including any\n///  null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_new_legacy_client(\n    out_tor_provider: *mut *mut GoslingTorProvider,\n    tor_bin_path: *const c_char,\n    tor_bin_path_length: usize,\n    tor_working_directory: *const c_char,\n    tor_working_directory_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_tor_provider.is_null() {\n            bail!(\"out_tor_provider must not be null\");\n        }\n        if tor_bin_path.is_null() \u0026\u0026 tor_bin_path_length != 0 {\n            bail!(\"tor_bin_path is null so tor_bin_path_length must be 0\");\n        }\n        if !tor_bin_path.is_null() \u0026\u0026 tor_bin_path_length == 0 {\n            bail!(\"tor_bin_path is not null so tor_bin_path_length must be greater than 0\");\n        }\n        if tor_working_directory.is_null() {\n            bail!(\"tor_working_directory must not be null\");\n        }\n        if tor_working_directory_length == 0usize {\n            bail!(\"tor_working_directory_length must not be 0\");\n        }\n\n        let tor_bin_path = if tor_bin_path.is_null() {\n            which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?\n        } else {\n            let tor_bin_path =\n                std::slice::from_raw_parts(tor_bin_path as *const u8, tor_bin_path_length);\n            let tor_bin_path = std::str::from_utf8(tor_bin_path)?;\n            let tor_bin_path = Path::new(tor_bin_path);\n            tor_bin_path.canonicalize()?\n        };\n\n        // tor working dir\n        let tor_working_directory = std::slice::from_raw_parts(\n            tor_working_directory as *const u8,\n            tor_working_directory_length,\n        );\n        let tor_working_directory = std::str::from_utf8(tor_working_directory)?;\n        let tor_working_directory = Path::new(tor_working_directory);\n\n        let tor_client = LegacyTorClient::new(\u0026tor_bin_path, tor_working_directory)?;\n        let tor_provider = Box::new(tor_client);\n\n        let handle = get_tor_provider_registry().insert(tor_provider);\n        *out_tor_provider = handle as *mut GoslingTorProvider;\n\n        Ok(())\n    });\n}\n\n/// Create a mock tor provider for no-internet required in-process testing.\n///\n/// @param out_tor_provider: returned tor provider\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_new_mock_client(\n    out_tor_provider: *mut *mut GoslingTorProvider,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_tor_provider.is_null() {\n            bail!(\"out_tor_provider must not be null\");\n        }\n\n        let tor_client: MockTorClient = Default::default();\n        let tor_provider = Box::new(tor_client);\n\n        let handle = get_tor_provider_registry().insert(tor_provider);\n        *out_tor_provider = handle as *mut GoslingTorProvider;\n\n        Ok(())\n    });\n}\n\n/// Initialize a gosling context.\n///\n/// @param out_context: returned initialied gosling context\n/// @param in_tor_provider: the tor client implementation to use; this function consumes the tor_provider\n///  and it may not be re-used in subsequent gosling_* calls, and it does not need to be freed\n/// @param identity_port: the tor virtual port the identity server listens on\n/// @param endpoint_port: the tor virtual port endpoint servers listen on\n/// @param identity_private_key: the e25519 private key used to start th identity server's onion service\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_context_init(\n    // out context\n    out_context: *mut *mut GoslingContext,\n    in_tor_provider: *mut GoslingTorProvider,\n    identity_port: u16,\n    endpoint_port: u16,\n    identity_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_context.is_null() {\n            bail!(\"out_context must not be null\");\n        }\n        if in_tor_provider.is_null() {\n            bail!(\"in_tor_provider must not be null\");\n        }\n        if identity_port == 0u16 {\n            bail!(\"identity_port must not be 0\");\n        }\n        if endpoint_port == 0u16 {\n            bail!(\"endpoint_port must not be 0\");\n        }\n        if identity_private_key.is_null() {\n            bail!(\"identity_private_key must not be null\");\n        }\n\n        // get our tor provider\n        let tor_provider = match get_tor_provider_registry().remove(in_tor_provider as usize) {\n            Some(tor_provider) =\u003e tor_provider,\n            None =\u003e bail!(\"tor_provider is invalid\"),\n        };\n\n        // get our identity key\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let identity_private_key =\n            match ed25519_private_key_registry.get(identity_private_key as usize) {\n                Some(identity_private_key) =\u003e identity_private_key,\n                None =\u003e bail!(\"identity_private_key is invalid\"),\n            };\n\n        // construct context\n        let context = Context::new(\n            tor_provider,\n            identity_port,\n            endpoint_port,\n            Duration::from_secs(60),\n            4096,\n            Some(Duration::from_secs(60)),\n            identity_private_key.clone(),\n        )?;\n\n        let handle = get_context_tuple_registry().insert((context, Default::default(), None));\n        *out_context = handle as *mut GoslingContext;\n\n        Ok(())\n    });\n}\n\n/// Connect a gosling_context to the tor network\n///\n/// @param context: the gosling context object to connect to the tor network\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_bootstrap_tor(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n        Ok(context.0.bootstrap()?)\n    });\n}\n\n/// Start the identity server so that clients may request endpoints\n///\n/// @param context: the gosling context whose identity server to start\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_start_identity_server(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n        Ok(context.0.identity_server_start()?)\n    });\n}\n\n/// Stop the identity server so clients can no longer request endpoints\n///\n/// @param context: the gosling context whose identity server to stop\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_stop_identity_server(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n        Ok(context.0.identity_server_stop()?)\n    });\n}\n\n/// Start an endpoint server so the confirmed contact may connect\n///\n/// @param context: the gosling context with the given endpoint to start\n/// @param endpoint_private_key: the ed25519 private key needed to start the endpoint\n///  onion service\n/// @param endpoint_name: the ascii-encoded name of the endpoint server\n/// @param endpoint_name_length: the number of chars in endpoint name not including any null-terminator\n/// @param client_identity: the v3 onion service id of the gosling client associated with this endpoint\n/// @param client_auth_public_key: the x25519 public key used to encrypt the onion service descriptor\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_start_endpoint_server(\n    context: *mut GoslingContext,\n    endpoint_private_key: *const GoslingEd25519PrivateKey,\n    endpoint_name: *const c_char,\n    endpoint_name_length: usize,\n    client_identity: *const GoslingV3OnionServiceId,\n    client_auth_public_key: *const GoslingX25519PublicKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n        if endpoint_private_key.is_null() {\n            bail!(\"endpoint_private_key mut not be null\");\n        }\n        if endpoint_name.is_null() {\n            bail!(\"endpoint_name must not be null\");\n        }\n        if endpoint_name_length == 0 {\n            bail!(\"endpoint_name_length must not be 0\");\n        }\n        if client_identity.is_null() {\n            bail!(\"client_identity must not be null\");\n        }\n        if client_auth_public_key.is_null() {\n            bail!(\"client_auth_public_key must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n\n        let endpoint_name =\n            unsafe { std::slice::from_raw_parts(endpoint_name as *const u8, endpoint_name_length) };\n        let endpoint_name = std::str::from_utf8(endpoint_name)?.to_string();\n        if !endpoint_name.is_ascii() {\n            bail!(\"endpoint_name must be an ascii string\");\n        }\n\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let endpoint_private_key =\n            match ed25519_private_key_registry.get(endpoint_private_key as usize) {\n                Some(ed25519_private_key) =\u003e ed25519_private_key,\n                None =\u003e bail!(\"endpoint_private_key is invalid\"),\n            };\n\n        let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n        let client_identity = match v3_onion_service_id_registry.get(client_identity as usize) {\n            Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n            None =\u003e bail!(\"client_identity is invalid\"),\n        };\n\n        let x25519_public_key_registry = get_x25519_public_key_registry();\n        let client_auth_public_key =\n            match x25519_public_key_registry.get(client_auth_public_key as usize) {\n                Some(x25519_public_key) =\u003e x25519_public_key,\n                None =\u003e bail!(\"client_auth_public_key is invalid\"),\n            };\n\n        Ok(context.0.endpoint_server_start(\n            endpoint_private_key.clone(),\n            endpoint_name,\n            client_identity.clone(),\n            client_auth_public_key.clone(),\n        )?)\n    });\n}\n\n/// Stops an endpoint server\n///\n/// @param context: the gosling context associated with the endpoint server\n/// @param endpoint_private_key: the ed25519 private key associated with the endpoint server to stop\n/// @param error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_stop_endpoint_server(\n    context: *mut GoslingContext,\n    endpoint_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n        if endpoint_private_key.is_null() {\n            bail!(\"endpoint_private_key must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let endpoint_private_key =\n            match ed25519_private_key_registry.get(endpoint_private_key as usize) {\n                Some(ed25519_private_key) =\u003e ed25519_private_key,\n                None =\u003e bail!(\"endpoint_private_key is invalid\"),\n            };\n\n        let endpoint_identity = V3OnionServiceId::from_private_key(endpoint_private_key);\n        Ok(context.0.endpoint_server_stop(endpoint_identity)?)\n    });\n}\n\n/// Connect to and begin a handshake to request an endpoint from the given identity server\n///\n/// @param context: the context to request an endpoint server for\n/// @param identity_service_id: the service id of the identity server we want to request an endpoint server\n///  from\n/// @param endpoint_name: the name of the endpoint server to request\n/// @param endpoint_name_length: the number of chars in endpoin_name not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_begin_identity_handshake(\n    context: *mut GoslingContext,\n    identity_service_id: *const GoslingV3OnionServiceId,\n    endpoint_name: *const c_char,\n    endpoint_name_length: usize,\n    error: *mut *mut GoslingFFIError,\n) -\u003e GoslingHandshakeHandle {\n    translate_failures(\n        !0usize,\n        error,\n        || -\u003e anyhow::Result\u003cGoslingHandshakeHandle\u003e {\n            if context.is_null() {\n                bail!(\"context must not be null\");\n            }\n            if identity_service_id.is_null() {\n                bail!(\"identity_service_id must not be null\");\n            }\n            if endpoint_name.is_null() {\n                bail!(\"endpoint_name must not be null\");\n            }\n            if endpoint_name_length == 0 {\n                bail!(\"endpoint_name_length must not be 0\");\n            }\n\n            let mut context_tuple_registry = get_context_tuple_registry();\n            let context = match context_tuple_registry.get_mut(context as usize) {\n                Some(context) =\u003e context,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n\n            let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n            let identity_service_id =\n                match v3_onion_service_id_registry.get(identity_service_id as usize) {\n                    Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n                    None =\u003e bail!(\"identity_service_id is invalid\"),\n                };\n\n            let endpoint_name = unsafe {\n                std::slice::from_raw_parts(endpoint_name as *const u8, endpoint_name_length)\n            };\n            let endpoint_name = std::str::from_utf8(endpoint_name)?.to_string();\n            if !endpoint_name.is_ascii() {\n                bail!(\"endpoint_name must be an ascii string\")\n            }\n\n            Ok(context\n                .0\n                .identity_client_begin_handshake(identity_service_id.clone(), endpoint_name)?)\n        },\n    )\n}\n\n/// Abort an in-progress identity client handshake\n///\n/// @param context: the context associated with the identity client handshake handle\n/// @param handshake_handle: the handle associated with the identity client handshake\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_abort_identity_client_handshake(\n    context: *mut GoslingContext,\n    handshake_handle: GoslingHandshakeHandle,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n\n        Ok(context\n            .0\n            .identity_client_abort_handshake(handshake_handle)?)\n    })\n}\n\n/// Connect to and begin a handshake to request a channel from the given endpoint server\n///\n/// @param context: the context which will be opening the channel\n/// @param endpoint_service_id: the endpoint server to open a channel to\n/// @param client_auth_private_key: the x25519 clienth authorization key needed to decrypt the endpoint server's\n///  onion service descriptor\n/// @param channel_name: the ascii-encoded name of the channel to open\n/// @param channel_name_length: the number of chars in channel name not including any null-terminator\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_begin_endpoint_handshake(\n    context: *mut GoslingContext,\n    endpoint_service_id: *const GoslingV3OnionServiceId,\n    client_auth_private_key: *const GoslingX25519PrivateKey,\n    channel_name: *const c_char,\n    channel_name_length: usize,\n    error: *mut *mut GoslingFFIError,\n) -\u003e GoslingHandshakeHandle {\n    translate_failures(\n        !0usize,\n        error,\n        || -\u003e anyhow::Result\u003cGoslingHandshakeHandle\u003e {\n            if context.is_null() {\n                bail!(\"context must not be null\");\n            }\n            if endpoint_service_id.is_null() {\n                bail!(\"endpoint_service_id must not be null\");\n            }\n            if client_auth_private_key.is_null() {\n                bail!(\"client_auth_private_key must not be null\");\n            }\n            if channel_name.is_null() {\n                bail!(\"channel_name must not be null\");\n            }\n            if channel_name_length == 0 {\n                bail!(\"channel_name_length must not be 0\");\n            }\n\n            let mut context_tuple_registry = get_context_tuple_registry();\n            let context = match context_tuple_registry.get_mut(context as usize) {\n                Some(context) =\u003e context,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n\n            let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n            let endpoint_service_id =\n                match v3_onion_service_id_registry.get(endpoint_service_id as usize) {\n                    Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n                    None =\u003e bail!(\"endpoint_service_id is invalid\"),\n                };\n\n            let x25519_private_key_registry = get_x25519_private_key_registry();\n            let client_auth_private_key =\n                match x25519_private_key_registry.get(client_auth_private_key as usize) {\n                    Some(x25519_private_key) =\u003e x25519_private_key,\n                    None =\u003e bail!(\"client_auth_private_key is invalid\"),\n                };\n\n            let channel_name = unsafe {\n                std::slice::from_raw_parts(channel_name as *const u8, channel_name_length)\n            };\n            let channel_name = std::str::from_utf8(channel_name)?.to_string();\n            if !channel_name.is_ascii() {\n                bail!(\"channel_name must be an ascii string\");\n            }\n\n            Ok(context.0.endpoint_client_begin_handshake(\n                endpoint_service_id.clone(),\n                client_auth_private_key.clone(),\n                channel_name,\n            )?)\n        },\n    )\n}\n\n/// Abort an in-progress endpoint client handshake\n///\n/// @param context: the context associated with the endpoint client handshake handle\n/// @param handshake_handle: the handle associated with the identity client handshake\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_abort_endpoint_client_handshake(\n    context: *mut GoslingContext,\n    handshake_handle: GoslingHandshakeHandle,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n\n        Ok(context\n            .0\n            .endpoint_client_abort_handshake(handshake_handle)?)\n    })\n}\n\nfn handle_context_event(\n    event: ContextEvent,\n    context: *mut GoslingContext,\n    callbacks: \u0026EventCallbacks,\n) -\u003e anyhow::Result\u003c()\u003e {\n    match event {\n        //\n        // Tor Events\n        //\n        ContextEvent::TorBootstrapStatusReceived {\n            progress,\n            tag,\n            summary,\n        } =\u003e {\n            if let Some(callback) = callbacks.tor_bootstrap_status_received_callback {\n                let tag0 = CString::new(tag.as_str()).expect(\n                    \"bootstrap status tag string should not have an intermediate null byte\",\n                );\n                let summary0 = CString::new(summary.as_str()).expect(\n                    \"bootstrap status summary string should not have an intermediate null byte\",\n                );\n                callback(\n                    context,\n                    progress,\n                    tag0.as_ptr(),\n                    tag.len(),\n                    summary0.as_ptr(),\n                    summary.len(),\n                );\n            }\n        }\n        ContextEvent::TorBootstrapCompleted =\u003e {\n            if let Some(callback) = callbacks.tor_bootstrap_completed_callback {\n                callback(context);\n            }\n        }\n        ContextEvent::TorLogReceived { line } =\u003e {\n            if let Some(callback) = callbacks.tor_log_received_callback {\n                let line0 = CString::new(line.as_str())\n                    .expect(\"tor log line string should not have an intermediate null byte\");\n                callback(context, line0.as_ptr(), line.len());\n            }\n        }\n        //\n        // Identity Client Events\n        //\n        ContextEvent::IdentityClientChallengeReceived {\n            handle,\n            endpoint_challenge,\n        } =\u003e {\n            // construct challenge response\n            let challenge_response = if let (\n                Some(challenge_response_size_callback),\n                Some(build_challenge_response_callback),\n            ) = (\n                callbacks.identity_client_challenge_response_size_callback,\n                callbacks.identity_client_build_challenge_response_callback,\n            ) {\n                let mut endpoint_challenge_buffer: Vec\u003cu8\u003e = Default::default();\n                endpoint_challenge.to_writer(\u0026mut endpoint_challenge_buffer).expect(\"endpoint_challenge should be a valid bson::document::Document and therefore serializable to Vec\u003cu8\u003e\");\n\n                // get the size of challenge response bson blob\n                let challenge_response_size = challenge_response_size_callback(\n                    context,\n                    handle,\n                    endpoint_challenge_buffer.as_ptr(),\n                    endpoint_challenge_buffer.len(),\n                );\n\n\n                if challenge_response_size \u003c SMALLEST_BSON_DOC_SIZE {\n                    bail!(\"identity_client_challenge_response_size_callback returned an impossibly small size '{}', smallest possible is {}\", challenge_response_size, SMALLEST_BSON_DOC_SIZE);\n                }\n\n                // get the challenge response bson blob\n                let mut challenge_response_buffer: Vec\u003cu8\u003e = vec![0u8; challenge_response_size];\n                build_challenge_response_callback(\n                    context,\n                    handle,\n                    endpoint_challenge_buffer.as_ptr(),\n                    endpoint_challenge_buffer.len(),\n                    challenge_response_buffer.as_mut_ptr(),\n                    challenge_response_buffer.len(),\n                );\n\n                // convert bson blob to bson object\n                match bson::document::Document::from_reader(Cursor::new(challenge_response_buffer))\n                {\n                    Ok(challenge_response) =\u003e challenge_response,\n                    Err(_) =\u003e bail!(\"failed to parse binary provided by identity_client_build_challenge_response_callback as BSON document\")\n                }\n            } else {\n                bail!(\"missing required identity_client_challenge_response_size() and identity_client_build_challenge_response() callbacks\");\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .identity_client_handle_challenge_received(handle, challenge_response)?,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n        }\n        ContextEvent::IdentityClientHandshakeCompleted {\n            handle,\n            identity_service_id,\n            endpoint_service_id,\n            endpoint_name,\n            client_auth_private_key,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_client_handshake_completed_callback {\n                let (identity_service_id, endpoint_service_id) = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    let identity_service_id =\n                        v3_onion_service_id_registry.insert(identity_service_id);\n                    let endpoint_service_id =\n                        v3_onion_service_id_registry.insert(endpoint_service_id);\n                    (identity_service_id, endpoint_service_id)\n                };\n\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                let client_auth_private_key =\n                    get_x25519_private_key_registry().insert(client_auth_private_key);\n\n                callback(\n                    context,\n                    handle,\n                    identity_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                    client_auth_private_key as *const GoslingX25519PrivateKey,\n                );\n\n                // cleanup\n                {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.remove(identity_service_id);\n                    v3_onion_service_id_registry.remove(endpoint_service_id);\n                }\n                get_x25519_private_key_registry().remove(client_auth_private_key);\n            } else {\n                bail!(\"missing required identity_client_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::IdentityClientHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.identity_client_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingFFIError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Identity Server Events\n        //\n        ContextEvent::IdentityServerPublished =\u003e {\n            if let Some(callback) = callbacks.identity_server_published_callback {\n                callback(context);\n            }\n        }\n        ContextEvent::IdentityServerHandshakeStarted { handle } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_started_callback {\n                callback(context, handle);\n            }\n        }\n        ContextEvent::IdentityServerEndpointRequestReceived {\n            handle,\n            client_service_id,\n            requested_endpoint,\n        } =\u003e {\n            let client_allowed = match callbacks.identity_server_client_allowed_callback {\n                Some(callback) =\u003e {\n                    let client_service_id =\n                        get_v3_onion_service_id_registry().insert(client_service_id);\n                    callback(\n                        context,\n                        handle,\n                        client_service_id as *const GoslingV3OnionServiceId,\n                    )\n                }\n                None =\u003e bail!(\"missing required identity_server_client_allowed() callback\"),\n            };\n\n            let endpoint_supported = match callbacks.identity_server_endpoint_supported_callback {\n                Some(callback) =\u003e {\n                    let requested_endpoint0 = CString::new(requested_endpoint.as_str()).expect(\n                        \"requested_endpoint should be a valid ASCII string and not have an intermediate null byte\",\n                    );\n                    callback(\n                        context,\n                        handle,\n                        requested_endpoint0.as_ptr(),\n                        requested_endpoint.len(),\n                    )\n                }\n                None =\u003e bail!(\"missing required identity_server_endpoint_supported() callback\"),\n            };\n            let endpoint_challenge = if let (\n                Some(challenge_size_callback),\n                Some(build_challenge_callback),\n            ) = (\n                callbacks.identity_server_challenge_size_callback,\n                callbacks.identity_server_build_challenge_callback,\n            ) {\n                // get the challenge size in bytes\n                let challenge_size = challenge_size_callback(context, handle);\n\n                if challenge_size \u003c SMALLEST_BSON_DOC_SIZE {\n                    bail!(\"identity_server_challenge_size_callback returned an impossibly small size '{}', smallest possible is {}\", challenge_size, SMALLEST_BSON_DOC_SIZE);\n                }\n\n                // construct challenge object into buffer\n                let mut challenge_buffer = vec![0u8; challenge_size];\n                build_challenge_callback(\n                    context,\n                    handle,\n                    challenge_buffer.as_mut_ptr(),\n                    challenge_size,\n                );\n\n                // convert bson blob to bson object\n                match bson::document::Document::from_reader(Cursor::new(challenge_buffer)) {\n                    Ok(challenge) =\u003e challenge,\n                    Err(_) =\u003e bail!(\"failed to parse binary provided by identity_server_build_challenge_callback as BSON document\")\n                }\n            } else {\n                bail!(\"missing required identity_server_challenge_size() and identity_server_build_challenge() callbacks\");\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context.0.identity_server_handle_endpoint_request_received(\n                    handle,\n                    client_allowed,\n                    endpoint_supported,\n                    endpoint_challenge,\n                )?,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n        }\n        ContextEvent::IdentityServerChallengeResponseReceived {\n            handle,\n            challenge_response,\n        } =\u003e {\n            let challenge_response_valid = match callbacks\n                .identity_server_verify_challenge_response_callback\n            {\n                Some(callback) =\u003e {\n                    // get response as bytes\n                    let mut challenge_response_buffer: Vec\u003cu8\u003e = Default::default();\n                    challenge_response\n                            .to_writer(\u0026mut challenge_response_buffer).expect(\"challenge_response should be a valid bson::document::Document and therefore serializable to Vec\u003cu8\u003e\");\n\n                    callback(\n                        context,\n                        handle,\n                        challenge_response_buffer.as_ptr(),\n                        challenge_response_buffer.len(),\n                    )\n                }\n                None =\u003e {\n                    bail!(\"missing required identity_server_verify_challenge_response() callback()\")\n                }\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .identity_server_handle_challenge_response_received(\n                        handle,\n                        challenge_response_valid,\n                    )?,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n        }\n        ContextEvent::IdentityServerHandshakeCompleted {\n            handle,\n            endpoint_private_key,\n            endpoint_name,\n            client_service_id,\n            client_auth_public_key,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_completed_callback {\n                let endpoint_private_key = {\n                    let mut ed25519_private_key_registry = get_ed25519_private_key_registry();\n                    ed25519_private_key_registry.insert(endpoint_private_key)\n                };\n\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                let client_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(client_service_id)\n                };\n\n                let client_auth_public_key = {\n                    let mut x25519_public_key_registry = get_x25519_public_key_registry();\n                    x25519_public_key_registry.insert(client_auth_public_key)\n                };\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_private_key as *const GoslingEd25519PrivateKey,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                    client_service_id as *const GoslingV3OnionServiceId,\n                    client_auth_public_key as *const GoslingX25519PublicKey,\n                );\n\n                // cleanup\n                get_ed25519_private_key_registry().remove(endpoint_private_key);\n                get_v3_onion_service_id_registry().remove(client_service_id);\n                get_x25519_public_key_registry().remove(client_auth_public_key);\n            } else {\n                bail!(\"missing required identity_server_handshake_completed_callback()\");\n            }\n        }\n        ContextEvent::IdentityServerHandshakeRejected {\n            handle,\n            client_allowed,\n            client_requested_endpoint_valid,\n            client_proof_signature_valid,\n            client_auth_signature_valid,\n            challenge_response_valid,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_rejected_callback {\n                callback(\n                    context,\n                    handle,\n                    client_allowed,\n                    client_requested_endpoint_valid,\n                    client_proof_signature_valid,\n                    client_auth_signature_valid,\n                    challenge_response_valid,\n                );\n            }\n        }\n        ContextEvent::IdentityServerHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingFFIError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Endpoint Client Events\n        //\n        ContextEvent::EndpointClientHandshakeCompleted {\n            endpoint_service_id,\n            handle,\n            channel_name,\n            stream,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_client_handshake_completed_callback {\n                let endpoint_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(endpoint_service_id)\n                };\n                let channel_name0 = CString::new(channel_name.as_str())\n                    .expect(\"channel_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n                let stream = stream.into_raw_fd();\n                #[cfg(target_os = \"windows\")]\n                let stream = stream.into_raw_socket();\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    channel_name0.as_ptr(),\n                    channel_name.len(),\n                    stream,\n                );\n\n                // cleanup\n                get_v3_onion_service_id_registry().remove(endpoint_service_id);\n            } else {\n                bail!(\"missing required endpoint_client_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::EndpointClientHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.endpoint_client_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingFFIError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Endpoint Server Events\n        //\n        ContextEvent::EndpointServerPublished {\n            endpoint_service_id,\n            endpoint_name,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_published_callback {\n                let endpoint_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(endpoint_service_id)\n                };\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                callback(\n                    context,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                );\n\n                // cleanup\n                get_v3_onion_service_id_registry().remove(endpoint_service_id);\n            }\n        }\n        ContextEvent::EndpointServerHandshakeStarted { handle } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_started_callback {\n                callback(context, handle);\n            }\n        }\n        ContextEvent::EndpointServerChannelRequestReceived {\n            handle,\n            client_service_id,\n            requested_channel,\n        } =\u003e {\n            let channel_supported: bool = match callbacks.endpoint_server_channel_supported_callback\n            {\n                Some(callback) =\u003e {\n                    let client_service_id = {\n                        let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                        v3_onion_service_id_registry.insert(client_service_id)\n                    };\n                    let requested_channel0 = CString::new(requested_channel.as_str()).expect(\"requested_channel should be a valid ASCII string and not have an intermediate null byte\",\n                    );\n                    let channel_supported = callback(\n                        context,\n                        handle,\n                        client_service_id as *const GoslingV3OnionServiceId,\n                        requested_channel0.as_ptr(),\n                        requested_channel.len(),\n                    );\n\n                    // cleanup\n                    get_v3_onion_service_id_registry().remove(client_service_id);\n                    channel_supported\n                }\n                None =\u003e bail!(\"missing required endpoint_server_channel_supported() callback\"),\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .endpoint_server_handle_channel_request_received(handle, channel_supported)?,\n                None =\u003e return Err(anyhow!(\"context is invalid\")),\n            };\n        }\n        ContextEvent::EndpointServerHandshakeCompleted {\n            handle,\n            endpoint_service_id,\n            client_service_id,\n            channel_name,\n            stream,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_completed_callback {\n                let (endpoint_service_id, client_service_id) = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    let endpoint_service_id =\n                        v3_onion_service_id_registry.insert(endpoint_service_id);\n                    let client_service_id = v3_onion_service_id_registry.insert(client_service_id);\n                    (endpoint_service_id, client_service_id)\n                };\n\n                let channel_name0 = CString::new(channel_name.as_str())\n                    .expect(\"channel_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n                let stream = stream.into_raw_fd();\n                #[cfg(target_os = \"windows\")]\n                let stream = stream.into_raw_socket();\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    client_service_id as *const GoslingV3OnionServiceId,\n                    channel_name0.as_ptr(),\n                    channel_name.len(),\n                    stream,\n                );\n\n                // cleanup\n                {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.remove(endpoint_service_id);\n                    v3_onion_service_id_registry.remove(client_service_id);\n                }\n            } else {\n                bail!(\"missing required endpoint_server_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::EndpointServerHandshakeRejected {\n            handle,\n            client_allowed,\n            client_requested_channel_valid,\n            client_proof_signature_valid,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_rejected_callback {\n                callback(\n                    context,\n                    handle,\n                    client_allowed,\n                    client_requested_channel_valid,\n                    client_proof_signature_valid,\n                );\n            }\n        }\n        ContextEvent::EndpointServerHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingFFIError);\n                get_error_registry().remove(key);\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Update the internal gosling context state and process event callbacks\n///\n/// @param context: the context object we are updating\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_poll_events(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        // we need to scope the context registry explicitly here\n        // in case our callbacks want to call any gosling functions\n        // to avoid deadlock (since a mutex is held while the context_tuple_registry\n        // is accesible)\n        let (mut context_events, callbacks) =\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e {\n                    // get our new events\n                    let mut new_events = context.0.update()?;\n                    // get a copy of our callbacks\n                    let callbacks = context.1.clone();\n\n                    // append new_events to any existing events if they exist,\n                    // otherwise just pass through new_events\n                    let context_events = match std::mem::take(\u0026mut context.2) {\n                        Some(mut context_events) =\u003e {\n                            context_events.append(\u0026mut new_events);\n                            context_events\n                        }\n                        None =\u003e {\n                            // no previous events so just pass through the new events\n                            new_events\n                        }\n                    };\n                    (context_events, callbacks)\n                }\n                None =\u003e bail!(\"context is invalid\"),\n            };\n\n        // consume the events and trigger any callbacks\n        while let Some(event) = context_events.pop_front() {\n            let result = handle_context_event(event, context, \u0026callbacks);\n            if result.is_err() {\n                // if we have remaining events to consume, save them off on\n                // the context\n                if !context_events.is_empty() {\n                    if let Some(context) = get_context_tuple_registry().get_mut(context as usize) {\n                        context.2 = Some(context_events);\n                    }\n                }\n                // return the error\n                return result;\n            }\n        }\n        Ok(())\n    });\n}\n\n/// The function pointer type for the tor bootstrap status received callback. This\n/// callback is called when context's tor daemon's bootstrap status has progressed.\n///\n/// @param context: the context associated with this event\n/// @param progress: an unsigned integer from 0 to 100 indicating the current completion\n///  perentage of the context's bootstrap process\n/// @param tag: the null-terminated short name of the current bootstrap stage\n/// @param tag_length: the number of chrs in tag not including any null-terminator\n/// @param summary: the null-terminated description of the current bootstra stage\n/// @param summmary_length: the number of chars in summary not including the null-terminator\npub type GoslingTorBootstrapStatusReceivedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        progress: u32,\n        tag: *const c_char,\n        tag_length: usize,\n        summary: *const c_char,\n        summary_length: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the tor boootstrap completed callback. This callback\n/// is called when the context's tor daemon's bootstrap process has completed.\n///\n/// @param context: the context associated with this event\npub type GoslingTorBootstrapCompletedCallback =\n    Option\u003cextern \"C\" fn(context: *mut GoslingContext) -\u003e ()\u003e;\n\n/// The function pointer type for the tor log received callback. This callback is called\n/// whenever the context's tor daemon prints new log lines.\n///\n/// @param context: the context associated with this event\n/// @param line: the null-terminated received log line\n/// @param line_length: the number of chars in line not including the null-terminator\npub type GoslingTorLogReceivedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, line: *const c_char, line_length: usize) -\u003e (),\n\u003e;\n\n/// The function pointer type for the client handshake challenge response size\n/// callback. This callback is called when a client needs to know how much memory\n/// to allocate for a challenge response.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: pointer to the client handshake handle this callback\n///  invocation is associated with; null if no client handshake init callback was\n///  provided\n/// @param challenge_buffer: the source buffer containing a BSON document received\n///  from the  identity server to serve as an endpoint request challenge\n/// @param challenge_buffer_size: the number of bytes in challenge_buffer\n/// @return the number of bytes required to store the challenge response object\npub type GoslingIdentityClientHandshakeChallengeResponseSizeCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n    ) -\u003e usize,\n\u003e;\n\n/// The function pointer type for the identity client handshake build challlenge\n/// response callback. This callback is called when a client is ready to build a\n/// challenge response object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param endpoint_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @param challenge_buffer: the source buffer containing a BSON document received\n///  from the  identity server to serve as an endpoint request challenge\n/// @param challenge_buffer_size: the number of bytes in challenge_buffer\n/// @param out_challenge_response_buffer: the destination buffer for the callback\n///  to write a BSON document representing the endpoint request challenge response\n///  object\n/// @param out_challenge_response_buffer_size: the number of bytes allocated in\n///  out_challenge_response_buffer\npub type GoslingIdentityClientHandshakeBuildChallengeResponseCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n        out_challenge_response_buffer: *mut u8,\n        out_challenge_response_buffer_size: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity client handshake completed callback. This\n/// callback is called whenever the client successfully completes a handshake with an\n/// identity server and is granted access to an endpoint server.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param identity_service_id: the onion service id of the identity server the client\n///  has successfully completed a hadshake with\n/// @param endpoint_service_id: the onion service id of the endpoint server the client\n///  now has access to\n/// @param endpoint_name: the null-terminated name of the provided endpoint server\n/// @param endpoint_name_length: the number of chars in endpoint_name string not including\n///  the null-terminator\n/// @param client_auth_private_key: the client's x25519 private required to connect to\n///  the provided endpoint server\npub type GoslingIdentityClientHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        identity_service_id: *const GoslingV3OnionServiceId,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_auth_private_key: *const GoslingX25519PrivateKey,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity client handshake handshake failed\n/// callback. This callback is called when a client's identity handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingIdentityClientHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingFFIError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity server published callback. This callback\n/// is called whenever the onion service of the identity server associated with the given\n/// context is published and should be reachable by clients.\n///\n/// @param context: the context associated with this event\npub type GoslingIdentityServerPublishedCallback =\n    Option\u003cextern \"C\" fn(context: *mut GoslingContext) -\u003e ()\u003e;\n\n/// The function pointer type of the identity server handshake started callback. This callback\n/// is called whenever the identity server is initially connected to.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\npub type GoslingIdentityServerHandshakeStartedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e (),\n\u003e;\n\n/// The function pointer type of the identity server handshake client allowed callback.\n/// The result of this callback partially determines if an incoming client handshake\n/// request is possible to complete. For instance an implementation of this function\n//  may reference an allow/block list to determime if identity handshakes can be\n/// completed.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_service_id: the v3 onion service id of the connected client\n/// @return true if the server wants to allow the requesting client to connect client may complete the handshake, false otherwise\npub type GoslingIdentityServerHandshakeClientAllowedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_service_id: *const GoslingV3OnionServiceId,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type of the identity server endpoint supported callback. This\n/// callback is called when the server needs to determine if the client's requested\n/// endpoint is supported. The result of this callback partially determines if an\n/// incoming client handshake request is possible to complete.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param endpoint_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @return true if the server can handle requests for the requested endpoint,\n///  false otherwise\npub type GoslingIdentityServerEndpointSupportedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the server handshake challenge size callback.\n/// This callback is called when a server needs to know how much memory to allocate\n/// for a challenge.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @return the number of bytes required to store the challenge object\npub type GoslingIdentityServerHandshakeChallengeSizeCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e usize,\n\u003e;\n\n/// The function pointer type for the server handshake build challenge callback.\n/// This callback is called when a server needs to build a challenge object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param out_challenge_buffer: the destination buffer for the callback\n///  to write a BSON document representing the endpoint request challenge object\n/// @param out_challenge_buffer_size: the number of bytes allocated in\n///  out_challenge_buffer\npub type GoslingIdentityServerHandshakeBuildChallengeCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        out_challenge_buffer: *mut u8,\n        out_challenge_buffer_size: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function poointer type for the server handshake verify challenge response\n/// callback. This callback is called when a server needs to verify a challenge\n/// response object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param challenge_response_buffer: a buffer containing the BSON document representing\n///  the endpoint request challenge response object\n/// @param challenge_response_buffer_size: the number of bytes in\n///  challenge_response_buffer\n/// @return the result of the challenge response verification\npub type GoslingIdentityServerHandshakeVerifyChallengeResponseCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_response_buffer: *const u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the identity server handshake completed callback. This\n/// callback is called whenever the identity server has successfully completed a\n/// handshake with and granted to a connecting identity client.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_private_key: the ed25519 private key of the endpoint server to host\n///  for the client\n/// @param endoint_name: the null-terminated name of the new endpoint server\n/// @param endpoint_name_length: the length of the endpoint_name string not including\n///  the null-terminator\n/// @param client_service_id: the onion service id of the client we have granted\n///  access to\n/// @param client_auth_public_key: the x25519 public key to use to encrypt the endpoint\n///  server's service descriptor as provided by the connecting client\npub type GoslingIdentityServerHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_private_key: *const GoslingEd25519PrivateKey,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        client_auth_public_key: *const GoslingX25519PublicKey,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type of the identity server handshake rejected callback. This\n/// callback is called whenever the identity server has rejected an identity client's\n/// handshake.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_allowed: true if requesting client is allowed, false otherwies\n/// @param client_requested_endpoint_valid: true if requesting client requested a\n///  valid endpoint, false otherwise\n/// @param client_proof_signature_valid: true if the requesting client properly\n///  signed the identity proof, false otherwise\n/// @param client_auth_signature_valid: true if the requesting client properly signed\n///  the authorization proof, false othewise\n/// @param challenge_response_valid: true if the requesting client's challenge\n///  response was accepted by the server, false otherwise\npub type GoslingIdentityServerHandshakeRejectedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_allowed: bool,\n        client_requested_endpoint_valid: bool,\n        client_proof_signature_valid: bool,\n        client_auth_signature_valid: bool,\n        challenge_response_valid: bool,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity server handshake handshake failed\n/// callback. This callback is called when a server's identity handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingIdentityServerHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingFFIError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint client handshake completed callback.\n/// This callback is called when the client successfully connects to an endpoint server.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_service_id: the onion service id of the endpoint server the client\n///  has connected to\n/// @param channel_name: the null-terminated name of the channel name requested by the\n///  the client\n/// @param channel_name_length: the number of chars in channel_name not including the\n///  null-terminator\n/// @param stream: os-specific tcp socket handle associated with the connection to the\n///  endpoint server\npub type GoslingEndpointClientHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: GoslingTcpSocket,\n    ),\n\u003e;\n\n/// The function pointer type for the endpoint client handshake handshake failed\n/// callback. This callback is called when a client's endpoint handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingEndpointClientHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingFFIError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint server published callback. This callbcak\n/// is called whenever the onion service of the indicated endpoint server associted with\n/// the given context is published and should be reachable by clients.\n///\n/// @param context: the context associated with this event\n/// @param endpoint_service_id: the onion service id of the published endpoint server\n/// @param endpoint_name: the null-terminated name of the endpoint server published\n/// @param endpoint_name_length: the number of chars in endpoint_name string not including the\n///  null-terminator\npub type GoslingEndpointServerPublishedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        enpdoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type of the endpoint server handshake started callback. This\n/// callback is called whenever the endpoint server is initially connected to.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\npub type GoslingEndpointServerHandshakeStartedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e (),\n\u003e;\n\n/// The function pointer type of the endpoint server channel supported callback. This\n/// callback is called when the server needs to determine if the client's requested\n/// channel is supported. The result of this callback partially determines if an\n/// incoming endpoint client handshake request is possible to complete.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_service_id: the onion service id of the connected endpoint client\n/// @param channel_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param channel_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @return true if the server can handle requests for the requested channel,\n///  false otherwise\npub type GoslingEndpointServerChannelSupportedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the endpoint server handshake completed callback.\n/// This callback is called when an endpoint server completes a handshake with an\n/// endpoint client.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_service_id: the onion service id of the endpoint server the\n///  endpoint client has connected to\n/// @param client_service_id: the onion service id of the connected endpoint client\n/// @param channel_name: the null-terminated name of the channel requested by the client\n/// @param channel_name_length: the number of chars in channel_name not including the\n///  null-terminator\n/// @param stream:os-specific tcp socket handle associated with the connection to the\n///  endpoint client\npub type GoslingEndpointServerHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: GoslingTcpSocket,\n    ),\n\u003e;\n\n/// The function pointer type of the endpoint server handshake rejected callback. This\n/// callback is called whenever the endpoint server has rejected an endpoint client's\n/// handshake.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_allowed: true if requesting client is allowed, false otherwies\n/// @param client_requested_channel_valid: true if requesting client requested a\n///  valid endpoint, false otherwise\n/// @param client_proof_signature_valid: true if the requesting client properly\n///  signed the endpoint proof, false otherwise\npub type GoslingEndpointServerHandshakeRejectedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_allowed: bool,\n        client_requested_channel_valid: bool,\n        client_proof_signature_valid: bool,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint server handshake handshake failed\n/// callback. This callback is called when a server's endpoint handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingEndpointServerHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingFFIError,\n    ) -\u003e (),\n\u003e;\n\n#[derive(Default, Clone)]\npub struct EventCallbacks {\n    // tor events\n    tor_bootstrap_status_received_callback: GoslingTorBootstrapStatusReceivedCallback,\n    tor_bootstrap_completed_callback: GoslingTorBootstrapCompletedCallback,\n    tor_log_received_callback: GoslingTorLogReceivedCallback,\n\n    // identity client events\n    identity_client_challenge_response_size_callback:\n        GoslingIdentityClientHandshakeChallengeResponseSizeCallback,\n    identity_client_build_challenge_response_callback:\n        GoslingIdentityClientHandshakeBuildChallengeResponseCallback,\n    identity_client_handshake_completed_callback: GoslingIdentityClientHandshakeCompletedCallback,\n    identity_client_handshake_failed_callback: GoslingIdentityClientHandshakeFailedCallback,\n\n    // identity server events\n    identity_server_published_callback: GoslingIdentityServerPublishedCallback,\n    identity_server_handshake_started_callback: GoslingIdentityServerHandshakeStartedCallback,\n    identity_server_client_allowed_callback: GoslingIdentityServerHandshakeClientAllowedCallback,\n    identity_server_endpoint_supported_callback: GoslingIdentityServerEndpointSupportedCallback,\n    identity_server_challenge_size_callback: GoslingIdentityServerHandshakeChallengeSizeCallback,\n    identity_server_build_challenge_callback: GoslingIdentityServerHandshakeBuildChallengeCallback,\n    identity_server_verify_challenge_response_callback:\n        GoslingIdentityServerHandshakeVerifyChallengeResponseCallback,\n    identity_server_handshake_completed_callback: GoslingIdentityServerHandshakeCompletedCallback,\n    identity_server_handshake_rejected_callback: GoslingIdentityServerHandshakeRejectedCallback,\n    identity_server_handshake_failed_callback: GoslingIdentityServerHandshakeFailedCallback,\n\n    // endpoint client events\n    endpoint_client_handshake_completed_callback: GoslingEndpointClientHandshakeCompletedCallback,\n    endpoint_client_handshake_failed_callback: GoslingEndpointClientHandshakeFailedCallback,\n\n    // endpoint server events\n    endpoint_server_published_callback: GoslingEndpointServerPublishedCallback,\n    endpoint_server_handshake_started_callback: GoslingEndpointServerHandshakeStartedCallback,\n    endpoint_server_channel_supported_callback: GoslingEndpointServerChannelSupportedCallback,\n    endpoint_server_handshake_completed_callback: GoslingEndpointServerHandshakeCompletedCallback,\n    endpoint_server_handshake_rejected_callback: GoslingEndpointServerHandshakeRejectedCallback,\n    endpoint_server_handshake_failed_callback: GoslingEndpointServerHandshakeFailedCallback,\n}\n\nmacro_rules! impl_callback_setter {\n    ($callback_type:tt, $context:expr, $callback:expr, $error:expr) =\u003e {\n        paste::paste! {\n            translate_failures((), $error, || -\u003e anyhow::Result\u003c()\u003e {\n                let mut context_tuple_registry = get_context_tuple_registry();\n                let context = match context_tuple_registry.get_mut($context as usize) {\n                    Some(context) =\u003e context,\n                    None =\u003e {\n                        bail!(\"context is invalid\");\n                    }\n                };\n                context.1.[\u003c$callback_type\u003e] = $callback;\n                Ok(())\n            })\n        }\n    };\n}\n\n/// Set the tor bootstrap status received callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_bootstrap_status_received_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorBootstrapStatusReceivedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        tor_bootstrap_status_received_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the tor bootstrap completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_bootstrap_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorBootstrapCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(tor_bootstrap_completed_callback, context, callback, error);\n}\n\n/// Sets the tor log received callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_log_received_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorLogReceivedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(tor_log_received_callback, context, callback, error);\n}\n\n/// Sets the identity challenge challenge response size callback for the specified\n/// context\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_challenge_response_size_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeChallengeResponseSizeCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_client_challenge_response_size_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity client build challenge response callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_build_challenge_response_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeBuildChallengeResponseCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_client_build_challenge_response_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity client handshake completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_client_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity client handshake failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeFailedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_client_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server published callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_published_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerPublishedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(identity_server_published_callback, context, callback, error);\n}\n\n/// Set the identity server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_started_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeStartedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_started_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server client allowed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_client_allowed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeClientAllowedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_client_allowed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server endpoint supported callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_endpoint_supported_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerEndpointSupportedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_endpoint_supported_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server challenge size callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_challenge_size_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeChallengeSizeCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_challenge_size_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server build challenge callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_build_challenge_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeBuildChallengeCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_build_challenge_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server verify challenge response callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_verify_challenge_response_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeVerifyChallengeResponseCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_verify_challenge_response_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request rejeced callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_rejected_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeRejectedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_rejected_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeFailedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint client handshake completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_client_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointClientHandshakeCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_client_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint client handshake failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_client_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointClientHandshakeFailedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_client_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server published callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_published_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerPublishedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(endpoint_server_published_callback, context, callback, error);\n}\n\n/// Set the endpoint server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_started_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeStartedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_started_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_channel_supported_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerChannelSupportedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_channel_supported_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_rejected_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeRejectedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_rejected_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeFailedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n","traces":[{"line":61,"address":[1448864,1451166,1450976,1450462,1453300,1451188,1449568,1453088,1450484,1449054,1450272,1452384,1449076,1449758,1451892,1452574,1453278,1449780,1452596,1451870,1451680],"length":1,"stats":{"Line":0},"fn_name":"get_error_registry"},{"line":62,"address":[1450983,1449575,1451687,1452391,1453095,1450279,1448871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1451712,1453120,1451008,1448896,1452416,1450304,1449600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1450403,1449699,1451811,1452515,1453219,1448995,1451107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1450947,1451904,1450876,1452284,1452988,1449792,1452608,1451200,1450172,1453059,1453692,1449539,1449088,1450243,1450496,1449468,1451580,1451651,1453312,1453763,1452355],"length":1,"stats":{"Line":0},"fn_name":"clear_error_registry"},{"line":69,"address":[1452615,1453319,1449799,1449095,1450503,1451207,1451911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1451240,1451570,1452978,1453682,1451280,1449128,1452688,1453392,1452274,1450866,1450536,1449168,1450162,1450576,1453352,1449458,1449832,1451944,1451984,1449872,1452648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1451589,1450885,1450181,1452293,1453701,1449477,1452997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1419632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1419652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1419712,1420103],"length":1,"stats":{"Line":0},"fn_name":"gosling_error_get_message"},{"line":106,"address":[1419729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1419743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1419756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1419907,1419778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1419948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1420031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[1419850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1420128],"length":1,"stats":{"Line":0},"fn_name":"gosling_error_clone"},{"line":132,"address":[1303232,1304030],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":133,"address":[1303249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1303293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1303274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1303386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1303343,1303487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1303576,1303691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1303549,1303617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1303771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1303939,1304009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1303982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1420208,1420385],"length":1,"stats":{"Line":0},"fn_name":"gosling_error_free"},{"line":174,"address":[1420222,1420293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1420416,1420607],"length":1,"stats":{"Line":0},"fn_name":"gosling_ed25519_private_key_free"},{"line":219,"address":[1420525,1420436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1420794,1420640],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_private_key_free"},{"line":228,"address":[1420725,1420654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1420816,1420958],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_public_key_free"},{"line":236,"address":[1420830,1420901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[1420992,1421141],"length":1,"stats":{"Line":0},"fn_name":"gosling_v3_onion_service_id_free"},{"line":244,"address":[1421082,1421009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[1421168,1421355],"length":1,"stats":{"Line":0},"fn_name":"gosling_tor_provider_free"},{"line":252,"address":[1421277,1421188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[1421392,1421579],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_free"},{"line":260,"address":[1421501,1421412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1356358,1344352,1363014,1323787,1321099,1337648,1335883,1375995,1324198,1316160,1310347,1367963,1359040,1333622,1332304,1372400,1340320,1331867,1349696,1304080,1306742,1362603,1313472,1325552,1307659,1344326,1355040,1345662,1314379,1314790,1341664,1322880,1333211,1324224,1355014,1361686,1363947,1343915,1353696,1329526,1373744,1332278,1336294,1328224,1352350,1309003,1309440,1321536,1318416,1330935,1346998,1317478,1318848,1355947,1365291,1365702,1365728,1354603,1368400,1359947,1371072,1376406,1349267,1310758,1369291,1319755,1326880,1346587,1340294,1353670,1351014,1360384,1370640,1376432,1317067,1330514,1351939,1321510,1338966,1342982,1349678,1357686,1360358,1371963,1359022,1325123,1313446,1356384,1357275,1357712,1367056,1330960,1318833,1351040,1338992,1358611,1337630,1334555,1371057,1353259,1326862,1352368,1308070,1305424,1336320,1347024,1312128,1322854,1347931,1364358,1372374,1367030,1377750,1348342,1314816,1333648,1320166,1374651,1341227,1317504,1329552,1339883,1373307,1304987,1320192,1322443,1350603,1315723,1338555,1342571,1343008,1329115,1368374,1348368,1325534,1341638,1369702,1313035,1306331,1375088,1345251,1308096,1311691,1305398,1327787,1334992,1377339,1312102,1306768,1328198,1326451,1361712,1369728,1316134,1334966,1337219,1364384,1375062,1361275,1345680,1366619,1373718,1310784,1309414,1363040],"length":1,"stats":{"Line":0},"fn_name":"translate_failures\u003c(), cgosling::ffi::gosling_context_set_endpoint_server_handshake_completed_callback::{closure_env#0}\u003e"},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[1421616],"length":1,"stats":{"Line":0},"fn_name":"gosling_library_init"},{"line":318,"address":[1377776],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":319,"address":[1377788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[1377833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[1377805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[1377945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[1377883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[1377916,1377996,1378024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[1378009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[1421680],"length":1,"stats":{"Line":0},"fn_name":"gosling_library_free"},{"line":340,"address":[1421689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[1421720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[1421725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[1421730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[1421735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1421740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[1421745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[1421750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[1421776],"length":1,"stats":{"Line":0},"fn_name":"gosling_ed25519_private_key_generate"},{"line":364,"address":[1378501,1378064],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":365,"address":[1378076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1378139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[1378101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[1378123,1378239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[1378403,1378467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[1378444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[1421840],"length":1,"stats":{"Line":0},"fn_name":"gosling_ed25519_private_key_clone"},{"line":389,"address":[1379339,1378544],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":390,"address":[1378561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[1378605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[1378586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[1378698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[1378655,1378799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[1378888,1378995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[1378931,1378861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[1379059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1379251,1379318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[1379292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[1421920],"length":1,"stats":{"Line":0},"fn_name":"gosling_ed25519_private_key_from_keyblob"},{"line":424,"address":[1380609,1379392],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":425,"address":[1379404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[1379450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[1379432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[1379521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1379505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[1379744,1379796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[1379582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[1379912,1379621,1379995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[1380186,1379944,1380089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[1380338,1380167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[1380510,1380575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1380551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[1422016],"length":1,"stats":{"Line":0},"fn_name":"gosling_ed25519_private_key_to_keyblob"},{"line":464,"address":[1381750,1380656],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":465,"address":[1380668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[1380706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[1380688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[1380773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[1380761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[1380942,1380994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[1380829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[1381160,1380860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[1381247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[1381263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[1381351,1381440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[1381479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[1381698,1381649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[1381290,1381220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[1381723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[1422112],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_private_key_clone"},{"line":518,"address":[1382567,1381776],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":519,"address":[1381793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[1381837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[1381818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[1381930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[1381887,1382031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[1382223,1382120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[1382159,1382093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[1382287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[1382546,1382479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[1382520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[1422192],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_private_key_from_base64"},{"line":552,"address":[1383817,1382608],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":553,"address":[1382620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[1382666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[1382648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[1382737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[1382721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[1382954,1383006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[1382792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[1383122,1382831,1383212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[1383306,1383397,1383154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[1383378,1383549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[1383783,1383721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[1383760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[1422288],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_private_key_to_base64"},{"line":591,"address":[1383872,1384934],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":592,"address":[1383884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[1383922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[1383904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[1383989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[1383977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[1384210,1384158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[1384045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[1384376,1384076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[1384463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[1384479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[1384567,1384656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[1384695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[1384833,1384882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[1384506,1384436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[1384907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[1422384],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_public_key_clone"},{"line":645,"address":[1384960,1385612],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":646,"address":[1384977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[1385013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[1384994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[1385106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[1385063,1385201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[1385290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[1385263,1385329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[1385398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[1385532,1385591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[1385573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[1422464],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_public_key_from_base32"},{"line":679,"address":[1386694,1385648],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":680,"address":[1385660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[1385698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[1385680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[1385769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[1385753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[1385986,1386038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[1385824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[1386244,1385863,1386154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[1386416,1386186,1386338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[1386370,1386518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[1386606,1386660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[1386645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[1422560],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_public_key_to_base32"},{"line":718,"address":[1386720,1387782],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":719,"address":[1386732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[1386770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[1386752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[1386837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[1386825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[1387006,1387058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[1386893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[1387224,1386924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[1387311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[1387327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[1387415,1387504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[1387543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[1387681,1387730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[1387354,1387284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[1387755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[1422656],"length":1,"stats":{"Line":0},"fn_name":"gosling_v3_onion_service_id_clone"},{"line":772,"address":[1388469,1387808],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":773,"address":[1387825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[1387861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[1387842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[1387954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[1387911,1388055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[1388144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[1388183,1388117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[1388252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[1388386,1388448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[1388429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[1422736],"length":1,"stats":{"Line":0},"fn_name":"gosling_v3_onion_service_id_from_string"},{"line":807,"address":[1388496,1389574],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":808,"address":[1388508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[1388546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[1388528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[1388617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[1388601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[1388886,1388834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[1388672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[1389002,1388711,1389092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[1389034,1389186,1389296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[1389398,1389250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[1389540,1389486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[1389525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[1422832],"length":1,"stats":{"Line":0},"fn_name":"gosling_v3_onion_service_id_from_ed25519_private_key"},{"line":844,"address":[1389600,1390265],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":845,"address":[1389617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[1389653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[1389634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[1389746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[1389703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[1389847,1389734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":856,"address":[1389936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[1389909,1389979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[1389952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":862,"address":[1390048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[1390182,1390244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[1390225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[1422912],"length":1,"stats":{"Line":0},"fn_name":"gosling_v3_onion_service_id_to_string"},{"line":885,"address":[1391352,1390288],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":886,"address":[1390300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[1390338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[1390320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[1390405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[1390393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[1390574,1390626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[1390461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[1390492,1390792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[1390879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[1390895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[1390997,1391072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[1390991,1390983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[1390987,1390994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[1391111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[1391300,1391251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[1390922,1390852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[1391325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[1423008],"length":1,"stats":{"Line":0},"fn_name":"gosling_string_is_valid_v3_onion_service_id"},{"line":943,"address":[1391376],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":944,"address":[1391403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[1391437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":948,"address":[1391420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":949,"address":[1391654,1391594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[1391497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[1391538,1391752,1391845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[1423088],"length":1,"stats":{"Line":0},"fn_name":"gosling_tor_provider_new_legacy_client"},{"line":984,"address":[1394578,1394471,1391920],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":985,"address":[1391935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[1391992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":988,"address":[1391974,1392085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[1392095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[1392059,1392159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[1392195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[1392177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[1392285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[1392273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[1392341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[1392408,1393073,1393264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[1393269,1392589,1393168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1005,"address":[1392432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[1392749,1392880,1392471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[1392781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1008,"address":[1392805,1392977,1393075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[1393138,1393371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[1393132,1393124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[1393135,1393128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1016,"address":[1393499,1393387,1394568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[1393476,1393580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[1393620,1394525,1393987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":[1393842,1394131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[1394147,1394210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[1394450,1394360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[1394399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[1423200],"length":1,"stats":{"Line":0},"fn_name":"gosling_tor_provider_new_mock_client"},{"line":1039,"address":[1395165,1394592],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1040,"address":[1394604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1041,"address":[1394825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[1394633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[1394793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[1394925,1394809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1048,"address":[1395131,1395067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1050,"address":[1395108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1065,"address":[1423264],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_init"},{"line":1074,"address":[1397737,1395216,1397625],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1075,"address":[1395247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1076,"address":[1395312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1078,"address":[1395294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1079,"address":[1395391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[1395379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[1395447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[1395511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1085,"address":[1395540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[1395604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1088,"address":[1395666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[1395781,1395620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[1395899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[1395872,1395978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1098,"address":[1396084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1100,"address":[1396217,1396146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[1396322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":[1396459,1396284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1106,"address":[1397086,1396703,1397661,1396826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[1396346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1108,"address":[1396394,1396402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1109,"address":[1396398,1396413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1110,"address":[1396429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1112,"address":[1396592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[1396652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[1397166,1396939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[1397510,1397591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[1397551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[1423392],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_bootstrap_tor"},{"line":1133,"address":[1397776,1398389],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1134,"address":[1397788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1135,"address":[1397839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[1397805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1139,"address":[1397827,1397931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1140,"address":[1398014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1141,"address":[1398054,1397987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[1398027,1397783,1398369,1398123,1398177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1153,"address":[1423456],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_start_identity_server"},{"line":1157,"address":[1398416,1399029],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1158,"address":[1398428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1159,"address":[1398479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[1398445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1163,"address":[1398467,1398571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1164,"address":[1398654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1165,"address":[1398694,1398627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[1398423,1398763,1399009,1398667,1398817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[1423520],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_stop_identity_server"},{"line":1181,"address":[1399669,1399056],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1182,"address":[1399068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1183,"address":[1399119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1186,"address":[1399085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1187,"address":[1399107,1399211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[1399294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[1399334,1399267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1191,"address":[1399649,1399403,1399063,1399457,1399307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1207,"address":[1423584],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_start_endpoint_server"},{"line":1216,"address":[1399696,1402657],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1217,"address":[1399711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[1399776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":[1399758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1221,"address":[1399861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1223,"address":[1399843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1224,"address":[1399940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1226,"address":[1399928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1227,"address":[1399996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[1400060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1230,"address":[1400120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[1400102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":[1400222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1236,"address":[1400176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1237,"address":[1400207,1400337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1238,"address":[1400438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1239,"address":[1400511,1400403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1243,"address":[1400462,1400584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1244,"address":[1402765,1400600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1245,"address":[1400865,1400785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1246,"address":[1400949,1400892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[1400919,1401025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1251,"address":[1401121,1401050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[1401215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1253,"address":[1401260,1401188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1256,"address":[1401320,1401236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1257,"address":[1401410,1401345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1258,"address":[1401498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1259,"address":[1401543,1401471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1262,"address":[1401519,1401603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1264,"address":[1401693,1401628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1265,"address":[1401786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1266,"address":[1401834,1401754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1269,"address":[1402043,1402578,1402333,1402142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1270,"address":[1401903,1401807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1271,"address":[1401911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1272,"address":[1401967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1273,"address":[1402028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1285,"address":[1423712],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_stop_endpoint_server"},{"line":1290,"address":[1403898,1402784],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1291,"address":[1402801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1292,"address":[1402837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[1402818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[1402930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1298,"address":[1402887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1299,"address":[1403031,1402918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1300,"address":[1403120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1301,"address":[1403165,1403093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1304,"address":[1403222,1403141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1306,"address":[1403304,1403247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1307,"address":[1403393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1308,"address":[1403436,1403366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1311,"address":[1403409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1312,"address":[1402791,1403502,1403860,1403605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[1423792],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_begin_identity_handshake"},{"line":1336,"address":[1403920,1405872],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1337,"address":[1403951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1338,"address":[1404000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1340,"address":[1403982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1341,"address":[1404099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1343,"address":[1404081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1344,"address":[1404195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1346,"address":[1404180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1347,"address":[1404265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1350,"address":[1404335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1351,"address":[1404447,1404366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[1404534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[1404507,1404579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1356,"address":[1404650,1404555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1358,"address":[1404675,1404740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1359,"address":[1404836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1360,"address":[1404900,1404801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1364,"address":[1404857,1404972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1366,"address":[1404988,1405916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1367,"address":[1405241,1405173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1368,"address":[1405262,1405317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1371,"address":[1405436,1405717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1373,"address":[1405396,1405302,1405589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1385,"address":[1423904],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_abort_identity_client_handshake"},{"line":1390,"address":[1405936,1406576],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1391,"address":[1405953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1392,"address":[1406007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1395,"address":[1405970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1396,"address":[1406099,1405995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1397,"address":[1406188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1398,"address":[1406239,1406161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1401,"address":[1406556,1405943,1406308,1406490,1406212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1403,"address":[1406204,1406362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[1423984],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_begin_endpoint_handshake"},{"line":1428,"address":[1406608,1409098],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1429,"address":[1406639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1430,"address":[1406688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1432,"address":[1406670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1433,"address":[1406787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1435,"address":[1406769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1436,"address":[1406886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1438,"address":[1406868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1439,"address":[1406982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1441,"address":[1406967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1442,"address":[1407052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1445,"address":[1407122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1446,"address":[1407153,1407240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1447,"address":[1407333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1448,"address":[1407387,1407306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[1407357,1407470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1453,"address":[1407495,1407566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1454,"address":[1407654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1455,"address":[1407627,1407699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1458,"address":[1407675,1407770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1460,"address":[1407860,1407795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1461,"address":[1407956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1462,"address":[1407921,1408020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1466,"address":[1407977,1408092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1468,"address":[1408108,1409142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1469,"address":[1408293,1408361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1470,"address":[1408382,1408437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1473,"address":[1408581,1408870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1474,"address":[1408422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1475,"address":[1408526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1476,"address":[1408541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1489,"address":[1424112],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_abort_endpoint_client_handshake"},{"line":1494,"address":[1409152,1409792],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":1495,"address":[1409169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1496,"address":[1409223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1499,"address":[1409186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1500,"address":[1409211,1409315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1501,"address":[1409404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1502,"address":[1409455,1409377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1505,"address":[1409428,1409159,1409706,1409772,1409524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1507,"address":[1409420,1409578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1511,"address":[1427720,1427801,1424192],"length":1,"stats":{"Line":0},"fn_name":"handle_context_event"},{"line":1516,"address":[1424269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1520,"address":[1424432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1525,"address":[1426973,1424504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1526,"address":[1427000,1427105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1529,"address":[1427218,1427301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1535,"address":[1427414,1427497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1536,"address":[1427520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1537,"address":[1427543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1538,"address":[1427605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1543,"address":[1427830,1424545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1544,"address":[1427842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1547,"address":[1424595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1548,"address":[1424631,1427854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1549,"address":[1427984,1427882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1551,"address":[1428097,1428180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1557,"address":[1424673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1562,"address":[1424731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1563,"address":[1428335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1564,"address":[1428359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1566,"address":[1424723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1567,"address":[1424727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1569,"address":[1428383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1570,"address":[1428446,1428522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1576,"address":[1428564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1577,"address":[1428579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1581,"address":[1428674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1582,"address":[1430698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1586,"address":[1428798,1428685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1590,"address":[1428814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1591,"address":[1428870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1592,"address":[1428905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1593,"address":[1428920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1597,"address":[1429007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1599,"address":[1429136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1600,"address":[1429363,1430393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1603,"address":[1430865,1428305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1606,"address":[1429494,1429587,1429680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1607,"address":[1430006,1429778,1430250,1429898,1430185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1609,"address":[1429794,1430057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1610,"address":[1429740,1429933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1613,"address":[1424843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1620,"address":[1424985,1430933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1621,"address":[1431294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1622,"address":[1431061,1430953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1623,"address":[1431154,1431086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1625,"address":[1431193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1627,"address":[1431263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1630,"address":[1431350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1633,"address":[1431494,1431575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1641,"address":[1431794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1642,"address":[1431856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1648,"address":[1431945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1649,"address":[1432007,1432086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1650,"address":[1432101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1652,"address":[1432162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1654,"address":[1430975,1432394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1657,"address":[1425027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1658,"address":[1432550,1425080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1659,"address":[1432670,1432570,1432842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1660,"address":[1433187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1661,"address":[1433191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[1425122,1433428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1669,"address":[1433440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1672,"address":[1425172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1673,"address":[1433471,1425192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1674,"address":[1433483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1677,"address":[1425254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1682,"address":[1425328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1683,"address":[1433525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1684,"address":[1433545,1433692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1692,"address":[1433619,1433490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1695,"address":[1433902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1696,"address":[1433962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1697,"address":[1433990,1434081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1703,"address":[1434194,1434277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1704,"address":[1434300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1707,"address":[1434021,1433927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1709,"address":[1434417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1710,"address":[1434537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1711,"address":[1434553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1713,"address":[1434409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1714,"address":[1434413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1717,"address":[1434577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1719,"address":[1434605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1720,"address":[1436326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1724,"address":[1434729,1434616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1728,"address":[1434745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1729,"address":[1434833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1733,"address":[1434845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1734,"address":[1434970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1735,"address":[1436040,1435075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1738,"address":[1436476,1434491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1741,"address":[1435198,1435105,1435291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1742,"address":[1435889,1435645,1435523,1435403,1435824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1746,"address":[1435419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1748,"address":[1435572,1435351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1751,"address":[1425370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1755,"address":[1425420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1758,"address":[1436555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1760,"address":[1436575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1761,"address":[1436704,1436783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1767,"address":[1436825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1768,"address":[1436840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1772,"address":[1436520,1436646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1776,"address":[1437086,1436953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1777,"address":[1437546,1437310,1437188,1437489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1783,"address":[1437146,1437237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1786,"address":[1425555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1793,"address":[1425656,1437567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1795,"address":[1437698,1437587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1796,"address":[1437775,1437723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1799,"address":[1437891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1803,"address":[1438035,1438116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1804,"address":[1438141,1438209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1808,"address":[1438255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1809,"address":[1438388,1438317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1816,"address":[1438458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1817,"address":[1438520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1823,"address":[1438609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1824,"address":[1438791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1825,"address":[1438954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[1437609,1439217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1830,"address":[1425746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1838,"address":[1425826,1439386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1850,"address":[1425868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1851,"address":[1425921,1439455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1852,"address":[1439578,1439478,1439750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1853,"address":[1440095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[1440099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1860,"address":[1426024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1866,"address":[1440328,1426078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1868,"address":[1440351,1440459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1869,"address":[1440552,1440484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1871,"address":[1440606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1875,"address":[1440750,1440838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1883,"address":[1440861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1884,"address":[1440923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1889,"address":[1440998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1891,"address":[1440373,1441215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1894,"address":[1426123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1895,"address":[1426176,1441371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1896,"address":[1441494,1441394,1441666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1897,"address":[1442011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1898,"address":[1442015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1904,"address":[1426259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1908,"address":[1442244,1426295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1910,"address":[1442267,1442367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1911,"address":[1442392,1442460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1913,"address":[1442514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1919,"address":[1442765,1442682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1920,"address":[1442788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1924,"address":[1442847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1927,"address":[1426348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1928,"address":[1426368,1443056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1929,"address":[1443071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1932,"address":[1426433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1937,"address":[1426507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1939,"address":[1443113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1941,"address":[1443283,1443136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1942,"address":[1443308,1443379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1944,"address":[1443433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1950,"address":[1443601,1443684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1951,"address":[1443707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1955,"address":[1443797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1958,"address":[1443210,1443078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1961,"address":[1444112,1443979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1962,"address":[1444359,1444214,1444538,1424253,1444595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1964,"address":[1444410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1965,"address":[1444263,1444172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1968,"address":[1426572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1975,"address":[1444616,1426697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1976,"address":[1444980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1977,"address":[1444639,1444747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1978,"address":[1444772,1444840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1980,"address":[1444879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1981,"address":[1444949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1984,"address":[1445036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1988,"address":[1445180,1445276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1997,"address":[1445307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1998,"address":[1445369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2004,"address":[1445458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2005,"address":[1445520,1445599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2006,"address":[1445614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2009,"address":[1445729,1444661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2012,"address":[1426770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2018,"address":[1426830,1445923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2028,"address":[1426875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2029,"address":[1426928,1445973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2030,"address":[1445993,1446087,1446244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2031,"address":[1446550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2032,"address":[1446554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2036,"address":[1427784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2045,"address":[1446752],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_poll_events"},{"line":2049,"address":[1411870,1411951,1409824],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":2054,"address":[1410964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2055,"address":[1409836,1409940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2056,"address":[1410029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2058,"address":[1410050,1410141,1410276,1412010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2060,"address":[1410251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2064,"address":[1410480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2065,"address":[1410611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2066,"address":[1410659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2067,"address":[1410887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2071,"address":[1410537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2074,"address":[1410669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2076,"address":[1410002,1410077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2080,"address":[1411125,1411243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2081,"address":[1411258,1411207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2082,"address":[1411329,1411274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2085,"address":[1411361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2086,"address":[1411521,1411439,1411865,1411382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2087,"address":[1411713,1411604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2091,"address":[1411398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2094,"address":[1411918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2595,"address":[1412336,1416563,1413219,1415376,1417504,1417808,1416896,1418112,1414768,1419328,1419299,1413856,1414435,1415043,1415347,1412611,1413827,1417779,1417171,1418387,1419024,1413552,1413248,1414464,1419603,1412915,1415955,1412944,1414160,1412032,1413523,1418691,1417200,1414131,1415072,1415984,1418083,1418416,1418720,1418995,1412307,1414739,1417475,1416592,1412640,1416288,1416259,1415651,1416867,1415680],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":2596,"address":[1414785,1417217,1418737,1417825,1416913,1416305,1417521,1418433,1413873,1419345,1418129,1412657,1415393,1413569,1412353,1412049,1412961,1414177,1414481,1415089,1415697,1416001,1416609,1419041,1413265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2597,"address":[1415415,1413042,1415719,1415111,1412130,1414258,1416690,1417239,1417906,1418818,1416327,1412679,1418759,1415474,1419367,1417298,1414807,1416386,1412983,1413591,1414199,1416631,1412434,1418151,1419063,1413346,1413895,1413650,1413954,1417543,1415170,1418514,1412071,1412375,1417602,1419426,1414562,1417847,1416994,1419122,1416082,1416023,1418455,1416935,1415778,1414866,1418210,1414503,1412738,1413287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2598,"address":[1419194,1412810,1415242,1417674,1418586,1413114,1414634,1414026,1416762,1417370,1418890,1415546,1415850,1417978,1414330,1417066,1412202,1412506,1418282,1419498,1413418,1414938,1416154,1416458,1413722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2600,"address":[1414992,1415904,1414080,1412482,1416738,1419170,1413090,1416130,1419474,1413394,1415600,1416816,1414306,1418258,1419248,1417954,1417728,1414914,1414688,1415522,1414610,1417346,1412786,1418032,1414002,1418562,1413472,1417120,1413698,1417650,1418640,1419552,1412256,1412864,1413776,1415296,1416512,1417042,1412560,1415218,1418336,1418944,1412178,1415826,1418866,1417424,1413168,1416208,1416434,1414384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2603,"address":[1419215,1419519,1414959,1416783,1412223,1418303,1418911,1417391,1418607,1415871,1413135,1413439,1413743,1417999,1412831,1414655,1415567,1414047,1412527,1414351,1415263,1417087,1416479,1417695,1416175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2604,"address":[1413446,1412838,1412534,1413142,1415270,1415574,1416486,1417398,1419222,1419526,1417094,1415878,1416790,1418614,1416182,1414358,1414054,1418006,1418310,1413750,1414662,1412230,1414966,1417702,1418918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2617,"address":[1446816],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_tor_bootstrap_status_received_callback"},{"line":2622,"address":[1446848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2624,"address":[1412122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2625,"address":[1412215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2637,"address":[1446896],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_tor_bootstrap_completed_callback"},{"line":2642,"address":[1412426,1412519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2652,"address":[1446976],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_tor_log_received_callback"},{"line":2657,"address":[1412730,1412823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2668,"address":[1447056],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_client_challenge_response_size_callback"},{"line":2673,"address":[1447088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2675,"address":[1413034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2676,"address":[1413127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2688,"address":[1447136],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_client_build_challenge_response_callback"},{"line":2693,"address":[1447168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2695,"address":[1413338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2696,"address":[1413431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2708,"address":[1447216],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_client_handshake_completed_callback"},{"line":2713,"address":[1447248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2715,"address":[1413642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2716,"address":[1413735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2728,"address":[1447296],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_client_handshake_failed_callback"},{"line":2733,"address":[1447328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2735,"address":[1413946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2736,"address":[1414039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2748,"address":[1447376],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_published_callback"},{"line":2753,"address":[1414343,1414250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2763,"address":[1447456],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_handshake_started_callback"},{"line":2768,"address":[1447488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2770,"address":[1414554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2771,"address":[1414647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2783,"address":[1447536],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_client_allowed_callback"},{"line":2788,"address":[1447568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2790,"address":[1414858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2791,"address":[1414951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2803,"address":[1447616],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_endpoint_supported_callback"},{"line":2808,"address":[1447648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2810,"address":[1415162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2811,"address":[1415255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2823,"address":[1447696],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_challenge_size_callback"},{"line":2828,"address":[1447728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2830,"address":[1415466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2831,"address":[1415559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2843,"address":[1447776],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_build_challenge_callback"},{"line":2848,"address":[1447808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2850,"address":[1415770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2851,"address":[1415863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2863,"address":[1447856],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_verify_challenge_response_callback"},{"line":2868,"address":[1447888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2870,"address":[1416074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2871,"address":[1416167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2883,"address":[1447936],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_handshake_completed_callback"},{"line":2888,"address":[1447968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2890,"address":[1416378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2891,"address":[1416471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2903,"address":[1448016],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_handshake_rejected_callback"},{"line":2908,"address":[1448048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2910,"address":[1416682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2911,"address":[1416775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2923,"address":[1448096],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_handshake_failed_callback"},{"line":2928,"address":[1448128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2930,"address":[1416986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2931,"address":[1417079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2943,"address":[1448176],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_client_handshake_completed_callback"},{"line":2948,"address":[1448208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2950,"address":[1417290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2951,"address":[1417383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2963,"address":[1448256],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_client_handshake_failed_callback"},{"line":2968,"address":[1448288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2970,"address":[1417594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2971,"address":[1417687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2983,"address":[1448336],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_server_published_callback"},{"line":2988,"address":[1417898,1417991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2998,"address":[1448416],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_server_handshake_started_callback"},{"line":3003,"address":[1448448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3005,"address":[1418202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3006,"address":[1418295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3018,"address":[1448496],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_server_channel_supported_callback"},{"line":3023,"address":[1448528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3025,"address":[1418506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3026,"address":[1418599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3038,"address":[1448576],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_server_handshake_completed_callback"},{"line":3043,"address":[1448608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3045,"address":[1418810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3046,"address":[1418903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3058,"address":[1448656],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_server_handshake_rejected_callback"},{"line":3063,"address":[1448688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3065,"address":[1419114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3066,"address":[1419207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3078,"address":[1448736],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_server_handshake_failed_callback"},{"line":3083,"address":[1448768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3085,"address":[1419418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3086,"address":[1419511],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":817},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","lib.rs"],"content":"// some internal functions take a lot of args but thats ok\n#![allow(clippy::too_many_arguments)]\n// we don't generate Rust docs since this crate should never be used from\n// Rust, only from languages where the c-ffi is the only option; developers\n// should consult the Doxygen generated docs\n#![allow(clippy::missing_safety_doc)]\n\npub mod ffi;\nmod object_registry;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","object_registry.rs"],"content":"// standard\nuse std::collections::BTreeMap;\nuse std::option::Option;\n\n// An ObjectRegistry\u003cT\u003e maintains ownership of objects and maps them to usize keys\n// which can be safely handed out to external consumers as opaque pointer.\n// Keys are represented as a usize; the high bits are a unique identifier (calculated\n// as the number of keys handed out at the time of key creation, but this is an implementation\n// detail) while the low bits are a user-provided tag used to disambiguate keys from different\n// ObjectRegistry's.\n//\n// T: the type we are storing in the registry\n// TAG: a usize constant which occupy the low bits of returned keys\n// TAG_BITS: the number of bits needed to store the tag (the remainder of the usize bits are used\n//   for the unique id portion of the returne dkeys)\npub struct ObjectRegistry\u003cT, const TAG: usize, const TAG_BITS: u32\u003e {\n    // our internal mapping from handles to Ts\n    map: Option\u003cBTreeMap\u003cusize, T\u003e\u003e,\n    // number of Ts registered to this registry over its lifetime\n    counter: usize,\n}\n\n// Rust only supports 8-bit bytes\nconst BITS_PER_BYTE: u32 = 8;\n\nimpl\u003cT, const TAG: usize, const TAG_BITS: u32\u003e ObjectRegistry\u003cT, TAG, TAG_BITS\u003e {\n    // the number of bits available to the counter portion of an object key\n    const COUNTER_BITS: u32 = std::mem::size_of::\u003cusize\u003e() as u32 * BITS_PER_BYTE - TAG_BITS;\n    // the largest value the counter portion of the key can be without rolling over to 0\n    const COUNTER_MAX: usize = !0usize \u003e\u003e TAG_BITS;\n\n    // return the next key to return on successful insertion\n    fn next_key(\u0026mut self) -\u003e usize {\n        assert!(self.counter \u003c Self::COUNTER_MAX);\n        self.counter += 1;\n        (self.counter \u003c\u003c TAG_BITS) | TAG\n    }\n\n    // returns a new empty ObjectRegisry\n    pub const fn new() -\u003e ObjectRegistry\u003cT, TAG, TAG_BITS\u003e {\n        assert!(TAG_BITS == 0 || (TAG \u003c\u003c Self::COUNTER_BITS) \u003e\u003e Self::COUNTER_BITS == TAG);\n\n        ObjectRegistry {\n            map: None,\n            counter: 0,\n        }\n    }\n\n    // determine if the registry has an object with the specified key\n    pub fn contains_key(\u0026self, key: usize) -\u003e bool {\n        match \u0026self.map {\n            Some(map) =\u003e map.contains_key(\u0026key),\n            None =\u003e false,\n        }\n    }\n\n    // remove and return an object with the specified key\n    pub fn remove(\u0026mut self, key: usize) -\u003e Option\u003cT\u003e {\n        match \u0026mut self.map {\n            Some(map) =\u003e map.remove(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    // add object into registry and return key to reference it\n    pub fn insert(\u0026mut self, val: T) -\u003e usize {\n        let key = self.next_key();\n        match \u0026mut self.map {\n            Some(map) =\u003e if map.insert(key, val).is_some() {\n                panic!();\n            },\n            None =\u003e {\n                let mut map = BTreeMap::new();\n                map.insert(key, val);\n                self.map = Some(map);\n            }\n        }\n        key\n    }\n\n    // gets a reference to a value by the given key\n    pub fn get(\u0026self, key: usize) -\u003e Option\u003c\u0026T\u003e {\n        match \u0026self.map {\n            Some(map) =\u003e map.get(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    // gets a mutable reference to a value by the given key\n    pub fn get_mut(\u0026mut self, key: usize) -\u003e Option\u003c\u0026mut T\u003e {\n        match \u0026mut self.map {\n            Some(map) =\u003e map.get_mut(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    #[cfg(test)]\n    // gets just the tag portion of a key assuming it came from\n    // this registry\n    fn get_tag_from_key(\u0026self, key: usize) -\u003e usize {\n        // zero out the counter bits and return tag\n        (key \u003c\u003c Self::COUNTER_BITS) \u003e\u003e Self::COUNTER_BITS\n    }\n\n    #[cfg(test)]\n    // gets the counter portion of a key assuming it came from\n    // this registry\n    fn get_counter_from_key(\u0026self, key: usize) -\u003e usize {\n        // rotate out the tag bits\n        key \u003e\u003e TAG_BITS\n    }\n\n    #[cfg(test)]\n    // calculate the key given the counter assuming it would be used\n    // by this registry\n    fn get_key_from_counter(\u0026self, counter: usize) -\u003e usize {\n        (counter \u003c\u003c TAG_BITS) | TAG\n    }\n}\n\n#[test]\nfn test_object_registry() -\u003e anyhow::Result\u003c()\u003e {\n    // create a new ObjectRegistry\n    type Int32Registry0_16 = ObjectRegistry\u003ci32, 1234usize, 16\u003e;\n    let mut registry = Int32Registry0_16::new();\n    assert_eq!(\n        Int32Registry0_16::COUNTER_BITS,\n        std::mem::size_of::\u003cusize\u003e() as u32 * BITS_PER_BYTE - 16\n    );\n\n    // add some objects to the registry and get their keys\n    let key1 = registry.insert(10);\n    let key2 = registry.insert(20);\n    let key3 = registry.insert(30);\n\n    // check that the registry contains the keys we just added\n    assert!(registry.contains_key(key1));\n    assert!(registry.contains_key(key2));\n    assert!(registry.contains_key(key3));\n\n    // check that we can get the objects back using their keys\n    assert_eq!(registry.get(key1), Some(\u002610));\n    assert_eq!(registry.get(key2), Some(\u002620));\n    assert_eq!(registry.get(key3), Some(\u002630));\n\n    // check that we can get mutable references to the objects and modify them\n    let obj = registry.get_mut(key1).unwrap();\n    *obj = 100;\n    assert_eq!(registry.get(key1), Some(\u0026100));\n\n    // check that we can remove objects from the registry and they are no longer contained\n    let obj = registry.remove(key2).unwrap();\n    assert_eq!(obj, 20);\n    assert!(!registry.contains_key(key2));\n\n    // check that the tag bits of the keys match the TAG constant we provided\n    assert_eq!(registry.get_tag_from_key(key1), 1234usize);\n    assert_eq!(registry.get_tag_from_key(key2), 1234usize);\n    assert_eq!(registry.get_tag_from_key(key3), 1234usize);\n\n    // check that the counter bits of the keys are unique and increasing\n    let counter1 = registry.get_counter_from_key(key1);\n    let counter2 = registry.get_counter_from_key(key2);\n    let counter3 = registry.get_counter_from_key(key3);\n    assert!(counter1 \u003c counter2 \u0026\u0026 counter2 \u003c counter3);\n\n    // check that we can calculate the key given the counter and it matches the key we got from insert()\n    assert_eq!(registry.get_key_from_counter(1), key1);\n    assert_eq!(registry.get_key_from_counter(2), key2);\n    assert_eq!(registry.get_key_from_counter(3), key3);\n\n    Ok(())\n}\n\n#[test]\nfn test_object_registry_key_collision() -\u003e anyhow::Result\u003c()\u003e {\n    // create two registries with different TAG values\n    let mut registry_a: ObjectRegistry\u003cString, 1usize, 8\u003e = ObjectRegistry::new();\n    let mut registry_b: ObjectRegistry\u003cString, 2usize, 8\u003e = ObjectRegistry::new();\n\n    // insert objects into the registries\n    let key_a_1 = registry_a.insert(\"a1\".to_string());\n    let key_a_2 = registry_a.insert(\"a2\".to_string());\n    let key_b_1 = registry_b.insert(\"b1\".to_string());\n    let key_b_2 = registry_b.insert(\"b2\".to_string());\n\n    // counter portions should be the same\n    assert_eq!(\n        registry_a.get_counter_from_key(key_a_1),\n        registry_b.get_counter_from_key(key_b_1)\n    );\n    assert_eq!(\n        registry_a.get_counter_from_key(key_a_2),\n        registry_b.get_counter_from_key(key_b_2)\n    );\n\n    // ensure the keys do not collide\n    assert!(key_a_1 != key_b_1);\n    assert!(key_a_2 != key_b_2);\n    assert!(key_a_1 != key_b_2);\n    assert!(key_a_2 != key_b_1);\n\n    Ok(())\n}\n#[test]\nfn test_object_registry_empty_tag() -\u003e anyhow::Result\u003c()\u003e {\n    // create a registry with tag 0 and tag bits 0\n    let mut reg = ObjectRegistry::\u003ci32, 0, 0\u003e::new();\n\n    // add some values and check their keys\n    let key1 = reg.insert(1);\n    let key2 = reg.insert(2);\n    assert_eq!(key1, 1);\n    assert_eq!(key2, 2);\n\n    Ok(())\n}\n","traces":[{"line":33,"address":[1955456,1955600,1955888,1956032,1956608,1956752,1956176,1955744,1956464,1955312,1956320],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":38},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","tests","ffi.rs"],"content":"// standard\nuse std::ffi::{CStr, CString};\nuse std::io::{BufRead, BufReader, Write};\nuse std::net::TcpStream;\nuse std::os::raw::c_char;\n#[cfg(unix)]\nuse std::os::unix::io::{FromRawFd, RawFd};\n#[cfg(windows)]\nuse std::os::windows::io::{FromRawSocket, RawSocket};\nuse std::ptr;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\n// external crates\nuse anyhow::bail;\n\n// internal crates\nuse cgosling::ffi::*;\n\nmacro_rules! require_noerror {\n    ($func:ident($($arg:tt)*)) =\u003e {\n        // println!(\"--- {}{}\", stringify!($func), stringify!(($($arg)*)));\n        unsafe {\n            let mut error: *mut GoslingFFIError = ptr::null_mut();\n            $func($($arg)*, \u0026mut error);\n            if !error.is_null() {\n                let msg = gosling_error_get_message(error);\n                let msg = format!(\"{:?}\", CStr::from_ptr(msg));\n                gosling_error_free(error);\n                anyhow::bail!(msg);\n            }\n        }\n    }\n}\n\n// simple bson document: { msg : \"hello world\" }\nconst CHALLENGE_BSON: [u8; 26] = [\n    0x1a, 0x00, 0x00, 0x00, // document length 26 == 0x0000001a\n    0x02, b'm', b's', b'g', 0x00, // string msg\n    0x0c, 0x00, 0x00, 0x00, // strlen(\"hello world\\x00\") 12 = 0x0000000c\n    b'h', b'e', b'l', b'l', b'o', b' ', b'w', b'o', b'r', b'l', b'd', 0x00, // \"hello world\"\n    0x00, // document null-terminator\n];\n\n// empty bson document: {}\nconst CHALLENGE_RESPONSE_BSON: [u8; 5] = [\n    0x05, 0x00, 0x00, 0x00, // document length 5 == 0x00000005\n    0x00, // document null-terminator\n];\n\nstatic ENDPOINT_NAME: \u0026CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"endpoint_name\\0\") };\nstatic CHANNEL_NAME: \u0026CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"channel_name\\0\") };\n\nfn create_client_identity_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn challenge_response_size_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        _challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n    ) -\u003e usize {\n        assert!(!context.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n\n        CHALLENGE_RESPONSE_BSON.len()\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_challenge_response_size_callback(\n            context,\n            Some(challenge_response_size_callback)\n        )\n    );\n\n    extern \"C\" fn build_challenge_response_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n        out_challenge_response_buffer: *mut u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!challenge_buffer.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n        let challenge_buffer = unsafe {\n            std::slice::from_raw_parts(challenge_buffer as *const u8, challenge_buffer_size)\n        };\n        assert_eq!(challenge_buffer, CHALLENGE_BSON);\n        assert!(!out_challenge_response_buffer.is_null());\n        let out_challenge_response_buffer = unsafe {\n            std::slice::from_raw_parts_mut(\n                out_challenge_response_buffer as *mut u8,\n                challenge_response_buffer_size,\n            )\n        };\n\n        out_challenge_response_buffer.clone_from_slice(\u0026CHALLENGE_RESPONSE_BSON);\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_build_challenge_response_callback(\n            context,\n            Some(build_challenge_response_callback)\n        )\n    );\n\n    Ok(())\n}\n\nfn create_server_identity_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn client_allowed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!client_service_id.is_null());\n\n        true\n    }\n    require_noerror!(gosling_context_set_identity_server_client_allowed_callback(\n        context,\n        Some(client_allowed_callback)\n    ));\n\n    extern \"C\" fn endpoint_supported_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        if endpoint_name == ENDPOINT_NAME {\n            return true;\n        }\n        false\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_endpoint_supported_callback(\n            context,\n            Some(endpoint_supported_callback)\n        )\n    );\n\n    extern \"C\" fn challenge_size_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n    ) -\u003e usize {\n        assert!(!context.is_null());\n        CHALLENGE_BSON.len()\n    }\n    require_noerror!(gosling_context_set_identity_server_challenge_size_callback(\n        context,\n        Some(challenge_size_callback)\n    ));\n\n    extern \"C\" fn build_challenge_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        out_challenge_buffer: *mut u8,\n        challenge_buffer_size: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!out_challenge_buffer.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n\n        let out_challenge_buffer = unsafe {\n            std::slice::from_raw_parts_mut(out_challenge_buffer as *mut u8, challenge_buffer_size)\n        };\n        out_challenge_buffer.clone_from_slice(\u0026CHALLENGE_BSON);\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_build_challenge_callback(\n            context,\n            Some(build_challenge_callback)\n        )\n    );\n\n    extern \"C\" fn verify_challenge_response_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        challenge_response_buffer: *const u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!challenge_response_buffer.is_null());\n        if challenge_response_buffer_size != CHALLENGE_RESPONSE_BSON.len() {\n            return false;\n        }\n\n        let challenge_response_buffer = unsafe {\n            std::slice::from_raw_parts(challenge_response_buffer, challenge_response_buffer_size)\n        };\n        if challenge_response_buffer != CHALLENGE_RESPONSE_BSON {\n            return false;\n        }\n        true\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_verify_challenge_response_callback(\n            context,\n            Some(verify_challenge_response_callback)\n        )\n    );\n\n    Ok(())\n}\n\nfn create_server_endpoint_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn channel_supported_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!channel_name.is_null());\n        assert!(!client_service_id.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        if channel_name == CHANNEL_NAME {\n            return true;\n        }\n        false\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_channel_supported_callback(\n            context,\n            Some(channel_supported_callback)\n        )\n    );\n\n    Ok(())\n}\n\n#[test]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_gosling_ffi_handshake() -\u003e anyhow::Result\u003c()\u003e {\n    // init libary\n\n    println!(\"--- init gosling library\");\n    let mut library: *mut GoslingLibrary = ptr::null_mut();\n    require_noerror!(gosling_library_init(\u0026mut library));\n\n    println!(\"--- library: {:?}\", library);\n\n    // init alice\n\n    println!(\"--- init alice\");\n    let mut alice_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    require_noerror!(gosling_ed25519_private_key_generate(\u0026mut alice_private_key));\n\n    let mut alice_identity: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    require_noerror!(gosling_v3_onion_service_id_from_ed25519_private_key(\n        \u0026mut alice_identity,\n        alice_private_key\n    ));\n\n    let mut alice_working_dir = std::env::temp_dir();\n    alice_working_dir.push(\"gosling_context_test_alice\");\n    let alice_working_dir: CString = CString::new(alice_working_dir.to_str().unwrap())?;\n\n    let mut alice_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_new_legacy_client(\n        \u0026mut alice_tor_provider,\n        ptr::null(),\n        0usize,\n        alice_working_dir.as_ptr(),\n        alice_working_dir.as_bytes().len()\n    ));\n\n    let mut alice_context: *mut GoslingContext = ptr::null_mut();\n    require_noerror!(gosling_context_init(\n        \u0026mut alice_context,\n        alice_tor_provider,\n        420,\n        420,\n        alice_private_key\n    ));\n\n    create_server_identity_handshake(alice_context)?;\n    create_server_endpoint_handshake(alice_context)?;\n    // init pat\n\n    println!(\"--- init pat\");\n    let mut pat_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    require_noerror!(gosling_ed25519_private_key_generate(\u0026mut pat_private_key));\n\n    let mut pat_identity: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    require_noerror!(gosling_v3_onion_service_id_from_ed25519_private_key(\n        \u0026mut pat_identity,\n        pat_private_key\n    ));\n\n    let mut pat_working_dir = std::env::temp_dir();\n    pat_working_dir.push(\"gosling_context_test_pat\");\n    let pat_working_dir: CString = CString::new(pat_working_dir.to_str().unwrap())?;\n\n    let mut pat_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_new_legacy_client(\n        \u0026mut pat_tor_provider,\n        ptr::null(),\n        0usize,\n        pat_working_dir.as_ptr(),\n        pat_working_dir.as_bytes().len()\n    ));\n\n    let mut pat_context: *mut GoslingContext = ptr::null_mut();\n    require_noerror!(gosling_context_init(\n        \u0026mut pat_context,\n        pat_tor_provider,\n        420,\n        420,\n        pat_private_key\n    ));\n\n    create_client_identity_handshake(pat_context)?;\n\n    // bootstrap alice\n\n    static ALICE_BOOTSTRAP_COMPLETE: AtomicBool = AtomicBool::new(false);\n    extern \"C\" fn alice_bootstrap_complete_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n        ALICE_BOOTSTRAP_COMPLETE.store(true, Ordering::Relaxed);\n        println!(\"--- alice bootstraped\");\n    }\n    require_noerror!(gosling_context_set_tor_bootstrap_completed_callback(\n        alice_context,\n        Some(alice_bootstrap_complete_callback)\n    ));\n\n    println!(\"--- begin alice bootstrap\");\n    require_noerror!(gosling_context_bootstrap_tor(alice_context));\n    while !ALICE_BOOTSTRAP_COMPLETE.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(alice_context));\n    }\n\n    // init alice's identity server\n    static ALICE_IDENTITY_SERVER_READY: AtomicBool = AtomicBool::new(false);\n    extern \"C\" fn alice_identity_server_published_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n        println!(\"--- alice identity server published\");\n\n        ALICE_IDENTITY_SERVER_READY.store(true, Ordering::Relaxed);\n    }\n    require_noerror!(gosling_context_set_identity_server_published_callback(\n        alice_context,\n        Some(alice_identity_server_published_callback)\n    ));\n\n    println!(\"--- start alice identity server\");\n    require_noerror!(gosling_context_start_identity_server(alice_context));\n\n    while !ALICE_IDENTITY_SERVER_READY.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(alice_context));\n    }\n\n    // bootstrap pat\n\n    static PAT_BOOTSTRAP_COMPLETE: AtomicBool = AtomicBool::new(false);\n    extern \"C\" fn pat_bootstrap_complete_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n\n        println!(\"--- pat bootstrapped\");\n\n        PAT_BOOTSTRAP_COMPLETE.store(true, Ordering::Relaxed);\n    }\n    require_noerror!(gosling_context_set_tor_bootstrap_completed_callback(\n        pat_context,\n        Some(pat_bootstrap_complete_callback)\n    ));\n\n    println!(\"--- begin pat bootstrap\");\n    require_noerror!(gosling_context_bootstrap_tor(pat_context));\n    while !PAT_BOOTSTRAP_COMPLETE.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    // pat requests an endpoint from alice\n\n    static mut PAT_ENDPOINT_REQUEST_COMPLETE: bool = false;\n    static mut ALICE_ENDPOINT_SERVICE_ID: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    static mut PAT_ONION_AUTH_PRIVATE_KEY: *mut GoslingX25519PrivateKey = ptr::null_mut();\n    extern \"C\" fn pat_identity_client_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        identity_service_id: *const GoslingV3OnionServiceId,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_auth_private_key: *const GoslingX25519PrivateKey,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!identity_service_id.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!endpoint_name.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n        assert!(!client_auth_private_key.is_null());\n\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n\n        let mut alice_endpoint_service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n        unsafe {\n            gosling_v3_onion_service_id_clone(\n                \u0026mut alice_endpoint_service_id,\n                endpoint_service_id,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!alice_endpoint_service_id.is_null());\n        unsafe {\n            ALICE_ENDPOINT_SERVICE_ID = alice_endpoint_service_id;\n        }\n\n        let mut pat_onion_auth_private_key: *mut GoslingX25519PrivateKey = ptr::null_mut();\n        unsafe {\n            gosling_x25519_private_key_clone(\n                \u0026mut pat_onion_auth_private_key,\n                client_auth_private_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_onion_auth_private_key.is_null());\n        unsafe {\n            PAT_ONION_AUTH_PRIVATE_KEY = pat_onion_auth_private_key;\n        }\n\n        println!(\"--- pat identity handshake completed\");\n\n        unsafe {\n            PAT_ENDPOINT_REQUEST_COMPLETE = true;\n        }\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_handshake_completed_callback(\n            pat_context,\n            Some(pat_identity_client_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn pat_identity_client_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingFFIError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n\n        panic!(\"--- pat identity handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_handshake_failed_callback(\n            pat_context,\n            Some(pat_identity_client_handshake_failed_callback)\n        )\n    );\n\n    static mut ALICE_ENDPOINT_REQUEST_COMPLETE: bool = false;\n    static mut ALICE_ENDPOINT_PRIVATE_KEY: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    static mut PAT_IDENTITY_SERVICE_ID: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    static mut PAT_ONION_AUTH_PUBLIC_KEY: *mut GoslingX25519PublicKey = ptr::null_mut();\n\n    extern \"C\" fn alice_identity_server_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_private_key: *const GoslingEd25519PrivateKey,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        client_auth_public_key: *const GoslingX25519PublicKey,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_private_key.is_null());\n        assert!(!endpoint_name.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n        assert!(!client_service_id.is_null());\n        assert!(!client_auth_public_key.is_null());\n\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n\n        let mut alice_endpoint_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n        unsafe {\n            gosling_ed25519_private_key_clone(\n                \u0026mut alice_endpoint_private_key,\n                endpoint_private_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!alice_endpoint_private_key.is_null());\n        unsafe {\n            ALICE_ENDPOINT_PRIVATE_KEY = alice_endpoint_private_key;\n        }\n\n        let mut pat_identity_service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n        unsafe {\n            gosling_v3_onion_service_id_clone(\n                \u0026mut pat_identity_service_id,\n                client_service_id,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_identity_service_id.is_null());\n        unsafe {\n            PAT_IDENTITY_SERVICE_ID = pat_identity_service_id;\n        }\n\n        let mut pat_onion_auth_public_key: *mut GoslingX25519PublicKey = ptr::null_mut();\n        unsafe {\n            gosling_x25519_public_key_clone(\n                \u0026mut pat_onion_auth_public_key,\n                client_auth_public_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_onion_auth_public_key.is_null());\n        unsafe {\n            PAT_ONION_AUTH_PUBLIC_KEY = pat_onion_auth_public_key;\n        }\n\n        println!(\"--- alice identity handshake completed\");\n\n        unsafe {\n            ALICE_ENDPOINT_REQUEST_COMPLETE = true;\n        }\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_handshake_completed_callback(\n            alice_context,\n            Some(alice_identity_server_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_identity_server_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingFFIError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n\n        panic!(\"--- alice identity handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_handshake_failed_callback(\n            alice_context,\n            Some(alice_identity_server_handshake_failed_callback)\n        )\n    );\n\n    let mut pat_begin_identity_handshake_succeeded = false;\n    for k in 1..=3 {\n        println!(\"--- pat begin identity handshake attempt {}\", k);\n\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n        gosling_context_begin_identity_handshake(\n            pat_context,\n            alice_identity,\n            ENDPOINT_NAME.as_ptr(),\n            ENDPOINT_NAME.to_bytes().len(),\n            \u0026mut error,\n        );\n\n        if error.is_null() {\n            pat_begin_identity_handshake_succeeded = true;\n            break;\n        } else {\n            let error_message = unsafe {\n                CStr::from_ptr(gosling_error_get_message(error))\n                    .to_str()\n                    .unwrap()\n            };\n            println!(\"--- pat begin identity hanshake failed: {}\", error_message);\n            gosling_error_free(error);\n        }\n    }\n    assert!(pat_begin_identity_handshake_succeeded);\n\n    while unsafe { !ALICE_ENDPOINT_REQUEST_COMPLETE } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    // start alice's enddpoint server\n\n    static mut ALICE_ENDPOINT_PUBLISHED: bool = false;\n\n    extern \"C\" fn alice_endpoint_server_published_callback(\n        context: *mut GoslingContext,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n\n        println!(\"--- alice endpoint server published\");\n        unsafe {\n            ALICE_ENDPOINT_PUBLISHED = true;\n        }\n    }\n    require_noerror!(gosling_context_set_endpoint_server_published_callback(\n        alice_context,\n        Some(alice_endpoint_server_published_callback)\n    ));\n\n    println!(\"--- start init alice endpoint server\");\n    require_noerror!(gosling_context_start_endpoint_server(\n        alice_context,\n        ALICE_ENDPOINT_PRIVATE_KEY,\n        ENDPOINT_NAME.as_ptr(),\n        ENDPOINT_NAME.to_bytes().len(),\n        PAT_IDENTITY_SERVICE_ID,\n        PAT_ONION_AUTH_PUBLIC_KEY\n    ));\n\n    while unsafe { !PAT_ENDPOINT_REQUEST_COMPLETE || !ALICE_ENDPOINT_PUBLISHED } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    #[cfg(target_os = \"windows\")]\n    type TcpSocket = RawSocket;\n    #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n    type TcpSocket = RawFd;\n\n    static mut PAT_SOCKET: Option\u003cTcpSocket\u003e = None;\n    static mut ALICE_SOCKET: Option\u003cTcpSocket\u003e = None;\n\n    extern \"C\" fn pat_enpdoint_client_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: TcpSocket,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!channel_name.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        assert_eq!(channel_name, CHANNEL_NAME);\n\n        unsafe {\n            PAT_SOCKET = Some(stream);\n        }\n        println!(\"--- pat endpoint handshake complete\");\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_client_handshake_completed_callback(\n            pat_context,\n            Some(pat_enpdoint_client_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn pat_endpoint_client_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingFFIError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n        panic!(\"--- pat endpoint handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_client_handshake_failed_callback(\n            pat_context,\n            Some(pat_endpoint_client_handshake_failed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_endpoint_server_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: TcpSocket,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!client_service_id.is_null());\n        assert!(!channel_name.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        assert_eq!(channel_name, CHANNEL_NAME);\n\n        unsafe { ALICE_SOCKET = Some(stream) };\n        println!(\"--- alice endpoint hanshake complete\");\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_handshake_completed_callback(\n            alice_context,\n            Some(alice_endpoint_server_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_endpoint_server_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingFFIError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n        panic!(\"--- alice endpoint handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_handshake_failed_callback(\n            alice_context,\n            Some(alice_endpoint_server_handshake_failed_callback)\n        )\n    );\n\n    let mut pat_begin_endpoint_handshake_succeeded = false;\n    for k in 1..=3 {\n        println!(\"--- pat begin endpoint handshake attempt {}\", k);\n\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n        unsafe {\n            gosling_context_begin_endpoint_handshake(\n                pat_context,\n                ALICE_ENDPOINT_SERVICE_ID,\n                PAT_ONION_AUTH_PRIVATE_KEY,\n                CHANNEL_NAME.as_ptr(),\n                CHANNEL_NAME.to_bytes().len(),\n                \u0026mut error,\n            );\n        }\n\n        if error.is_null() {\n            pat_begin_endpoint_handshake_succeeded = true;\n            break;\n        } else {\n            let error_message = unsafe {\n                CStr::from_ptr(gosling_error_get_message(error))\n                    .to_str()\n                    .unwrap()\n            };\n            println!(\"--- pat begin endpoint hanshake failed: {}\", error_message);\n            gosling_error_free(error);\n        }\n    }\n    assert!(pat_begin_endpoint_handshake_succeeded);\n\n    while unsafe { PAT_SOCKET.is_none() || ALICE_SOCKET.is_none() } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    #[cfg(unix)]\n    let (mut pat_stream, alice_stream) = unsafe {\n        (\n            TcpStream::from_raw_fd(PAT_SOCKET.unwrap()),\n            TcpStream::from_raw_fd(ALICE_SOCKET.unwrap()),\n        )\n    };\n    #[cfg(windows)]\n    let (mut pat_stream, alice_stream) = unsafe {\n        (\n            TcpStream::from_raw_socket(PAT_SOCKET.unwrap()),\n            TcpStream::from_raw_socket(ALICE_SOCKET.unwrap()),\n        )\n    };\n\n    println!(\"--- pat writes message\");\n\n    static MESSAGE: \u0026str = \"Hello Alice!\\n\";\n\n    pat_stream.write(MESSAGE.as_bytes())?;\n    pat_stream.flush()?;\n\n    println!(\"--- alice waits for message\");\n\n    alice_stream.set_nonblocking(false)?;\n    let mut alice_reader = BufReader::new(alice_stream);\n    let mut alice_read_string: String = Default::default();\n    let mut alice_message_read: bool = false;\n    while !alice_message_read {\n        match alice_reader.read_line(\u0026mut alice_read_string) {\n            Ok(0) =\u003e {\n                println!(\"--- alice reads 0\");\n            }\n            Ok(val) =\u003e {\n                assert_eq!(val, MESSAGE.len());\n                assert_eq!(alice_read_string, MESSAGE);\n                // remove trailing new-line\n                alice_read_string.truncate(alice_read_string.len() - 1);\n\n                println!(\"--- alice received '{}'\", alice_read_string);\n                alice_message_read = true;\n            }\n            Err(err) =\u003e bail!(\"{}\", err),\n        }\n    }\n\n    // we have to free gosling library at the end or else the backing TorProvider will go away\n    // and then pat_stream and alice_stream will no longer be valid\n    println!(\"--- free gosling library\");\n    gosling_library_free(library);\n\n    Ok(())\n}\n","traces":[{"line":53,"address":[1263504,1264315],"length":1,"stats":{"Line":0},"fn_name":"create_client_identity_handshake"},{"line":54,"address":[1264912],"length":1,"stats":{"Line":0},"fn_name":"challenge_response_size_callback"},{"line":60,"address":[1265027,1264942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[1264952,1265065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1263616,1263777,1264293,1264031,1264337,1263524,1263633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1263621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1265120],"length":1,"stats":{"Line":0},"fn_name":"build_challenge_response_callback"},{"line":80,"address":[1265213,1265187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1265202,1265316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1265241,1265354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1265399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[1265426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1265651,1265571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1265618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1263982,1264868,1264353,1264465,1263959,1264614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[1263967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1264600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1265680,1266557],"length":1,"stats":{"Line":0},"fn_name":"create_server_identity_handshake"},{"line":108,"address":[1269216],"length":1,"stats":{"Line":0},"fn_name":"client_allowed_callback"},{"line":113,"address":[1269267,1269240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1269255,1269307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1265700,1266270,1265857,1266579,1265840,1266001,1266535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1265845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1269344],"length":1,"stats":{"Line":0},"fn_name":"endpoint_supported_callback"},{"line":129,"address":[1269385,1269500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1269400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1269537,1269415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1269577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1266707,1266982,1267238,1266198,1266221,1266595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1266206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1269616],"length":1,"stats":{"Line":0},"fn_name":"challenge_size_callback"},{"line":148,"address":[1269650,1269630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[1266910,1267925,1267669,1267282,1266933,1267394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[1266918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1269680],"length":1,"stats":{"Line":0},"fn_name":"build_challenge_callback"},{"line":162,"address":[1269715,1269741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1269843,1269730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[1269769,1269880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[1269925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[1269958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[1268612,1267620,1267969,1267597,1268356,1268081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1267605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[1270000],"length":1,"stats":{"Line":0},"fn_name":"verify_challenge_response_callback"},{"line":184,"address":[1270033,1270058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[1270099,1270047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1270091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1270179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1270136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1270177,1270152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[1270169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[1268307,1268917,1269171,1268284,1268656,1268768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1268292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[1268903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1270872,1270208],"length":1,"stats":{"Line":0},"fn_name":"create_server_endpoint_handshake"},{"line":209,"address":[1270912],"length":1,"stats":{"Line":0},"fn_name":"channel_supported_callback"},{"line":216,"address":[1270993,1270966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1271042,1270981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1271175,1271026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[1271075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[1271212,1271090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[1271252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1270588,1270460,1270850,1270894,1270299,1270223,1270316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1270304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1270574],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":64},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling-proc-macros","src","lib.rs"],"content":"use proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, ItemFn};\n\n// This macro renames a function call to a _impl variant.\n//\n// Why is this necessary? Basically, cargo  cannot currently be relied\n// on to build cdylibs correctly due to various issues limited to but\n// probably not including:\n// - not setting soname for linux shared libraries\n// - naming import libs incorrectly for mingw windows\n// - not generating correct symlinks based on version and major version for linux and macos\n//\n// The recommended solution is to use the cdylib_link_lines crate to work around\n// some of these problems, but I've run into other fun issues with that crate:\n// - import libs output to wrong directory for mingw windows\n// - import_name being set incorrectly for macos\n// - hasn't been updated in some years and seems abandoned\n//\n// So now dear reader, we come to this monstrosity. This is just one part of\n// the rest of the build system hack to solve all the above problems; namely\n// we will only use rustc to generate a static library, and from there build\n// a shared library using native C tools via CMake which handles all of the\n// above problems.\n//\n// So we need to build our cgosling crate as a static lib twice: first with the\n// ordinary functions names and second with the functions renamed in the form\n// foo() to foo_impl(). The foo_impl() variant will then be linked into a shared\n// library and called through exported functions of the foo() variety using\n// the ordinary toolchain.\n//\n// The cgosling shared library target will call the underlying functions via simple\n// passthrough with the final (logical) call chain being like a so:\n// - shared_library::foo() -\u003e static_library::foo_impl()\n//\n// Static library callers will have the following call chain:\n// - static_library::foo()\n//\n// I'm sorry it had to be this way\n#[proc_macro_attribute]\npub fn rename_impl(_attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    // parse the input as a function\n    let mut impl_fn: ItemFn = parse_macro_input!(item);\n\n    // append \"_impl\" to the original function name for the _impl function\n    impl_fn.sig.ident = syn::Ident::new(\n      \u0026format!(\"{}_impl\", impl_fn.sig.ident),\n      impl_fn.sig.ident.span(),\n    );\n\n    let expanded = quote! {\n        #impl_fn\n    };\n\n    // Return the combined TokenStream\n    TokenStream::from(expanded)\n}\n","traces":[{"line":41,"address":[272221,272337,271248],"length":1,"stats":{"Line":0},"fn_name":"rename_impl"},{"line":43,"address":[271322,271274,272230,271494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[271845,271981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[271419,271607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[271808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[272032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[272151],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","arbitrary_types.rs"],"content":"// extern\nuse bson::Document;\nuse bson::spec::BinarySubtype::Generic;\nuse curve25519_dalek::Scalar;\nuse tor_interface::tor_crypto::*;\n\n// fuzzing\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::{Arbitrary, Error, Unstructured};\n\n// Generate Arbitray Types\n\n// Ed25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519PrivateKey {\n    pub value: Ed25519PrivateKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519PrivateKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        // expanded secret key raw bytes\n        let mut raw: [u8; 64] = [0u8; 64];\n\n        // construct a valid Scalar\n        let mut scalar: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut scalar)?;\n\n        scalar = curve25519_dalek::scalar::clamp_integer(scalar.clone());\n        scalar = Scalar::from_bytes_mod_order(scalar).to_bytes();\n        raw[00..32].copy_from_slice(\u0026scalar);\n\n        let mut hash: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut hash)?;\n\n        raw[32..64].copy_from_slice(\u0026hash);\n\n        let value = Ed25519PrivateKey::from_raw(\u0026raw).unwrap();\n\n        Ok(ArbitraryEd25519PrivateKey{value})\n    }\n}\n\n// Ed25519 Public Key\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519PublicKey {\n    pub value: Ed25519PublicKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519PublicKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = Ed25519PublicKey::from_private_key(\u0026private.value);\n\n        Ok(ArbitraryEd25519PublicKey{value})\n    }\n}\n\n// Ed25519 Signature\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519Signature {\n    pub value: Ed25519Signature,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519Signature {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut message: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut message)?;\n\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = private.value.sign_message(\u0026message);\n\n        Ok(ArbitraryEd25519Signature{value})\n    }\n}\n\n// V3OnionServicId\n// x25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryV3OnionServiceId {\n    pub value: V3OnionServiceId,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryV3OnionServiceId {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = V3OnionServiceId::from_private_key(\u0026private.value);\n\n        Ok(ArbitraryV3OnionServiceId{value})\n    }\n}\n\n// x25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryX25519PrivateKey {\n    pub value: X25519PrivateKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryX25519PrivateKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut raw: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut raw)?;\n\n        raw[0] \u0026= 240;\n        raw[31] \u0026= 127;\n        raw[31] |= 64;\n\n        let value = X25519PrivateKey::from_raw(\u0026raw).unwrap();\n\n        Ok(ArbitraryX25519PrivateKey{value})\n    }\n}\n\n// x25519 Public Key\n#[derive(Debug)]\npub(crate) struct ArbitraryX25519PublicKey {\n    pub value: X25519PublicKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryX25519PublicKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut raw: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut raw)?;\n\n        let value = X25519PublicKey::from_raw(\u0026raw);\n\n        Ok(ArbitraryX25519PublicKey{value})\n    }\n}\n\n// Bson\n#[derive(Debug)]\npub(crate) struct ArbitraryBSON {\n    pub value: bson::Bson,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryBSON {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        #[derive(Arbitrary)]\n        enum BSONType {\n            Null, // 0\n            Boolean, // 1\n            Int32, // 2\n            Int64, // 3\n            Double, // 4\n            String, // 5\n            Binary, // 6\n            Array, // 7\n            Document, // 8\n        }\n\n        let value = match BSONType::arbitrary(u)? {\n            BSONType::Null =\u003e bson::Bson::Null,\n            BSONType::Boolean =\u003e bson::Bson::Boolean(bool::arbitrary(u)?),\n            BSONType::Int32 =\u003e bson::Bson::Int32(i32::arbitrary(u)?),\n            BSONType::Int64 =\u003e bson::Bson::Int64(i64::arbitrary(u)?),\n            BSONType::Double =\u003e bson::Bson::Double(f64::arbitrary(u)?),\n            BSONType::String =\u003e {\n                match std::ffi::CString::arbitrary(u)?.into_string() {\n                    Ok(value) =\u003e bson::Bson::String(value),\n                    Err(_) =\u003e bson::Bson::Null,\n                }\n            },\n            BSONType::Binary =\u003e bson::Bson::Binary(bson::Binary {subtype: Generic, bytes: Vec::\u003cu8\u003e::arbitrary(u)?}),\n            BSONType::Array =\u003e bson::Bson::Array(Vec::\u003cArbitraryBSON\u003e::arbitrary(u)?.drain(..).map(|val| val.value).collect()),\n            BSONType::Document =\u003e bson::Bson::Document(ArbitraryBSONDocument::arbitrary(u)?.value),\n        };\n\n        Ok(ArbitraryBSON{value})\n    }\n}\n\n#[derive(Debug)]\npub(crate) struct ArbitraryBSONDocument {\n    pub value: Document,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryBSONDocument {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut value = Document::new();\n        for key in Vec::\u003cstd::ffi::CString\u003e::arbitrary(u)?.drain(..) {\n            match key.into_string() {\n                Ok(key) =\u003e value.insert(key, ArbitraryBSON::arbitrary(u)?.value),\n                Err(_) =\u003e None,\n            };\n        }\n        Ok(ArbitraryBSONDocument{value})\n    }\n}\n\n// argument for a bson doc\n#[derive(Arbitrary, Debug)]\npub(crate) enum Argument\u003cT\u003e {\n    // no value\n    Missing,\n    // a valid value\n    Valid,\n    // an invalid value of the same type\n    Invalid(T),\n    // an invalid value of an arbitrary type\n    Random(ArbitraryBSON),\n}","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":61},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_endpoint_client.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\n\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nstruct ErrorSection {\n    cookie: Argument\u003ci64\u003e,\n    code: Argument\u003ci32\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nstruct ResponseSection {\n    cookie: Argument\u003ci64\u003e,\n    state: Argument\u003ci32\u003e,\n    result: Argument\u003cArbitraryBSON\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Response {\n    Noise(Vec\u003cu8\u003e),\n    Document(ArbitraryBSONDocument),\n    HonkRPC {\n        single_message: bool,\n        pending: Option\u003cResponseSection\u003e,\n        complete: Option\u003cResponseSection\u003e,\n        error: Option\u003cErrorSection\u003e,\n    },\n}\n\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    alice_endpoint_ed25519: ArbitraryEd25519PrivateKey,\n    server_cookie: Cookie,\n\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n\n    begin_handshake_response: Response,\n    send_response_response: Response,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a malicious/broken server, Bob is a valid client\nfuzz_target!(|data: HandshakeData| {\n\n    // Bob client data\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_service_id_string = bob_service_id.to_string();\n    let bob_private_x25519 = data.bob_private_x25519.value;\n    let bob_public_x25519 = X25519PublicKey::from_private_key(\u0026bob_private_x25519);\n\n    // Alice server data\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_endpoint_ed25519 = data.alice_endpoint_ed25519.value;\n    let alice_endpoint_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_endpoint_ed25519);\n    let alice_endpoint_onion_service_id_string = alice_endpoint_onion_service_id.to_string();\n\n    //\n    // Init malicious Alice server and Bob client\n    //\n\n    // init alice\n    let mut alice_tor = MockTorClient::new();\n\n    // bootstrap alice\n    alice_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n\n    let alice_listener = alice_tor.listener(\u0026alice_endpoint_ed25519, 420, Some(\u0026[bob_public_x25519])).unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::OnionServicePublished{service_id} =\u003e {\n                    assert_eq!(service_id, alice_endpoint_onion_service_id);\n                    identity_server_published = true;\n                },\n                _ =\u003e ()\n            }\n        }\n    }\n\n    // init bob\n    let bob_tor = MockTorClient::new();\n\n    // create bob gosling context\n    let mut bob = Context::new(Box::new(bob_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, Some(std::time::Duration::from_millis(32)), bob_private_key).unwrap();\n    bob.bootstrap().unwrap();\n    let mut bootstrap_complete: bool = false;\n    while !bootstrap_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n    //\n    // Bob initiates handshake\n    //\n    let handshake_handle = bob.endpoint_client_begin_handshake(alice_endpoint_onion_service_id.clone(), bob_private_x25519, VALID_CHANNEL.to_string()).unwrap();\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // alice waits for connect, return OnionStream\n    let mut alice_stream : TcpStream = match alice_listener.accept().unwrap() {\n        Some(stream) =\u003e stream.into(),\n        None =\u003e panic!(\"listener accept failed\"),\n    };\n    alice_stream.set_nonblocking(false).unwrap();\n    alice_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n\n    //\n    // Alice receives begin_handshake() and build responses\n    //\n\n    let begin_handshake_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let begin_handshake_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_ENDPOINT_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_ENDPOINT_BEGIN_HANDSHAKE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        assert_eq!(arguments.get_str(\"client_identity\").unwrap(), bob_service_id_string);\n        assert_eq!(arguments.get_str(\"channel\").unwrap(), VALID_CHANNEL);\n        begin_handshake_cookie\n    };\n\n\n\n    // messages can be built such that multiple errors exist so lets track\n    // all the layers of possible errors\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.begin_handshake_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE \u0026\u0026 state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        let mut result = Document::new();\n                        result.insert(\"server_cookie\", Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.server_cookie.to_vec()}));\n                        Some(Bson::Document(result))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!begin_handshake_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives begin_handshake() response and builds reply\n    //\n    for event in bob.update().unwrap().drain(..) {\n        match event {\n            ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                assert_eq!(handshake_handle, handle);\n                match reason {\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                        assert!(expect_timeout, \"{:?}\", reason);\n                    }\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                        assert!(expect_bson_too_small, \"{:?}\", reason);\n                    },\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                        assert!(expect_bson_too_large, \"{:?}\", reason);\n                    },\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                        assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                    },\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                        assert!(expect_unknown_error_section, \"{:?}\", reason);\n                    },\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                        assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                    },\n                    error =\u003e panic!(\"unexpected error: {:?}\", error),\n                }\n                // bob should have closed the connection on alice after handshake failure\n                return;\n            }\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    // handle dangling unexpected response\n    for event in bob.update().unwrap().drain(..) {\n        match event {\n            ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                assert_eq!(handshake_handle, handle);\n                match reason {\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                        assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                    },\n                    error =\u003e panic!(\"unexpected error: {:?}\", error),\n                }\n                // bob should have closed the connection on alice after handshake failure\n                return;\n            }\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // give it a chance to timeout if it is mean to\n    while expect_timeout {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e (),\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    // println!(\"expect_timeout: {}\", expect_timeout);\n\n    // Alice receives send_reponse() and builds response\n    let send_response_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let send_response_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_ENDPOINT_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_ENDPOINT_SEND_RESPONSE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        let client_cookie = arguments.get_binary_generic(\"client_cookie\").unwrap();\n        let client_identity_proof_signature = arguments.get_binary_generic(\"client_identity_proof_signature\").unwrap();\n\n        send_response_cookie\n    };\n\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.send_response_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE \u0026\u0026 state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        Some(Bson::Document(doc!{}))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!send_response_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives send_response() response and finishes handshake\n    //\n    let mut send_response_complete: bool = false;\n    while !send_response_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                },\n                ContextEvent::EndpointClientHandshakeCompleted{handle, endpoint_service_id, channel_name, stream: _} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(channel_name, VALID_CHANNEL);\n                    send_response_complete = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_endpoint_server.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse data_encoding::HEXLOWER;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\nuse honk_rpc::honk_rpc::{get_message_overhead, get_response_section_size};\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nenum BeginHandshakeMessage {\n    // random bytes\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc request\n    Request{\n        version: Argument\u003cString\u003e,\n        client_identity: Argument\u003cArbitraryV3OnionServiceId\u003e,\n        channel: Argument\u003cString\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nenum SendResponseMessage {\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc requst\n    Request{\n        client_cookie: Argument\u003cCookie\u003e,\n        client_identity_proof_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    alice_endpoint_ed25519: ArbitraryEd25519PrivateKey,\n    channel_supported: bool,\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n    client_cookie: Cookie,\n    // client messages\n    begin_handshake_cookie: i64,\n    begin_handshake: BeginHandshakeMessage,\n    send_response_cookie: i64,\n    send_response: SendResponseMessage,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a valid server, Bob connects and sends garbage at certain point in the form of bad data in correctly structured+ordered gosling bison messages or noise\nfuzz_target!(|data: HandshakeData| {\n\n    // alice server data\n    let alice_identity_ed25519 = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_identity_ed25519);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_endpoint_ed25519 = data.alice_endpoint_ed25519.value;\n    let alice_endpoint_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_endpoint_ed25519);\n    let alice_endpoint_onion_service_id_string = alice_endpoint_onion_service_id.to_string();\n\n\n    // bob client data\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_onion_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_onion_service_id_string = bob_onion_service_id.to_string();\n    let bob_private_x25519 = data.bob_private_x25519.value;\n    let bob_public_x25519 = X25519PublicKey::from_private_key(\u0026bob_private_x25519);\n\n    //\n    // Init Alice server and malicious Bob client\n    //\n\n    // init alice\n    let alice_tor = MockTorClient::new();\n\n    // create alice gosling context\n    let mut alice = Context::new(Box::new(alice_tor), 420, 420, std::time::Duration::from_millis(32), ENDPOINT_MAX_MESSAGE_SIZE, Some(std::time::Duration::from_millis(32)), alice_identity_ed25519.clone()).unwrap();\n\n    // bootstrap alice\n    alice.bootstrap().unwrap();\n    let mut endpoint_server_published: bool = false;\n    while !endpoint_server_published {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    // start alice endpoint server\n                    match alice.endpoint_server_start(alice_endpoint_ed25519.clone(), VALID_ENDPOINT.to_string(), bob_onion_service_id.clone(), bob_public_x25519.clone()) {\n                        Ok(()) =\u003e (),\n                        Err(gosling::Error::InvalidArgument(_)) =\u003e {\n                            assert_eq!(alice_onion_service_id_string, alice_endpoint_onion_service_id_string);\n                            return;\n                        },\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                ContextEvent::EndpointServerPublished{endpoint_service_id, endpoint_name} =\u003e {\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    endpoint_server_published = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n\n    // init bob\n    let mut bob_tor = MockTorClient::new();\n\n    // bootstrap bob\n    bob_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in bob_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n    bob_tor.add_client_auth(\u0026alice_endpoint_onion_service_id, \u0026bob_private_x25519).unwrap();\n\n    // bob connects to alice\n    let mut bob_stream = bob_tor.connect(\u0026alice_endpoint_onion_service_id, 420, None).unwrap();\n    bob_stream.set_nonblocking(false).unwrap();\n    bob_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n\n    //\n    // Alice waits for handshake started\n    //\n    let mut alice_handshake_started: bool = false;\n    let mut alice_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    while !alice_handshake_started {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerHandshakeStarted{handle} =\u003e {\n                    alice_handshake_started = true;\n                    alice_handshake_handle = handle;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob sends begin_handshake()\n    //\n    #[derive(PartialEq, Debug)]\n    enum ExpectedBeginHandshakeResponse {\n        // Success Case\n        EndpointRequestReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorBadGoslingVersion,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = ExpectedBeginHandshakeResponse::EndpointRequestReceived;\n\n    let message = match \u0026data.begin_handshake {\n        BeginHandshakeMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedBeginHandshakeResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedBeginHandshakeResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedBeginHandshakeResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedBeginHandshakeResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        BeginHandshakeMessage::Request{\n            version,\n            client_identity,\n            channel} =\u003e {\n            match (\u0026version, \u0026client_identity, \u0026channel) {\n                (Argument::Valid, Argument::Valid | Argument::Invalid(_), Argument::Valid | Argument::Invalid(_)) =\u003e (),\n                (Argument::Missing | Argument::Invalid(_) | Argument::Random(_), _, _) =\u003e  expected_response = ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion,\n                _ =\u003e expected_response = ExpectedBeginHandshakeResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_endpoint\".to_string()));\n            section.insert(\"function\", Bson::String(\"begin_handshake\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.begin_handshake_cookie));\n\n            let mut arguments = Document::new();\n            let version = match version {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(GOSLING_VERSION.to_string())),\n                Argument::Invalid(invalid) =\u003e {\n                    if invalid == GOSLING_VERSION {\n                        Some(Bson::String(\"invalid_version\".to_string()))\n                    } else {\n                        Some(Bson::String(invalid.clone()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(version) = version {\n                arguments.insert(\"version\", version);\n            }\n\n            let client_identity = match client_identity {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(bob_onion_service_id_string.clone())),\n                Argument::Invalid(invalid) =\u003e {\n                    let invalid = invalid.value.to_string();\n                    Some(Bson::String(invalid))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(client_identity) = client_identity {\n                arguments.insert(\"client_identity\", client_identity);\n            }\n\n            let channel = match channel {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(VALID_CHANNEL.to_string())),\n                Argument::Invalid(value) =\u003e {\n                    if value == VALID_CHANNEL {\n                        Some(Bson::String(\"invalid_channel\".to_string()))\n                    } else if value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::String(Default::default()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(value)}) =\u003e {\n                    if !value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::Null)\n                    }\n                },\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(channel) = channel {\n                arguments.insert(\"channel\", channel);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedBeginHandshakeResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n\n    //\n    // Alice handles begin_handshake()\n    //\n    let mut alice_begin_handshake_handled: bool = false;\n    while !alice_begin_handshake_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerChannelRequestReceived{handle, client_service_id: _, requested_channel} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(expected_response, ExpectedBeginHandshakeResponse::EndpointRequestReceived);\n                    #[derive(PartialEq, Debug)]\n                    enum ExpectedHandleEndpointRequestReceiveResult {\n                        Success,\n                        // Error Cases\n                        ErrorSectionTooLarge,\n                    }\n\n                    let mut expected_result = ExpectedHandleEndpointRequestReceiveResult::Success;\n\n                    // calculate the expected size of our reponse message\n                    let begin_handshake_complete_message_size = {\n                        let result = doc!{\n                            \"server_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: [0u8; COOKIE_SIZE].to_vec()}),\n                        };\n                        let response_section_size = get_response_section_size(Some(Bson::Document(result))).unwrap();\n                        get_message_overhead().unwrap() + response_section_size\n                    };\n                    if begin_handshake_complete_message_size \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expected_result = ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge;\n                    }\n\n                    match alice.endpoint_server_handle_channel_request_received(\n                        alice_handshake_handle,\n                        data.channel_supported \u0026\u0026 requested_channel == VALID_CHANNEL) {\n                        Ok(()) =\u003e assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::Success),\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n\n                    alice_begin_handshake_handled = true;\n                }\n                ContextEvent::EndpointServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(endpoint_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedBeginHandshakeResponse::ErrorBadClient ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_begin_handshake_handled = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n        // Alice sends Bob begin_handshake() response (or does nothing)\n    for event in alice.update().unwrap().drain(..) {\n        match event {\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    //\n    // Bob reads begin_handshake() response or error sections\n    //\n\n    // bob receives begin_handshake() pending response\n    let begin_handshake_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure =\u003e {\n            match begin_handshake_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_BAD_VERSION,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived |\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n\n    // bob receives begin_handshake() result\n    let begin_handshake_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    let mut server_cookie: Cookie = Default::default();\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion |\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let section = \u0026sections[0];\n                    match section {\n                        Bson::Document(section) =\u003e {\n                            assert_eq!(section.get_i32(\"id\"), Ok(RESPONSE_SECTION));\n                            let response = section;\n                            assert_eq!(response.get_i64(\"cookie\"), Ok(data.begin_handshake_cookie));\n                            assert_eq!(response.get_i32(\"state\"), Ok(COMPLETE_REQUEST_STATE));\n                            let result = response.get_document(\"result\").unwrap();\n                            server_cookie = result.get_binary_generic(\"server_cookie\").unwrap().clone().try_into().unwrap();\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    //\n    // Bsob sends send_response()\n    //\n\n    #[derive(PartialEq, Debug)]\n    enum ExpectedSendResponseResponse {\n        // Success Case\n        EmptyDocumentReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = match (data.channel_supported, data.begin_handshake) {\n        (true, BeginHandshakeMessage::Request{version: Argument::Valid, client_identity: Argument::Valid, channel: Argument::Valid}) =\u003e ExpectedSendResponseResponse::EmptyDocumentReceived,\n        _ =\u003e ExpectedSendResponseResponse::ErrorBadClient,\n    };\n\n    let message = match data.send_response {\n        SendResponseMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedSendResponseResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedSendResponseResponse::ErrorBsonTooSmall\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        ExpectedSendResponseResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedSendResponseResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedSendResponseResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedSendResponseResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes\n        },\n        SendResponseMessage::Request{\n            client_cookie,\n            client_identity_proof_signature} =\u003e {\n            match (\u0026client_cookie, \u0026client_identity_proof_signature) {\n                (Argument::Valid, Argument::Valid) =\u003e (),\n                (Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_)) =\u003e expected_response = ExpectedSendResponseResponse::ErrorBadClient,\n                _ =\u003e expected_response = ExpectedSendResponseResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_endpoint\".to_string()));\n            section.insert(\"function\", Bson::String(\"send_response\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.send_response_cookie));\n\n            let mut arguments = Document::new();\n            let client_cookie = match client_cookie {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.client_cookie.to_vec()})),\n                Argument::Invalid(value) =\u003e {\n                    // ensure the cookie is actually invalid\n                    if value == data.client_cookie {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.map(|x| !x).to_vec()}))\n                    } else {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.to_vec()}))\n                    }\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_cookie) = client_cookie {\n                arguments.insert(\"client_cookie\", client_cookie);\n            }\n\n            let client_identity_proof_signature = match client_identity_proof_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_identity_proof = build_client_proof(\"gosling-endpoint\", VALID_CHANNEL, \u0026bob_onion_service_id, \u0026alice_endpoint_onion_service_id, \u0026data.client_cookie, \u0026server_cookie);\n                    let client_identity_proof_signature = bob_private_key.sign_message(\u0026client_identity_proof);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_identity_proof_signature) = client_identity_proof_signature {\n                arguments.insert(\"client_identity_proof_signature\", client_identity_proof_signature);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedSendResponseResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Alice handles send_response()\n    //\n\n    let mut alice_send_response_handled: bool = false;\n    while !alice_send_response_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(endpoint_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedSendResponseResponse::ErrorBadClient ||\n                                    expected_response == ExpectedSendResponseResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_send_response_handled = true;\n                },\n                ContextEvent::EndpointServerHandshakeCompleted{handle, endpoint_service_id, client_service_id, channel_name, stream: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(client_service_id, bob_onion_service_id);\n                    assert_eq!(channel_name, VALID_CHANNEL);\n                    alice_send_response_handled = true;\n                    assert_eq!(expected_response, ExpectedSendResponseResponse::EmptyDocumentReceived);\n                },\n                ContextEvent::EndpointServerHandshakeRejected { handle, client_allowed: _, client_requested_channel_valid: _, client_proof_signature_valid: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice_send_response_handled = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob reads send_response() response or error sections\n    //\n\n    // first read response (pending) or error section\n    let send_response_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure =\u003e {\n            match send_response_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EmptyDocumentReceived =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"state\": COMPLETE_REQUEST_STATE,\n                                \"result\": doc!{},\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // success!\n    ()\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_identity_client.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\n\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nstruct ErrorSection {\n    cookie: Argument\u003ci64\u003e,\n    code: Argument\u003ci32\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nstruct ResponseSection {\n    cookie: Argument\u003ci64\u003e,\n    state: Argument\u003ci32\u003e,\n    result: Argument\u003cArbitraryBSON\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Response {\n    Noise(Vec\u003cu8\u003e),\n    Document(ArbitraryBSONDocument),\n    HonkRPC {\n        single_message: bool,\n        pending: Option\u003cResponseSection\u003e,\n        complete: Option\u003cResponseSection\u003e,\n        error: Option\u003cErrorSection\u003e,\n    },\n}\n\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    server_cookie: Cookie,\n    endpoint_challenge: ArbitraryBSONDocument,\n    endpoint_service_id: ArbitraryV3OnionServiceId,\n\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    endpoint_challenge_response: ArbitraryBSONDocument,\n\n    begin_handshake_response: Response,\n    send_response_response: Response,\n\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a malicious/broken server, Bob is a valid client\nfuzz_target!(|data: HandshakeData| {\n\n    //\n    // Init malicious Alice server and Bon client\n    //\n\n    // init alice\n    let mut alice_tor = MockTorClient::new();\n\n    // bootstrap alice\n    alice_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_listener = alice_tor.listener(\u0026alice_private_key, 420, None).unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::OnionServicePublished{service_id} =\u003e {\n                    assert_eq!(service_id, alice_onion_service_id);\n                    identity_server_published = true;\n                },\n                _ =\u003e ()\n            }\n        }\n    }\n\n    // init bob\n    let bob_tor = MockTorClient::new();\n\n    // create bob gosling context\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_service_id_string = bob_service_id.to_string();\n    let mut bob = Context::new(Box::new(bob_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, None, bob_private_key).unwrap();\n    bob.bootstrap().unwrap();\n    let mut bootstrap_complete: bool = false;\n    while !bootstrap_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob initiates handshake\n    //\n    let handshake_handle = bob.identity_client_begin_handshake(alice_onion_service_id.clone(), VALID_ENDPOINT.to_string()).unwrap();\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // alice waits for connect, return OnionStream\n    let mut alice_stream : TcpStream = match alice_listener.accept().unwrap() {\n        Some(stream) =\u003e stream.into(),\n        None =\u003e panic!(\"listener accept failed\"),\n    };\n    alice_stream.set_nonblocking(false).unwrap();\n    alice_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n    //\n    // Alice receives begin_handshake() and build responses\n    //\n\n    let begin_handshake_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let begin_handshake_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_IDENTITY_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_IDENTITY_BEGIN_HANDSHAKE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        assert_eq!(arguments.get_str(\"client_identity\").unwrap(), bob_service_id_string);\n        assert_eq!(arguments.get_str(\"endpoint\").unwrap(), VALID_ENDPOINT);\n        begin_handshake_cookie\n    };\n\n    // messages can be built such that multiple errors exist so lets track\n    // all the layers of possible errors\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.begin_handshake_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        let mut result = Document::new();\n                        result.insert(\"server_cookie\", Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.server_cookie.to_vec()}));\n                        result.insert(\"endpoint_challenge\", data.endpoint_challenge.value.clone());\n                        Some(Bson::Document(result))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!begin_handshake_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives begin_handshake() response and builds reply\n    //\n    let mut begin_handshake_complete: bool = false;\n    while !begin_handshake_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                }\n                ContextEvent::IdentityClientChallengeReceived{handle, endpoint_challenge} =\u003e {\n                    assert!(!begin_handshake_complete);\n                    assert!(!expect_timeout);\n                    assert!(!expect_bson_too_small);\n                    assert!(!expect_bson_too_large);\n                    assert!(!expect_honkrpc_message_parse_failure);\n                    assert!(!expect_gosling_unexpected_response);\n                    assert_eq!(handshake_handle, handle);\n                    // compare the raw bytes ince an arbitrary bson doc may have Double(NaN) which fails equality test\n                    assert_eq!({\n                        let mut bytes: Vec\u003cu8\u003e = Default::default();\n                        endpoint_challenge.to_writer(\u0026mut bytes).unwrap();\n                        bytes\n                    },{\n                        let mut bytes: Vec\u003cu8\u003e = Default::default();\n                        data.endpoint_challenge.value.to_writer(\u0026mut bytes).unwrap();\n                        bytes\n                    });\n\n                    // just reply with an empty challenge response\n                    match bob.identity_client_handle_challenge_received(handle, data.endpoint_challenge_response.value.clone()) {\n                        Ok(()) =\u003e begin_handshake_complete = true,\n                        // there is a limit to how large a response can be based on the honk-rpc max message size\n                        Err(gosling::Error::IdentityClientError(identity_client::Error::EndpointChallengeResponseTooLarge(_,_))) =\u003e return,\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n\n    // Alice receives send_reponse() and builds response\n    let send_response_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let send_response_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_IDENTITY_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_IDENTITY_SEND_RESPONSE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        let client_cookie = arguments.get_binary_generic(\"client_cookie\").unwrap();\n        let client_identity_proof_signature = arguments.get_binary_generic(\"client_identity_proof_signature\").unwrap();\n        let client_authorization_key = arguments.get_binary_generic(\"client_authorization_key\").unwrap();\n        let client_authorization_key_signbit = arguments.get_bool(\"client_authorization_key_signbit\").unwrap();\n        let client_authorization_signature = arguments.get_binary_generic(\"client_authorization_signature\").unwrap();\n        let challenge_response = arguments.get_document(\"challenge_response\").unwrap();\n\n        send_response_cookie\n    };\n\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.send_response_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        Some(Bson::String(data.endpoint_service_id.value.to_string()))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!send_response_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives send_response() response and finishes handshake\n    //\n    let mut send_response_complete: bool = false;\n    while !send_response_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                },\n                ContextEvent::IdentityClientHandshakeCompleted{handle, identity_service_id, endpoint_service_id, endpoint_name, client_auth_private_key} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    assert_eq!(identity_service_id, alice_onion_service_id);\n                    assert_eq!(endpoint_service_id, data.endpoint_service_id.value);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    send_response_complete = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_identity_server.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse data_encoding::HEXLOWER;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\nuse honk_rpc::honk_rpc::{get_message_overhead, get_response_section_size};\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nenum BeginHandshakeMessage {\n    // random bytes\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc request\n    Request{\n        version: Argument\u003cString\u003e,\n        client_identity: Argument\u003cArbitraryV3OnionServiceId\u003e,\n        endpoint: Argument\u003cString\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nenum SendResponseMessage {\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc requst\n    Request{\n        client_cookie: Argument\u003cCookie\u003e,\n        client_identity_proof_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n        client_authorization_key: Argument\u003cArbitraryX25519PrivateKey\u003e,\n        client_authorization_key_signbit: Argument\u003cbool\u003e,\n        client_authorization_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n        challenge_response: Argument\u003cArbitraryBSONDocument\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    client_allowed: bool,\n    endpoint_supported: bool,\n    endpoint_challenge: ArbitraryBSONDocument,\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n    client_cookie: Cookie,\n    // client messages\n    begin_handshake_cookie: i64,\n    begin_handshake: BeginHandshakeMessage,\n    send_response_cookie: i64,\n    send_response: SendResponseMessage,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a valid server, Bob connects and sends garbage at certain point in the form of bad data in correctly structured+ordered gosling bison messages or noise\nfuzz_target!(|data: HandshakeData| {\n\n    //\n    // Init Alice server and malicious Bob client\n    //\n\n    // init alice\n    let alice_tor = MockTorClient::new();\n\n    // create alice gosling context\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let mut alice = Context::new(Box::new(alice_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, None, alice_private_key).unwrap();\n\n    // bootstrap alice\n    alice.bootstrap().unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    // start alice identity server\n                    alice.identity_server_start().unwrap();\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                ContextEvent::IdentityServerPublished =\u003e {\n                    identity_server_published = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    // init bob\n    let mut bob_tor = MockTorClient::new();\n\n    // bootstrap bob\n    bob_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in bob_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_onion_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_onion_service_id_string = bob_onion_service_id.to_string();\n\n    // bob connects to alice\n    let mut bob_stream = bob_tor.connect(\u0026alice_onion_service_id, 420, None).unwrap();\n    bob_stream.set_nonblocking(false).unwrap();\n    bob_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n    //\n    // Alice waits for handshake started\n    //\n    let mut alice_handshake_started: bool = false;\n    let mut alice_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    while !alice_handshake_started {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerHandshakeStarted{handle} =\u003e {\n                    alice_handshake_started = true;\n                    alice_handshake_handle = handle;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob sends begin_handshake()\n    //\n    #[derive(PartialEq, Debug)]\n    enum ExpectedBeginHandshakeResponse {\n        // Success Case\n        EndpointRequestReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorBadGoslingVersion,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = ExpectedBeginHandshakeResponse::EndpointRequestReceived;\n\n    let message = match \u0026data.begin_handshake {\n        BeginHandshakeMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedBeginHandshakeResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedBeginHandshakeResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedBeginHandshakeResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedBeginHandshakeResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        BeginHandshakeMessage::Request{\n            version,\n            client_identity,\n            endpoint} =\u003e {\n            match (\u0026version, \u0026client_identity, \u0026endpoint) {\n                (Argument::Valid, Argument::Valid | Argument::Invalid(_), Argument::Valid | Argument::Invalid(_)) =\u003e (),\n                (Argument::Missing | Argument::Invalid(_) | Argument::Random(_), _, _) =\u003e  expected_response = ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion,\n                _ =\u003e expected_response = ExpectedBeginHandshakeResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_identity\".to_string()));\n            section.insert(\"function\", Bson::String(\"begin_handshake\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.begin_handshake_cookie));\n\n            let mut arguments = Document::new();\n            let version = match version {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(GOSLING_VERSION.to_string())),\n                Argument::Invalid(invalid) =\u003e {\n                    if invalid == GOSLING_VERSION {\n                        Some(Bson::String(\"invalid_version\".to_string()))\n                    } else {\n                        Some(Bson::String(invalid.clone()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(version) = version {\n                arguments.insert(\"version\", version);\n            }\n\n            let client_identity = match client_identity {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(bob_onion_service_id_string.clone())),\n                Argument::Invalid(invalid) =\u003e {\n                    let invalid = invalid.value.to_string();\n                    Some(Bson::String(invalid))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(client_identity) = client_identity {\n                arguments.insert(\"client_identity\", client_identity);\n            }\n\n            let endpoint = match endpoint {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(VALID_ENDPOINT.to_string())),\n                Argument::Invalid(value) =\u003e {\n                    if value == VALID_ENDPOINT {\n                        Some(Bson::String(\"invalid_endpoint\".to_string()))\n                    } else if value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::String(Default::default()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(value)}) =\u003e {\n                    if !value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::Null)\n                    }\n                },\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(endpoint) = endpoint {\n                arguments.insert(\"endpoint\", endpoint);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedBeginHandshakeResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Alice handles begin_handshake()\n    //\n    let mut alice_begin_handshake_handled: bool = false;\n    while !alice_begin_handshake_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerEndpointRequestReceived{handle, client_service_id: _, requested_endpoint} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(expected_response, ExpectedBeginHandshakeResponse::EndpointRequestReceived);\n                    #[derive(PartialEq, Debug)]\n                    enum ExpectedHandleEndpointRequestReceiveResult {\n                        Success,\n                        // Error Cases\n                        ErrorSectionTooLarge,\n                    }\n\n                    let mut expected_result = ExpectedHandleEndpointRequestReceiveResult::Success;\n\n                    // calculate the expected size of our reponse message\n                    let begin_handshake_complete_message_size = {\n                        let result = doc!{\n                            \"server_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: [0u8; COOKIE_SIZE].to_vec()}),\n                            \"endpoint_challenge\" : data.endpoint_challenge.value.clone(),\n                        };\n                        let response_section_size = get_response_section_size(Some(Bson::Document(result))).unwrap();\n                        get_message_overhead().unwrap() + response_section_size\n                    };\n                    if begin_handshake_complete_message_size \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expected_result = ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge;\n                    }\n\n                    match alice.identity_server_handle_endpoint_request_received(\n                        alice_handshake_handle,\n                        data.client_allowed,\n                        data.endpoint_supported \u0026\u0026 requested_endpoint == VALID_ENDPOINT,\n                        data.endpoint_challenge.value.clone()) {\n                        Err(gosling::Error::IdentityServerError(identity_server::Error::EndpointChallengeTooLarge(_,_))) =\u003e {\n                            assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge);\n                            return;\n                        },\n                        Ok(()) =\u003e {\n                            assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::Success);\n                        }\n                        result =\u003e panic!(\"unexpected result: {:?}\", result)\n                    }\n\n                    alice_begin_handshake_handled = true;\n                }\n                ContextEvent::IdentityServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(identity_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedBeginHandshakeResponse::ErrorBadClient ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_begin_handshake_handled = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n        // Alice sends Bob begin_handshake() response (or does nothing)\n    for event in alice.update().unwrap().drain(..) {\n        match event {\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    //\n    // Bob reads begin_handshake() response or error sections\n    //\n\n    // bob receives begin_handshake() pending response\n    let begin_handshake_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure =\u003e {\n            match begin_handshake_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_BAD_VERSION,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived |\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // bob receives begin_handshake() result\n    let begin_handshake_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    let mut server_cookie: Cookie = Default::default();\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion |\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let section = \u0026sections[0];\n                    match section {\n                        Bson::Document(section) =\u003e {\n                            assert_eq!(section.get_i32(\"id\"), Ok(RESPONSE_SECTION));\n                            let response = section;\n                            assert_eq!(response.get_i64(\"cookie\"), Ok(data.begin_handshake_cookie));\n                            assert_eq!(response.get_i32(\"state\"), Ok(COMPLETE_REQUEST_STATE));\n                            let result = response.get_document(\"result\").unwrap();\n                            server_cookie = result.get_binary_generic(\"server_cookie\").unwrap().clone().try_into().unwrap();\n                            let endpoint_challenge = result.get_document(\"endpoint_challenge\").unwrap();\n                            // compare the raw bytes ince an arbitrary bson doc may have Double(NaN) which fails equality test\n                            assert_eq!({\n                                let mut bytes: Vec\u003cu8\u003e = Default::default();\n                                endpoint_challenge.to_writer(\u0026mut bytes).unwrap();\n                                bytes\n                            },{\n                                let mut bytes: Vec\u003cu8\u003e = Default::default();\n                                data.endpoint_challenge.value.to_writer(\u0026mut bytes).unwrap();\n                                bytes\n                            });\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n\n    }\n\n    //\n    // Bsob sends send_response()\n    //\n\n    #[derive(PartialEq, Debug)]\n    enum ExpectedSendResponseResponse {\n        // Success Case\n        EndpointOnionServiceIdReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = match (data.client_allowed \u0026\u0026 data.endpoint_supported, data.begin_handshake) {\n        (true, BeginHandshakeMessage::Request{version: Argument::Valid, client_identity: Argument::Valid, endpoint: Argument::Valid}) =\u003e ExpectedSendResponseResponse::EndpointOnionServiceIdReceived,\n        _ =\u003e ExpectedSendResponseResponse::ErrorBadClient,\n    };\n\n    let message = match data.send_response {\n        SendResponseMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedSendResponseResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedSendResponseResponse::ErrorBsonTooSmall\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        ExpectedSendResponseResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedSendResponseResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedSendResponseResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedSendResponseResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes\n        },\n        SendResponseMessage::Request{\n            client_cookie,\n            client_identity_proof_signature,\n            client_authorization_key,\n            client_authorization_key_signbit,\n            client_authorization_signature,\n            challenge_response} =\u003e {\n            match (\u0026client_cookie, \u0026client_identity_proof_signature, \u0026client_authorization_key, \u0026client_authorization_key_signbit, \u0026client_authorization_signature, \u0026challenge_response) {\n                (Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid) =\u003e (),\n                (Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_)) =\u003e expected_response = ExpectedSendResponseResponse::ErrorBadClient,\n                _ =\u003e expected_response = ExpectedSendResponseResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_identity\".to_string()));\n            section.insert(\"function\", Bson::String(\"send_response\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.send_response_cookie));\n\n            let mut arguments = Document::new();\n            let client_cookie = match client_cookie {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.client_cookie.to_vec()})),\n                Argument::Invalid(value) =\u003e {\n                    // ensure the cookie is actually invalid\n                    if value == data.client_cookie {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.map(|x| !x).to_vec()}))\n                    } else {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.to_vec()}))\n                    }\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_cookie) = client_cookie {\n                arguments.insert(\"client_cookie\", client_cookie);\n            }\n\n            let client_identity_proof_signature = match client_identity_proof_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_identity_proof = build_client_proof(\"gosling-identity\", VALID_ENDPOINT, \u0026bob_onion_service_id, \u0026alice_onion_service_id, \u0026data.client_cookie, \u0026server_cookie);\n                    let client_identity_proof_signature = bob_private_key.sign_message(\u0026client_identity_proof);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_identity_proof_signature) = client_identity_proof_signature {\n                arguments.insert(\"client_identity_proof_signature\", client_identity_proof_signature);\n            }\n\n            let client_authorization_key = match client_authorization_key {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_authorization_key = X25519PublicKey::from_private_key(\u0026data.bob_private_x25519.value);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    let client_authorization_key = X25519PublicKey::from_private_key(\u0026invalid.value);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}))\n                },\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_key) = client_authorization_key {\n                arguments.insert(\"client_authorization_key\", client_authorization_key);\n            }\n\n            let client_authorization_signing_key_private = Ed25519PrivateKey::from_private_x25519(\u0026data.bob_private_x25519.value).unwrap();\n            let client_authorization_key_signbit = match client_authorization_key_signbit {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let signbit = client_authorization_signing_key_private.1;\n                    Some(Bson::Boolean(bool::from(signbit)))\n                },\n                Argument::Invalid(_) =\u003e {\n                    let signbit = client_authorization_signing_key_private.1;\n                    Some(Bson::Boolean(!bool::from(signbit)))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::Boolean(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_key_signbit) = client_authorization_key_signbit {\n                arguments.insert(\"client_authorization_key_signbit\", client_authorization_key_signbit);\n            }\n\n            let client_authorization_signature = match client_authorization_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_authorization_signature = client_authorization_signing_key_private.0.sign_message(bob_onion_service_id_string.as_bytes());\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                },\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_signature) = client_authorization_signature {\n                arguments.insert(\"client_authorization_signature\", client_authorization_signature);\n            }\n\n            let challenge_response = match challenge_response {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Document(Document::new())),\n                Argument::Invalid(ArbitraryBSONDocument{value}) =\u003e {\n                    // server is expecting an empty response so to be invalid\n                    // it must contain *some* member\n                    if value == Document::new() {\n                        Some(Bson::Document(doc!{\"foo\": Bson::Null}))\n                    } else {\n                        Some(Bson::Document(value))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::Document(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(challenge_response) = challenge_response {\n                arguments.insert(\"challenge_response\", challenge_response);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedSendResponseResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n\n    //\n    // Alice handles send_response()\n    //\n\n    let mut alice_send_response_handled: bool = false;\n    while !alice_send_response_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(identity_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedSendResponseResponse::ErrorBadClient ||\n                                    expected_response == ExpectedSendResponseResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_send_response_handled = true;\n                },\n                ContextEvent::IdentityServerChallengeResponseReceived{handle, challenge_response} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice.identity_server_handle_challenge_response_received(handle, challenge_response == Document::new()).unwrap();\n                },\n                ContextEvent::IdentityServerHandshakeCompleted{handle, endpoint_private_key: _, endpoint_name, client_service_id: _, client_auth_public_key: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    alice_send_response_handled = true;\n                    assert_eq!(expected_response, ExpectedSendResponseResponse::EndpointOnionServiceIdReceived);\n                },\n                ContextEvent::IdentityServerHandshakeRejected { handle, client_allowed: _, client_requested_endpoint_valid: _, client_proof_signature_valid: _, client_auth_signature_valid: _, challenge_response_valid: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice_send_response_handled = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob reads send_response() response or error sections\n    //\n\n    // first read response (pending) or error section\n    let send_response_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure =\u003e {\n            match send_response_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EndpointOnionServiceIdReceived |\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // next read response (result) or error section\n    let send_response_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure |\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EndpointOnionServiceIdReceived =\u003e {\n            match send_response_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let response = \u0026sections[0];\n                    match response {\n                        Bson::Document(response) =\u003e {\n                            assert_eq!(response.get_i32(\"id\").unwrap(), RESPONSE_SECTION, \"{:?}\", message);\n                            assert_eq!(response.get_i64(\"cookie\").unwrap(), data.send_response_cookie, \"{:?}\", message);\n                            assert_eq!(response.get_i32(\"state\").unwrap(), COMPLETE_REQUEST_STATE, \"{:?}\", message);\n                            match response.get(\"result\") {\n                                Some(Bson::String(serviceid)) =\u003e {\n                                    // ensure returned valueis a valid service id\n                                    V3OnionServiceId::from_string(serviceid).unwrap();\n                                },\n                                Some(bson) =\u003e panic!(\"unexpected result: {:?}\", bson),\n                                None =\u003e panic!(\"unexpected send_response result message: {:?}\", message),\n                            }\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n    }\n\n    // success!\n    ()\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","utils.rs"],"content":"// extern\nuse data_encoding::HEXLOWER;\nuse tor_interface::tor_crypto::*;\n\n\n// honk-rpc constants\npub(crate) const HONK_RPC: i32 = 1;\npub(crate) const ERROR_SECTION: i32 = 0;\npub(crate) const ERROR_CODE_BAD_VERSION: i32 = 0;\npub(crate) const ERROR_CODE_REQUEST_COOKIE_REQUIRED: i32 = 1;\npub(crate) const ERROR_CODE_INVALID_ARG: i32 = 2;\npub(crate) const ERROR_CODE_FAILURE: i32 = 3;\npub(crate) const REQUEST_SECTION: i32 = 1;\npub(crate) const RESPONSE_SECTION: i32 = 2;\npub(crate) const PENDING_REQUEST_STATE: i32 = 0;\npub(crate) const COMPLETE_REQUEST_STATE: i32 = 1;\n\n// gosling constants\npub(crate) const GOSLING_VERSION: \u0026str = gosling::gosling::GOSLING_PROTOCOL_VERSION;\npub(crate) const GOSLING_IDENTITY_NAMESPACE: \u0026str = \"gosling_identity\";\npub(crate) const GOSLING_IDENTITY_BEGIN_HANDSHAKE_FUNCTION: \u0026str = \"begin_handshake\";\npub(crate) const GOSLING_IDENTITY_SEND_RESPONSE_FUNCTION: \u0026str = \"send_response\";\npub(crate) const GOSLING_ENDPOINT_NAMESPACE: \u0026str = \"gosling_endpoint\";\npub(crate) const GOSLING_ENDPOINT_BEGIN_HANDSHAKE_FUNCTION: \u0026str = \"begin_handshake\";\npub(crate) const GOSLING_ENDPOINT_SEND_RESPONSE_FUNCTION: \u0026str = \"send_response\";\npub(crate) const VALID_ENDPOINT: \u0026str = \"valid_endpoint\";\npub(crate) const VALID_CHANNEL: \u0026str = \"valid_channel\";\npub(crate) const IDENTITY_MAX_MESSAGE_SIZE: i32 = 1024;\npub(crate) const ENDPOINT_MAX_MESSAGE_SIZE: i32 = 384;\npub(crate) const COOKIE_SIZE: usize = 32usize;\npub(crate) type Cookie = [u8; COOKIE_SIZE];\n\n\npub(crate) fn build_client_proof(\n    domain_separator: \u0026str,\n    request: \u0026str,\n    client_service_id: \u0026V3OnionServiceId,\n    server_service_id: \u0026V3OnionServiceId,\n    client_cookie: \u0026Cookie,\n    server_cookie: \u0026Cookie,\n) -\u003e Vec\u003cu8\u003e {\n    let mut client_proof: Vec\u003cu8\u003e= Default::default();\n\n    client_proof.extend_from_slice(domain_separator.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(request.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(client_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(server_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(client_cookie).as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(server_cookie).as_bytes());\n\n    client_proof\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","ascii_string.rs"],"content":"#[cfg(test)]\nuse anyhow::bail;\nuse std::ops::Deref;\n\n#[derive(thiserror::Error, Debug)]\npub(crate) enum Error {\n    #[error(\"input string is not ASCII: {0}\")]\n    InvalidAscii(String),\n}\n\n/// An immutable wrapper around a String guaranteed to be ASCII encoded\n#[derive(Clone, PartialEq)]\npub(crate) struct AsciiString {\n    value: String,\n}\n\nimpl AsciiString {\n    pub fn new(value: String) -\u003e Result\u003cAsciiString, Error\u003e {\n        if value.is_ascii() {\n            Ok(Self { value })\n        } else {\n            Err(Error::InvalidAscii(value))\n        }\n    }\n}\n\nimpl Deref for AsciiString {\n    type Target = String;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.value\n    }\n}\n\nimpl std::fmt::Debug for AsciiString {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.value.fmt(f)\n    }\n}\n\nimpl std::fmt::Display for AsciiString {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.value.fmt(f)\n    }\n}\n\n#[test]\nfn test_ascii_string() -\u003e anyhow::Result\u003c()\u003e {\n    let valid_ascii: [String; 8] = [\n        \"\".to_string(),\n        \" !\\\"#$%\u0026'()*+,-./\".to_string(),\n        \"0123456789\".to_string(),\n        \":\u003c=\u003e?@\".to_string(),\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".to_string(),\n        \"[\\\\]^_`\".to_string(),\n        \"abcdefghijklmnopqstuvwxyz\".to_string(),\n        \"{|}~\".to_string(),\n    ];\n\n    for string in valid_ascii {\n        match AsciiString::new(string) {\n            Ok(string) =\u003e println!(\"ascii: '{}'\", string),\n            Err(err) =\u003e bail!(\"unexpected error: {}\", err),\n        }\n    }\n\n    let utf8: [String; 2] = [\"\".to_string(), \"heart \".to_string()];\n\n    for string in utf8 {\n        match AsciiString::new(string) {\n            Ok(string) =\u003e bail!(\"this is not ascii: {}\", string),\n            Err(_) =\u003e (),\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":18,"address":[2985552,2985904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1603474,1603613,1603406],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[2929961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2985681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1690208],"length":1,"stats":{"Line":2},"fn_name":"deref"},{"line":36,"address":[1603776],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":37,"address":[1603790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1603808],"length":1,"stats":{"Line":2},"fn_name":"fmt"},{"line":43,"address":[1603822],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":7,"coverable":9},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","context.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::collections::{BTreeMap, HashMap, VecDeque};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// extern crates\nuse honk_rpc::honk_rpc::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::endpoint_client::*;\nuse crate::endpoint_server::*;\nuse crate::gosling::Error;\nuse crate::identity_client::*;\nuse crate::identity_server::*;\n\n/// cbindgen:ignore\npub type HandshakeHandle = usize;\npub const INVALID_HANDSHAKE_HANDLE: HandshakeHandle = !0usize;\nconst DEFAULT_ENDPOINT_TIMEOUT: Duration = Duration::from_secs(60);\nconst DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE: i32 = 384;\n//\n// The root Gosling Context object\n//\npub struct Context {\n    // our tor instance\n    tor_provider: Box\u003cdyn TorProvider\u003e,\n    bootstrap_complete: bool,\n    identity_port: u16,\n    endpoint_port: u16,\n    identity_timeout: Duration,\n    identity_max_message_size: i32,\n    endpoint_timeout: Duration,\n\n    //\n    // Servers and Clients for in-process handshakes\n    //\n    next_handshake_handle: HandshakeHandle,\n    identity_clients: BTreeMap\u003cHandshakeHandle, IdentityClient\u003e,\n    identity_servers: BTreeMap\u003cHandshakeHandle, IdentityServer\u003e,\n    endpoint_clients: BTreeMap\u003cHandshakeHandle, EndpointClient\u003e,\n    endpoint_servers: BTreeMap\u003cHandshakeHandle, EndpointServer\u003e,\n\n    //\n    // Listeners for incoming connections\n    //\n    identity_listener: Option\u003cOnionListener\u003e,\n    identity_server_published: bool,\n    // maps the endpoint service id to the (enpdoint name, alowed client, onion listener tuple, published)\n    endpoint_listeners: HashMap\u003cV3OnionServiceId, (String, V3OnionServiceId, OnionListener, bool)\u003e,\n\n    //\n    // Server Config Data\n    //\n\n    // Private key behind the identity onion service\n    identity_private_key: Ed25519PrivateKey,\n    // Identity server's service id\n    identity_service_id: V3OnionServiceId,\n}\n\n#[derive(Debug)]\npub enum ContextEvent {\n    //\n    // Tor Events\n    //\n\n    // bootstrap progress\n    TorBootstrapStatusReceived {\n        progress: u32,\n        tag: String,\n        summary: String,\n    },\n\n    // bootstrapping finished\n    TorBootstrapCompleted,\n\n    // tor log\n    TorLogReceived {\n        line: String,\n    },\n\n    //\n    // Identity Client Events\n    //\n\n    // identity client has received a challenge request from an identy server\n    // to continue the handshake, call Context::identity_client_handle_challenge_received\n    IdentityClientChallengeReceived {\n        handle: HandshakeHandle,\n        endpoint_challenge: bson::document::Document,\n    },\n\n    // identity client successfully completes identity handshake\n    IdentityClientHandshakeCompleted {\n        handle: HandshakeHandle,\n        identity_service_id: V3OnionServiceId,\n        endpoint_service_id: V3OnionServiceId,\n        endpoint_name: String,\n        client_auth_private_key: X25519PrivateKey,\n    },\n\n    // identity client handshake failed\n    IdentityClientHandshakeFailed {\n        handle: HandshakeHandle,\n        reason: Error,\n    },\n\n    // identity server onion service published\n    IdentityServerPublished,\n\n    // identity server has received incoming connection\n    IdentityServerHandshakeStarted {\n        handle: HandshakeHandle,\n    },\n\n    // identity server receives request from identity client\n    // to continue the handshake, call Context::identity_server_handle_endpoint_request_received()\n    IdentityServerEndpointRequestReceived {\n        handle: HandshakeHandle,\n        client_service_id: V3OnionServiceId,\n        requested_endpoint: String,\n    },\n\n    // identity server receives challenge response from identity client\n    // to continue the handshake, call Context::identity_server_handle_challenge_response_received()\n    IdentityServerChallengeResponseReceived {\n        handle: HandshakeHandle,\n        challenge_response: bson::document::Document,\n    },\n\n    // identity server supplies a new endpoint server to an identity client\n    IdentityServerHandshakeCompleted {\n        handle: HandshakeHandle,\n        endpoint_private_key: Ed25519PrivateKey,\n        endpoint_name: String,\n        client_service_id: V3OnionServiceId,\n        client_auth_public_key: X25519PublicKey,\n    },\n\n    // identity server handshake explicitly rejected client handshake\n    IdentityServerHandshakeRejected {\n        handle: HandshakeHandle,\n        client_allowed: bool,\n        client_requested_endpoint_valid: bool,\n        client_proof_signature_valid: bool,\n        client_auth_signature_valid: bool,\n        challenge_response_valid: bool,\n    },\n\n    // identity server handshake failed due to error\n    IdentityServerHandshakeFailed {\n        handle: HandshakeHandle,\n        reason: Error,\n    },\n\n    //\n    // Endpoint Client Events\n    //\n\n    // endpoint client successfully opens a channel on an endpoint server\n    EndpointClientHandshakeCompleted {\n        handle: HandshakeHandle,\n        endpoint_service_id: V3OnionServiceId,\n        channel_name: String,\n        stream: TcpStream,\n    },\n\n    // identity client handshake aborted\n    EndpointClientHandshakeFailed {\n        handle: HandshakeHandle,\n        reason: Error,\n    },\n\n    //\n    // Endpint Server Events\n    //\n\n    // endpoint server onion service published\n    EndpointServerPublished {\n        endpoint_service_id: V3OnionServiceId,\n        endpoint_name: String,\n    },\n\n    EndpointServerHandshakeStarted {\n        handle: HandshakeHandle,\n    },\n\n    // endpoint server receives request from endpoint client\n    // to continue the handshake, call Context::endpoint_server_handle_channel_request_received()\n    EndpointServerChannelRequestReceived {\n        handle: HandshakeHandle,\n        client_service_id: V3OnionServiceId,\n        requested_channel: String,\n    },\n\n    // endpoint server has acepted incoming channel request from identity client\n    EndpointServerHandshakeCompleted {\n        handle: HandshakeHandle,\n        endpoint_service_id: V3OnionServiceId,\n        client_service_id: V3OnionServiceId,\n        channel_name: String,\n        stream: TcpStream,\n    },\n\n    // endpoint server handshake explicitly rejected client handshake\n    EndpointServerHandshakeRejected {\n        handle: HandshakeHandle,\n        client_allowed: bool,\n        client_requested_channel_valid: bool,\n        client_proof_signature_valid: bool,\n    },\n\n    // endpoint server request failed\n    EndpointServerHandshakeFailed {\n        handle: HandshakeHandle,\n        reason: Error,\n    },\n}\n\nimpl Context {\n    pub fn new(\n        tor_provider: Box\u003cdyn TorProvider\u003e,\n        identity_port: u16,\n        endpoint_port: u16,\n        identity_timeout: Duration,\n        identity_max_message_size: i32,\n        endpoint_timeout: Option\u003cDuration\u003e,\n        identity_private_key: Ed25519PrivateKey,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        let identity_service_id = V3OnionServiceId::from_private_key(\u0026identity_private_key);\n\n        Ok(Self {\n            tor_provider,\n            bootstrap_complete: false,\n            identity_port,\n            identity_max_message_size,\n            endpoint_port,\n            identity_timeout,\n            endpoint_timeout: match endpoint_timeout {\n                Some(timeout) =\u003e timeout,\n                None =\u003e DEFAULT_ENDPOINT_TIMEOUT,\n            },\n\n            next_handshake_handle: Default::default(),\n            identity_clients: Default::default(),\n            identity_servers: Default::default(),\n            endpoint_clients: Default::default(),\n            endpoint_servers: Default::default(),\n\n            identity_listener: None,\n            identity_server_published: false,\n            endpoint_listeners: Default::default(),\n\n            identity_private_key,\n            identity_service_id,\n        })\n    }\n\n    pub fn bootstrap(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.tor_provider.bootstrap()?;\n        Ok(())\n    }\n\n    pub fn identity_client_begin_handshake(\n        \u0026mut self,\n        identity_server_id: V3OnionServiceId,\n        endpoint: String,\n    ) -\u003e Result\u003cHandshakeHandle, Error\u003e {\n        let endpoint = match AsciiString::new(endpoint) {\n            Ok(endpoint) =\u003e endpoint,\n            Err(_) =\u003e {\n                return Err(Error::InvalidArgument(\n                    \"endpoint must be an ASCII string\".to_string(),\n                ))\n            }\n        };\n\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        // open tcp stream to remove ident server\n        let stream: TcpStream = self\n            .tor_provider\n            .connect(\u0026identity_server_id, self.identity_port, None)?\n            .into();\n        stream.set_nonblocking(true)?;\n        let mut client_rpc = Session::new(stream);\n        client_rpc.set_max_wait_time(self.identity_timeout);\n        client_rpc.set_max_message_size(self.identity_max_message_size)?;\n\n        let ident_client = IdentityClient::new(\n            client_rpc,\n            identity_server_id,\n            endpoint,\n            self.identity_private_key.clone(),\n            X25519PrivateKey::generate(),\n        )?;\n\n        let handshake_handle = self.next_handshake_handle;\n        self.next_handshake_handle += 1;\n        self.identity_clients.insert(handshake_handle, ident_client);\n\n        Ok(handshake_handle)\n    }\n\n    pub fn identity_client_abort_handshake(\n        \u0026mut self,\n        handle: HandshakeHandle,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(_identity_client) = self.identity_clients.remove(\u0026handle) {\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    // sends an endpoint challenge response to a connected identity server as\n    // part of an identity handshake session\n    pub fn identity_client_handle_challenge_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        challenge_response: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_client) = self.identity_clients.get_mut(\u0026handle) {\n            identity_client.send_response(challenge_response)?;\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    // no-op if identity server is already running\n    pub fn identity_server_start(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n        if self.identity_listener.is_some() {\n            return Err(Error::IncorrectUsage(\n                \"identity server already started\".to_string(),\n            ));\n        }\n\n        let identity_listener =\n            self.tor_provider\n                .listener(\u0026self.identity_private_key, self.identity_port, None)?;\n        identity_listener.set_nonblocking(true)?;\n\n        self.identity_listener = Some(identity_listener);\n        Ok(())\n    }\n\n    pub fn identity_server_stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if self.identity_listener.is_none() {\n            return Err(Error::IncorrectUsage(\n                \"identity server is not started\".to_string(),\n            ));\n        }\n\n        // clear out current identity listener\n        self.identity_listener = None;\n        // clear out published flag\n        self.identity_server_published = false;\n        // clear out any in-process identity handshakes\n        self.identity_servers = Default::default();\n        Ok(())\n    }\n\n    // sends an endpoint challenge to a connected identity client as part of\n    // an identity handshake session abd save off wheether the requested endpoint\n    // is supported\n    pub fn identity_server_handle_endpoint_request_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        client_allowed: bool,\n        endpoint_supported: bool,\n        endpoint_challenge: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_server) = self.identity_servers.get_mut(\u0026handle) {\n            Ok(identity_server.handle_endpoint_request_received(\n                client_allowed,\n                endpoint_supported,\n                endpoint_challenge,\n            )?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    // confirm that a received endpoint challenge response is valid\n    pub fn identity_server_handle_challenge_response_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        challenge_response_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_server) = self.identity_servers.get_mut(\u0026handle) {\n            Ok(identity_server.handle_challenge_response_received(challenge_response_valid)?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    pub fn endpoint_client_begin_handshake(\n        \u0026mut self,\n        endpoint_server_id: V3OnionServiceId,\n        client_auth_key: X25519PrivateKey,\n        channel: String,\n    ) -\u003e Result\u003cHandshakeHandle, Error\u003e {\n        let channel = match AsciiString::new(channel) {\n            Ok(channel) =\u003e channel,\n            Err(_) =\u003e {\n                return Err(Error::InvalidArgument(\n                    \"channel must be an ASCII string\".to_string(),\n                ))\n            }\n        };\n\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        self.tor_provider\n            .add_client_auth(\u0026endpoint_server_id, \u0026client_auth_key)?;\n        let stream: TcpStream = self\n            .tor_provider\n            .connect(\u0026endpoint_server_id, self.endpoint_port, None)?\n            .into();\n        stream.set_nonblocking(true)?;\n\n        let mut session = Session::new(stream);\n        session.set_max_wait_time(self.endpoint_timeout);\n        session.set_max_message_size(DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE)?;\n\n        let endpoint_client = EndpointClient::new(\n            session,\n            endpoint_server_id,\n            channel,\n            self.identity_private_key.clone(),\n        );\n\n        let handshake_handle = self.next_handshake_handle;\n        self.next_handshake_handle += 1;\n        self.endpoint_clients\n            .insert(handshake_handle, endpoint_client);\n        Ok(handshake_handle)\n    }\n\n    pub fn endpoint_client_abort_handshake(\n        \u0026mut self,\n        handle: HandshakeHandle,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(_endpoint_client) = self.endpoint_clients.remove(\u0026handle) {\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    pub fn endpoint_server_start(\n        \u0026mut self,\n        endpoint_private_key: Ed25519PrivateKey,\n        endpoint_name: String,\n        client_identity: V3OnionServiceId,\n        client_auth: X25519PublicKey,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        let endpoint_public_key = Ed25519PublicKey::from_private_key(\u0026endpoint_private_key);\n        let endpoint_service_id = V3OnionServiceId::from_public_key(\u0026endpoint_public_key);\n\n        if endpoint_service_id == self.identity_service_id {\n            return Err(Error::InvalidArgument(\n                \"endpoint server must be different from identity server\".to_string(),\n            ));\n        }\n\n        if self.endpoint_listeners.contains_key(\u0026endpoint_service_id) {\n            return Err(Error::IncorrectUsage(\n                \"endpoint server already started\".to_string(),\n            ));\n        }\n\n        let endpoint_listener = self.tor_provider.listener(\n            \u0026endpoint_private_key,\n            self.endpoint_port,\n            Some(\u0026[client_auth]),\n        )?;\n        endpoint_listener.set_nonblocking(true)?;\n\n        self.endpoint_listeners.insert(\n            endpoint_service_id,\n            (endpoint_name, client_identity, endpoint_listener, false),\n        );\n        Ok(())\n    }\n\n    pub fn endpoint_server_handle_channel_request_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        channel_supported: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(endpoint_server) = self.endpoint_servers.get_mut(\u0026handle) {\n            Ok(endpoint_server.handle_channel_request_received(channel_supported)?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    pub fn endpoint_server_stop(\n        \u0026mut self,\n        endpoint_identity: V3OnionServiceId,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        if let Some(_listener) = self.endpoint_listeners.remove(\u0026endpoint_identity) {\n            Ok(())\n        } else {\n            Err(Error::InvalidArgument(format!(\n                \"endpoint server with service id {} not found\",\n                endpoint_identity\n            )))\n        }\n    }\n\n    fn identity_server_handle_accept(\n        identity_listener: \u0026OnionListener,\n        identity_timeout: Duration,\n        identity_max_message_size: i32,\n        identity_private_key: \u0026Ed25519PrivateKey,\n    ) -\u003e Result\u003cOption\u003cIdentityServer\u003e, Error\u003e {\n        if let Some(stream) = identity_listener.accept()? {\n            let stream: TcpStream = stream.into();\n            if stream.set_nonblocking(true).is_err() {\n                return Ok(None);\n            }\n\n            let mut server_rpc = Session::new(stream);\n            server_rpc.set_max_wait_time(identity_timeout);\n            server_rpc.set_max_message_size(identity_max_message_size)?;\n            let service_id = V3OnionServiceId::from_private_key(identity_private_key);\n            let identity_server = IdentityServer::new(server_rpc, service_id);\n\n            Ok(Some(identity_server))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn endpoint_server_handle_accept(\n        endpoint_listener: \u0026OnionListener,\n        endpoint_timeout: Duration,\n        client_service_id: \u0026V3OnionServiceId,\n        endpoint_service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003cOption\u003cEndpointServer\u003e, Error\u003e {\n        if let Some(stream) = endpoint_listener.accept()? {\n            let stream: TcpStream = stream.into();\n            if stream.set_nonblocking(true).is_err() {\n                return Ok(None);\n            }\n\n            let mut server_rpc = Session::new(stream);\n            server_rpc.set_max_wait_time(endpoint_timeout);\n            server_rpc.set_max_message_size(DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE)?;\n\n            let endpoint_server = EndpointServer::new(\n                server_rpc,\n                client_service_id.clone(),\n                endpoint_service_id.clone(),\n            );\n\n            Ok(Some(endpoint_server))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cVecDeque\u003cContextEvent\u003e, Error\u003e {\n        // events to return\n        let mut events: VecDeque\u003cContextEvent\u003e = Default::default();\n\n        // first handle new identity connections\n        if let Some(identity_listener) = \u0026self.identity_listener {\n            match Self::identity_server_handle_accept(\n                identity_listener,\n                self.identity_timeout,\n                self.identity_max_message_size,\n                \u0026self.identity_private_key,\n            ) {\n                Ok(Some(identity_server)) =\u003e {\n                    let handle = self.next_handshake_handle;\n                    self.next_handshake_handle += 1;\n                    self.identity_servers.insert(handle, identity_server);\n                    events.push_back(ContextEvent::IdentityServerHandshakeStarted { handle });\n                }\n                Ok(None) =\u003e {}\n                // identity listener failed, remove it\n                // TODO: signal caller identity listener is down\n                Err(_) =\u003e self.identity_listener = None,\n            }\n        }\n\n        // next handle new endpoint connections\n        self.endpoint_listeners.retain(\n            |endpoint_service_id, (_endpoint_name, allowed_client, listener, _published)| -\u003e bool {\n                match Self::endpoint_server_handle_accept(\n                    listener,\n                    self.endpoint_timeout,\n                    allowed_client,\n                    endpoint_service_id,\n                ) {\n                    Ok(Some(endpoint_server)) =\u003e {\n                        let handle = self.next_handshake_handle;\n                        self.next_handshake_handle += 1;\n                        self.endpoint_servers.insert(handle, endpoint_server);\n                        events.push_back(ContextEvent::EndpointServerHandshakeStarted { handle });\n                        true\n                    }\n                    Ok(None) =\u003e true,\n                    // endpoint listener failed, remove it\n                    // TODO: signal caller endpoint listener is down\n                    Err(_) =\u003e false,\n                }\n            },\n        );\n\n        // consume tor events\n        // TODO: so curently the only failure mode of this function is a result of the\n        // LegacyTorClient failing; we should probably consider a LegacyTorClient failure fatal, since\n        // reading the LegacyTorClient::update() function it seems the only failure modes are a\n        // failure to DEL_ONION (which realistically speaking could only be due to a logic\n        // error on our part by deleting an onion that doesn't exist, or a parse error of\n        // the response) and a failure to read async events which is either again a parsing\n        // bug on our end or a malformed/buggy tor daemon which we also cannot recover\n        // from.\n        for event in self.tor_provider.update()?.drain(..) {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e {\n                    events.push_back(ContextEvent::TorBootstrapStatusReceived {\n                        progress,\n                        tag,\n                        summary,\n                    });\n                }\n                TorEvent::BootstrapComplete =\u003e {\n                    events.push_back(ContextEvent::TorBootstrapCompleted);\n                    self.bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    events.push_back(ContextEvent::TorLogReceived { line });\n                }\n                TorEvent::OnionServicePublished { service_id } =\u003e {\n                    if service_id == self.identity_service_id {\n                        if !self.identity_server_published {\n                            events.push_back(ContextEvent::IdentityServerPublished);\n                            self.identity_server_published = true;\n                        }\n                    } else if let Some((endpoint_name, _, _, published)) =\n                        self.endpoint_listeners.get_mut(\u0026service_id)\n                    {\n                        // ingore duplicate publish events\n                        if !*published {\n                            events.push_back(ContextEvent::EndpointServerPublished {\n                                endpoint_service_id: service_id,\n                                endpoint_name: endpoint_name.clone(),\n                            });\n                            *published = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        // update the ident client handshakes\n        self.identity_clients\n            .retain(|handle, identity_client| -\u003e bool {\n                let handle = *handle;\n                match identity_client.update() {\n                    Ok(Some(IdentityClientEvent::ChallengeReceived { endpoint_challenge })) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientChallengeReceived {\n                            handle,\n                            endpoint_challenge,\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                        identity_service_id,\n                        endpoint_service_id,\n                        endpoint_name,\n                        client_auth_private_key,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientHandshakeCompleted {\n                            handle,\n                            identity_service_id,\n                            endpoint_service_id,\n                            endpoint_name,\n                            client_auth_private_key,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the ident server handshakes\n        self.identity_servers\n            .retain(|handle, identity_server| -\u003e bool {\n                let handle = *handle;\n                match identity_server.update() {\n                    Ok(Some(IdentityServerEvent::EndpointRequestReceived {\n                        client_service_id,\n                        requested_endpoint,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerEndpointRequestReceived {\n                            handle,\n                            client_service_id,\n                            requested_endpoint: requested_endpoint.to_string(),\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityServerEvent::ChallengeResponseReceived {\n                        challenge_response,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerChallengeResponseReceived {\n                            handle,\n                            challenge_response,\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityServerEvent::HandshakeCompleted {\n                        endpoint_private_key,\n                        endpoint_name,\n                        client_service_id,\n                        client_auth_public_key,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeCompleted {\n                            handle,\n                            endpoint_private_key,\n                            endpoint_name: endpoint_name.to_string(),\n                            client_service_id,\n                            client_auth_public_key,\n                        });\n                        false\n                    }\n                    Ok(Some(IdentityServerEvent::HandshakeRejected {\n                        client_allowed,\n                        client_requested_endpoint_valid,\n                        client_proof_signature_valid,\n                        client_auth_signature_valid,\n                        challenge_response_valid,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeRejected {\n                            handle,\n                            client_allowed,\n                            client_requested_endpoint_valid,\n                            client_proof_signature_valid,\n                            client_auth_signature_valid,\n                            challenge_response_valid,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the endpoint client handshakes\n        self.endpoint_clients\n            .retain(|handle, endpoint_client| -\u003e bool {\n                let handle = *handle;\n                match endpoint_client.update() {\n                    Ok(Some(EndpointClientEvent::HandshakeCompleted { stream })) =\u003e {\n                        events.push_back(ContextEvent::EndpointClientHandshakeCompleted {\n                            handle,\n                            endpoint_service_id: endpoint_client.server_service_id.clone(),\n                            channel_name: endpoint_client.requested_channel.to_string(),\n                            stream,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::EndpointClientHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the endpoint server handshakes\n        self.endpoint_servers\n            .retain(|handle, endpoint_server| -\u003e bool {\n                let handle = *handle;\n                match endpoint_server.update() {\n                    Ok(Some(EndpointServerEvent::ChannelRequestReceived {\n                        requested_channel,\n                        client_service_id,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerChannelRequestReceived {\n                            handle,\n                            client_service_id,\n                            requested_channel: requested_channel.to_string(),\n                        });\n                        true\n                    }\n                    Ok(Some(EndpointServerEvent::HandshakeCompleted {\n                        client_service_id,\n                        channel_name,\n                        stream,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeCompleted {\n                            handle,\n                            endpoint_service_id: endpoint_server.server_identity.clone(),\n                            client_service_id,\n                            channel_name: channel_name.to_string(),\n                            stream,\n                        });\n                        false\n                    }\n                    Ok(Some(EndpointServerEvent::HandshakeRejected {\n                        client_allowed,\n                        client_requested_channel_valid,\n                        client_proof_signature_valid,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeRejected {\n                            handle,\n                            client_allowed,\n                            client_requested_channel_valid,\n                            client_proof_signature_valid,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        Ok(events)\n    }\n}\n","traces":[{"line":225,"address":[1581647,1581606,1580416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1580563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1581125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1580636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[1580670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[1580720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[1580695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[1580805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[1580824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1580884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1580944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[1581004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[1581016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[1581084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[1581680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[1581782,1581696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1581769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[1584405,1584149,1581840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[1581918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[1581998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[1584477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[1582109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1582144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[1582220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[1584377,1582339,1582262,1582288,1582591],"length":1,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[1582559,1582276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[1582811,1582639,1582714,1584321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[1582772,1582853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[1582861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[1583213,1582932,1584256,1581910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[1583031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[1583087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[1583134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[1583179,1583395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[1583403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1583681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[1583883,1583698,1583973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[1583887,1584042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[1584071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1584624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[1584654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[1584749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[1584777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[1584896,1585504,1585476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[1584943,1585301,1585030,1585228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":330,"address":[1584930,1585311,1585078,1585449,1585233],"length":1,"stats":{"Line":3},"fn_name":null},{"line":331,"address":[1585294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[1585185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[1585520,1586440,1586408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1585550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[1585572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[1585603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[1585806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[1585776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[1585681,1585644,1585889,1586027],"length":1,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[1585652,1585979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[1586099,1585542,1586225,1585945],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[1586264,1586162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[1586361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[1586937,1586464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[1586500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[1586584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[1586554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[1586521,1586656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[1586747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[1586754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[1586917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[1586960,1587629,1587600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[1587421,1587038,1587125,1587348],"length":1,"stats":{"Line":3},"fn_name":null},{"line":384,"address":[1587572,1587265,1587006,1587353,1587534],"length":1,"stats":{"Line":3},"fn_name":null},{"line":387,"address":[1587186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[1587305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[1587648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[1587890,1587704,1587904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[1587770,1587897,1587906,1587682],"length":1,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[1587847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[1587968,1590132,1590548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[1588140,1588036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[1588151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[1590411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[1588265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[1588300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[1588376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[1588423,1590316,1588634,1588466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[1588602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[1588663,1588915,1590314,1588565,1588538],"length":1,"stats":{"Line":3},"fn_name":null},{"line":430,"address":[1588553,1588883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[1589038,1589135,1588963,1590258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[1589096,1589177],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[1589185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[1589252,1589532,1588028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[1589350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[1589406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[1589453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[1589498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[1589806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[1589823,1589945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[1589926,1589857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[1589868,1590014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[1590048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[1590576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[1590606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[1590704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[1590732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[1592339,1592082,1590848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[1590898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1590936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[1590967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[1591046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[1591078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[1592186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[1591146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[1591119,1591180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":484,"address":[1592098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[1591299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[1591267,1591329,1591201,1591513,1592091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":492,"address":[1591216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[1591588,1591447,1591931,1590890],"length":1,"stats":{"Line":3},"fn_name":null},{"line":496,"address":[1591665,1591891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[1591669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[1591733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[1591994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[1592352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[1592408,1592608,1592594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":509,"address":[1592610,1592601,1592386,1592474],"length":1,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[1592551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[1592672,1593437,1593405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[1592707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[1592729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[1592765,1592849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[1592969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[1593188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[1594854,1593456,1594772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[1593546,1593989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[1593886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[1593925,1594040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[1594786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[1594163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[1594214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[1594399,1594278,1593507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[1594372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[1594540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[1594611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[1593959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[1594944,1596445,1596302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[1595019,1595470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":564,"address":[1595367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[1595406,1595521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[1596377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[1595644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[1595695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[1594980,1595755,1595923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":574,"address":[1595849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[1595908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[1596118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[1596180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[1595440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[1597342,1599301,1596528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[1596573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[1596597,1597471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":591,"address":[1596828,1596686,1598349],"length":1,"stats":{"Line":2},"fn_name":null},{"line":593,"address":[1596657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[1596664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[1596671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[1596955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[1596994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[1597011,1597131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[1597045,1597201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":601,"address":[1597225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[1597356,1596887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[1596765,1596701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[1596708],"length":1,"stats":{"Line":3},"fn_name":null},{"line":613,"address":[1793754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":615,"address":[1793745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[1793826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[1793862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[1794046,1793953,1793882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":622,"address":[1793960,1794116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":623,"address":[1794145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[1794194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[1793819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[1793812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[1597503,1598032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":644,"address":[1597998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[1598365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[1598429,1598791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":656,"address":[1598808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":657,"address":[1598555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":658,"address":[1598801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[1598590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":661,"address":[1598813,1598622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":663,"address":[1598701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":664,"address":[1598765,1598822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[1598866,1599280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":666,"address":[1599236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":667,"address":[1599273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[1598833,1598889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":673,"address":[1598978,1599221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":674,"address":[1599075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[1598992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[1599056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[1599218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[1598073,1598056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":687,"address":[1598065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":688,"address":[1794385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[1794663,1794409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":690,"address":[1794741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":691,"address":[1794778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[1794861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[1794871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":[1794898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":700,"address":[1794935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":701,"address":[1794974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[1795038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[1795261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[1794500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[1794532,1794574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[1794540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[1794649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[1794656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[1598114,1598097],"length":1,"stats":{"Line":2},"fn_name":null},{"line":725,"address":[1598106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":726,"address":[1795409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":727,"address":[1795687,1795788,1795433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":729,"address":[1795795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[1795859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[1795885,1796536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":735,"address":[1795893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":737,"address":[1796677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[1795923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[1795960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":746,"address":[1796043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[1796053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[1796113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":751,"address":[1796139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[1796203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[1796772,1796235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":756,"address":[1796251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":757,"address":[1796253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":761,"address":[1797006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":[1796293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[1796310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[1796327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[1796342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[1796357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[1796376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[1796472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[1795524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[1795556,1795598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[1795564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[1795673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[1795680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":792,"address":[1598138,1598158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":793,"address":[1598150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":794,"address":[1797174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[1797206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":796,"address":[1797456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":797,"address":[1797475,1797643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":799,"address":[1797483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":800,"address":[1797592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":801,"address":[1797628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":803,"address":[1797791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[1797287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[1797357,1797315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[1797323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[1797432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[1797439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[1598182,1598202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":818,"address":[1598194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":819,"address":[1797990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[1798381,1798022,1798272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":822,"address":[1798388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":823,"address":[1798414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":825,"address":[1798475,1798860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":828,"address":[1798483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[1799001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[1798523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":834,"address":[1798584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[1798610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":837,"address":[1798632,1799140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":839,"address":[1798640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[1799088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[1799125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[1799352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[1798675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[1798690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[1798705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[1798724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[1798796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[1798113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[1798141,1798183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":862,"address":[1798149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[1798258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":866,"address":[1798265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":870,"address":[1598226],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":221,"coverable":295},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","endpoint_client.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{RequestCookie, Response, Session};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Endpoint Client\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"client received unexpected response: {0}\")]\n    UnexpectedResponseReceived(String),\n\n    #[error(\"client is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n}\n\npub(crate) enum EndpointClientEvent {\n    HandshakeCompleted { stream: TcpStream },\n}\n\n#[derive(Debug, PartialEq)]\nenum EndpointClientState {\n    BeginHandshake,\n    WaitingForServerCookie,\n    WaitingForProofVerification,\n    HandshakeComplete,\n}\n\npub(crate) struct EndpointClient {\n    // session data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    pub server_service_id: V3OnionServiceId,\n    pub requested_channel: AsciiString,\n    client_service_id: V3OnionServiceId,\n    client_ed25519_private: Ed25519PrivateKey,\n\n    // state machine data\n    state: EndpointClientState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n}\n\nimpl EndpointClient {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, send_response_request_cookie: {:?} }}\", self.state, self.begin_handshake_request_cookie, self.send_response_request_cookie)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        server_service_id: V3OnionServiceId,\n        requested_channel: AsciiString,\n        client_ed25519_private: Ed25519PrivateKey,\n    ) -\u003e Self {\n        Self {\n            rpc: Some(rpc),\n            server_service_id,\n            requested_channel,\n            client_service_id: V3OnionServiceId::from_private_key(\u0026client_ed25519_private),\n            client_ed25519_private,\n\n            state: EndpointClientState::BeginHandshake,\n            begin_handshake_request_cookie: None,\n            send_response_request_cookie: None,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cEndpointClientEvent\u003e, Error\u003e {\n        if self.state == EndpointClientState::HandshakeComplete {\n            return Err(Error::IncorrectUsage(\"update() may not be called after HandshakeComplete has been returned from previous update() call\".to_string()));\n        }\n\n        // update our rpc session\n        if let Some(rpc) = self.rpc.as_mut() {\n            rpc.update(None)?;\n\n            // client state machine\n            match (\n                \u0026self.state,\n                self.begin_handshake_request_cookie,\n                self.send_response_request_cookie,\n            ) {\n                (\u0026EndpointClientState::BeginHandshake, None, None) =\u003e {\n                    self.begin_handshake_request_cookie = Some(rpc.client_call(\n                        \"gosling_endpoint\",\n                        \"begin_handshake\",\n                        0,\n                        doc! {\n                            \"version\" : bson::Bson::String(GOSLING_PROTOCOL_VERSION.to_string()),\n                            \"client_identity\" : bson::Bson::String(self.client_service_id.to_string()),\n                            \"channel\" : bson::Bson::String(self.requested_channel.to_string()),\n                        },\n                    ).unwrap());\n                    self.state = EndpointClientState::WaitingForServerCookie;\n                    Ok(None)\n                }\n                (\n                    \u0026EndpointClientState::WaitingForServerCookie,\n                    Some(begin_handshake_request_cookie),\n                    None, // send_response_request_cookie\n                ) =\u003e {\n                    if let Some(response) = rpc.client_next_response() {\n                        let result = match response {\n                            Response::Pending { cookie } =\u003e {\n                                if cookie == begin_handshake_request_cookie {\n                                    return Ok(None);\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected pending response\".to_string(),\n                                    ));\n                                }\n                            }\n                            Response::Error { cookie, error_code } =\u003e {\n                                if cookie != begin_handshake_request_cookie {\n                                    return Err(Error::UnexpectedResponseReceived(format!(\n                                        \"received unexpected error response; rpc error_code: {}\",\n                                        error_code\n                                    )));\n                                }\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            Response::Success { cookie, result } =\u003e {\n                                if cookie == begin_handshake_request_cookie {\n                                    result\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected success response\".to_string(),\n                                    ));\n                                }\n                            }\n                        };\n\n                        if let bson::Bson::Document(result) = result {\n                            if let Some(Bson::Binary(Binary {\n                                subtype: BinarySubtype::Generic,\n                                bytes: server_cookie,\n                            })) = result.get(\"server_cookie\")\n                            {\n                                // build arguments for send_response()\n\n                                // client_cookie\n                                let mut client_cookie: ClientCookie = Default::default();\n                                OsRng.fill_bytes(\u0026mut client_cookie);\n\n                                // client_identity_proof_signature\n                                let server_cookie: ServerCookie =\n                                    match server_cookie.clone().try_into() {\n                                        Ok(server_cookie) =\u003e server_cookie,\n                                        Err(_) =\u003e {\n                                            return Err(Error::UnexpectedResponseReceived(format!(\n                                                \"unable to convert '{:?}' to server cookie\",\n                                                server_cookie\n                                            )))\n                                        }\n                                    };\n                                let client_identity_proof = build_client_proof(\n                                    DomainSeparator::GoslingEndpoint,\n                                    \u0026self.requested_channel,\n                                    \u0026self.client_service_id,\n                                    \u0026self.server_service_id,\n                                    \u0026client_cookie,\n                                    \u0026server_cookie,\n                                );\n                                let client_identity_proof_signature = self\n                                    .client_ed25519_private\n                                    .sign_message(\u0026client_identity_proof);\n\n                                // build our args object for rpc call\n                                let args = doc! {\n                                    \"client_cookie\" : Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_cookie.to_vec()}),\n                                    \"client_identity_proof_signature\" : Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}),\n                                };\n\n                                // make rpc call\n                                self.send_response_request_cookie = Some(\n                                    rpc.client_call(\"gosling_endpoint\", \"send_response\", 0, args)\n                                        .unwrap(),\n                                );\n\n                                self.state = EndpointClientState::WaitingForProofVerification;\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"begin_handshake() returned unexpected value: {}\",\n                                    result\n                                )));\n                            }\n                        } else {\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"begin_handshake() returned unexpected value: {}\",\n                                result\n                            )));\n                        }\n                    }\n                    Ok(None)\n                }\n                (\n                    \u0026EndpointClientState::WaitingForProofVerification,\n                    Some(_begin_handshake_request_cookie),\n                    Some(send_response_request_cookie),\n                ) =\u003e {\n                    if let Some(response) = rpc.client_next_response() {\n                        let result = match response {\n                            Response::Pending { cookie } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    return Ok(None);\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected pending response\".to_string(),\n                                    ));\n                                }\n                            }\n                            Response::Error { cookie, error_code } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    return Err(Error::UnexpectedResponseReceived(format!(\n                                        \"received unexpected error response; rpc error_code: {}\",\n                                        error_code\n                                    )));\n                                }\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            Response::Success { cookie, result } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    result\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected success response\".to_string(),\n                                    ));\n                                }\n                            }\n                        };\n\n                        if let Bson::Document(result) = result {\n                            if result.is_empty() {\n                                self.state = EndpointClientState::HandshakeComplete;\n                                let stream = std::mem::take(\u0026mut self.rpc).unwrap().into_stream();\n                                return Ok(Some(EndpointClientEvent::HandshakeCompleted {\n                                    stream,\n                                }));\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected data from send_response(): {:?}\",\n                                    result\n                                )));\n                            }\n                        } else {\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"received unexpected data from send_response(): {:?}\",\n                                result\n                            )));\n                        }\n                    }\n                    Ok(None)\n                }\n                _ =\u003e Err(Error::InvalidState(self.get_state())),\n            }\n        } else {\n            Err(Error::InvalidState(self.get_state()))\n        }\n    }\n}\n","traces":[{"line":65,"address":[1568496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[1568520,1568686,1568634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1568784,1569220,1569261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[1568833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1568868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[1569280,1571355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[1569360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[1569467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1569830,1569589,1569415],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[1569352,1569613,1569978,1571746],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[1576192,1569868,1570156,1571385],"length":1,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[1569843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[1569853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[1569860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[1570891,1571241],"length":1,"stats":{"Line":4},"fn_name":null},{"line":108,"address":[1570227,1570407,1570599,1570271,1570791],"length":1,"stats":{"Line":8},"fn_name":null},{"line":109,"address":[1570244,1570315],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[1570481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[1570673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[1571284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1571305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1571408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1571432,1574753],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[1571629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[1571756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[1571772],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[1572059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[1571965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1571932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1571874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1571918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1575940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1575706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1571786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[1571852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[1572141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[1572276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1572114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1572175,1572379],"length":1,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[1572483,1572661],"length":1,"stats":{"Line":4},"fn_name":null},{"line":159,"address":[1572843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[1572863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[1572882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[1572914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1572986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[1574834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1573161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[1573169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[1573179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[1573189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[1573249,1573374],"length":1,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[1573260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[1573393,1573452,1573997,1573680],"length":1,"stats":{"Line":6},"fn_name":null},{"line":193,"address":[1573412,1573496],"length":1,"stats":{"Line":4},"fn_name":null},{"line":194,"address":[1573746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[1574531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[1574167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[1574575],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[1575112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1575352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1576137],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[1576215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[1576252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[1576433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[1576566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1576582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1576857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[1576763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1576730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1576672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1576716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1578633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[1578399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[1576596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1576653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[1576931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[1577066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1576904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1576965,1577169],"length":1,"stats":{"Line":4},"fn_name":null},{"line":259,"address":[1577273,1577422],"length":1,"stats":{"Line":4},"fn_name":null},{"line":260,"address":[1577511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[1577824,1577532],"length":1,"stats":{"Line":4},"fn_name":null},{"line":262,"address":[1577866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[1577568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1578045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1576522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[1570046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1569725],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":62,"coverable":88},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","endpoint_server.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{ApiSet, ErrorCode, RequestCookie, Session};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Endpoint Server\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"server is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"client sent invalid request\")]\n    BadClient,\n}\n\npub(crate) enum EndpointServerEvent {\n    ChannelRequestReceived {\n        client_service_id: V3OnionServiceId,\n        requested_channel: AsciiString,\n    },\n    // endpoint server has acepted incoming channel request from identity client\n    HandshakeCompleted {\n        client_service_id: V3OnionServiceId,\n        channel_name: AsciiString,\n        stream: TcpStream,\n    },\n    // endpoint server has reject an incoming channel request\n    HandshakeRejected {\n        client_allowed: bool,\n        client_requested_channel_valid: bool,\n        client_proof_signature_valid: bool,\n    },\n}\n\n#[derive(Debug, PartialEq)]\nenum EndpointServerState {\n    // valid/expected states\n    WaitingForBeginHandshake,\n    ValidatingChannelRequest,\n    ChannelRequestValidated,\n    WaitingForSendResponse,\n    HandledSendResponse,\n    HandshakeComplete,\n    // failure state\n    HandshakeFailed,\n}\n\npub(crate) struct EndpointServer {\n    // Session Data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    pub server_identity: V3OnionServiceId,\n    allowed_client_identity: V3OnionServiceId,\n\n    // State Machine Data\n    state: EndpointServerState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    client_identity: Option\u003cV3OnionServiceId\u003e,\n    requested_channel: Option\u003cAsciiString\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    handshake_succeeded: Option\u003cbool\u003e,\n\n    // Verification flags\n\n    // Client not on the block-list\n    client_allowed: bool,\n    // The requested endpoint is valid\n    client_requested_channel_valid: bool,\n    // The client proof is valid and signed with client's public key\n    client_proof_signature_valid: bool,\n}\n\nimpl EndpointServer {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, client_identity: {:?}, requested_channel: {:?}, server_cookie: {:?}, handshake_succeeded:{:?} }}\", self.state, self.begin_handshake_request_cookie, self.client_identity, self.requested_channel, self.server_cookie, self.handshake_succeeded)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        client_identity: V3OnionServiceId,\n        server_identity: V3OnionServiceId,\n    ) -\u003e Self {\n        // generate server cookie\n        let mut server_cookie: ServerCookie = Default::default();\n        OsRng.fill_bytes(\u0026mut server_cookie);\n\n        EndpointServer {\n            rpc: Some(rpc),\n            server_identity,\n            allowed_client_identity: client_identity,\n            state: EndpointServerState::WaitingForBeginHandshake,\n            begin_handshake_request_cookie: None,\n            requested_channel: None,\n            client_identity: None,\n            server_cookie: None,\n            handshake_succeeded: None,\n            client_allowed: false,\n            // TODO: hookup this to event and callback\n            client_requested_channel_valid: true,\n            client_proof_signature_valid: false,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cEndpointServerEvent\u003e, Error\u003e {\n        if let Some(mut rpc) = std::mem::take(\u0026mut self.rpc) {\n            match rpc.update(Some(\u0026mut [self])) {\n                Ok(()) =\u003e {\n                    self.rpc = Some(rpc);\n                }\n                Err(err) =\u003e {\n                    self.rpc = Some(rpc);\n                    return Err(err.into());\n                }\n            }\n        }\n\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_channel.as_ref(),\n              self.server_cookie.as_ref(),\n              self.handshake_succeeded) {\n            (\u0026EndpointServerState::WaitingForBeginHandshake,\n             None, // begin_handshake_request_cookie\n             None, // client_identity\n             None, // requested_channel\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::WaitingForBeginHandshake,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {\n                self.state = EndpointServerState::ValidatingChannelRequest;\n                return Ok(\n                        Some(\n                            EndpointServerEvent::ChannelRequestReceived\n                            {\n                                client_service_id: client_identity.clone(),\n                                requested_channel: requested_channel.clone()\n                            }));\n            },\n            (\u0026EndpointServerState::ValidatingChannelRequest,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::ChannelRequestValidated,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             Some(_server_cookie),\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             Some(_server_cookie),\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::HandledSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_channel),\n             Some(_server_cookie),\n             Some(handshake_succeeded))\n            =\u003e {\n                self.state = EndpointServerState::HandshakeComplete;\n                if handshake_succeeded {\n                    let stream = std::mem::take(\u0026mut self.rpc).unwrap().into_stream();\n                    return Ok(Some(EndpointServerEvent::HandshakeCompleted{\n                        client_service_id: client_identity.clone(),\n                        channel_name: requested_channel.clone(),\n                        stream}));\n                } else {\n                    return Ok(Some(EndpointServerEvent::HandshakeRejected{\n                        client_allowed: self.client_allowed,\n                        client_requested_channel_valid: self.client_requested_channel_valid,\n                        client_proof_signature_valid: self.client_proof_signature_valid}));\n                }\n            },\n            _ =\u003e {\n                if self.state == EndpointServerState::HandshakeFailed {\n                    return Err(Error::BadClient);\n                } else {\n                    return Err(Error::InvalidState(self.get_state()));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    pub fn handle_channel_request_received(\n        \u0026mut self,\n        client_requested_channel_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_channel.as_ref(),\n              self.server_cookie.as_ref(),\n              self.handshake_succeeded) {\n            (\u0026EndpointServerState::ValidatingChannelRequest,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(_requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {\n                let mut server_cookie: ServerCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut server_cookie);\n                self.server_cookie = Some(server_cookie);\n                self.client_allowed = *client_identity == self.allowed_client_identity;\n                self.client_requested_channel_valid = client_requested_channel_valid;\n                self.state = EndpointServerState::ChannelRequestValidated;\n                Ok(())\n            },\n            _ =\u003e Err(Error::IncorrectUsage(\"handle_channel_request_received() may only be called after ChannelRequestReceived has been returned from update(), and it may only be called once\".to_string()))\n        }\n    }\n}\n\nimpl ApiSet for EndpointServer {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"gosling_endpoint\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        let request_cookie = match request_cookie {\n            Some(request_cookie) =\u003e request_cookie,\n            None =\u003e return Err(ErrorCode::Runtime(RpcError::RequestCookieRequired as i32)),\n        };\n\n        match\n            (name, version,\n             \u0026self.state,\n             self.client_identity.as_ref(),\n             self.requested_channel.as_ref(),\n             self.server_cookie.as_ref()) {\n            // handle begin_handshake call\n            (\"begin_handshake\", 0,\n            \u0026EndpointServerState::WaitingForBeginHandshake,\n            None, // client_identity\n            None, // requested_channel\n            None) // server_cookie\n            =\u003e {\n                let valid_version = match args.remove(\"version\") {\n                    Some(Bson::String(value)) =\u003e value == GOSLING_PROTOCOL_VERSION,\n                    _ =\u003e false,\n                };\n                if !valid_version {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    return Err(ErrorCode::Runtime(RpcError::BadVersion as i32));\n                }\n\n                if let (\n                    Some(Bson::String(client_identity)),\n                    Some(Bson::String(channel_name))\n                ) = (\n                    args.remove(\"client_identity\"),\n                    args.remove(\"channel\")\n                ) {\n                    // client_identiity\n                    self.client_identity = match V3OnionServiceId::from_string(\u0026client_identity) {\n                        Ok(client_identity) =\u003e Some(client_identity),\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    let channel_name = match AsciiString::new(channel_name) {\n                        Ok(channel_name) =\u003e channel_name,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // save cookie\n                    self.begin_handshake_request_cookie = Some(request_cookie);\n\n                    // save channel name\n                    self.requested_channel = Some(channel_name);\n\n                    Ok(None)\n                } else {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    Err(ErrorCode::Runtime(RpcError::InvalidArg as i32))\n                }\n            },\n            (\"send_response\", 0,\n            \u0026EndpointServerState::WaitingForSendResponse,\n            Some(client_identity),\n            Some(requested_channel),\n            Some(server_cookie))\n            =\u003e {\n                if let (Some(Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: client_cookie})),\n                        Some(Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature}))) =\n                       (args.remove(\"client_cookie\"),\n                        args.remove(\"client_identity_proof_signature\")) {\n                    // client_cookie\n                    let client_cookie : ClientCookie = match client_cookie.try_into() {\n                        Ok(client_cookie) =\u003e client_cookie,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // client_identity_proof_signature\n                    let client_identity_proof_signature : [u8; ED25519_SIGNATURE_SIZE] = match client_identity_proof_signature.try_into() {\n                        Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n                    let client_identity_proof_signature = match Ed25519Signature::from_raw(\u0026client_identity_proof_signature) {\n                        Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // convert client_identity to client's public ed25519 key\n                    let client_identity_key = match Ed25519PublicKey::from_service_id(client_identity) {\n                        Ok(client_identity_key) =\u003e client_identity_key,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // construct + verify client proof\n                    let client_proof = build_client_proof(\n                        DomainSeparator::GoslingEndpoint,\n                        requested_channel,\n                        client_identity,\n                        \u0026self.server_identity,\n                        \u0026client_cookie,\n                        server_cookie,\n                    );\n                    self.client_proof_signature_valid =\n                        client_identity_proof_signature.verify(\u0026client_proof, \u0026client_identity_key);\n\n                    if self.client_allowed\n                        \u0026\u0026 self.client_requested_channel_valid\n                        \u0026\u0026 self.client_proof_signature_valid\n                    {\n                        self.handshake_succeeded = Some(true);\n                        self.state = EndpointServerState::HandledSendResponse;\n                        // success, return empty doc\n                        Ok(Some(Bson::Document(doc! {})))\n                    } else {\n                        self.handshake_succeeded = Some(false);\n                        self.state = EndpointServerState::HandledSendResponse;\n                        Err(ErrorCode::Runtime(RpcError::Failure as i32))\n                    }\n                } else {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    Err(ErrorCode::Runtime(RpcError::InvalidArg as i32))\n                }\n            },\n            _ =\u003e {\n                self.state = EndpointServerState::HandshakeFailed;\n                Err(ErrorCode::Runtime(RpcError::Failure as i32))\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie.as_ref(),\n        ) {\n            (\n                \u0026EndpointServerState::ChannelRequestValidated,\n                Some(begin_handshake_request_cookie),\n                Some(server_cookie),\n            ) =\u003e {\n                self.state = EndpointServerState::WaitingForSendResponse;\n                Some((\n                    begin_handshake_request_cookie,\n                    Some(Bson::Document(doc! {\n                        \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                    })),\n                    ErrorCode::Success,\n                ))\n            }\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":95,"address":[1522464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1522617,1522874,1522497,1522747,1522812,1522682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1523024,1523518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[1523056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1523113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[1523144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[1524760,1523552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[1523603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[1523915,1523753],"length":1,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[1524298,1523950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[1524066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1524186,1524398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1524481,1524680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1526221,1525457,1524978,1525843,1526418,1525135,1524831,1526024],"length":1,"stats":{"Line":12},"fn_name":null},{"line":139,"address":[1524845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[1524862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[1524891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[1524920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[1524972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[1525576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[1525613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[1525795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[1525761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[1525665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[1525634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[1525652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[1526003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1526019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1526168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1526216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1526381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[1526413],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[1526612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[1526647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[1526668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[1526931,1526839],"length":1,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[1527042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[1526960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[1527024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[1527031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[1526702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1526684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1526690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1526696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1525103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1527339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[1527221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1525391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1527392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[1527756,1527445,1527575],"length":1,"stats":{"Line":6},"fn_name":null},{"line":226,"address":[1527460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[1527477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[1527500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1527523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[1527569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[1527891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[1527922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1527947],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[1527974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[1528081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[1528121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[1528130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[1528151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[1527637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1528192],"length":1,"stats":{"Line":2},"fn_name":"namespace"},{"line":256,"address":[1528224,1529374,1536448],"length":1,"stats":{"Line":2},"fn_name":"exec_function"},{"line":263,"address":[1528351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[1528499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[1528434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1532863,1528883,1532896,1532801,1528933,1528904,1528962,1532780,1532830,1528991],"length":1,"stats":{"Line":20},"fn_name":null},{"line":269,"address":[1528910,1528968,1528737,1532873,1528893,1532840,1532807,1528939,1532790],"length":1,"stats":{"Line":18},"fn_name":null},{"line":270,"address":[1528520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[1528537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[1528634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[1528665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[1528792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[1529009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[1529136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[1529123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[1529499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[1529581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[1529602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[1529784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[1530111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[1530151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[1529670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[1529709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[1530275,1530460,1530207],"length":1,"stats":{"Line":6},"fn_name":null},{"line":299,"address":[1530324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[1530555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[1530576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[1530658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[1530732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[1530868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[1530889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[1530977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[1531184,1531020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":320,"address":[1531309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[1529942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[1529963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[1532935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[1533325,1533163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":335,"address":[1533016],"length":1,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[1533542,1533610],"length":1,"stats":{"Line":4},"fn_name":null},{"line":338,"address":[1533628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[1533727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[1533748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1533825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[1533914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[1534077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[1534098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[1534175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[1534224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[1534387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[1534408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[1534495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[1534525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[1534630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1534651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[1534749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":375,"address":[1534757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[1534927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[1534801,1534884],"length":1,"stats":{"Line":4},"fn_name":null},{"line":382,"address":[1535290,1535058,1534936],"length":1,"stats":{"Line":5},"fn_name":null},{"line":383,"address":[1535068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":384,"address":[1535089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":386,"address":[1535110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[1535131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":389,"address":[1535152,1535190],"length":1,"stats":{"Line":4},"fn_name":null},{"line":391,"address":[1534961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[1534982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[1535003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[1533249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[1533270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[1532702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1532723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[1537263,1536464],"length":1,"stats":{"Line":2},"fn_name":"next_result"},{"line":408,"address":[1536627,1536562],"length":1,"stats":{"Line":4},"fn_name":null},{"line":409,"address":[1536502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[1536517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[1536534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[1536675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":418,"address":[1536693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[1537171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":421,"address":[1536990,1536708,1536762],"length":1,"stats":{"Line":4},"fn_name":null},{"line":422,"address":[1536806,1536730],"length":1,"stats":{"Line":4},"fn_name":null},{"line":424,"address":[1537160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[1536609],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":113,"coverable":148},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","gosling.rs"],"content":"// standard\n#[cfg(test)]\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// extern crates\n#[cfg(test)]\nuse bson::doc;\nuse data_encoding::HEXLOWER;\n#[cfg(test)]\nuse honk_rpc::honk_rpc::Session;\nuse num_enum::TryFromPrimitive;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::context;\nuse crate::endpoint_client;\n#[cfg(test)]\nuse crate::endpoint_client::*;\nuse crate::endpoint_server;\n#[cfg(test)]\nuse crate::endpoint_server::*;\nuse crate::identity_client;\n#[cfg(test)]\nuse crate::identity_client::*;\nuse crate::identity_server;\n#[cfg(test)]\nuse crate::identity_server::*;\n\n#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]\n#[repr(i32)]\n/// cbindgen:ignore\npub enum RpcError {\n    // bad gosling version\n    BadVersion,\n    // cookie required\n    RequestCookieRequired,\n    // invalid or missing arguments\n    InvalidArg,\n    // generic runtime error\n    Failure,\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"invalid argument: {0}\")]\n    InvalidArgument(String),\n\n    #[error(\n        \"context is not connected, must call bootstrap() and wait for TorBootstrapCompleted event\"\n    )]\n    TorNotConnected(),\n\n    #[error(\"handshake handle {0} not found\")]\n    HandshakeHandleNotFound(context::HandshakeHandle),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(transparent)]\n    Io(#[from] std::io::Error),\n\n    #[error(transparent)]\n    HonkRpc(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(transparent)]\n    TorCrypto(#[from] tor_interface::tor_crypto::Error),\n\n    #[error(transparent)]\n    TorProvider(#[from] tor_interface::tor_provider::Error),\n\n    #[error(transparent)]\n    IdentityClientError(#[from] identity_client::Error),\n\n    #[error(transparent)]\n    IdentityServerError(#[from] identity_server::Error),\n\n    #[error(transparent)]\n    EndpointClientError(#[from] endpoint_client::Error),\n\n    #[error(transparent)]\n    EndpointServerError(#[from] endpoint_server::Error),\n}\n\npub const GOSLING_CRATE_VERSION: \u0026str = std::env!(\"CARGO_PKG_VERSION\");\npub const GOSLING_PROTOCOL_VERSION: \u0026str = \"0.1.0\";\n\n\npub(crate) const CLIENT_COOKIE_SIZE: usize = 32usize;\npub(crate) const SERVER_COOKIE_SIZE: usize = 32usize;\n\npub(crate) type ClientCookie = [u8; CLIENT_COOKIE_SIZE];\npub(crate) type ServerCookie = [u8; SERVER_COOKIE_SIZE];\npub(crate) type ClientProof = Vec\u003cu8\u003e;\n\npub(crate) enum DomainSeparator {\n    GoslingIdentity,\n    GoslingEndpoint,\n}\n\nimpl From\u003cDomainSeparator\u003e for \u0026[u8] {\n    fn from(sep: DomainSeparator) -\u003e \u0026'static [u8] {\n        match sep {\n            DomainSeparator::GoslingIdentity =\u003e b\"gosling-identity\",\n            DomainSeparator::GoslingEndpoint =\u003e b\"gosling-endpoint\",\n        }\n    }\n}\n\npub(crate) fn build_client_proof(\n    domain_separator: DomainSeparator,\n    request: \u0026AsciiString,\n    client_service_id: \u0026V3OnionServiceId,\n    server_service_id: \u0026V3OnionServiceId,\n    client_cookie: \u0026ClientCookie,\n    server_cookie: \u0026ServerCookie,\n) -\u003e ClientProof {\n    let mut client_proof: ClientProof = Default::default();\n\n    client_proof.extend_from_slice(domain_separator.into());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(request.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(client_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(server_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(client_cookie).as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(server_cookie).as_bytes());\n\n    client_proof\n}\n\n//\n// Tests\n//\n\n#[cfg(test)]\nfn identity_test(\n    client_blocked: bool,\n    client_requested_endpoint: \u0026str,\n    client_requested_endpoint_valid: bool,\n    server_challenge: bson::document::Document,\n    client_response: bson::document::Document,\n    server_expected_response: bson::document::Document,\n    should_fail: bool,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // test sockets\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    // client setup\n    let client_ed25519_private = Ed25519PrivateKey::generate();\n\n    // server setup\n    let server_ed25519_private = Ed25519PrivateKey::generate();\n    let server_ed25519_public = Ed25519PublicKey::from_private_key(\u0026server_ed25519_private);\n    let server_service_id = V3OnionServiceId::from_public_key(\u0026server_ed25519_public);\n\n    let client_requested_endpoint = match AsciiString::new(client_requested_endpoint.to_string()) {\n        Ok(ascii) =\u003e ascii,\n        Err(_) =\u003e {\n            assert!(should_fail);\n            return Ok(());\n        }\n    };\n\n    // rpc setup\n    let client_rpc = Session::new(stream1);\n    let mut ident_client = IdentityClient::new(\n        client_rpc,\n        server_service_id.clone(),\n        client_requested_endpoint.clone(),\n        client_ed25519_private,\n        X25519PrivateKey::generate(),\n    )\n    .unwrap();\n\n    let server_rpc = Session::new(stream2);\n    let mut ident_server = IdentityServer::new(server_rpc, server_service_id.clone());\n\n    let mut failure_ocurred = false;\n    let mut server_complete = false;\n    let mut client_complete = false;\n    while !server_complete \u0026\u0026 !client_complete {\n        if !server_complete {\n            match ident_server.update() {\n                Ok(Some(IdentityServerEvent::EndpointRequestReceived {\n                    client_service_id,\n                    requested_endpoint,\n                })) =\u003e {\n                    println!(\n                        \"server challenge send: client_service_id {}, requested_endpoint: {}\",\n                        client_service_id.to_string(),\n                        requested_endpoint\n                    );\n                    let client_allowed = !client_blocked;\n                    ident_server.handle_endpoint_request_received(\n                        client_allowed,\n                        client_requested_endpoint_valid,\n                        server_challenge.clone(),\n                    )?;\n                }\n                Ok(Some(IdentityServerEvent::ChallengeResponseReceived { challenge_response })) =\u003e {\n                    println!(\"server challenge repsonse received\");\n                    ident_server.handle_challenge_response_received(\n                        challenge_response == server_expected_response,\n                    )?;\n                }\n                Ok(Some(IdentityServerEvent::HandshakeCompleted {\n                    endpoint_private_key: _,\n                    endpoint_name,\n                    client_service_id,\n                    client_auth_public_key: _,\n                })) =\u003e {\n                    assert!(endpoint_name == client_requested_endpoint);\n                    println!(\n                        \"server complete! client_service_id : {}\",\n                        client_service_id.to_string()\n                    );\n                    server_complete = true;\n                }\n                Ok(Some(IdentityServerEvent::HandshakeRejected {\n                    client_allowed,\n                    client_requested_endpoint_valid,\n                    client_proof_signature_valid,\n                    client_auth_signature_valid,\n                    challenge_response_valid,\n                })) =\u003e {\n                    println!(\"server complete! client request rejected\");\n                    println!(\" client_allowed: {}\", client_allowed);\n                    println!(\n                        \" client_requested_endpoint_valid: {}\",\n                        client_requested_endpoint_valid\n                    );\n                    println!(\n                        \" client_proof_signature_valid: {}\",\n                        client_proof_signature_valid\n                    );\n                    println!(\n                        \" client_auth_signature_valid: {}\",\n                        client_auth_signature_valid\n                    );\n                    println!(\" client_response_valid: {}\", challenge_response_valid);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"server failure: {:?}\", err);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n\n        if !client_complete {\n            match ident_client.update() {\n                Ok(Some(IdentityClientEvent::ChallengeReceived { endpoint_challenge })) =\u003e {\n                    println!(\n                        \"client challenge request received: endpoint_challenge: {}\",\n                        endpoint_challenge\n                    );\n                    ident_client.send_response(client_response.clone())?;\n                }\n                Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                    identity_service_id,\n                    endpoint_service_id,\n                    endpoint_name,\n                    client_auth_private_key: _,\n                })) =\u003e {\n                    assert!(identity_service_id == server_service_id);\n                    assert!(endpoint_name == client_requested_endpoint.clone().to_string());\n                    println!(\n                        \"client complete! endpoint_server : {}\",\n                        endpoint_service_id.to_string()\n                    );\n                    client_complete = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"client failure: {:?}\", err);\n                    client_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n    }\n\n    assert!(failure_ocurred == should_fail);\n    Ok(())\n}\n\n#[test]\nfn test_identity_handshake() -\u003e anyhow::Result\u003c()\u003e {\n    println!(\"Sucessful ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = false;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Bad Endpoint ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = false;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Bad Challenge Response ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Friend?\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Blocked Client ---\");\n    {\n        let client_blocked: bool = true;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Non-ASCII endpoint ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nfn endpoint_test(\n    should_fail: bool,\n    client_allowed: bool,\n    channel: \u0026str,\n    channel_allowed: bool,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // test sockets\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    // server+client setup\n    let server_ed25519_private = Ed25519PrivateKey::generate();\n    let server_ed25519_public = Ed25519PublicKey::from_private_key(\u0026server_ed25519_private);\n    let server_service_id = V3OnionServiceId::from_public_key(\u0026server_ed25519_public);\n\n    let client_ed25519_private = Ed25519PrivateKey::generate();\n    let client_ed25519_public = Ed25519PublicKey::from_private_key(\u0026client_ed25519_private);\n    let client_service_id = V3OnionServiceId::from_public_key(\u0026client_ed25519_public);\n\n    // ensure our client is in the allow list\n    let allowed_client = if client_allowed {\n        client_service_id.clone()\n    } else {\n        let ed25519_private = Ed25519PrivateKey::generate();\n        let ed25519_public = Ed25519PublicKey::from_private_key(\u0026ed25519_private);\n        V3OnionServiceId::from_public_key(\u0026ed25519_public)\n    };\n\n    let server_rpc = Session::new(stream1);\n\n    let mut endpoint_server = EndpointServer::new(\n        server_rpc,\n        allowed_client.clone(),\n        server_service_id.clone(),\n    );\n\n    let client_rpc = Session::new(stream2);\n\n    let channel = match AsciiString::new(channel.to_string()) {\n        Ok(channel) =\u003e channel,\n        Err(_) =\u003e {\n            assert!(should_fail);\n            return Ok(());\n        }\n    };\n\n    let mut endpoint_client = EndpointClient::new(\n        client_rpc,\n        server_service_id.clone(),\n        channel.clone(),\n        client_ed25519_private,\n    );\n\n    let mut failure_ocurred = false;\n    let mut server_complete = false;\n    let mut client_complete = false;\n    while !server_complete \u0026\u0026 !client_complete {\n        if !server_complete {\n            match endpoint_server.update() {\n                Ok(Some(EndpointServerEvent::ChannelRequestReceived {\n                    client_service_id: ret_client_service_id,\n                    requested_channel,\n                })) =\u003e {\n                    assert_eq!(ret_client_service_id, client_service_id);\n                    assert!(requested_channel == channel);\n                    endpoint_server.handle_channel_request_received(channel_allowed)?;\n                }\n                Ok(Some(EndpointServerEvent::HandshakeCompleted {\n                    client_service_id: ret_client_service_id,\n                    channel_name: ret_channel,\n                    stream: _,\n                })) =\u003e {\n                    assert!(ret_client_service_id == client_service_id);\n                    assert!(ret_channel == channel);\n                    server_complete = true;\n                }\n                Ok(Some(EndpointServerEvent::HandshakeRejected {\n                    client_allowed,\n                    client_requested_channel_valid,\n                    client_proof_signature_valid,\n                })) =\u003e {\n                    println!(\"handshake rejected: client_allowed: {}, client_requested_channel_valid: {}, client_proof_signature_valid: {}\", client_allowed, client_requested_channel_valid, client_proof_signature_valid);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"server failure: {:?}\", err);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n\n        if !client_complete {\n            match endpoint_client.update() {\n                Ok(Some(EndpointClientEvent::HandshakeCompleted { stream: _ })) =\u003e {\n                    client_complete = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"client failure: {:?}\", err);\n                    client_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n    }\n\n    println!(\"server_complete: {}\", server_complete);\n    println!(\"client_complete: {}\", client_complete);\n\n    assert!(should_fail == failure_ocurred);\n\n    Ok(())\n}\n\n#[test]\nfn test_endpoint_handshake() -\u003e anyhow::Result\u003c()\u003e {\n    println!(\"Success ---\");\n    {\n        let should_fail = false;\n        let client_allowed = true;\n        let channel = \"channel\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Client Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = false;\n        let channel = \"channel\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Channel Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = true;\n        let channel = \"channel\";\n        let channel_allowed = false;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Client and Channel Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = false;\n        let channel = \"channel\";\n        let channel_allowed = false;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Non-Ascii Channel ---\");\n    {\n        let should_fail = true;\n        let client_allowed = true;\n        let channel = \"\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n\n    Ok(())\n}\n","traces":[{"line":102,"address":[1627232],"length":1,"stats":{"Line":2},"fn_name":"from"},{"line":103,"address":[1627241,1627300],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[1160968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[1160991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[1161024,1162278],"length":1,"stats":{"Line":2},"fn_name":"build_client_proof"},{"line":118,"address":[1161134],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1627446,1627546],"length":1,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[1627565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1627591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[1627658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[1627684],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[1627820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[1627846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[1627982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[1628008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[1628247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[1628276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[1628531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[1162304,1167076,1172816],"length":1,"stats":{"Line":1},"fn_name":"identity_test"},{"line":150,"address":[1162465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1162696,1165710,1162839,1172768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1162924,1172731,1162812,1163068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[1163009,1163109,1172694,1163210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[1163178,1163300,1163391,1172625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[1172607,1163364,1163604,1163448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[1163694,1172526,1163572,1163777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[1163758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1163818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1163886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1163954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1164005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[1164046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[1164162,1172308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1172341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1164175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1164292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[1164346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[1164410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1164425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[1164471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1164928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1164998,1172228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[1165144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1165152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1165160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[1165168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1169055,1165218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[1165306,1165641,1165244],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[1165712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1166314,1166501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1165808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1166627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1166905,1167009,1166674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1166653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1165838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1165934,1167129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[1167406,1167185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1167164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1165996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1167675,1166076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[1167821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1167711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1167976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1166149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1166163,1168002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[1168116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[1168287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[1168446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1168605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1168764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1168840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[1168848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[1165401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1168917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1168993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[1169001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[1171639,1165251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[1169357,1169693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[1169732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[1170150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1162418,1170360,1170242,1170570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[1169906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1170866,1170082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1170921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1171272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1171170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[1171421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1169459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[1171501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[1171577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1171585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1171915,1165195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[1171948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[1179889,1172832,1174678],"length":1,"stats":{"Line":1},"fn_name":"endpoint_test"},{"line":409,"address":[1172945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[1173274,1173106,1176105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[1173359,1173503,1179879,1173247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[1173444,1179842,1173645,1173544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[1173613,1173735,1179773,1173826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[1179755,1174039,1173883,1173799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[1179674,1174212,1174129,1174007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[1174193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[1174253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[1174324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[1174351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[1174370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[1174446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[1174480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[1174521,1174687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[1174486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[1174531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[1174602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[1174648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[1174689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[1174743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[1174807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[1174869,1174955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[1174971,1175032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[1175050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[1175166,1179365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[1179398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[1175179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[1175241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[1175357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[1175364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[1175473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[1175481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[1175489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[1175497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[1178027,1175601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[1175693,1175627,1176028],"length":1,"stats":{"Line":3},"fn_name":null},{"line":467,"address":[1176107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1176211,1176599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[1176687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[1172896,1176852,1176747,1177062],"length":1,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[1176364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[1176412,1177350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":481,"address":[1177405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[1177459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[1176429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1177704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[1177812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[1177820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[1175788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[1177889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[1177965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[1177973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[1175634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[1178329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[1178644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[1178636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[1178405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[1178696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[1178772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[1178780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[1178921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[1179078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[1179161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[1179209],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":140,"coverable":159},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","identity_client.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{\n    get_message_overhead, get_request_section_size, RequestCookie, Response, Session,\n};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Identity Client\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to convert x25519 private key to ed25519 private key\")]\n    ClientCreationFailed(#[source] tor_interface::tor_crypto::Error),\n\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"client received unexpected response: {0}\")]\n    UnexpectedResponseReceived(String),\n\n    #[error(\"client is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"provided endpoint challenge response too large; encoded size would be {0} but session's maximum honk-rpc message size is {1}\")]\n    EndpointChallengeResponseTooLarge(usize, usize),\n}\n\npub(crate) enum IdentityClientEvent {\n    ChallengeReceived {\n        endpoint_challenge: bson::document::Document,\n    },\n    HandshakeCompleted {\n        identity_service_id: V3OnionServiceId,\n        endpoint_service_id: V3OnionServiceId,\n        endpoint_name: String,\n        client_auth_private_key: X25519PrivateKey,\n    },\n}\n\n#[derive(Debug, PartialEq)]\npub(crate) enum IdentityClientState {\n    BeginHandshake,\n    WaitingForChallenge,\n    WaitingForChallengeResponse,\n    WaitingForChallengeVerification,\n    HandshakeComplete,\n}\n\n//\n// An identity client object used for connecting\n// to an identity server\n//\npub(crate) struct IdentityClient {\n    // session data\n    rpc: Session\u003cTcpStream\u003e,\n    server_service_id: V3OnionServiceId,\n    requested_endpoint: AsciiString,\n    client_service_id: V3OnionServiceId,\n    client_identity_ed25519_private: Ed25519PrivateKey,\n    client_authorization_key_private: X25519PrivateKey,\n    client_authorization_signing_key_private: (Ed25519PrivateKey, SignBit),\n\n    // state machine data\n    state: IdentityClientState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    endpoint_challenge_response: Option\u003cbson::document::Document\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n}\n\nimpl IdentityClient {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?},  begin_handshake_request_cookie: {:?},  server_cookie: {:?}, endpoint_challenge_response: {:?},  send_response_request_cookie: {:?} }}\", self.state,  self.begin_handshake_request_cookie, self.server_cookie, self.endpoint_challenge_response, self.send_response_request_cookie)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        server_service_id: V3OnionServiceId,\n        requested_endpoint: AsciiString,\n        client_identity_ed25519_private: Ed25519PrivateKey,\n        client_authorization_key_private: X25519PrivateKey,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(Self {\n            rpc,\n            server_service_id,\n            requested_endpoint,\n            client_service_id: V3OnionServiceId::from_private_key(\u0026client_identity_ed25519_private),\n            client_identity_ed25519_private,\n            client_authorization_signing_key_private: Ed25519PrivateKey::from_private_x25519(\n                \u0026client_authorization_key_private,\n            )\n            .map_err(Error::ClientCreationFailed)?,\n            client_authorization_key_private,\n\n            state: IdentityClientState::BeginHandshake,\n            begin_handshake_request_cookie: None,\n            server_cookie: None,\n            send_response_request_cookie: None,\n            endpoint_challenge_response: None,\n        })\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cIdentityClientEvent\u003e, Error\u003e {\n        if self.state == IdentityClientState::HandshakeComplete {\n            return Err(Error::IncorrectUsage(\"update() may not be called after HandshakeComplete has been returned from previous update() call\".to_string()));\n        }\n\n        // update our rpc session\n        self.rpc.update(None)?;\n\n        // client state machine\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie,\n            self.endpoint_challenge_response.take(),\n            self.send_response_request_cookie,\n        ) {\n            // send initial handshake request\n            (\n                \u0026IdentityClientState::BeginHandshake,\n                None, // begin_handshake_request_cookie\n                None, // server_cookie\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                self.begin_handshake_request_cookie = Some(self.rpc.client_call(\n                    \"gosling_identity\",\n                    \"begin_handshake\",\n                    0,\n                    doc! {\n                        \"version\" : bson::Bson::String(GOSLING_PROTOCOL_VERSION.to_string()),\n                        \"client_identity\" : bson::Bson::String(self.client_service_id.to_string()),\n                        \"endpoint\" : bson::Bson::String(self.requested_endpoint.clone().to_string()),\n                    },\n                )?);\n                self.state = IdentityClientState::WaitingForChallenge;\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallenge,\n                Some(begin_handshake_request_cookie),\n                None, // server_cookie\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                if let Some(response) = self.rpc.client_next_response() {\n                    // check for response for the begin_handshake() call\n                    let mut response = match response {\n                        Response::Pending { cookie } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected pending response\".to_string(),\n                                ));\n                            }\n                            return Ok(None);\n                        }\n                        Response::Error { cookie, error_code } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected error response; rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"received unexpected rpc error_code: {}\",\n                                error_code\n                            )));\n                        }\n                        Response::Success { cookie, result } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected success response\".to_string(),\n                                ));\n                            }\n                            match result {\n                                Bson::Document(result) =\u003e result,\n                                _ =\u003e {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"begin_handshake() response is unexpected bson type\"\n                                            .to_string(),\n                                    ))\n                                }\n                            }\n                        }\n                    };\n\n                    // save off the server cookie\n                    self.server_cookie = match response.get(\"server_cookie\") {\n                        Some(Bson::Binary(Binary {\n                            subtype: BinarySubtype::Generic,\n                            bytes: server_cookie,\n                        })) =\u003e match server_cookie.clone().try_into() {\n                            Ok(server_cookie) =\u003e Some(server_cookie),\n                            Err(_) =\u003e {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"unable to convert '{:?}' to server cookie\",\n                                    server_cookie\n                                )))\n                            }\n                        },\n                        Some(_) =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"server_cookie is unxpected bson type\".to_string(),\n                            ))\n                        }\n                        None =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"missing server_cookie\".to_string(),\n                            ))\n                        }\n                    };\n\n                    // get the endpoint challenge\n                    let endpoint_challenge = match response.get_mut(\"endpoint_challenge\") {\n                        Some(Bson::Document(endpoint_challenge)) =\u003e {\n                            std::mem::take(endpoint_challenge)\n                        }\n                        Some(_) =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"endpoint challenge is unexpected bson type\".to_string(),\n                            ))\n                        }\n                        None =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"missing endpoint_challenge\".to_string(),\n                            ))\n                        }\n                    };\n\n                    self.state = IdentityClientState::WaitingForChallengeResponse;\n                    return Ok(Some(IdentityClientEvent::ChallengeReceived {\n                        endpoint_challenge,\n                    }));\n                }\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(_server_cookie),\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                // no-op, waiting for response for challenge response from caller\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(server_cookie),\n                Some(endpoint_challenge_response),\n                None,\n            ) =\u003e {\n                // client_cookie\n                let mut client_cookie: ClientCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut client_cookie);\n                let client_cookie = client_cookie;\n\n                // client_identity_proof_signature\n                let client_identity_proof = build_client_proof(\n                    DomainSeparator::GoslingIdentity,\n                    \u0026self.requested_endpoint,\n                    \u0026self.client_service_id,\n                    \u0026self.server_service_id,\n                    \u0026client_cookie,\n                    \u0026server_cookie,\n                );\n                let client_identity_proof_signature = self\n                    .client_identity_ed25519_private\n                    .sign_message(\u0026client_identity_proof);\n\n                // client_authorization_key\n                let client_authorization_key =\n                    X25519PublicKey::from_private_key(\u0026self.client_authorization_key_private);\n\n                // client_authorization_signature\n                let client_identity = self.client_service_id.to_string();\n                let (client_authorization_signature, signbit) = (\n                    self.client_authorization_signing_key_private\n                        .0\n                        .sign_message(client_identity.as_bytes()),\n                    self.client_authorization_signing_key_private.1,\n                );\n\n                // build our args object for rpc call\n                let args = doc! {\n                    \"client_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_cookie.to_vec()}),\n                    \"client_identity_proof_signature\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}),\n                    \"client_authorization_key\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}),\n                    \"client_authorization_key_signbit\" : bson::Bson::Boolean(signbit.into()),\n                    \"client_authorization_signature\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_signature.to_bytes().to_vec()}),\n                    \"challenge_response\" : endpoint_challenge_response,\n                };\n\n                // make rpc call\n                self.send_response_request_cookie =\n                    Some(\n                        self.rpc\n                            .client_call(\"gosling_identity\", \"send_response\", 0, args)?,\n                    );\n                self.state = IdentityClientState::WaitingForChallengeVerification;\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeVerification,\n                Some(_begin_handshake_request_cookie),\n                Some(_server_cookie),\n                None, // endpoint_challenge_response\n                Some(send_response_request_cookie),\n            ) =\u003e {\n                if let Some(response) = self.rpc.client_next_response() {\n                    let endpoint_service_id = match response {\n                        Response::Pending { cookie } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                return Ok(None);\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpectd pending response\".to_string(),\n                                ));\n                            }\n                        }\n                        Response::Error { cookie, error_code } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected error response; rpc error_code: {}\",\n                                    error_code\n                                )));\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                        }\n                        Response::Success { cookie, result } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                match result {\n                                    Bson::String(endpoint_service_id) =\u003e {\n                                        match V3OnionServiceId::from_string(\u0026endpoint_service_id) {\n                                            Ok(endpoint_service_id) =\u003e endpoint_service_id,\n                                            Err(_) =\u003e return Err(Error::UnexpectedResponseReceived(format!(\"unable to parse received endpoint service id '{}' as v3 onion service id\", endpoint_service_id))),\n                                        }\n                                    }\n                                    _ =\u003e {\n                                        return Err(Error::UnexpectedResponseReceived(\n                                            \"endpoint service id is unexpected bson type\".to_string(),\n                                        ))\n                                    }\n                                }\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected success response\".to_string(),\n                                ));\n                            }\n                        }\n                    };\n                    self.state = IdentityClientState::HandshakeComplete;\n                    return Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                        identity_service_id: self.server_service_id.clone(),\n                        endpoint_service_id,\n                        endpoint_name: self.requested_endpoint.clone().to_string(),\n                        client_auth_private_key: self.client_authorization_key_private.clone(),\n                    }));\n                }\n            }\n            _ =\u003e {\n                return Err(Error::InvalidState(self.get_state()));\n            }\n        }\n        Ok(None)\n    }\n\n    pub fn send_response(\n        \u0026mut self,\n        challenge_response: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie,\n            self.endpoint_challenge_response.as_ref(),\n            self.send_response_request_cookie,\n        ) {\n            (\u0026IdentityClientState::WaitingForChallengeResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_server_cookie),\n             None, // endpoint_challenge_response\n             None  // end_response_request_cookie\n            ) =\u003e {\n                // calculate required size of request message and ensure it fits our\n                // specified message size budget\n                let arguments = doc!{\n                    \"client_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; CLIENT_COOKIE_SIZE].to_vec()}),\n                    \"client_identity_proof_signature\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; ED25519_SIGNATURE_SIZE].to_vec()}),\n                    \"client_authorization_key\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; X25519_PUBLIC_KEY_SIZE].to_vec()}),\n                    \"client_authorization_key_signbit\" : Bson::Boolean(false),\n                    \"client_authorization_signature\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; ED25519_SIGNATURE_SIZE].to_vec()}),\n                    \"challenge_response\" : challenge_response.clone(),\n                };\n                let request_section_size = get_request_section_size(Some(0i64), Some(\"gosling_identity\".to_string()), \"send_response\".to_string(), Some(0i32), Some(arguments))?;\n                let message_size = get_message_overhead()? + request_section_size;\n                let max_message_size = self.rpc.get_max_message_size();\n                if message_size \u003e max_message_size {\n                    Err(Error::EndpointChallengeResponseTooLarge(message_size, max_message_size))\n                } else {\n                    self.endpoint_challenge_response = Some(challenge_response);\n                    Ok(())\n                }\n            }\n            _ =\u003e Err(Error::IncorrectUsage(\"send_response() may only be called after ChallengeReceived event has been returned from update(), and it may only be called once\".to_string()))\n        }\n    }\n}\n","traces":[{"line":90,"address":[1709328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1709487,1709552,1709672,1709617,1709357,1709422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1711199,1711156,1709808],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[1709844,1710319],"length":1,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[1709896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[1709908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[1709931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1709999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1710851,1710033,1710093],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[1710739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1710206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[1710261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[1710269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1710281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[1710289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1710301],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[1723976,1711232,1713612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1711312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[1711475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1711367,1712029,1714010,1711304],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[1712115,1711790,1717275,1713621,1720575],"length":1,"stats":{"Line":10},"fn_name":null},{"line":131,"address":[1711630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[1711647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[1711677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[1711720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1711776],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[1713358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[1713483,1713136,1713566],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[1712251,1712496,1712363,1712947,1712688,1712811],"length":1,"stats":{"Line":8},"fn_name":null},{"line":150,"address":[1712404,1712336],"length":1,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[1712570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[1712762,1712855],"length":1,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[1713337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[1713705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[1713729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[1713915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[1714020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[1714036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[1714280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[1714245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1714204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[1714138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1714182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1717075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[1716859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1714050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[1714116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1716564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1714439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1714394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[1714469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[1716425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[1714567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[1714707,1714597,1714962,1714771,1715285],"length":1,"stats":{"Line":10},"fn_name":null},{"line":209,"address":[1715010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[1715030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[1715102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[1715994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[1716259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[1714980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1714831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1714744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[1715439,1715328],"length":1,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[1715609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[1715629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[1715820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[1715648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[1715495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[1715412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[1715686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[1715707],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[1717380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1717465],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[1717577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[1717637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[1717677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[1717709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[1717717],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[1717727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[1717737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[1717797,1717914],"length":1,"stats":{"Line":4},"fn_name":null},{"line":286,"address":[1717811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[1717941],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[1717975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[1718155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[1718009,1718122],"length":1,"stats":{"Line":4},"fn_name":null},{"line":297,"address":[1718031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[1718149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[1719232,1718311,1719396,1718598,1718370,1719713,1719883,1718915],"length":1,"stats":{"Line":14},"fn_name":null},{"line":303,"address":[1718414,1718330],"length":1,"stats":{"Line":4},"fn_name":null},{"line":304,"address":[1718664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":305,"address":[1718981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[1719305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[1719462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[1719779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[1720251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[1720231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[1720444,1720080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[1720332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[1720281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[1720675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[1720728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[1720914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[1721008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[1721024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[1721215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[1721264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[1721180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[1721122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[1721166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[1723585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[1723375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[1721038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[1721103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[1721405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[1721691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[1721840,1721739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[1721877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[1722690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[1722976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[1721756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1721533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[1721378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[1722113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[1722347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[1722134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[1722183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[1722284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[1723809,1712105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[1713525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":388,"address":[1727671,1727812,1724016],"length":1,"stats":{"Line":2},"fn_name":null},{"line":392,"address":[1724435,1724293,1724071],"length":1,"stats":{"Line":6},"fn_name":null},{"line":393,"address":[1724103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[1724118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[1724142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[1724185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":397,"address":[1724269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[1724509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[1725523,1724541,1725898,1724827,1725116,1724599,1725405,1725812],"length":1,"stats":{"Line":14},"fn_name":null},{"line":408,"address":[1724560,1724643],"length":1,"stats":{"Line":4},"fn_name":null},{"line":409,"address":[1724893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[1725182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[1725471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[1725589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[1725891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[1726187,1726723,1727634,1727649,1726095],"length":1,"stats":{"Line":4},"fn_name":null},{"line":416,"address":[1727151,1726864,1727611,1726696],"length":1,"stats":{"Line":4},"fn_name":null},{"line":417,"address":[1727135,1727193],"length":1,"stats":{"Line":4},"fn_name":null},{"line":418,"address":[1727201,1727480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[1727428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[1727487,1727220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[1727574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":425,"address":[1724405,1727707],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":114,"coverable":153},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","identity_server.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{\n    get_message_overhead, get_response_section_size, ApiSet, ErrorCode, RequestCookie, Session,\n};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Identity Server\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"server is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"client sent invalid request\")]\n    BadClient,\n\n    #[error(\"provided endpoint challenge too large; encoded size would be {0} but session's maximum honk-rpc message size is {1}\")]\n    EndpointChallengeTooLarge(usize, usize),\n}\n\npub(crate) enum IdentityServerEvent {\n    EndpointRequestReceived {\n        client_service_id: V3OnionServiceId,\n        requested_endpoint: AsciiString,\n    },\n\n    ChallengeResponseReceived {\n        challenge_response: bson::document::Document,\n    },\n\n    HandshakeCompleted {\n        endpoint_private_key: Ed25519PrivateKey,\n        endpoint_name: AsciiString,\n        client_service_id: V3OnionServiceId,\n        client_auth_public_key: X25519PublicKey,\n    },\n\n    HandshakeRejected {\n        // Client not on the block-list\n        client_allowed: bool,\n        // The requested endpoint is valid\n        client_requested_endpoint_valid: bool,\n        // The client proof is valid and signed with client's public key\n        client_proof_signature_valid: bool,\n        // The client authorization signature is valid\n        client_auth_signature_valid: bool,\n        // The challenge response is valid\n        challenge_response_valid: bool,\n    },\n}\n\n#[derive(Debug, PartialEq)]\nenum IdentityServerState {\n    // valid/expected states\n    WaitingForBeginHandshake,\n    GettingChallenge,\n    ChallengeReady,\n    WaitingForSendResponse,\n    GettingChallengeVerification,\n    ChallengeVerificationReady,\n    ChallengeVerificationResponseSent,\n    HandshakeComplete,\n    // failure state\n    HandshakeFailed,\n}\n\npub(crate) struct IdentityServer {\n    // Session Data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    server_identity: V3OnionServiceId,\n\n    // State Machine Data\n    state: IdentityServerState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    client_identity: Option\u003cV3OnionServiceId\u003e,\n    requested_endpoint: Option\u003cAsciiString\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    endpoint_challenge: Option\u003cbson::document::Document\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n    client_auth_key: Option\u003cX25519PublicKey\u003e,\n    challenge_response: Option\u003cbson::document::Document\u003e,\n    endpoint_private_key: Option\u003cEd25519PrivateKey\u003e,\n\n    // Verification flags\n\n    // Client not on the block-list\n    client_allowed: bool,\n    // The requested endpoint is valid\n    client_requested_endpoint_valid: bool,\n    // The client proof is valid and signed with client's public key\n    client_proof_signature_valid: bool,\n    // The client authorization signature is valid\n    client_auth_signature_valid: bool,\n    // The challenge response is valid\n    challenge_response_valid: bool,\n}\n\nimpl IdentityServer {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, client_identity: {:?}, requested_endpoint: {:?}, server_cookie: {:?}, endpoint_challenge: {:?}, send_response_request_cookie: {:?}, client_auth_key: {:?}, challenge_response: {:?}, endpoint_private_key: {:?} }}\", self.state, self.begin_handshake_request_cookie, self.client_identity, self.requested_endpoint, self.server_cookie, self.endpoint_challenge, self.send_response_request_cookie, self.client_auth_key, self.challenge_response, self.endpoint_private_key)\n    }\n\n    pub fn new(rpc: Session\u003cTcpStream\u003e, server_identity: V3OnionServiceId) -\u003e Self {\n        IdentityServer {\n            // Session Data\n            rpc: Some(rpc),\n            server_identity,\n\n            // State Machine Data\n            state: IdentityServerState::WaitingForBeginHandshake,\n            begin_handshake_request_cookie: None,\n            client_identity: None,\n            requested_endpoint: None,\n            server_cookie: None,\n            endpoint_challenge: None,\n            send_response_request_cookie: None,\n            client_auth_key: None,\n            challenge_response: None,\n            endpoint_private_key: None,\n\n            // Verification Flags\n            client_allowed: false,\n            client_requested_endpoint_valid: false,\n            client_proof_signature_valid: false,\n            client_auth_signature_valid: false,\n            challenge_response_valid: false,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cIdentityServerEvent\u003e, Error\u003e {\n        // need to remove ownership of the HonkRPC session from Self\n        // before being able to pass self into the session update method\n        if let Some(mut rpc) = std::mem::take(\u0026mut self.rpc) {\n            match rpc.update(Some(\u0026mut [self])) {\n                Ok(()) =\u003e {\n                    self.rpc = Some(rpc);\n                }\n                Err(err) =\u003e {\n                    self.rpc = Some(rpc);\n                    return Err(err.into());\n                }\n            }\n        }\n\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_endpoint.as_ref(),\n              self.server_cookie.as_ref(),\n              self.endpoint_challenge.as_ref(),\n              self.send_response_request_cookie,\n              self.client_auth_key.as_ref(),\n              self.challenge_response.as_mut(),\n              self.endpoint_private_key.as_ref()) {\n            (\u0026IdentityServerState::WaitingForBeginHandshake,\n             None, // begin_handshake_request_cookie\n             None, // client_identity\n             None, // requested_endpoint\n             None, // server_cookie\n             None, // endpoint_challenge\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                // no-op, waiting for client to connect and begin handshake\n            },\n            (\u0026IdentityServerState::WaitingForBeginHandshake,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_endpoint),\n             None, // server_cookie\n             None, // endpoint_challenge\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::GettingChallenge;\n                return Ok(Some(IdentityServerEvent::EndpointRequestReceived{client_service_id: client_identity.clone(), requested_endpoint: requested_endpoint.clone()}));\n            },\n            (\u0026IdentityServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                // no-op, waiting for client to send challenge response\n            },\n            (\u0026IdentityServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(_client_auth_key),\n             Some(challenge_response),\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::GettingChallengeVerification;\n                return Ok(Some(IdentityServerEvent::ChallengeResponseReceived{\n                    challenge_response: std::mem::take(challenge_response),\n                }));\n            },\n            (\u0026IdentityServerState::ChallengeVerificationResponseSent,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(client_auth_key),\n             Some(_challenge_response),\n             Some(endpoint_private_key))\n            =\u003e {\n                self.state = IdentityServerState::HandshakeComplete;\n                return Ok(Some(IdentityServerEvent::HandshakeCompleted{\n                    endpoint_private_key: endpoint_private_key.clone(),\n                    endpoint_name: requested_endpoint.clone(),\n                    client_service_id: client_identity.clone(),\n                    client_auth_public_key: client_auth_key.clone(),\n                }));\n            },\n            (\u0026IdentityServerState::ChallengeVerificationResponseSent,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(_client_auth_key),\n             Some(_challenge_response),\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::HandshakeComplete;\n                return Ok(Some(IdentityServerEvent::HandshakeRejected{\n                    client_allowed: self.client_allowed,\n                    client_requested_endpoint_valid: self.client_requested_endpoint_valid,\n                    client_proof_signature_valid: self.client_proof_signature_valid,\n                    client_auth_signature_valid: self.client_auth_signature_valid,\n                    challenge_response_valid: self.challenge_response_valid,\n                }));\n            },\n             _ =\u003e {\n                if self.state == IdentityServerState::HandshakeFailed {\n                    return Err(Error::BadClient);\n                } else {\n                    return Err(Error::InvalidState(self.get_state()));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    pub fn handle_endpoint_request_received(\n        \u0026mut self,\n        client_allowed: bool,\n        endpoint_valid: bool,\n        endpoint_challenge: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.rpc.as_ref(),\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            (\n                \u0026IdentityServerState::GettingChallenge,\n                Some(rpc),\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_endpoint_name),\n                None, // server_cookie\n                None, // endpoint_challenge\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                let mut server_cookie: ServerCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut server_cookie);\n\n                // calculate required size of response message and ensure if fits our\n                // specified message size budget\n                let result = doc!{\n                    \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                    \"endpoint_challenge\" : endpoint_challenge.clone(),\n                };\n                let response_section_size = get_response_section_size(Some(Bson::Document(result)))?;\n                let message_size = get_message_overhead()? + response_section_size;\n                let max_message_size = rpc.get_max_message_size();\n                if message_size \u003e max_message_size {\n                    Err(Error::EndpointChallengeTooLarge(message_size, max_message_size))\n                } else {\n                    self.server_cookie = Some(server_cookie);\n                    self.endpoint_challenge = Some(endpoint_challenge);\n                    self.client_allowed = client_allowed;\n                    self.client_requested_endpoint_valid = endpoint_valid;\n                    self.state = IdentityServerState::ChallengeReady;\n                    Ok(())\n                }\n            }\n            _ =\u003e {\n                Err(Error::IncorrectUsage(\"handle_endpoint_request_received() may only be called after EndpointRequestReceived has been returned from update(), and it may only be called once\".to_string()))\n            }\n        }\n    }\n\n    pub fn handle_challenge_response_received(\n        \u0026mut self,\n        challenge_response_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            (\n                \u0026IdentityServerState::GettingChallengeVerification,\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(_server_cookie),\n                Some(_endpoint_challenge),\n                Some(_client_auth_key),\n                Some(_challenge_response),\n                None,\n            ) =\u003e\n            // endpoint_private_key\n            {\n                self.challenge_response_valid = challenge_response_valid;\n                self.state = IdentityServerState::ChallengeVerificationReady;\n                Ok(())\n            }\n            _ =\u003e {\n                Err(Error::IncorrectUsage(\"handle_challenge_response_received() may only be called after ChallengeResponseReceived event has been returned from update(), and it may only be called once\".to_string()))\n            }\n        }\n    }\n}\n\nimpl ApiSet for IdentityServer {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"gosling_identity\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        let request_cookie = match request_cookie {\n            Some(request_cookie) =\u003e request_cookie,\n            None =\u003e return Err(ErrorCode::Runtime(RpcError::RequestCookieRequired as i32)),\n        };\n\n        match (\n            name,\n            version,\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            // handle begin_handshake call\n            (\n                \"begin_handshake\",\n                0,\n                \u0026IdentityServerState::WaitingForBeginHandshake,\n                None, // begin_handshake_request_cookie\n                None, // client_identity\n                None, // requested_endpoint\n                None, // server_cookie\n                None, // endpoint_challenge\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                let valid_version = match args.remove(\"version\") {\n                    Some(Bson::String(value)) =\u003e value == GOSLING_PROTOCOL_VERSION,\n                    _ =\u003e false,\n                };\n                if !valid_version {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    return Err(ErrorCode::Runtime(RpcError::BadVersion as i32));\n                }\n\n                if let (Some(Bson::String(client_identity)), Some(Bson::String(endpoint_name))) =\n                    (args.remove(\"client_identity\"), args.remove(\"endpoint\"))\n                {\n                    // client_identiity\n                    let client_identity = match V3OnionServiceId::from_string(\u0026client_identity) {\n                        Ok(client_identity) =\u003e client_identity,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // endpoint name\n                    let endpoint_name = match AsciiString::new(endpoint_name) {\n                        Ok(endpoint_name) =\u003e endpoint_name,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // save cookie\n                    self.begin_handshake_request_cookie = Some(request_cookie);\n\n                    // save results\n                    self.client_identity = Some(client_identity);\n                    self.requested_endpoint = Some(endpoint_name);\n                    Ok(None)\n                } else {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    Err(ErrorCode::Runtime(RpcError::InvalidArg as i32))\n                }\n            }\n            // handle send_response call\n            (\n                \"send_response\",\n                0,\n                \u0026IdentityServerState::WaitingForSendResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(client_identity),\n                Some(requested_endpoint),\n                Some(server_cookie),\n                Some(_endpoint_challenge),\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                // arg validation\n                if let (\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_cookie,\n                    })),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_identity_proof_signature,\n                    })),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_authorization_key,\n                    })),\n                    Some(Bson::Boolean(client_authorization_key_signbit)),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_authorization_signature,\n                    })),\n                    Some(Bson::Document(challenge_response)),\n                ) = (\n                    args.remove(\"client_cookie\"),\n                    args.remove(\"client_identity_proof_signature\"),\n                    args.remove(\"client_authorization_key\"),\n                    args.remove(\"client_authorization_key_signbit\"),\n                    args.remove(\"client_authorization_signature\"),\n                    args.remove(\"challenge_response\"),\n                ) {\n                    // client_cookie\n                    let client_cookie: ClientCookie = match client_cookie.try_into() {\n                        Ok(client_cookie) =\u003e client_cookie,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // client_identity_proof_signature\n                    let client_identity_proof_signature: [u8; ED25519_SIGNATURE_SIZE] =\n                        match client_identity_proof_signature.try_into() {\n                            Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n                    let client_identity_proof_signature =\n                        match Ed25519Signature::from_raw(\u0026client_identity_proof_signature) {\n                            Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n\n                    // client_authorization_key\n                    let client_authorization_key: [u8; X25519_PUBLIC_KEY_SIZE] =\n                        match client_authorization_key.try_into() {\n                            Ok(client_authorization_key) =\u003e client_authorization_key,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n                    let client_authorization_key =\n                        X25519PublicKey::from_raw(\u0026client_authorization_key);\n\n                    // client_authorization_key_signbit\n                    let client_authorization_key_signbit: SignBit =\n                        client_authorization_key_signbit.into();\n\n                    // client_authorization_signature\n                    let client_authorization_signature: [u8; ED25519_SIGNATURE_SIZE] =\n                        match client_authorization_signature.try_into() {\n                            Ok(client_authorization_signature) =\u003e client_authorization_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n                    let client_authorization_signature =\n                        match Ed25519Signature::from_raw(\u0026client_authorization_signature) {\n                            Ok(client_authorization_signature) =\u003e client_authorization_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n\n                    // save  cookie\n                    self.send_response_request_cookie = Some(request_cookie);\n\n                    // convert client_identity to client's public ed25519 key\n                    if let Ok(client_identity_key) =\n                        Ed25519PublicKey::from_service_id(client_identity)\n                    {\n                        // construct + verify client proof\n                        let client_proof = build_client_proof(\n                            DomainSeparator::GoslingIdentity,\n                            requested_endpoint,\n                            client_identity,\n                            \u0026self.server_identity,\n                            \u0026client_cookie,\n                            server_cookie,\n                        );\n                        self.client_proof_signature_valid = client_identity_proof_signature\n                            .verify(\u0026client_proof, \u0026client_identity_key);\n                    }\n\n                    // evaluate the client authorization signature\n                    self.client_auth_signature_valid = client_authorization_signature\n                        .verify_x25519(\n                            client_identity.as_bytes(),\n                            \u0026client_authorization_key,\n                            client_authorization_key_signbit,\n                        );\n\n                    // save off client auth key for future endpoint generation\n                    self.client_auth_key = Some(client_authorization_key);\n\n                    // safe off challenge response for verification\n                    self.challenge_response = Some(challenge_response);\n\n                    Ok(None)\n                } else {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    Err(ErrorCode::Runtime(RpcError::InvalidArg as i32))\n                }\n            }\n            _ =\u003e {\n                self.state = IdentityServerState::HandshakeFailed;\n                Err(ErrorCode::Runtime(RpcError::Failure as i32))\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_mut(),\n            self.send_response_request_cookie,\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n        ) {\n            // return challenge from begin_handshake\n            (\n                \u0026IdentityServerState::ChallengeReady,\n                Some(begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(server_cookie),\n                Some(endpoint_challenge),\n                None, // send_response_request_cookie\n                None, // client_auth_key\n                None,\n            ) =\u003e\n            // challenge_response\n            {\n                self.state = IdentityServerState::WaitingForSendResponse;\n                Some((\n                    begin_handshake_request_cookie,\n                    Some(Bson::Document(doc! {\n                        \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                        \"endpoint_challenge\" : std::mem::take(endpoint_challenge),\n                    })),\n                    ErrorCode::Success,\n                ))\n            }\n            (\u0026IdentityServerState::ChallengeReady, _, _, _, _, _, _, _, _) =\u003e unreachable!(),\n            (\n                \u0026IdentityServerState::ChallengeVerificationReady,\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(_server_cookie),\n                Some(_endpoint_challenge),\n                Some(send_response_request_cookie),\n                Some(_client_auth_key),\n                Some(_challenge_response),\n            ) =\u003e {\n                let mut success = true;\n                success \u0026= self.client_allowed;\n                success \u0026= self.client_requested_endpoint_valid;\n                success \u0026= self.client_proof_signature_valid;\n                success \u0026= self.client_auth_signature_valid;\n                success \u0026= self.challenge_response_valid;\n\n                self.state = IdentityServerState::ChallengeVerificationResponseSent;\n                if success {\n                    let endpoint_private_key = Ed25519PrivateKey::generate();\n                    let endpoint_service_id =\n                        V3OnionServiceId::from_private_key(\u0026endpoint_private_key);\n                    self.endpoint_private_key = Some(endpoint_private_key);\n                    Some((\n                        send_response_request_cookie,\n                        Some(Bson::String(endpoint_service_id.to_string())),\n                        ErrorCode::Success,\n                    ))\n                } else {\n                    Some((\n                        send_response_request_cookie,\n                        None,\n                        ErrorCode::Runtime(RpcError::Failure as i32),\n                    ))\n                }\n            }\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":121,"address":[1539040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[1539660,1539417,1539537,1539078,1539482,1539352,1539602,1539217,1539728,1539287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1539984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[1540006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[1540544,1541823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[1540603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[1540756,1540918],"length":1,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[1540953,1541319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[1541078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[1541198,1541425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[1541713,1541514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[1543925,1542738,1542156,1541894,1542360,1543217,1543583],"length":1,"stats":{"Line":14},"fn_name":null},{"line":168,"address":[1541904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[1541911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[1541940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1541969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[1541998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[1542027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[1542045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[1542074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[1542103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1542959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[1543012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[1543033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[1543514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[1543721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[1543785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1543820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[1543806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[1544639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[1544655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[1544838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[1544676],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[1544706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1544770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[1544831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[1544243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[1544307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[1544360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1544328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[1544335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[1544342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[1544348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[1544354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[1542328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1545221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1545078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1542697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[1545296,1548288,1548407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[1545754,1545382,1545918],"length":1,"stats":{"Line":6},"fn_name":null},{"line":291,"address":[1545398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[1545416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[1545488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[1545505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[1545533],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[1545561],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[1545589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[1545617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[1545645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[1545673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[1546169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[1546217],"length":1,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[1546236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[1546641,1546268,1546555,1546327],"length":1,"stats":{"Line":6},"fn_name":null},{"line":320,"address":[1546287,1546371],"length":1,"stats":{"Line":4},"fn_name":null},{"line":321,"address":[1546634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[1547193,1548267,1546830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[1547334,1547620,1547166,1548252],"length":1,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[1547661,1547605],"length":1,"stats":{"Line":4},"fn_name":null},{"line":326,"address":[1547669,1548065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[1548013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[1547688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[1548075,1547803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[1548182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[1548193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[1548202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[1548223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[1545888,1548302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[1548448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[1548929,1548717],"length":1,"stats":{"Line":4},"fn_name":null},{"line":348,"address":[1548502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[1548512],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[1548529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[1548552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[1548575],"length":1,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[1548598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[1548621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[1548644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[1548667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[1549251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[1549283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":372,"address":[1549292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[1549313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[1548810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[1549344],"length":1,"stats":{"Line":2},"fn_name":"namespace"},{"line":387,"address":[1550991,1549376,1562851],"length":1,"stats":{"Line":2},"fn_name":"exec_function"},{"line":394,"address":[1549524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[1549720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[1549655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[1550159,1550353,1554388],"length":1,"stats":{"Line":6},"fn_name":null},{"line":402,"address":[1549744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[1549761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[1549784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":405,"address":[1549881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":406,"address":[1549915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[1549949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[1549983],"length":1,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[1550014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[1550045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[1550262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[1550626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[1550753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[1550740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[1551116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[1551198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1551219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[1551287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[1551892,1551824],"length":1,"stats":{"Line":4},"fn_name":null},{"line":440,"address":[1551929],"length":1,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[1552028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1552049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[1552131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[1552205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":451,"address":[1552341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[1552362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[1552453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[1552496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[1552792,1552628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[1552917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":464,"address":[1551559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[1551580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[1554727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":483,"address":[1555588,1555426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[1556085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":490,"address":[1556125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":494,"address":[1556173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":496,"address":[1556221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":499,"address":[1556239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":501,"address":[1556287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":503,"address":[1554764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[1554803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":505,"address":[1554886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":506,"address":[1554966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[1555046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":508,"address":[1555126],"length":1,"stats":{"Line":2},"fn_name":null},{"line":511,"address":[1556467,1556399],"length":1,"stats":{"Line":4},"fn_name":null},{"line":512,"address":[1556485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":514,"address":[1556584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[1556605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[1556682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":522,"address":[1556771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":524,"address":[1556934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[1556955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[1557032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[1557081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[1557244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[1557265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[1557347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[1557432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[1557531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[1557552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[1557629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[1557660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[1557701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":556,"address":[1557790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":558,"address":[1557953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[1557974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[1558051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":564,"address":[1558100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[1558263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[1558284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[1558387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":575,"address":[1558450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":580,"address":[1558514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":583,"address":[1558522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":587,"address":[1558712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[1558632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":592,"address":[1558816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":594,"address":[1558791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":600,"address":[1558880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":603,"address":[1558995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":605,"address":[1559314],"length":1,"stats":{"Line":2},"fn_name":null},{"line":607,"address":[1555512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[1555533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[1554310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[1554331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[1564365,1562864],"length":1,"stats":{"Line":2},"fn_name":"next_result"},{"line":619,"address":[1562905,1563311,1564387,1563157,1563398],"length":1,"stats":{"Line":10},"fn_name":null},{"line":620,"address":[1562913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[1562923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":622,"address":[1562935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":623,"address":[1562961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":624,"address":[1562987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":625,"address":[1563013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":626,"address":[1563039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":627,"address":[1563063],"length":1,"stats":{"Line":2},"fn_name":null},{"line":628,"address":[1563092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":631,"address":[1563641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":644,"address":[1563662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":645,"address":[1564264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":647,"address":[1563683,1564055,1563737,1563965],"length":1,"stats":{"Line":6},"fn_name":null},{"line":648,"address":[1563705,1563781],"length":1,"stats":{"Line":4},"fn_name":null},{"line":649,"address":[1564036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":651,"address":[1564253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":655,"address":[1564621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":666,"address":[1564738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":667,"address":[1564746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":668,"address":[1564771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[1564796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":670,"address":[1564821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":671,"address":[1564846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":673,"address":[1564871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":674,"address":[1565036,1564892,1565557],"length":1,"stats":{"Line":5},"fn_name":null},{"line":675,"address":[1565041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":676,"address":[1565076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":678,"address":[1565136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":679,"address":[1565464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":681,"address":[1565329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":682,"address":[1565453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":685,"address":[1564951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[1564911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[1564929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[1563293],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":186,"coverable":223},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","lib.rs"],"content":"// some internal functions take a lot of args but thats ok\n#![allow(clippy::too_many_arguments)]\n\nmod ascii_string;\npub mod context;\npub mod endpoint_client;\npub mod endpoint_server;\npub mod gosling;\npub mod identity_client;\npub mod identity_server;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","tests","context.rs"],"content":"// standard\nuse std::io::{BufRead, BufReader, Write};\nuse std::net::TcpStream;\n\n// extern crates\nuse anyhow::bail;\nuse bson::doc;\nuse serial_test::serial;\nuse tor_interface::legacy_tor_client::*;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// internal crates\nuse gosling::context::*;\n\n#[test]\nfn test_mock_client_gosling_context() -\u003e anyhow::Result\u003c()\u003e {\n    let alice_tor_client = Box::new(MockTorClient::new());\n    let pat_tor_client = Box::new(MockTorClient::new());\n    gosling_context_test(alice_tor_client, pat_tor_client)\n}\n\n#[test]\n#[serial]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_legacy_client_gosling_context() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(\"tor\")?;\n\n    let mut alice_path = std::env::temp_dir();\n    alice_path.push(\"test_legacy_client_gosling_context_alice\");\n    let alice_tor_client = Box::new(LegacyTorClient::new(\u0026tor_path, \u0026alice_path)?);\n\n    let mut pat_path = std::env::temp_dir();\n    pat_path.push(\"test_legacy_client_gosling_context_pat\");\n    let pat_tor_client = Box::new(LegacyTorClient::new(\u0026tor_path, \u0026pat_path)?);\n\n    gosling_context_test(alice_tor_client, pat_tor_client)\n}\n\n#[cfg(test)]\nfn gosling_context_test(\n    alice_tor_client: Box\u003cdyn TorProvider\u003e,\n    pat_tor_client: Box\u003cdyn TorProvider\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // Bootstrap Alice\n    let alice_private_key = Ed25519PrivateKey::generate();\n    let alice_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n\n    println!(\n        \"Starting Alice gosling context ({})\",\n        alice_service_id.to_string()\n    );\n\n    let mut alice = Context::new(\n        alice_tor_client,\n        420,\n        420,\n        std::time::Duration::from_secs(60),\n        4096,\n        None,\n        alice_private_key,\n    )?;\n    alice.bootstrap()?;\n\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice.update()?.drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Alice BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    println!(\"Alice Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived { line } =\u003e {\n                    println!(\"--- ALICE --- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // Bootstrap Pat\n    let pat_private_key = Ed25519PrivateKey::generate();\n    let pat_service_id = V3OnionServiceId::from_private_key(\u0026pat_private_key);\n\n    println!(\n        \"Starting Pat gosling context ({})\",\n        pat_service_id.to_string()\n    );\n    let mut pat = Context::new(\n        pat_tor_client,\n        420,\n        420,\n        std::time::Duration::from_secs(60),\n        4096,\n        None,\n        pat_private_key,\n    )?;\n    pat.bootstrap()?;\n\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in pat.update()?.drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Pat BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    println!(\"Pat Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived { line } =\u003e {\n                    println!(\"--- PAT --- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // Start the Alice identity server\n    println!(\"Alice identity server starting\");\n    alice.identity_server_start()?;\n    let mut alice_identity_published: bool = false;\n\n    while !alice_identity_published {\n        for event in alice.update()?.drain(..) {\n            match event {\n                ContextEvent::IdentityServerPublished =\u003e {\n                    alice_identity_published = true;\n                    println!(\"Alice identity server published\");\n                }\n                ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n            }\n        }\n    }\n\n    // Pat begins client handshake\n    println!(\"Pat identity client handshake begin\");\n    let mut pat_identity_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    {\n        let mut pat_identity_handshake_tries_remaining = 3;\n        while pat_identity_handshake_tries_remaining \u003e 0\n            \u0026\u0026 pat_identity_handshake_handle == INVALID_HANDSHAKE_HANDLE\n        {\n            match pat.identity_client_begin_handshake(\n                alice_service_id.clone(),\n                \"test_endpoint\".to_string(),\n            ) {\n                Ok(handle) =\u003e {\n                    pat_identity_handshake_handle = handle;\n                }\n                Err(err) =\u003e {\n                    println!(\n                        \"Pat connecting to Alice's identity server failed with: {:?}\",\n                        err\n                    );\n                    pat_identity_handshake_tries_remaining -= 1;\n                }\n            }\n        }\n\n        if pat_identity_handshake_tries_remaining == 0 {\n            bail!(\"pat.identity_client_handshake() failed no more retries remain\");\n        }\n    }\n\n    // Alice waits for handshake start\n    let mut alice_identity_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    println!(\"Alice waits for identity handshake start\");\n    {\n        let mut alice_identity_server_endpoint_request_received: bool = false;\n        while !alice_identity_server_endpoint_request_received {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerHandshakeStarted { handle } =\u003e {\n                        alice_identity_handshake_handle = handle;\n                        println!(\"Pat has connected to Alice identity server\");\n                    }\n                    ContextEvent::IdentityServerEndpointRequestReceived {\n                        handle,\n                        client_service_id,\n                        requested_endpoint,\n                    } =\u003e {\n                        assert_eq!(alice_identity_handshake_handle, handle);\n                        assert_eq!(pat_service_id, client_service_id);\n                        assert_eq!(requested_endpoint, \"test_endpoint\");\n                        alice_identity_server_endpoint_request_received = true;\n                        println!(\"Alice receives initial identity handshake request\");\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n    }\n\n    // Alice sends challenge\n    println!(\"Alice sends identity server challenge\");\n    alice.identity_server_handle_endpoint_request_received(\n        alice_identity_handshake_handle,\n        true,\n        true,\n        doc! {},\n    )?;\n\n    // Pat responds to challenge\n    println!(\"Pat waits for server challenge\");\n    {\n        let mut pat_identity_client_challenge: Option\u003cbson::document::Document\u003e = None;\n        while pat_identity_client_challenge.is_none() {\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityClientChallengeReceived {\n                        handle,\n                        endpoint_challenge,\n                    } =\u003e {\n                        assert_eq!(handle, pat_identity_handshake_handle);\n                        pat_identity_client_challenge = Some(endpoint_challenge);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        println!(\"Pat responds to challenge\");\n        if let Some(challenge) = pat_identity_client_challenge {\n            assert_eq!(challenge, doc! {});\n            // send empty doc in response\n            pat.identity_client_handle_challenge_received(pat_identity_handshake_handle, doc! {})?;\n        } else {\n            bail!(\"missing pat_identity_client_challenge\");\n        }\n    }\n\n    // Alice evaluate challenge response\n    println!(\"Alice awaits challenge response\");\n    {\n        let mut alice_identity_server_challenge_response: Option\u003cbson::document::Document\u003e = None;\n        while alice_identity_server_challenge_response.is_none() {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerChallengeResponseReceived {\n                        handle,\n                        challenge_response,\n                    } =\u003e {\n                        assert_eq!(handle, alice_identity_handshake_handle);\n                        alice_identity_server_challenge_response = Some(challenge_response);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n        println!(\"Alice evaluates challenge response\");\n        if let Some(challenge_response) = alice_identity_server_challenge_response {\n            assert_eq!(challenge_response, doc! {});\n            println!(\"Alice accepts challenge response\");\n            alice.identity_server_handle_challenge_response_received(\n                alice_identity_handshake_handle,\n                true,\n            )?;\n        } else {\n            bail!(\"missing challenge response\");\n        }\n    }\n\n    // Alice and Pat awaits handshake results\n    println!(\"Identity handshake completing\");\n    let (\n        alice_endpoint_private_key,\n        alice_endpoint_service_id,\n        pat_auth_private_key,\n        pat_auth_public_key,\n    ) = {\n        let mut alice_endpoint_private_key: Option\u003cEd25519PrivateKey\u003e = None;\n        let mut alice_endpoint_service_id: Option\u003cV3OnionServiceId\u003e = None;\n        let mut pat_auth_private_key: Option\u003cX25519PrivateKey\u003e = None;\n        let mut pat_auth_public_key: Option\u003cX25519PublicKey\u003e = None;\n\n        let mut pat_identity_client_handshake_completed: bool = false;\n        let mut alice_identity_server_hanshake_completed: bool = false;\n        while !pat_identity_client_handshake_completed || !alice_identity_server_hanshake_completed\n        {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerHandshakeCompleted {\n                        handle,\n                        endpoint_private_key,\n                        endpoint_name,\n                        client_service_id,\n                        client_auth_public_key,\n                    } =\u003e {\n                        assert_eq!(handle, alice_identity_handshake_handle);\n                        alice_endpoint_private_key = Some(endpoint_private_key);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        assert_eq!(client_service_id, pat_service_id);\n                        pat_auth_public_key = Some(client_auth_public_key);\n                        alice_identity_server_hanshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityClientHandshakeCompleted {\n                        handle,\n                        identity_service_id,\n                        endpoint_service_id,\n                        endpoint_name,\n                        client_auth_private_key,\n                    } =\u003e {\n                        assert_eq!(handle, pat_identity_handshake_handle);\n                        assert_eq!(identity_service_id, alice_service_id);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        alice_endpoint_service_id = Some(endpoint_service_id);\n                        pat_auth_private_key = Some(client_auth_private_key);\n                        pat_identity_client_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        // verify the private key returned by alice matches service id returned by pat\n        assert_eq!(\n            V3OnionServiceId::from_private_key(alice_endpoint_private_key.as_ref().unwrap()),\n            *alice_endpoint_service_id.as_ref().unwrap()\n        );\n\n        (\n            alice_endpoint_private_key.unwrap(),\n            alice_endpoint_service_id.unwrap(),\n            pat_auth_private_key.unwrap(),\n            pat_auth_public_key.unwrap(),\n        )\n    };\n\n    // Alice starts endpoint server\n    println!(\"Alice endpoint server starting\");\n    alice.endpoint_server_start(\n        alice_endpoint_private_key,\n        \"test_endpoint\".to_string(),\n        pat_service_id.clone(),\n        pat_auth_public_key.clone(),\n    )?;\n    {\n        let mut alice_endpoint_server_published: bool = false;\n        while !alice_endpoint_server_published {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerPublished {\n                        endpoint_service_id,\n                        endpoint_name,\n                    } =\u003e {\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        println!(\"Alice endpoint server published\");\n                        alice_endpoint_server_published = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n    }\n\n    // Pat begins client handshake\n    println!(\"Pat endpoint client handshake begin\");\n    let mut pat_endpoint_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    {\n        let mut pat_endpoint_handshake_tries_remaining = 3;\n        while pat_endpoint_handshake_tries_remaining \u003e 0\n            \u0026\u0026 pat_endpoint_handshake_handle == INVALID_HANDSHAKE_HANDLE\n        {\n            match pat.endpoint_client_begin_handshake(\n                alice_endpoint_service_id.clone(),\n                pat_auth_private_key.clone(),\n                \"test_channel\".to_string(),\n            ) {\n                Ok(handle) =\u003e {\n                    pat_endpoint_handshake_handle = handle;\n                }\n                Err(err) =\u003e {\n                    println!(\n                        \"Pat connecting to Alice's identity server failed with:\\n{:?}\",\n                        err\n                    );\n                    pat_endpoint_handshake_tries_remaining -= 1;\n                }\n            }\n        }\n\n        if pat_endpoint_handshake_tries_remaining == 0 {\n            bail!(\"pat.endpoint_client_begin_handshake() failed no more retries remain\");\n        }\n    }\n\n    // Alice waits for handshake start\n    let mut alice_endpoint_server_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    println!(\"Alice waits for endpoint handshake to start\");\n    {\n        let mut alice_endpoint_server_request_recieved: bool = false;\n        while !alice_endpoint_server_request_recieved {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerHandshakeStarted { handle } =\u003e {\n                        alice_endpoint_server_handshake_handle = handle;\n                        println!(\"Pat has connected to Alice endpoint server\")\n                    }\n                    ContextEvent::EndpointServerChannelRequestReceived {\n                        handle,\n                        client_service_id,\n                        requested_channel,\n                    } =\u003e {\n                        assert_eq!(handle, alice_endpoint_server_handshake_handle);\n                        assert_eq!(client_service_id, pat_service_id);\n                        assert_eq!(requested_channel, \"test_channel\");\n                        alice_endpoint_server_request_recieved = true;\n                        println!(\"Pat requesting '{0}' endpoint channel\", requested_channel);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        // Alice sends handshake response\n        println!(\"Alice sends endpoint handshake response\");\n        alice.endpoint_server_handle_channel_request_received(\n            alice_endpoint_server_handshake_handle,\n            true,\n        )?;\n    }\n\n    // Alice and Pat await hndshake result\n    println!(\"Endpoint handshake completing\");\n    let (alice_server_stream, mut pat_client_stream) = {\n        let mut alice_server_stream: Option\u003cTcpStream\u003e = None;\n        let mut pat_client_stream: Option\u003cTcpStream\u003e = None;\n\n        let mut pat_endpoint_client_handshake_completed: bool = false;\n        let mut alice_endpoint_server_handshake_completed: bool = false;\n\n        while !pat_endpoint_client_handshake_completed || !alice_endpoint_server_handshake_completed\n        {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerHandshakeCompleted {\n                        handle,\n                        endpoint_service_id,\n                        client_service_id,\n                        channel_name,\n                        stream,\n                    } =\u003e {\n                        assert_eq!(handle, alice_endpoint_server_handshake_handle);\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(client_service_id, pat_service_id);\n                        assert_eq!(channel_name, \"test_channel\");\n                        alice_server_stream = Some(stream);\n                        alice_endpoint_server_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    _ =\u003e bail!(\"alice.upate() returned unexepcted event\"),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointClientHandshakeCompleted {\n                        handle,\n                        endpoint_service_id,\n                        channel_name,\n                        stream,\n                    } =\u003e {\n                        assert_eq!(handle, pat_endpoint_handshake_handle);\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(channel_name, \"test_channel\");\n                        pat_client_stream = Some(stream);\n                        pat_endpoint_client_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    _ =\u003e bail!(\"pat.upate() returned unexepcted event\"),\n                }\n            }\n        }\n        (alice_server_stream.unwrap(), pat_client_stream.unwrap())\n    };\n\n    println!(\"Endpoint handshake complete, TcpStreams returned\");\n\n    pat_client_stream.write(b\"Hello World!\\n\")?;\n    pat_client_stream.flush()?;\n\n    alice_server_stream.set_nonblocking(false)?;\n    let mut alice_reader = BufReader::new(alice_server_stream);\n\n    let mut response: String = Default::default();\n    alice_reader.read_line(\u0026mut response)?;\n\n    assert_eq!(response, \"Hello World!\\n\");\n\n    println!(\"TcpStream communication succesful\");\n\n    Ok(())\n}\n","traces":[{"line":42,"address":[1184433,1180992,1222333],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_test"},{"line":47,"address":[1181061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1181465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1181646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1181538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1181801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1181854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1181917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1181928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1222160,1182252,1182495,1182541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[1182528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1182536,1182702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[1182712,1184793,1184866,1182777,1183420],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[1183324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1184167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1184469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1183699,1184442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[1184461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[1183729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[1184534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1182739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1184896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1185080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1184972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1185235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[1185288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1185351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1185362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1185929,1185975,1222064,1185686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[1185962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1185970,1186136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[1186862,1188223,1186219,1188296,1186146],"length":1,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[1186766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1186977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1187902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[1187141,1187875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[1187894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1187171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1187964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1186173,1188326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1188434,1188345,1222043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1188421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1188595,1188429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[1188605,1189283,1188678,1189559,1189836,1189777],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[1189206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[1189454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1189462,1189530],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[1189564,1189305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1188632,1189849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[1189868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1189880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1189891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1189913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1221518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[1189940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[1221491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1221587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1221603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[1221616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[1221873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[1221949,1222002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1189901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[1190024,1189950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[1189977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1189989,1190068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[1190087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1190095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1190178,1190105,1193135,1193238,1192895,1190809],"length":1,"stats":{"Line":4},"fn_name":null},{"line":188,"address":[1190709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[1192029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1192045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1192053,1192312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[1192099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1192352,1192177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1192556,1192417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[1192636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1192803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1192811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1192919,1191850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1191429,1191800,1190828],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[1191387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1191592,1191509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1193251,1190132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[1193564,1193313,1221478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1193270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1193286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[1193406,1193597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1193616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1193650,1193737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[1219202,1193770,1221276,1221379,1218594,1220988],"length":1,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[1219122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[1220404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1220458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1220607,1220867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1220237,1221050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[1220187,1219221,1219822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[1219780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[1219902,1219985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1193800,1193743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[1193819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[1194059,1193958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[1194290,1194439,1218458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[1193977,1218537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1194608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1194654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[1194775,1194688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[1218359,1194808,1217956,1216140,1215532,1218256],"length":1,"stats":{"Line":4},"fn_name":null},{"line":268,"address":[1216060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[1217376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[1217414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[1217835,1217575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[1217181,1218018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1217131,1216159,1216760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[1216718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1216840,1216923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[1194781,1194838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[1194857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[1195097,1194996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[1195328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[1195382,1195613,1215396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[1195374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[1215475,1195015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[1195654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[1201963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1201981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[1202045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[1202077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[1195700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[1195720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[1195728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1195744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[1195752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[1195760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[1195805,1195768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[1200710,1200307,1195902,1195778,1196510,1200607],"length":1,"stats":{"Line":4},"fn_name":null},{"line":318,"address":[1196430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[1199207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[1199352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[1199513,1199684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[1199788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[1199963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[1200131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[1200217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[1200369,1198974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[1198568,1196529,1197177,1198964,1198846],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[1197100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1197394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[1197574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[1197743,1197877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[1197960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[1198127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[1198263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[1198473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[1198630,1197199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[1201036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[1200893,1195815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[1200912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[1201196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[1201291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[1201431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[1201567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[1202180,1202109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":375,"address":[1215256,1202512,1202686,1202405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[1202199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[1202313,1202245],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[1202337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[1202398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[1202545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[1202553,1202719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":384,"address":[1204469,1204591,1202802,1202729,1203407,1204232],"length":1,"stats":{"Line":4},"fn_name":null},{"line":385,"address":[1203330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[1203672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[1203712,1203849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":391,"address":[1203932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[1204099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[1204145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[1204256,1203429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[1202756,1204601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[1204620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[1204632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[1204643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[1204665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[1214734,1214667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[1204692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[1214584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[1214599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[1214760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[1214776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[1214789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[1215058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[1215193,1215134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[1204653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[1204776,1204702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[1204729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[1204820,1204741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":437,"address":[1204839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[1204847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[1204857,1208116,1205561,1208013,1204930,1207773],"length":1,"stats":{"Line":4},"fn_name":null},{"line":440,"address":[1205461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[1206781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[1206797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[1207064,1206805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[1206851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[1207104,1206929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[1207306,1207169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[1207389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[1207556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[1207659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[1206602,1207797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[1206552,1205580,1206181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[1206139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[1206344,1206261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[1208129,1204884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[1208156,1208395,1214555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1208148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[1208237,1208428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":478,"address":[1213061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[1208447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[1208466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[1208485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[1208493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[1208541,1208501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":487,"address":[1208693,1208511,1212505,1212660,1212787,1209309],"length":1,"stats":{"Line":4},"fn_name":null},{"line":488,"address":[1209229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1211381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[1211543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[1211712,1211846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[1211929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[1212105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[1212272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[1212380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[1211302,1212578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[1211150,1209328,1209976,1210995,1211292],"length":1,"stats":{"Line":3},"fn_name":null},{"line":508,"address":[1209907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[1210179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[1210209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[1210512,1210378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[1210595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[1210762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[1210870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[1211068,1209998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[1212884,1212973,1208551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":529,"address":[1213097,1213168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[1214437,1213187,1213303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[1213445,1213288,1213352,1214419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[1214401,1213416,1181029,1213494,1213588],"length":1,"stats":{"Line":3},"fn_name":null},{"line":535,"address":[1213558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[1213637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[1213708,1213756,1213903,1214332],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[1213818,1213951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[1214026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[1214072],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":222,"coverable":252},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","fuzz","fuzz_targets","fuzz_session.rs"],"content":"#![no_main]\n\n// std\nuse std::collections::{BTreeSet, VecDeque};\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// honk_rpc\nuse honk_rpc::honk_rpc::{ApiSet, Error, ErrorCode, RequestCookie, Response, Session};\n\n// extern\nuse bson::Bson;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\n#[derive(Arbitrary, Debug)]\nenum SessionMethod {\n    Update,\n    ClientCallSync,\n    ClientCallAsync {\n        // the number of update calls the ApiSet should wait before returning\n        wait_count: u8,\n    },\n    ClientCallInvalid{\n        namespace: Option\u003cString\u003e,\n        function: Option\u003cString\u003e,\n        version: Option\u003ci32\u003e,\n        // arguments: Option\u003cbson::document::Document\u003e,\n    },\n    ClientDrainResponses,\n}\n\n\n#[derive(Default)]\nstruct TestApiSet {\n    pending_async_calls: Vec\u003c(u8, RequestCookie)\u003e,\n    complete_async_calls: VecDeque\u003cRequestCookie\u003e,\n}\n\n// impl ApiSet\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"fuzzing\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e) -\u003e Result\u003cOption\u003cBson\u003e, ErrorCode\u003e {\n        match (name, version) {\n            (\"sync_call\", 0) =\u003e Ok(Some(bson::Bson::Null)),\n            (\"sync_call\", _) =\u003e Err(ErrorCode::RequestVersionInvalid),\n            (\"async_call\", 0) =\u003e {\n                if let Some(request_cookie) = request_cookie {\n                    if let Some(bson::Bson::Int32(val)) = args.get_mut(\"wait_count\") {\n                        let \u0026mut val = val;\n                        let wait_count = val.clamp(0, 255) as u8;\n                        self.pending_async_calls.push((wait_count, request_cookie));\n                    }\n                }\n                Ok(None)\n            },\n            (\"async_call\", _) =\u003e Err(ErrorCode::RequestVersionInvalid),\n            _ =\u003e Err(ErrorCode::RequestFunctionInvalid),\n        }\n    }\n\n    fn update(\u0026mut self) -\u003e () {\n        self.pending_async_calls.retain_mut(|record| -\u003e bool {\n            if record.0 == 0 {\n                self.complete_async_calls.push_back(record.1);\n                false\n            } else {\n                record.0 -= 1;\n                true\n            }\n        });\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cBson\u003e, ErrorCode)\u003e {\n        match self.complete_async_calls.pop_front() {\n            Some(cookie) =\u003e Some((cookie, Some(bson::Bson::Null), ErrorCode::Success)),\n            None =\u003e None\n        }\n    }\n}\n\n\nstruct Context {\n    session: Session\u003cTcpStream\u003e,\n    apiset: TestApiSet,\n    pending_successes: BTreeSet\u003cRequestCookie\u003e,\n    pending_failures: BTreeSet\u003cRequestCookie\u003e,\n}\n\nimpl Context {\n    fn new(session: Session\u003cTcpStream\u003e) -\u003e Context {\n        Context{session, apiset: Default::default(), pending_successes: Default::default(), pending_failures: Default::default()}\n    }\n}\n\nfuzz_target!(|methods: Vec\u003cSessionMethod\u003e| {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr).unwrap();\n    let socket_addr = listener.local_addr().unwrap();\n\n    let alice_stream = TcpStream::connect(socket_addr).unwrap();\n    alice_stream.set_nonblocking(true).unwrap();\n\n    let (pat_stream, _socket_addr) = listener.accept().unwrap();\n    pat_stream.set_nonblocking(true).unwrap();\n\n    let alice = Session::new(alice_stream);\n    let pat = Session::new(pat_stream);\n\n    let mut current = \u0026mut Context::new(alice);\n    let mut next = \u0026mut Context::new(pat);\n\n    // run the methods on our pair of HonkRpc Sessions\n    for method in methods {\n        match method {\n            SessionMethod::Update =\u003e match current.session.update(Some(\u0026mut [\u0026mut current.apiset])) {\n                Ok(()) =\u003e {},\n                Err(Error::MessageConversionFailed(ErrorCode::RequestFunctionInvalid)) =\u003e {},\n                Err(error) =\u003e panic!(\"{:?}\", error),\n            },\n            SessionMethod::ClientCallSync =\u003e {\n                let cookie = current.session.client_call(\"fuzzing\", \"sync_call\", 0, bson::doc!{}).unwrap();\n                assert!(current.pending_successes.insert(cookie));\n            }\n            SessionMethod::ClientCallAsync{wait_count} =\u003e {\n                let cookie = current.session.client_call(\"fuzzing\", \"async_call\", 0, bson::doc!{\"wait_count\" : Bson::Int32(wait_count as i32)}).unwrap();\n                assert!(current.pending_successes.insert(cookie));\n            }\n            SessionMethod::ClientCallInvalid{namespace,function,version} =\u003e {\n                // ensure invalid namespace\n                let namespace = match namespace {\n                    Some(namespace) =\u003e namespace,\n                    None =\u003e \"invalid\".to_string(),\n                };\n                let namespace = match namespace.as_str() {\n                    \"fuzzing\" =\u003e \"invalid\",\n                    namespace =\u003e namespace,\n                };\n\n                // ensure invalid function name\n                let function = match function {\n                    Some(function) =\u003e function,\n                    None =\u003e \"invalid\".to_string(),\n                };\n                let function = match function.as_str() {\n                    \"sync_call\" =\u003e \"invalid\",\n                    \"async_call\" =\u003e \"invalid\",\n                    function =\u003e function,\n                };\n\n                // ensure invalid function version\n                let version = match version {\n                    Some(0) =\u003e 1,\n                    Some(version) =\u003e version,\n                    None =\u003e 1,\n                };\n\n                let cookie = current.session.client_call(namespace, function, version, bson::doc!{}).unwrap();\n                assert!(current.pending_failures.insert(cookie));\n            }\n            SessionMethod::ClientDrainResponses =\u003e {\n                for response in current.session.client_drain_responses() {\n                    match response {\n                        Response::Pending{cookie} =\u003e assert!(current.pending_successes.contains(\u0026cookie) || current.pending_failures.contains(\u0026cookie)),\n                        Response::Success{cookie, result: _} =\u003e assert!(current.pending_successes.remove(\u0026cookie)),\n                        Response::Error{cookie, error_code} =\u003e {\n                            assert!(current.pending_failures.remove(\u0026cookie));\n                            assert!(error_code == ErrorCode::RequestNamespaceInvalid ||\n                                    error_code == ErrorCode::RequestFunctionInvalid ||\n                                    error_code == ErrorCode::RequestVersionInvalid);\n                        }\n                    }\n                }\n            },\n        }\n        std::mem::swap(\u0026mut current, \u0026mut next);\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","byte_counter.rs"],"content":"use std::io::Write;\n\n#[derive(Default)]\npub(crate) struct ByteCounter {\n    bytes: usize,\n}\n\nimpl ByteCounter {\n    pub fn bytes(\u0026self) -\u003e usize {\n        self.bytes\n    }\n}\n\nimpl Write for ByteCounter {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.bytes += buf.len();\n        Ok(buf.len())\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), std::io::Error\u003e {\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[11118624],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10,"address":[559765],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[12489392],"length":1,"stats":{"Line":4},"fn_name":"write"},{"line":16,"address":[559815,559874],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[12489474],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[2090800],"length":1,"stats":{"Line":0},"fn_name":"flush"},{"line":21,"address":[2090805],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":7},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","honk_rpc.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::fmt::Debug;\nuse std::io::{Cursor, ErrorKind};\n#[cfg(test)]\nuse std::net::{SocketAddr, TcpListener, TcpStream};\nuse std::option::Option;\n\n// extern crates\nuse bson::doc;\nuse bson::document::ValueAccessError;\n\nuse crate::byte_counter::ByteCounter;\n\n#[derive(Debug, Eq, PartialEq)]\npub enum ErrorCode {\n    // Protocol Errors\n    BsonParseFailed,\n    MessageTooBig,\n    MessageParseFailed,\n    MessageVersionIncompatible,\n    SectionIdUnknown,\n    SectionParseFailed,\n    RequestCookieInvalid,\n    RequestNamespaceInvalid,\n    RequestFunctionInvalid,\n    RequestVersionInvalid,\n    ResponseCookieInvalid,\n    ResponseStateInvalid,\n\n    Success,\n    Runtime(i32),\n    Unknown(i32),\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to read data from read stream\")]\n    ReaderReadFailed(#[source] std::io::Error),\n\n    #[error(\"received invalid bson document size header value of {0}, must be at least 4\")]\n    BsonDocumentSizeTooSmall(i32),\n\n    #[error(\"received invalid bson document size header value of {0}, must be less than {1}\")]\n    BsonDocumentSizeTooLarge(i32, i32),\n\n    #[error(\"waited longer than {} seconds for read\", .0.as_secs_f32())]\n    MessageReadTimedOut(std::time::Duration),\n\n    #[error(\"failed to parse bson Message document\")]\n    BsonDocumentParseFailed(#[source] bson::de::Error),\n\n    #[error(\"failed to convert bson document to Message\")]\n    MessageConversionFailed(#[source] crate::honk_rpc::ErrorCode),\n\n    #[error(\"failed to serialize bson Message document\")]\n    MessageWriteFailed(#[source] bson::ser::Error),\n\n    #[error(\"failed to write message to write stream\")]\n    WriterWriteFailed(#[source] std::io::Error),\n\n    #[error(\"failed to flush message to write stream\")]\n    WriterFlushFailed(#[source] std::io::Error),\n\n    #[error(\"recieved error section without cookie\")]\n    UnknownErrorSectionReceived(#[source] crate::honk_rpc::ErrorCode),\n\n    #[error(\n        \"tried to set invalid max message size; must be \u003e=5 bytes and \u003c= i32::MAX (2147483647)\"\n    )]\n    InvalidMaxMesageSize(),\n\n    #[error(\"queued message section is too large to write; calculated size is {0} but must be less than {1}\")]\n    SectionTooLarge(usize, usize),\n}\n\nimpl From\u003ci32\u003e for ErrorCode {\n    fn from(value: i32) -\u003e ErrorCode {\n        match value {\n            -1i32 =\u003e ErrorCode::BsonParseFailed,\n            -2i32 =\u003e ErrorCode::MessageTooBig,\n            -3i32 =\u003e ErrorCode::MessageParseFailed,\n            -4i32 =\u003e ErrorCode::MessageVersionIncompatible,\n            -5i32 =\u003e ErrorCode::SectionIdUnknown,\n            -6i32 =\u003e ErrorCode::SectionParseFailed,\n            -7i32 =\u003e ErrorCode::RequestCookieInvalid,\n            -8i32 =\u003e ErrorCode::RequestNamespaceInvalid,\n            -9i32 =\u003e ErrorCode::RequestFunctionInvalid,\n            -10i32 =\u003e ErrorCode::RequestVersionInvalid,\n            -11i32 =\u003e ErrorCode::ResponseCookieInvalid,\n            -12i32 =\u003e ErrorCode::ResponseStateInvalid,\n            0i32 =\u003e ErrorCode::Success,\n            value =\u003e {\n                if value \u003e 0 {\n                    ErrorCode::Runtime(value)\n                } else {\n                    ErrorCode::Unknown(value)\n                }\n            }\n        }\n    }\n}\n\nimpl From\u003cErrorCode\u003e for i32 {\n    fn from(err: ErrorCode) -\u003e Self {\n        match err {\n            ErrorCode::BsonParseFailed =\u003e -1i32,\n            ErrorCode::MessageTooBig =\u003e -2i32,\n            ErrorCode::MessageParseFailed =\u003e -3i32,\n            ErrorCode::MessageVersionIncompatible =\u003e -4i32,\n            ErrorCode::SectionIdUnknown =\u003e -5i32,\n            ErrorCode::SectionParseFailed =\u003e -6i32,\n            ErrorCode::RequestCookieInvalid =\u003e -7i32,\n            ErrorCode::RequestNamespaceInvalid =\u003e -8i32,\n            ErrorCode::RequestFunctionInvalid =\u003e -9i32,\n            ErrorCode::RequestVersionInvalid =\u003e -10i32,\n            ErrorCode::ResponseCookieInvalid =\u003e -11i32,\n            ErrorCode::ResponseStateInvalid =\u003e -12i32,\n            ErrorCode::Success =\u003e 0i32,\n            ErrorCode::Runtime(val) =\u003e val,\n            ErrorCode::Unknown(val) =\u003e val,\n        }\n    }\n}\n\nimpl std::fmt::Display for ErrorCode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            ErrorCode::BsonParseFailed =\u003e write!(f, \"ProtocolError: failed to parse BSON object\"),\n            ErrorCode::MessageTooBig =\u003e write!(f, \"ProtocolError: received document too large\"),\n            ErrorCode::MessageParseFailed =\u003e {\n                write!(f, \"ProtocolError: received message has invalid schema\")\n            }\n            ErrorCode::MessageVersionIncompatible =\u003e write!(\n                f,\n                \"ProtocolError: received message has incompatible version\"\n            ),\n            ErrorCode::SectionIdUnknown =\u003e write!(\n                f,\n                \"ProtocolError: received message contains section of unknown type\"\n            ),\n            ErrorCode::SectionParseFailed =\u003e write!(\n                f,\n                \"ProtocolError: received message contains section with invalid schema\"\n            ),\n            ErrorCode::RequestCookieInvalid =\u003e {\n                write!(f, \"ProtocolError: request cookie already in use\")\n            }\n            ErrorCode::RequestNamespaceInvalid =\u003e write!(\n                f,\n                \"ProtocolError: request function does not exist in requested namespace\"\n            ),\n            ErrorCode::RequestFunctionInvalid =\u003e {\n                write!(f, \"ProtocolError: request function does not exist\")\n            }\n            ErrorCode::RequestVersionInvalid =\u003e {\n                write!(f, \"ProtocolError: request function version does not exist\")\n            }\n            ErrorCode::ResponseCookieInvalid =\u003e {\n                write!(f, \"ProtocolError: response cookie is not recognized\")\n            }\n            ErrorCode::ResponseStateInvalid =\u003e write!(f, \"ProtocolError: response state not valid\"),\n            ErrorCode::Success =\u003e write!(f, \"Success\"),\n            ErrorCode::Runtime(code) =\u003e write!(f, \"RuntimeError: runtime error {}\", code),\n            ErrorCode::Unknown(code) =\u003e write!(f, \"UnknownError: unknown error code {}\", code),\n        }\n    }\n}\n\nimpl std::error::Error for ErrorCode {}\n\nconst HONK_RPC_VERSION: i32 = 1i32;\n\nstruct Message {\n    honk_rpc: i32,\n    sections: Vec\u003cSection\u003e,\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for Message {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        // verify version\n        let honk_rpc = match value.get_i32(\"honk_rpc\") {\n            Ok(HONK_RPC_VERSION) =\u003e HONK_RPC_VERSION,\n            Ok(_bad_version) =\u003e return Err(ErrorCode::MessageVersionIncompatible),\n            Err(_err) =\u003e return Err(ErrorCode::MessageParseFailed),\n        };\n\n        if let Ok(sections) = value.get_array_mut(\"sections\") {\n            // messages must have at least one section\n            if sections.is_empty() {\n                return Err(ErrorCode::MessageParseFailed);\n            }\n\n            let mut message = Message {\n                honk_rpc,\n                sections: Default::default(),\n            };\n\n            for section in sections.iter_mut() {\n                if let bson::Bson::Document(section) = std::mem::take(section) {\n                    message.sections.push(Section::try_from(section)?);\n                } else {\n                    return Err(ErrorCode::SectionParseFailed);\n                }\n            }\n            Ok(message)\n        } else {\n            Err(ErrorCode::MessageParseFailed)\n        }\n    }\n}\n\nimpl From\u003cMessage\u003e for bson::document::Document {\n    fn from(value: Message) -\u003e bson::document::Document {\n        let mut value = value;\n        let mut message = bson::document::Document::new();\n        message.insert(\"honk_rpc\", value.honk_rpc);\n\n        let mut sections = bson::Array::new();\n        for section in value.sections.drain(0..) {\n            sections.push(bson::Bson::Document(bson::document::Document::from(\n                section,\n            )));\n        }\n        message.insert(\"sections\", sections);\n\n        message\n    }\n}\n\npub type RequestCookie = i64;\n\nconst ERROR_SECTION_ID: i32 = 0i32;\nconst REQUEST_SECTION_ID: i32 = 1i32;\nconst RESPONSE_SECTION_ID: i32 = 2i32;\n\nenum Section {\n    Error(ErrorSection),\n    Request(RequestSection),\n    Response(ResponseSection),\n}\n\nstruct ErrorSection {\n    cookie: Option\u003cRequestCookie\u003e,\n    code: ErrorCode,\n    message: Option\u003cString\u003e,\n    data: Option\u003cbson::Bson\u003e,\n}\n\nstruct RequestSection {\n    cookie: Option\u003cRequestCookie\u003e,\n    namespace: String,\n    function: String,\n    version: i32,\n    arguments: bson::document::Document,\n}\n\n#[repr(i32)]\n#[derive(Debug, PartialEq)]\nenum RequestState {\n    Pending = 0i32,\n    Complete = 1i32,\n}\n\nstruct ResponseSection {\n    cookie: RequestCookie,\n    state: RequestState,\n    result: Option\u003cbson::Bson\u003e,\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for Section {\n    type Error = ErrorCode;\n\n    fn try_from(\n        value: bson::document::Document,\n    ) -\u003e Result\u003cSelf, \u003cSelf as TryFrom\u003cbson::document::Document\u003e\u003e::Error\u003e {\n        match value.get_i32(\"id\") {\n            Ok(ERROR_SECTION_ID) =\u003e Ok(Section::Error(ErrorSection::try_from(value)?)),\n            Ok(REQUEST_SECTION_ID) =\u003e Ok(Section::Request(RequestSection::try_from(value)?)),\n            Ok(RESPONSE_SECTION_ID) =\u003e Ok(Section::Response(ResponseSection::try_from(value)?)),\n            Ok(_) =\u003e Err(ErrorCode::SectionIdUnknown),\n            Err(_) =\u003e Err(ErrorCode::SectionParseFailed),\n        }\n    }\n}\n\nimpl From\u003cSection\u003e for bson::document::Document {\n    fn from(value: Section) -\u003e bson::document::Document {\n        match value {\n            Section::Error(section) =\u003e bson::document::Document::from(section),\n            Section::Request(section) =\u003e bson::document::Document::from(section),\n            Section::Response(section) =\u003e bson::document::Document::from(section),\n        }\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for ErrorSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e Some(cookie),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let code = match value.get_i32(\"code\") {\n            Ok(code) =\u003e ErrorCode::from(code),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let message = match value.get_str(\"message\") {\n            Ok(message) =\u003e Some(message.to_string()),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let data = value.get_mut(\"data\").map(std::mem::take);\n\n        Ok(ErrorSection {\n            cookie,\n            code,\n            message,\n            data,\n        })\n    }\n}\n\nimpl From\u003cErrorSection\u003e for bson::document::Document {\n    fn from(value: ErrorSection) -\u003e bson::document::Document {\n        let mut error_section = bson::document::Document::new();\n        error_section.insert(\"id\", ERROR_SECTION_ID);\n\n        if let Some(cookie) = value.cookie {\n            error_section.insert(\"cookie\", cookie);\n        }\n\n        error_section.insert(\"code\", Into::\u003ci32\u003e::into(value.code));\n\n        if let Some(message) = value.message {\n            error_section.insert(\"message\", message);\n        }\n\n        if let Some(data) = value.data {\n            error_section.insert(\"data\", data);\n        }\n\n        error_section\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for RequestSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e Some(cookie),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let namespace = match value.get_str(\"namespace\") {\n            Ok(namespace) =\u003e namespace.to_string(),\n            Err(ValueAccessError::NotPresent) =\u003e String::default(),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let function = match value.get_str(\"function\") {\n            Ok(function) =\u003e {\n                if function.is_empty() {\n                    return Err(ErrorCode::RequestFunctionInvalid);\n                } else {\n                    function.to_string()\n                }\n            }\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let version = match value.get_i32(\"version\") {\n            Ok(version) =\u003e version,\n            Err(ValueAccessError::NotPresent) =\u003e 0i32,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let arguments = match value.get_document_mut(\"arguments\") {\n            Ok(arguments) =\u003e std::mem::take(arguments),\n            Err(ValueAccessError::NotPresent) =\u003e bson::document::Document::new(),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        Ok(RequestSection {\n            cookie,\n            namespace,\n            function,\n            version,\n            arguments,\n        })\n    }\n}\n\nimpl From\u003cRequestSection\u003e for bson::document::Document {\n    fn from(value: RequestSection) -\u003e bson::document::Document {\n        let mut request_section = bson::document::Document::new();\n        request_section.insert(\"id\", REQUEST_SECTION_ID);\n\n        if let Some(cookie) = value.cookie {\n            request_section.insert(\"cookie\", cookie);\n        }\n\n        if !value.namespace.is_empty() {\n            request_section.insert(\"namespace\", value.namespace);\n        }\n\n        request_section.insert(\"function\", value.function);\n\n        if value.version != 0i32 {\n            request_section.insert(\"version\", value.version);\n        }\n\n        request_section.insert(\"arguments\", value.arguments);\n\n        request_section\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for ResponseSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e cookie,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let state = match value.get_i32(\"state\") {\n            Ok(0i32) =\u003e RequestState::Pending,\n            Ok(1i32) =\u003e RequestState::Complete,\n            Ok(_) =\u003e return Err(ErrorCode::ResponseStateInvalid),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let result = value.get_mut(\"result\").map(std::mem::take);\n\n        // if complete the result must be present\n        if state == RequestState::Complete \u0026\u0026 result.is_none() {\n            return Err(ErrorCode::SectionParseFailed);\n        }\n\n        // if pending there should be no result\n        if state == RequestState::Pending \u0026\u0026 result.is_some() {\n            return Err(ErrorCode::SectionParseFailed);\n        }\n\n        Ok(ResponseSection {\n            cookie,\n            state,\n            result,\n        })\n    }\n}\n\nimpl From\u003cResponseSection\u003e for bson::document::Document {\n    fn from(value: ResponseSection) -\u003e bson::document::Document {\n        let mut response_section = bson::document::Document::new();\n        response_section.insert(\"id\", RESPONSE_SECTION_ID);\n\n        response_section.insert(\"cookie\", value.cookie);\n        response_section.insert(\"state\", value.state as i32);\n\n        if let Some(result) = value.result {\n            response_section.insert(\"result\", result);\n        }\n\n        response_section\n    }\n}\n\npub trait ApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str;\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e;\n    fn update(\u0026mut self) {}\n    // TODO: add support for more error data per spec (string, debug)?\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e {\n        None\n    }\n}\n\npub enum Response {\n    Pending {\n        cookie: RequestCookie,\n    },\n    Success {\n        cookie: RequestCookie,\n        result: bson::Bson,\n    },\n    Error {\n        cookie: RequestCookie,\n        error_code: ErrorCode,\n    },\n}\n\n// 4 kilobytes per specification\npub const DEFAULT_MAX_MESSAGE_SIZE: usize = 4 * 1024;\npub const DEFAULT_MAX_WAIT_TIME: std::time::Duration = std::time::Duration::from_secs(60);\n\n// Base Message Bson Format\n// document size             4 (sizeof i32 )\nconst HEADER_SIZE: usize = 4usize;\n// \"honk_rpc\" : i32          1 (0x10) + 8 (strlen \"honk_rpc\") + 1 (null) + 4 (sizeof i32)\nconst HONK_RPC_SIZE: usize = 14usize;\n// \"sections\" : {\"0\": Null}  1 (0x04) + 8 (strlen \"sections\") + 1 (null) + 4 (sizeof i32) + 1 (0x0a) + 1 (strlen \"0\") + 1 (null) + 1 (0x00)\nconst SECTIONS_SIZE: usize = 18usize;\n// footer                    1 (0x00)\nconst FOOTER_SIZE: usize = 1usize;\n\n// The honk-rpc message overhead before the content of a single section is added\nconst MIN_MESSAGE_SIZE: usize = HEADER_SIZE + HONK_RPC_SIZE + SECTIONS_SIZE + FOOTER_SIZE;\n\n// returns the number of bytes needed to encode a message with one section, not\n// counting the size of that section\npub fn get_message_overhead() -\u003e Result\u003cusize, Error\u003e {\n    // construct an example empty message; the size of a real message with\n    // one section can be calculated as the sizeof(message) + sizeof(section)\n    let message = doc! {\n        \"honk_rpc\" : HONK_RPC_VERSION,\n        \"sections\" : [\n            bson::Bson::Null\n        ]\n    };\n\n    let mut counter: ByteCounter = Default::default();\n    message\n        .to_writer(\u0026mut counter)\n        .map_err(Error::MessageWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\npub fn get_error_section_size(\n    cookie: Option\u003cRequestCookie\u003e,\n    message: Option\u003cString\u003e,\n    data: Option\u003cbson::Bson\u003e,\n) -\u003e Result\u003cusize, Error\u003e {\n    let mut error_section = doc! {\n        \"id\": ERROR_SECTION_ID,\n        \"code\": Into::\u003ci32\u003e::into(ErrorCode::Success),\n    };\n\n    if let Some(cookie) = cookie {\n        error_section.insert(\"cookie\", bson::Bson::Int64(cookie));\n    }\n\n    if let Some(message) = message {\n        error_section.insert(\"message\", bson::Bson::String(message));\n    }\n\n    if let Some(data) = data {\n        error_section.insert(\"data\", data);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    error_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::MessageWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\npub fn get_request_section_size(\n    cookie: Option\u003cRequestCookie\u003e,\n    namespace: Option\u003cString\u003e,\n    function: String,\n    version: Option\u003ci32\u003e,\n    arguments: Option\u003cbson::Document\u003e,\n) -\u003e Result\u003cusize, Error\u003e {\n    let mut request_section = doc! {\n        \"id\": REQUEST_SECTION_ID,\n        \"function\": bson::Bson::String(function),\n    };\n\n    if let Some(cookie) = cookie {\n        request_section.insert(\"cookie\", bson::Bson::Int64(cookie));\n    }\n\n    if let Some(namespace) = namespace {\n        request_section.insert(\"namespace\", bson::Bson::String(namespace));\n    }\n\n    if let Some(version) = version {\n        request_section.insert(\"version\", bson::Bson::Int32(version));\n    }\n\n    if let Some(arguments) = arguments {\n        request_section.insert(\"arguments\", arguments);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    request_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::MessageWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\npub fn get_response_section_size(result: Option\u003cbson::Bson\u003e) -\u003e Result\u003cusize, Error\u003e {\n    let mut response_section = doc! {\n        \"id\": RESPONSE_SECTION_ID,\n        \"cookie\": bson::Bson::Int64(0),\n        \"state\": bson::Bson::Int32(0),\n    };\n\n    if let Some(result) = result {\n        response_section.insert(\"result\", result);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    response_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::MessageWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\npub struct Session\u003cRW\u003e {\n    // read-write stream\n    stream: RW,\n    // we write outgoing data to an intermediate buffer to handle writer blocking\n    message_write_buffer: VecDeque\u003cu8\u003e,\n\n    // message read data\n\n    // remaining number of bytes to read for current message\n    // if None, no message read is in progress\n    remaining_byte_count: Option\u003cusize\u003e,\n    // data we've read but not yet a full Message object\n    message_read_buffer: Vec\u003cu8\u003e,\n    // received sections to be handled\n    pending_sections: VecDeque\u003cSection\u003e,\n    // remote client's inbound remote procedure calls to local server\n    inbound_requests: Vec\u003cRequestSection\u003e,\n    // remote server's responses to local client's remote procedure calls\n    inbound_responses: VecDeque\u003cResponse\u003e,\n\n    // message write data\n\n    // we serialize outgoing messages to this buffer first to verify size limitations\n    message_serialization_buffer: VecDeque\u003cu8\u003e,\n    // the next request cookie to use when making a remote prodedure call\n    next_cookie: RequestCookie,\n    // sections to be sent to the remote server\n    outbound_sections: Vec\u003cbson::Document\u003e,\n\n    // the maximum size of a message we've agreed to allow in the session\n    max_message_size: usize,\n    // the maximum amount of time the session is willing to wait to receive a message\n    // before terminating the session\n    max_wait_time: std::time::Duration,\n    // last time a new message read began\n    read_timestamp: std::time::Instant,\n}\n\n#[allow(dead_code)]\nimpl\u003cRW\u003e Session\u003cRW\u003e\nwhere\n    RW: std::io::Read + std::io::Write + Send,\n{\n    pub fn set_max_message_size(\u0026mut self, max_message_size: i32) -\u003e Result\u003c(), Error\u003e {\n        if max_message_size \u003c MIN_MESSAGE_SIZE as i32 {\n            // base size of a honk-rpc mssage\n            Err(Error::InvalidMaxMesageSize())\n        } else {\n            self.max_message_size = max_message_size as usize;\n            Ok(())\n        }\n    }\n\n    pub fn get_max_message_size(\u0026self) -\u003e usize {\n        self.max_message_size\n    }\n\n    pub fn set_max_wait_time(\u0026mut self, max_wait_time: std::time::Duration) {\n        self.max_wait_time = max_wait_time;\n    }\n\n    pub fn get_max_wait_time(\u0026self) -\u003e std::time::Duration {\n        self.max_wait_time\n    }\n\n    pub fn new(stream: RW) -\u003e Self {\n        let mut message_write_buffer: VecDeque\u003cu8\u003e = Default::default();\n        message_write_buffer.reserve(DEFAULT_MAX_MESSAGE_SIZE);\n\n        let mut message_serialization_buffer: VecDeque\u003cu8\u003e = Default::default();\n        message_serialization_buffer.reserve(DEFAULT_MAX_MESSAGE_SIZE);\n\n        Session {\n            stream,\n            message_write_buffer,\n            remaining_byte_count: None,\n            message_read_buffer: Default::default(),\n            pending_sections: Default::default(),\n            inbound_requests: Default::default(),\n            inbound_responses: Default::default(),\n            message_serialization_buffer,\n            next_cookie: Default::default(),\n            outbound_sections: Default::default(),\n            max_message_size: DEFAULT_MAX_MESSAGE_SIZE,\n            max_wait_time: DEFAULT_MAX_WAIT_TIME,\n            read_timestamp: std::time::Instant::now(),\n        }\n    }\n\n    pub fn into_stream(self) -\u003e RW {\n        self.stream\n    }\n\n    fn stream_read(\u0026mut self, buffer: \u0026mut [u8]) -\u003e Result\u003cusize, Error\u003e {\n        match self.stream.read(buffer) {\n            Err(err) =\u003e {\n                if err.kind() == ErrorKind::WouldBlock || err.kind() == ErrorKind::TimedOut {\n                    // abort if we've gone too long without a new message\n                    if std::time::Instant::now().duration_since(self.read_timestamp)\n                        \u003e self.max_wait_time\n                    {\n                        Err(Error::MessageReadTimedOut(self.max_wait_time))\n                    } else {\n                        Ok(0)\n                    }\n                } else {\n                    Err(Error::ReaderReadFailed(err))\n                }\n            }\n            Ok(0) =\u003e Err(Error::ReaderReadFailed(std::io::Error::from(\n                ErrorKind::UnexpectedEof,\n            ))),\n            Ok(count) =\u003e {\n                // update read_timestamp\n                self.read_timestamp = std::time::Instant::now();\n                Ok(count)\n            }\n        }\n    }\n\n    fn read_message_size(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        match self.remaining_byte_count {\n            // we've already read the size header\n            Some(_remaining) =\u003e Ok(()),\n            // still need to read the size header\n            None =\u003e {\n                // may have been partially read already so ensure it's the right size\n                assert!(self.message_read_buffer.len() \u003c std::mem::size_of::\u003ci32\u003e());\n                let bytes_needed = std::mem::size_of::\u003ci32\u003e() - self.message_read_buffer.len();\n                // ensure we have enough space for an entire int32\n                let mut buffer = [0u8; std::mem::size_of::\u003ci32\u003e()];\n                // but shrink view down to number of bytes remaining\n                let buffer = \u0026mut buffer[0..bytes_needed];\n                match self.stream_read(buffer) {\n                    Err(err) =\u003e Err(err),\n                    Ok(0) =\u003e Ok(()),\n                    Ok(count) =\u003e {\n                        #[cfg(test)]\n                        println!(\"\u003c\u003c\u003c read {} bytes for message header\", count);\n                        self.message_read_buffer\n                            .extend_from_slice(\u0026buffer[0..count]);\n\n                        // all bytes required for i32 message size have been read\n                        if self.message_read_buffer.len() == std::mem::size_of::\u003ci32\u003e() {\n                            let size = \u0026self.message_read_buffer.as_slice();\n                            let size: i32 = (size[0] as i32)\n                                | (size[1] as i32) \u003c\u003c 8\n                                | (size[2] as i32) \u003c\u003c 16\n                                | (size[3] as i32) \u003c\u003c 24;\n                            // size should be at least larger than the bytes required for size header\n                            if size \u003c= std::mem::size_of::\u003ci32\u003e() as i32 {\n                                return Err(Error::BsonDocumentSizeTooSmall(size));\n                            }\n                            // convert to usize type now that we know it's not negative\n                            if size as usize \u003e self.max_message_size {\n                                return Err(Error::BsonDocumentSizeTooLarge(\n                                    size,\n                                    self.max_message_size as i32,\n                                ));\n                            }\n\n                            // deduct size of i32 header and save\n                            let size = size as usize - std::mem::size_of::\u003ci32\u003e();\n\n                            self.remaining_byte_count = Some(size);\n                        }\n                        Ok(())\n                    }\n                }\n            }\n        }\n    }\n\n    fn read_message(\u0026mut self) -\u003e Result\u003cOption\u003cMessage\u003e, Error\u003e {\n        // update remaining bytes to read for message\n        self.read_message_size()?;\n        // read the message bytes\n        if let Some(remaining) = self.remaining_byte_count {\n            #[cfg(test)]\n            println!(\"--- message requires {} more bytes\", remaining);\n\n            let mut buffer = vec![0u8; remaining];\n            match self.stream_read(\u0026mut buffer) {\n                Err(err) =\u003e Err(err),\n                Ok(0) =\u003e Ok(None),\n                Ok(count) =\u003e {\n                    #[cfg(test)]\n                    println!(\"\u003c\u003c\u003c read {} bytes\", count);\n                    // append read bytes\n                    self.message_read_buffer\n                        .extend_from_slice(\u0026buffer[0..count]);\n                    if remaining == count {\n                        self.remaining_byte_count = None;\n\n                        let mut cursor = Cursor::new(std::mem::take(\u0026mut self.message_read_buffer));\n                        let bson = bson::document::Document::from_reader(\u0026mut cursor)\n                            .map_err(Error::BsonDocumentParseFailed)?;\n\n                        // take back our allocated vec and clear it\n                        self.message_read_buffer = cursor.into_inner();\n                        self.message_read_buffer.clear();\n\n                        #[cfg(test)]\n                        println!(\"\u003c\u003c\u003c read message: {}\", bson);\n\n                        Ok(Some(\n                            Message::try_from(bson).map_err(Error::MessageConversionFailed)?,\n                        ))\n                    } else {\n                        // update the remaining byte count\n                        self.remaining_byte_count = Some(remaining - count);\n                        Ok(None)\n                    }\n                }\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    // read and save of available sections\n    fn read_sections(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        loop {\n            match self.read_message() {\n                Ok(Some(mut message)) =\u003e {\n                    self.pending_sections.extend(message.sections.drain(..));\n                }\n                Ok(None) =\u003e return Ok(()),\n                Err(err) =\u003e {\n                    match err {\n                        // in the event of timeouts and IO errors we finish any remaining work\n                        Error::MessageReadTimedOut(_) | Error::ReaderReadFailed(_) =\u003e {\n                            // ensure no pending items to handle\n                            if self.pending_sections.is_empty() \u0026\u0026 self.inbound_responses.is_empty()\n                            {\n                                return Err(err);\n                            }\n                            return Ok(());\n                        }\n                        // all other errors we terminate\n                        _ =\u003e return Err(err),\n                    }\n                }\n            }\n        }\n    }\n\n    // route read sections to client and server buffers\n    fn process_sections(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        while let Some(section) = self.pending_sections.pop_front() {\n            match section {\n                Section::Error(error) =\u003e {\n                    if let Some(cookie) = error.cookie {\n                        // error in response to a request\n                        self.inbound_responses.push_back(Response::Error {\n                            cookie,\n                            error_code: error.code,\n                        });\n                    } else {\n                        return Err(Error::UnknownErrorSectionReceived(error.code));\n                    }\n                }\n                Section::Request(request) =\u003e {\n                    // request to route to our apisets\n                    self.inbound_requests.push(request);\n                }\n                Section::Response(response) =\u003e {\n                    // response to our client\n\n                    if let Some(result) = response.result {\n                        self.inbound_responses.push_back(Response::Success {\n                            cookie: response.cookie,\n                            result,\n                        });\n                    } else {\n                        self.inbound_responses.push_back(Response::Pending {\n                            cookie: response.cookie,\n                        });\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn push_outbound_section(\u0026mut self, section: Section) -\u003e Result\u003c(), Error\u003e {\n        let max_section_size = self.max_message_size - MIN_MESSAGE_SIZE;\n\n        let mut counter: ByteCounter = Default::default();\n        let section: bson::Document = section.into();\n        section\n            .to_writer(\u0026mut counter)\n            .map_err(Error::MessageWriteFailed)?;\n        let section_size = counter.bytes();\n\n        if section_size \u003c= max_section_size {\n            self.outbound_sections.push(section);\n            Ok(())\n        } else {\n            Err(Error::SectionTooLarge(section_size, max_section_size))\n        }\n    }\n\n    // package outbound sections into a message, and serialize message to the message_write_buffer\n    fn serialize_messages(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        // if no pending sections there is nothing to do\n        if self.outbound_sections.is_empty() {\n            return Ok(());\n        }\n\n        // build message and convert to bson to send\n        let message = Message {\n            honk_rpc: HONK_RPC_VERSION,\n            sections: Default::default(),\n        };\n        let mut message = bson::document::Document::from(message);\n        message.insert(\"sections\", std::mem::take(\u0026mut self.outbound_sections));\n        self.serialize_messages_impl(message)\n    }\n\n    fn serialize_messages_impl(\n        \u0026mut self,\n        mut message: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self.message_serialization_buffer.clear();\n        message\n            .to_writer(\u0026mut self.message_serialization_buffer)\n            .map_err(Error::MessageWriteFailed)?;\n\n        if self.message_serialization_buffer.len() \u003e self.max_message_size {\n            // if we can't split a message anymore then we have a problem\n            let sections = message.get_array_mut(\"sections\").unwrap();\n            assert!(sections.len() \u003e 1);\n\n            let right = doc! {\n                \"honk_rpc\" : HONK_RPC_VERSION,\n                \"sections\" : sections.split_off(sections.len() / 2),\n            };\n            let left = message;\n\n            self.serialize_messages_impl(left)?;\n            self.serialize_messages_impl(right)?;\n        } else {\n            #[cfg(test)]\n            println!(\"\u003e\u003e\u003e write message: {:?}\", message);\n            // copy the serialized message into the pending write buffer\n            self.message_write_buffer\n                .append(\u0026mut self.message_serialization_buffer);\n        }\n\n        Ok(())\n    }\n\n    fn write_pending_data(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let bytes_written = self.write_pending_data_impl()?;\n        self.stream.flush().map_err(Error::WriterWriteFailed)?;\n        // removes the written bytes\n        self.message_write_buffer.drain(0..bytes_written);\n        // and shuffles the data so it is contiguous\n        self.message_write_buffer.make_contiguous();\n\n        Ok(())\n    }\n\n    fn write_pending_data_impl(\u0026mut self) -\u003e Result\u003cusize, Error\u003e {\n        // write pending data\n        let (mut pending_data, empty): (\u0026[u8], \u0026[u8]) = self.message_write_buffer.as_slices();\n        assert!(empty.is_empty());\n        let pending_bytes: usize = pending_data.len();\n        let mut bytes_written: usize = 0usize;\n\n        while bytes_written != pending_bytes {\n            match self.stream.write(pending_data) {\n                Err(err) =\u003e {\n                    let kind = err.kind();\n                    if kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut {\n                        // no *additional* bytes written so return bytes written so far\n                        return Ok(bytes_written);\n                    } else {\n                        return Err(Error::WriterWriteFailed(err));\n                    }\n                }\n                Ok(count) =\u003e {\n                    bytes_written += count;\n                    #[cfg(test)]\n                    println!(\"\u003e\u003e\u003e sent {} of {} bytes\", bytes_written, pending_bytes);\n                    pending_data = \u0026pending_data[count..];\n                }\n            }\n        }\n\n        Ok(bytes_written)\n    }\n\n    pub fn update(\u0026mut self, apisets: Option\u003c\u0026mut [\u0026mut dyn ApiSet]\u003e) -\u003e Result\u003c(), Error\u003e {\n        // read sections from remote\n        self.read_sections()?;\n        // route sections to buffers\n        self.process_sections()?;\n\n        // handle incoming api calls\n        let apisets = apisets.unwrap_or(\u0026mut []);\n        self.handle_requests(apisets)?;\n\n        // serialize pending responses\n        self.serialize_messages()?;\n\n        // write pendng data to writer\n        self.write_pending_data()?;\n\n        Ok(())\n    }\n\n    // apisets : a slice of mutable ApiSet references sorted by their namespaces\n    fn handle_requests(\u0026mut self, apisets: \u0026mut [\u0026mut dyn ApiSet]) -\u003e Result\u003c(), Error\u003e {\n        // first handle all of our inbound requests\n        let mut inbound_requests = std::mem::take(\u0026mut self.inbound_requests);\n        for mut request in inbound_requests.drain(..) {\n            if let Ok(idx) =\n                apisets.binary_search_by(|probe| probe.namespace().cmp(\u0026request.namespace))\n            {\n                let apiset = match apisets.get_mut(idx) {\n                    Some(apiset) =\u003e apiset,\n                    None =\u003e unreachable!(),\n                };\n                match apiset.exec_function(\n                    \u0026request.function,\n                    request.version,\n                    std::mem::take(\u0026mut request.arguments),\n                    request.cookie,\n                ) {\n                    // func found, called, and returned immediately\n                    Ok(Some(result)) =\u003e {\n                        if let Some(cookie) = request.cookie {\n                            self.push_outbound_section(Section::Response(ResponseSection {\n                                cookie,\n                                state: RequestState::Complete,\n                                result: Some(result),\n                            }))?;\n                        }\n                    }\n                    // func found, called, and result is pending\n                    Ok(None) =\u003e {\n                        if let Some(cookie) = request.cookie {\n                            self.push_outbound_section(Section::Response(ResponseSection {\n                                cookie,\n                                state: RequestState::Pending,\n                                result: None,\n                            }))?;\n                        }\n                    }\n                    // some error\n                    Err(error_code) =\u003e {\n                        self.push_outbound_section(Section::Error(ErrorSection {\n                            cookie: request.cookie,\n                            code: error_code,\n                            message: None,\n                            data: None,\n                        }))?;\n                    }\n                }\n            } else {\n                // invalid namespace\n                self.push_outbound_section(Section::Error(ErrorSection {\n                    cookie: request.cookie,\n                    code: ErrorCode::RequestNamespaceInvalid,\n                    message: None,\n                    data: None,\n                }))?;\n            }\n        }\n\n        // next send out async responses from apisets\n        for apiset in apisets.iter_mut() {\n            // allow apiset to do any required repetitive work\n            apiset.update();\n            // put pending results in our message\n            while let Some((cookie, result, error_code)) = apiset.next_result() {\n                match (cookie, result, error_code) {\n                    (cookie, Some(result), ErrorCode::Success) =\u003e {\n                        self.push_outbound_section(Section::Response(ResponseSection {\n                            cookie,\n                            state: RequestState::Complete,\n                            result: Some(result),\n                        }))?;\n                    }\n                    (cookie, result, error_code) =\u003e {\n                        if let Some(result) = result {\n                            println!(\"Server::update(): ApiSet next_result() returned both result and an ErrorCode {{ result : '{}', error : {} }}\", result, error_code);\n                        }\n                        self.push_outbound_section(Section::Error(ErrorSection {\n                            cookie: Some(cookie),\n                            code: error_code,\n                            message: None,\n                            data: None,\n                        }))?;\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    // call a remote client's function\n    pub fn client_call(\n        \u0026mut self,\n        namespace: \u0026str,\n        function: \u0026str,\n        version: i32,\n        arguments: bson::document::Document,\n    ) -\u003e Result\u003cRequestCookie, Error\u003e {\n        // always make sure we have a new cookie\n        let cookie = self.next_cookie;\n        self.next_cookie += 1;\n\n        // add request to outgoing buffer\n        self.push_outbound_section(Section::Request(RequestSection {\n            cookie: Some(cookie),\n            namespace: namespace.to_string(),\n            function: function.to_string(),\n            version,\n            arguments,\n        }))?;\n\n        Ok(cookie)\n    }\n\n    // consume all the responses from the client\n    pub fn client_drain_responses(\u0026mut self) -\u003e std::collections::vec_deque::Drain\u003cResponse\u003e {\n        self.inbound_responses.drain(..)\n    }\n\n    // get the next response from the client\n    pub fn client_next_response(\u0026mut self) -\u003e Option\u003cResponse\u003e {\n        self.inbound_responses.pop_front()\n    }\n}\n\n#[test]\nfn test_honk_client_read_write() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    let mut alice = Session::new(stream1);\n    let mut pat = Session::new(stream2);\n\n    println!(\"--- pat reads message, but none has been sent\");\n\n    // no message sent yet\n    assert!(pat.read_message()?.is_none());\n\n    println!(\"--- alice sends no message, but no pending sections so no message sent\");\n\n    // send an empty message\n    alice.serialize_messages()?;\n    alice.write_pending_data()?;\n\n    println!(\"--- pat reads message, but none has been sent\");\n\n    // ensure no mesage as actually sent\n    match pat.read_message() {\n        Ok(Some(msg)) =\u003e panic!(\n            \"message should not have been sent: {}\",\n            bson::document::Document::from(msg)\n        ),\n        Ok(None) =\u003e {}\n        Err(err) =\u003e panic!(\"{:?}\", err),\n    }\n\n    println!(\"--- pat sends an error message\");\n\n    const CUSTOM_ERROR: \u0026str = \"Custom Error!\";\n\n    pat.push_outbound_section(Section::Error(ErrorSection {\n        cookie: Some(42069),\n        code: ErrorCode::Runtime(1),\n        message: Some(CUSTOM_ERROR.to_string()),\n        data: None,\n    }))?;\n\n    pat.serialize_messages()?;\n    pat.write_pending_data()?;\n\n    println!(\"--- alice reads and verifies message\");\n\n    // wait for alice to receive message\n    let mut alice_read_message: bool = false;\n    while !alice_read_message {\n        // println!(\"reading...\");\n        if let Some(mut msg) = alice.read_message()? {\n            assert_eq!(msg.sections.len(), 1);\n            match msg.sections.pop() {\n                Some(Section::Error(section)) =\u003e {\n                    match (section.cookie, section.code, section.message) {\n                        (Some(42069), ErrorCode::Runtime(1), Some(message)) =\u003e {\n                            assert_eq!(message, CUSTOM_ERROR);\n                            alice_read_message = true;\n                        }\n                        (cookie, code, message) =\u003e panic!(\n                            \"unexpected error section: cookie: {:?}, code: {:?}, message: {:?}\",\n                            cookie, code, message\n                        ),\n                    };\n                }\n                Some(_) =\u003e panic!(\"was expecting an Error section\"),\n                None =\u003e panic!(\"we should have a message\"),\n            }\n        }\n    }\n\n    println!(\"--- alice sends multi-section message\");\n\n    alice.push_outbound_section(Section::Error(ErrorSection {\n        cookie: Some(42069),\n        code: ErrorCode::Runtime(2),\n        message: Some(CUSTOM_ERROR.to_string()),\n        data: None,\n    }))?;\n    alice.push_outbound_section(Section::Request(RequestSection {\n        cookie: None,\n        namespace: \"std\".to_string(),\n        function: \"print\".to_string(),\n        version: 0,\n        arguments: doc! {\"message\": \"hello!\"},\n    }))?;\n    alice.push_outbound_section(Section::Response(ResponseSection {\n        cookie: 123456,\n        state: RequestState::Pending,\n        result: None,\n    }))?;\n\n    // send a multi-section mesage\n    alice.serialize_messages()?;\n    alice.write_pending_data()?;\n\n    println!(\"--- pat reads and verifies multi-section message\");\n\n    // read sections sent to pat\n    let mut pat_read_message: bool = false;\n    while !pat_read_message {\n        if let Some(msg) = pat.read_message()? {\n            assert_eq!(msg.sections.len(), 3);\n            for section in msg.sections.iter() {\n                match section {\n                    Section::Error(section) =\u003e {\n                        assert_eq!(section.cookie, Some(42069));\n                        assert_eq!(section.code, ErrorCode::Runtime(2));\n                        assert_eq!(section.message, Some(CUSTOM_ERROR.to_string()));\n                        assert_eq!(section.data, None);\n                    }\n                    Section::Request(section) =\u003e {\n                        assert_eq!(section.cookie, None);\n                        assert_eq!(section.namespace, \"std\");\n                        assert_eq!(section.function, \"print\");\n                        assert_eq!(section.version, 0i32);\n                    }\n                    Section::Response(section) =\u003e {\n                        assert_eq!(section.cookie, 123456);\n                        assert_eq!(section.state, RequestState::Pending);\n                        assert_eq!(section.result, None);\n                    }\n                }\n            }\n            pat_read_message = true;\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nstruct TestApiSet {\n    call_count: usize,\n}\n\n#[cfg(test)]\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"namespace\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        _args: bson::document::Document,\n        _request_section: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        match (name, version) {\n            (\"function\", 0) =\u003e {\n                println!(\"--- namespace::function_0() called\");\n                self.call_count += 1;\n            }\n            _ =\u003e (),\n        }\n        Ok(Some(bson::Bson::Null))\n    }\n}\n\n#[test]\nfn test_honk_timeout() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let alice_stream = TcpStream::connect(socket_addr)?;\n    alice_stream.set_nonblocking(true)?;\n    alice_stream.set_nodelay(true)?;\n    println!(\"--- alice peer_addr: {}\", alice_stream.peer_addr()?);\n    let (pat_stream, _socket_addr) = listener.accept()?;\n    pat_stream.set_nonblocking(true)?;\n    pat_stream.set_nodelay(true)?;\n\n    let mut alice = Session::new(alice_stream);\n    let mut alice_apiset = TestApiSet { call_count: 0usize };\n    let mut pat = Session::new(pat_stream);\n\n    let start = std::time::Instant::now();\n\n    println!(\n        \"--- {:?} alice set max_wait_time to 3 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    alice.update(None)?;\n    alice.set_max_wait_time(std::time::Duration::from_secs(3));\n    alice.update(None)?;\n\n    // a read will happen so time should reset\n    println!(\n        \"--- {:?} sleep 2 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(2));\n\n    println!(\n        \"--- {:?} pat calls namespace::function_0()\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.client_call(\"namespace\", \"function\", 0, doc! {})?;\n    while alice_apiset.call_count != 1 {\n        pat.update(None)?;\n        alice.update(Some(\u0026mut [\u0026mut alice_apiset]))?;\n    }\n\n    // a read will happen so time should reset\n    println!(\n        \"--- {:?} sleep 2 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(2));\n    pat.update(None)?;\n    alice.update(None)?;\n\n    println!(\n        \"--- {:?} pat calls namespace::function_0()\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.client_call(\"namespace\", \"function\", 0, doc! {})?;\n    while alice_apiset.call_count != 2 {\n        pat.update(None)?;\n        alice.update(Some(\u0026mut [\u0026mut alice_apiset]))?;\n    }\n\n    // on reads occur so alice should timeout\n    println!(\n        \"--- {:?} sleep 4 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(4));\n\n    println!(\n        \"--- {:?} pat+alice update\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.update(None)?;\n    match alice.update(None) {\n        Ok(()) =\u003e panic!(\"should have timed out\"),\n        Err(Error::MessageReadTimedOut(duration)) =\u003e {\n            println!(\"--- expected time out after {:?}\", duration)\n        }\n        Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n    }\n    Ok(())\n}\n","traces":[{"line":78,"address":[2070752],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":79,"address":[2070762],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[2070816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2070826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[2070836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2070846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2070856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2070866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[2070876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[2070886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[2070896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[2070906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2070916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2070926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[2070936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2070802,2070969,2070987],"length":1,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[2070975],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[2070957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2070992],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":106,"address":[2071000],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[2071032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[2071045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2071058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[2071068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2071078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2071088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2071098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[2071108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2071118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2071128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2071138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[2071148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[2071158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2071168],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[2071182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2071200],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":128,"address":[2071233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[2071263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[2071312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[2071361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2071416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2071471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2071526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[2071581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[2071636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[2071691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[2071746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2071801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2071856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[2071911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[2072046,2071971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[2072134,2072209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2072304,2073947,2074070],"length":1,"stats":{"Line":4},"fn_name":"try_from"},{"line":183,"address":[2072329],"length":1,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[2072484,2072321,2072405],"length":1,"stats":{"Line":12},"fn_name":null},{"line":188,"address":[2072650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2072543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[2073287,2072609,2072816,2072713],"length":1,"stats":{"Line":12},"fn_name":null},{"line":194,"address":[2072825,2072752],"length":1,"stats":{"Line":8},"fn_name":null},{"line":195,"address":[2072855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[2072831],"length":1,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[2073027,2073857,2073289,2072952],"length":1,"stats":{"Line":16},"fn_name":null},{"line":204,"address":[2073305,2073340],"length":1,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[2073648,2073881,2073496],"length":1,"stats":{"Line":8},"fn_name":null},{"line":207,"address":[2073528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2073176],"length":1,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[2072772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[2097640,2096768,2097609],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":219,"address":[2096785],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[2096810],"length":1,"stats":{"Line":4},"fn_name":null},{"line":221,"address":[2096867,2096946],"length":1,"stats":{"Line":8},"fn_name":null},{"line":223,"address":[2096965],"length":1,"stats":{"Line":4},"fn_name":null},{"line":224,"address":[2097077,2096984],"length":1,"stats":{"Line":8},"fn_name":null},{"line":225,"address":[2097463,2097286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[2097308],"length":1,"stats":{"Line":4},"fn_name":null},{"line":231,"address":[2097416],"length":1,"stats":{"Line":4},"fn_name":null},{"line":278,"address":[2075421,2075392,2074096],"length":1,"stats":{"Line":4},"fn_name":"try_from"},{"line":281,"address":[2074216,2074126],"length":1,"stats":{"Line":8},"fn_name":null},{"line":282,"address":[2074401,2074738,2074942],"length":1,"stats":{"Line":6},"fn_name":null},{"line":283,"address":[2074515,2074957],"length":1,"stats":{"Line":8},"fn_name":null},{"line":284,"address":[2074629,2075162],"length":1,"stats":{"Line":8},"fn_name":null},{"line":285,"address":[2074353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2074305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[2097664],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":293,"address":[2097686],"length":1,"stats":{"Line":4},"fn_name":null},{"line":294,"address":[2097723],"length":1,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[2097765],"length":1,"stats":{"Line":4},"fn_name":null},{"line":296,"address":[2097813],"length":1,"stats":{"Line":4},"fn_name":null},{"line":304,"address":[2076519,2075440,2076497],"length":1,"stats":{"Line":3},"fn_name":"try_from"},{"line":305,"address":[2075457],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[2075513,2075590,2075646],"length":1,"stats":{"Line":6},"fn_name":null},{"line":308,"address":[2075608],"length":1,"stats":{"Line":3},"fn_name":null},{"line":309,"address":[2075699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[2075718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2075766,2075666],"length":1,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[2075808,2075897],"length":1,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[2075846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[2076035,2075923],"length":1,"stats":{"Line":5},"fn_name":null},{"line":319,"address":[2075988,2076055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":320,"address":[2076135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[2076160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[2076251,2076103],"length":1,"stats":{"Line":6},"fn_name":null},{"line":326,"address":[2076342],"length":1,"stats":{"Line":3},"fn_name":null},{"line":327,"address":[2076278],"length":1,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[2076294],"length":1,"stats":{"Line":3},"fn_name":null},{"line":336,"address":[2098863,2097872,2098830],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":337,"address":[2097894],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[2098009,2098086],"length":1,"stats":{"Line":6},"fn_name":null},{"line":340,"address":[2098110],"length":1,"stats":{"Line":3},"fn_name":null},{"line":341,"address":[2098133,2098208],"length":1,"stats":{"Line":6},"fn_name":null},{"line":344,"address":[2098174,2098232],"length":1,"stats":{"Line":6},"fn_name":null},{"line":346,"address":[2098292],"length":1,"stats":{"Line":3},"fn_name":null},{"line":347,"address":[2098445,2098360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[2098409,2098469],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[2098666,2098564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[2098613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":361,"address":[2076544,2078154,2078176],"length":1,"stats":{"Line":4},"fn_name":"try_from"},{"line":362,"address":[2076561],"length":1,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[2076700,2076623,2076756],"length":1,"stats":{"Line":9},"fn_name":null},{"line":365,"address":[2076718],"length":1,"stats":{"Line":4},"fn_name":null},{"line":366,"address":[2076812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[2076831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[2076950,2076874,2076776],"length":1,"stats":{"Line":8},"fn_name":null},{"line":371,"address":[2076903,2076970],"length":1,"stats":{"Line":8},"fn_name":null},{"line":372,"address":[2077071,2077016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[2077028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[2076972,2077117],"length":1,"stats":{"Line":8},"fn_name":null},{"line":377,"address":[2077146],"length":1,"stats":{"Line":4},"fn_name":null},{"line":378,"address":[2077188,2077251],"length":1,"stats":{"Line":8},"fn_name":null},{"line":379,"address":[2077287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[2077275],"length":1,"stats":{"Line":4},"fn_name":null},{"line":384,"address":[2077204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[2077412,2077477,2077330],"length":1,"stats":{"Line":12},"fn_name":null},{"line":388,"address":[2077454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[2077533],"length":1,"stats":{"Line":4},"fn_name":null},{"line":390,"address":[2077551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[2077497,2077594,2077647],"length":1,"stats":{"Line":8},"fn_name":null},{"line":394,"address":[2077612,2077674],"length":1,"stats":{"Line":8},"fn_name":null},{"line":395,"address":[2078098,2078034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[2078058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[2077849],"length":1,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[2077676],"length":1,"stats":{"Line":4},"fn_name":null},{"line":401,"address":[2077702],"length":1,"stats":{"Line":4},"fn_name":null},{"line":402,"address":[2077750],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[2077798],"length":1,"stats":{"Line":4},"fn_name":null},{"line":404,"address":[2077809],"length":1,"stats":{"Line":4},"fn_name":null},{"line":410,"address":[2099024,2099938,2099865],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":411,"address":[2099046],"length":1,"stats":{"Line":4},"fn_name":null},{"line":412,"address":[2099231,2099151],"length":1,"stats":{"Line":8},"fn_name":null},{"line":414,"address":[2099255],"length":1,"stats":{"Line":4},"fn_name":null},{"line":415,"address":[2099278,2099334],"length":1,"stats":{"Line":8},"fn_name":null},{"line":418,"address":[2099319,2099357],"length":1,"stats":{"Line":8},"fn_name":null},{"line":419,"address":[2099368,2099525],"length":1,"stats":{"Line":8},"fn_name":null},{"line":422,"address":[2099544,2099449],"length":1,"stats":{"Line":8},"fn_name":null},{"line":424,"address":[2099568],"length":1,"stats":{"Line":4},"fn_name":null},{"line":425,"address":[2099721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[2099586,2099786],"length":1,"stats":{"Line":8},"fn_name":null},{"line":430,"address":[2099810],"length":1,"stats":{"Line":4},"fn_name":null},{"line":437,"address":[2079193,2078192],"length":1,"stats":{"Line":4},"fn_name":"try_from"},{"line":438,"address":[2078209],"length":1,"stats":{"Line":4},"fn_name":null},{"line":439,"address":[2078268,2078345],"length":1,"stats":{"Line":8},"fn_name":null},{"line":440,"address":[2078363],"length":1,"stats":{"Line":4},"fn_name":null},{"line":441,"address":[2078422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[2078384,2078476],"length":1,"stats":{"Line":8},"fn_name":null},{"line":445,"address":[2078654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":446,"address":[2078667],"length":1,"stats":{"Line":4},"fn_name":null},{"line":447,"address":[2078605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[2078551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[2078678],"length":1,"stats":{"Line":4},"fn_name":null},{"line":454,"address":[2078841,2078809,2078735],"length":1,"stats":{"Line":12},"fn_name":null},{"line":455,"address":[2078879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[2078815,2078932,2079061],"length":1,"stats":{"Line":12},"fn_name":null},{"line":460,"address":[2079102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[2078984],"length":1,"stats":{"Line":4},"fn_name":null},{"line":465,"address":[2078938],"length":1,"stats":{"Line":4},"fn_name":null},{"line":466,"address":[2078949],"length":1,"stats":{"Line":4},"fn_name":null},{"line":472,"address":[2100630,2100649,2099984],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":473,"address":[2100006],"length":1,"stats":{"Line":4},"fn_name":null},{"line":474,"address":[2100104,2100181],"length":1,"stats":{"Line":8},"fn_name":null},{"line":476,"address":[2100202],"length":1,"stats":{"Line":4},"fn_name":null},{"line":477,"address":[2100266],"length":1,"stats":{"Line":4},"fn_name":null},{"line":479,"address":[2100344],"length":1,"stats":{"Line":4},"fn_name":null},{"line":480,"address":[2100474,2100575],"length":1,"stats":{"Line":8},"fn_name":null},{"line":483,"address":[2100523],"length":1,"stats":{"Line":4},"fn_name":null},{"line":496,"address":[1521637,1521632],"length":1,"stats":{"Line":12},"fn_name":"update\u003cgosling::identity_server::IdentityServer\u003e"},{"line":498,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[2080260,2079216],"length":1,"stats":{"Line":2},"fn_name":"get_message_overhead"},{"line":539,"address":[2079233,2079463],"length":1,"stats":{"Line":4},"fn_name":null},{"line":542,"address":[2079419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":546,"address":[2079839,2079897],"length":1,"stats":{"Line":4},"fn_name":null},{"line":547,"address":[2080170,2079905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[2080058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[2080026,2080206],"length":1,"stats":{"Line":4},"fn_name":null},{"line":554,"address":[2081974,2080288,2082026],"length":1,"stats":{"Line":0},"fn_name":"get_error_section_size"},{"line":559,"address":[2080621,2080325,2080442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[2080570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[2080729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[2080750,2080901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[2080925,2080825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[2081090,2080956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[2081055,2081114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[2081261,2081205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[2081285,2081249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[2080315,2081293,2081558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[2081446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[2081414,2081597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[2084045,2083940,2082064],"length":1,"stats":{"Line":2},"fn_name":"get_request_section_size"},{"line":591,"address":[2082130,2082263,2082534],"length":1,"stats":{"Line":6},"fn_name":null},{"line":593,"address":[2082399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":596,"address":[2082623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":597,"address":[2082795,2082644],"length":1,"stats":{"Line":4},"fn_name":null},{"line":600,"address":[2082719,2082819],"length":1,"stats":{"Line":4},"fn_name":null},{"line":601,"address":[2082956,2082850],"length":1,"stats":{"Line":4},"fn_name":null},{"line":604,"address":[2082975,2082944],"length":1,"stats":{"Line":4},"fn_name":null},{"line":605,"address":[2082986,2083095],"length":1,"stats":{"Line":4},"fn_name":null},{"line":608,"address":[2083060,2083119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":609,"address":[2083198,2083254],"length":1,"stats":{"Line":4},"fn_name":null},{"line":612,"address":[2083278,2083242],"length":1,"stats":{"Line":4},"fn_name":null},{"line":613,"address":[2083286,2083550,2082111],"length":1,"stats":{"Line":4},"fn_name":null},{"line":615,"address":[2083438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[2083588,2083407],"length":1,"stats":{"Line":4},"fn_name":null},{"line":620,"address":[2084080,2085341,2085360],"length":1,"stats":{"Line":2},"fn_name":"get_response_section_size"},{"line":621,"address":[2084203,2084102,2084511,2084390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":623,"address":[2084334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":624,"address":[2084456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":627,"address":[2084605],"length":1,"stats":{"Line":2},"fn_name":null},{"line":628,"address":[2084735,2084832],"length":1,"stats":{"Line":4},"fn_name":null},{"line":631,"address":[2084856,2084779],"length":1,"stats":{"Line":4},"fn_name":null},{"line":632,"address":[2084864,2085128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":634,"address":[2085016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[2084985,2085163],"length":1,"stats":{"Line":4},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":862,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":908,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":960,"address":[1624332,1624305,1622288],"length":1,"stats":{"Line":4},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":965,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":966,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":969,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":972,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":974,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":981,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":999,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1008,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1026,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1041,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1042,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1048,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1050,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1054,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1056,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1058,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1059,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1061,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1065,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1066,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1067,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1069,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1072,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1073,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1074,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1077,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1087,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1096,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1115,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1144,"address":[1605264,1606235],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1158,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1159,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1164,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1173,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1174,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":365,"coverable":499},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","lib.rs"],"content":"mod byte_counter;\npub mod honk_rpc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","tests","honk_rpc.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// extern crates\nuse bson::doc;\nuse data_encoding::HEXLOWER;\nuse sha3::{Digest, Sha3_256};\n\n// internal crates\nuse honk_rpc::honk_rpc::*;\n\n#[derive(Default)]\nstruct TestApiSet {\n    delay_echo_results: VecDeque\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e,\n}\n\nconst RUNTIME_ERROR_INVALID_ARG: ErrorCode = ErrorCode::Runtime(1i32);\nconst RUNTIME_ERROR_NOT_IMPLEMENTED: ErrorCode = ErrorCode::Runtime(2i32);\n\nimpl TestApiSet {\n    // returns the same string arg sent\n    fn echo_0(\n        \u0026mut self,\n        mut args: bson::document::Document,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        if let Some(bson::Bson::String(val)) = args.get_mut(\"val\") {\n            println!(\"TestApiSet::echo_0(val): val = '{}'\", val);\n            Ok(Some(bson::Bson::String(std::mem::take(val))))\n        } else {\n            Err(RUNTIME_ERROR_INVALID_ARG)\n        }\n    }\n\n    // second version of echo that isn't implemented\n    fn echo_1(\u0026mut self, _args: bson::document::Document) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        Err(RUNTIME_ERROR_NOT_IMPLEMENTED)\n    }\n\n    // same as echo but takes awhile and appends ' - Delayed!' to source string before returning\n    fn delay_echo_0(\n        \u0026mut self,\n        request_cookie: Option\u003cRequestCookie\u003e,\n        mut args: bson::document::Document,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        if let Some(bson::Bson::String(val)) = args.get_mut(\"val\") {\n            println!(\"TestApiSet::delay_echo_0(val): val = '{}'\", val);\n            // only enqueue response if a request cookie is provided\n            if let Some(request_cookie) = request_cookie {\n                val.push_str(\" - Delayed!\");\n                self.delay_echo_results.push_back((\n                    request_cookie,\n                    Some(bson::Bson::String(std::mem::take(val))),\n                    ErrorCode::Success,\n                ));\n            }\n            // async func so don't return result immediately\n            Ok(None)\n        } else {\n            Err(RUNTIME_ERROR_INVALID_ARG)\n        }\n    }\n\n    fn sha256_0(\n        \u0026mut self,\n        mut args: bson::document::Document,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        if let Some(bson::Bson::Binary(val)) = args.get_mut(\"data\") {\n            let mut sha256 = Sha3_256::new();\n            sha256.update(\u0026val.bytes);\n\n            let hash = sha256.finalize();\n\n            Ok(Some(bson::Bson::String(HEXLOWER.encode(\u0026hash))))\n        } else {\n            Err(RUNTIME_ERROR_INVALID_ARG)\n        }\n    }\n}\n\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"test\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        match (name, version) {\n            (\"echo\", 0) =\u003e self.echo_0(args),\n            (\"echo\", 1) =\u003e self.echo_1(args),\n            (\"delay_echo\", 0) =\u003e self.delay_echo_0(request_cookie, args),\n            (\"sha256\", 0) =\u003e self.sha256_0(args),\n            (name, version) =\u003e {\n                println!(\"received {{ name: '{}', version: {} }}\", name, version);\n                Err(ErrorCode::RequestFunctionInvalid)\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e {\n        self.delay_echo_results.pop_front()\n    }\n}\n\n#[test]\nfn test_honk_client_apiset() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    let mut alice = Session::new(stream1);\n    let mut pat = Session::new(stream2);\n\n    let mut test_api_set: TestApiSet = Default::default();\n    let alice_apisets: \u0026mut [\u0026mut dyn ApiSet] = \u0026mut [\u0026mut test_api_set];\n\n    //\n    // Pat calls remote test::echo_0 call\n    //\n\n    println!(\"--- pat calling test::echo(val: \\\"Hello Alice!\\\")\");\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 0, doc! {\"val\" : \"Hello Alice!\"})?;\n\n    println!(\"--- pat wits for response from alice\");\n    let mut pat_sync_call_handled: bool = false;\n    while !pat_sync_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    if let bson::Bson::String(result) = result {\n                        assert_eq!(result, \"Hello Alice!\");\n                        pat_sync_call_handled = true;\n                    }\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls remote test::echo_0 call (with wrong arg)\n    //\n    println!(\"--- pat calling test::echo(string: \\\"Hello Alice!\\\"), should fail because bad arg\");\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 0, doc! {\"string\" : \"Hello Alice!\"})?;\n\n    println!(\"--- pat waits for response from alice\");\n    let mut pat_bad_call_handled: bool = false;\n    while !pat_bad_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\"received unexpected result: {}, cookie: {}\", result, cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    assert_eq!(error_code, RUNTIME_ERROR_INVALID_ARG);\n                    println!(\"--- pat received invlaid arg response\");\n                    pat_bad_call_handled = true;\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls v2 remote test::echo_1 call (which is not implemented)\n    //\n    println!(\n        \"--- pat calling test::echo_1(val: \\\"Hello Again!\\\"), should fail because not implemented\"\n    );\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 1, doc! {\"val\" : \"Hello Again!\"})?;\n\n    println!(\"--- pat waits for response from alice\");\n    let mut pat_bad_call_handled: bool = false;\n    while !pat_bad_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\"received unexpected result: {}, cookie: {}\", result, cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    assert_eq!(error_code, RUNTIME_ERROR_NOT_IMPLEMENTED);\n                    println!(\"--- pat received not implemented response\");\n                    pat_bad_call_handled = true;\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls test::delay_echo_0 which goes through the async machinery\n    //\n    println!(\"--- pat calling test::delay_echo(val: \\\"Hello Delayed?\\\"), should succeed\");\n    let sent_cookie = pat.client_call(\"test\", \"delay_echo\", 0, doc! {\"val\" : \"Hello Delayed?\"})?;\n\n    println!(\"--- pat waits for ack from alice\");\n    let mut pat_async_call_acked: bool = false;\n    while !pat_async_call_acked {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    println!(\"--- pat received pending response\");\n                    pat_async_call_acked = true;\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\"received unexpected sucess: {}, cookie: {}\", result, cookie);\n                }\n            }\n        }\n    }\n\n    println!(\"--- pat waits for alice response\");\n    let mut pat_async_call_handled: bool = false;\n    while !pat_async_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    if let bson::Bson::String(result) = result {\n                        assert_eq!(result, \"Hello Delayed? - Delayed!\");\n                        println!(\"--- pat received success response\");\n                        pat_async_call_handled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    println!(\"--- pat calling test::sha256(data: [0x00..])\");\n    let mut args: bson::document::Document = Default::default();\n    let data = vec![0u8; DEFAULT_MAX_MESSAGE_SIZE / 2];\n    args.insert(\n        \"data\",\n        bson::Bson::Binary(bson::Binary {\n            subtype: bson::spec::BinarySubtype::Generic,\n            bytes: data,\n        }),\n    );\n\n    let cookie1 = pat.client_call(\"test\", \"sha256\", 0, args)?;\n\n    println!(\"--- pat calling test::sha256(data: [0xff..])\");\n    let mut args: bson::document::Document = Default::default();\n    let data = vec![0xFFu8; DEFAULT_MAX_MESSAGE_SIZE / 2];\n    args.insert(\n        \"data\",\n        bson::Bson::Binary(bson::Binary {\n            subtype: bson::spec::BinarySubtype::Generic,\n            bytes: data,\n        }),\n    );\n\n    let cookie2 = pat.client_call(\"test\", \"sha256\", 0, args)?;\n\n    println!(\"--- pat waits for alice responses\");\n    let mut pat_0x00_buffer_hashed: bool = false;\n    let mut pat_0xff_buffer_hashed: bool = false;\n\n    while !pat_0x00_buffer_hashed || !pat_0xff_buffer_hashed {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        for response in pat.client_drain_responses() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    println!(\"cookie: {}, result: {}\", cookie, result);\n                    if let bson::Bson::String(result) = result {\n                        if cookie == cookie1 {\n                            pat_0x00_buffer_hashed = true;\n                            assert_eq!(\n                                result,\n                                \"463c61ad03873aa9e82581205205acc3d3c8346c7037c43e4e241ee529f2dc27\"\n                            );\n                            println!(\"--- pat received 0x00 buffer hash\");\n                        } else if cookie == cookie2 {\n                            assert_eq!(\n                                result,\n                                \"9bd2dc706dd5251ae8fad858931585c71a1b4587aa7ecb30e15880e1b9dcda16\"\n                            );\n                            pat_0xff_buffer_hashed = true;\n                            println!(\"--- pat received 0xff buffer hash\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":23,"address":[499949,499408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[499627,499446,499520],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[499726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[499790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[499596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[499984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[500012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[500064,500956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[500191,500298,500117,500557],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[500397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[500467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[500492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[500764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[500562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[500753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[500521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[500267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[501767,500992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[501104,501030,501211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[501243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[501260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[501297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[501447,501319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[501180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[501792],"length":1,"stats":{"Line":1},"fn_name":"namespace"},{"line":86,"address":[503112,501824,503083],"length":1,"stats":{"Line":1},"fn_name":"exec_function"},{"line":93,"address":[502414,502096,502676,501933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[501970,502051,502342,502139],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[502248,502363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[502057,502369,502449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[502375,502552,502701],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[502558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[502911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[503008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[503136],"length":1,"stats":{"Line":1},"fn_name":"next_result"},{"line":106,"address":[503153],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":36},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","fuzz","fuzz_targets","fuzz_crypto.rs"],"content":"#![no_main]\n\n// tor_interface\nuse tor_interface::tor_crypto::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\n#[derive(Arbitrary, Debug)]\nstruct CryptoData\u003c'a\u003e {\n    ed25519_public_raw: [u8; 32],\n    onion_service_id: \u0026'a str,\n    x25519_public_raw: [u8; 32],\n    message_1: \u0026'a [u8],\n    message_2: \u0026'a [u8],\n    ed25519_private_raw_1: [u8; 64],\n    ed25519_private_raw_2: [u8; 64],\n    x25519_private_raw_1: [u8; 32],\n    x25519_private_raw_2: [u8; 32],\n}\n\nfuzz_target!(|data: CryptoData| {\n\n    //\n    // ed25519 tests\n    //\n\n    // ensure random bytes don't break ed25519public from_raw\n    let _ = Ed25519PublicKey::from_raw(\u0026data.ed25519_public_raw);\n\n    // ensure random string doesn't break v3onionserviceid from_string\n    let _ = V3OnionServiceId::from_string(data.onion_service_id);\n\n    // ensure random bytes don't break x25519public from_raw\n    let _ = X25519PublicKey::from_raw(\u0026data.x25519_public_raw);\n\n    // try to build key from raw binary blob, return early if invalid\n    if let Ok(ed25519_private_1) = Ed25519PrivateKey::from_raw(\u0026data.ed25519_private_raw_1) {\n        // ensure key round-trips through keyblob representation\n        assert_eq!(Ed25519PrivateKey::from_key_blob(ed25519_private_1.to_key_blob().as_ref()).unwrap(), ed25519_private_1);\n\n        // ensure key round-trips through raw bytes representation\n        match Ed25519PrivateKey::from_raw(\u0026ed25519_private_1.to_bytes()) {\n            Ok(ed25519_private) =\u003e assert_eq!(ed25519_private, ed25519_private_1),\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        }\n\n        // derive private keys public key\n        let ed25519_public_1 = Ed25519PublicKey::from_private_key(\u0026ed25519_private_1);\n\n        // compare onion service id derivation from public vs privat ekey\n        assert_eq!(V3OnionServiceId::from_private_key(\u0026ed25519_private_1), V3OnionServiceId::from_public_key(\u0026ed25519_public_1));\n        let onion_service_id_1 = V3OnionServiceId::from_public_key(\u0026ed25519_public_1);\n        // ensure service id round-trips through string representation\n        assert_eq!(V3OnionServiceId::from_string(\u0026onion_service_id_1.to_string()).unwrap(), onion_service_id_1);\n\n        // ensure public key round-trips through service id\n        assert_eq!(ed25519_public_1, Ed25519PublicKey::from_service_id(\u0026V3OnionServiceId::from_public_key(\u0026ed25519_public_1)).unwrap());\n\n        // ensure key round-trips through raw bytes representation\n        assert_eq!(ed25519_public_1, Ed25519PublicKey::from_raw(ed25519_public_1.as_bytes()).unwrap());\n\n        // sign and verify a message\n        let ed25519_signature_1 = ed25519_private_1.sign_message(data.message_1);\n        assert!(ed25519_signature_1.verify(data.message_1, \u0026ed25519_public_1));\n        // verify signature does not work for unrelated message\n        if data.message_1 != data.message_2 {\n            assert!(!ed25519_signature_1.verify(data.message_2, \u0026ed25519_public_1));\n        }\n\n        // ensure we can't verfify another key's signature\n        if data.ed25519_private_raw_1 != data.ed25519_private_raw_2 {\n            // try to build key from raw binary blob, return early if invalid\n            if let Ok(ed25519_private_2) = Ed25519PrivateKey::from_raw(\u0026data.ed25519_private_raw_2) {\n\n                // ensure key round-trips through keyblob representation\n                assert_eq!(Ed25519PrivateKey::from_key_blob(ed25519_private_2.to_key_blob().as_ref()).unwrap(), ed25519_private_2);\n\n                // ensure key round-trips through raw bytes representation\n                match Ed25519PrivateKey::from_raw(\u0026ed25519_private_2.to_bytes()) {\n                    Ok(ed25519_private) =\u003e assert_eq!(ed25519_private, ed25519_private_2),\n                    Err(err) =\u003e panic!(\"{:?}\", err),\n                }\n\n                // derive private key's public key\n                let ed25519_public_2 = Ed25519PublicKey::from_private_key(\u0026ed25519_private_2);\n\n                // compare onion service id derivation from public vs privat ekey\n                assert_eq!(V3OnionServiceId::from_private_key(\u0026ed25519_private_2), V3OnionServiceId::from_public_key(\u0026ed25519_public_2));\n                let onion_service_id_2 = V3OnionServiceId::from_public_key(\u0026ed25519_public_2);\n                // ensure service id round-trips through string representation\n                assert_eq!(V3OnionServiceId::from_string(\u0026onion_service_id_2.to_string()).unwrap(), onion_service_id_2);\n\n                // ensure public key round-trips through service id\n                assert_eq!(ed25519_public_2, Ed25519PublicKey::from_service_id(\u0026V3OnionServiceId::from_public_key(\u0026ed25519_public_2)).unwrap());\n\n                // ensure key round-trips through raw bytes representation\n                assert_eq!(ed25519_public_2, Ed25519PublicKey::from_raw(ed25519_public_2.as_bytes()).unwrap());\n\n\n                // sign and verify a message\n                let ed25519_signature_2 = ed25519_private_2.sign_message(data.message_2);\n                assert!(ed25519_signature_2.verify(data.message_2, \u0026ed25519_public_2));\n\n                // verify signature does not work for unrelated message\n                if data.message_1 != data.message_2 {\n                    assert!(!ed25519_signature_2.verify(data.message_1, \u0026ed25519_public_2));\n                }\n\n                // verify we cannot verify signatures using the wrong public keys\n                if ed25519_public_1 != ed25519_public_2 {\n                    assert!(!ed25519_signature_1.verify(data.message_1, \u0026ed25519_public_2));\n                    assert!(!ed25519_signature_2.verify(data.message_2, \u0026ed25519_public_1));\n                }\n            }\n        }\n    }\n\n    //\n    // x25519 tests\n    //\n\n    if let Ok(x25519_private_1) = X25519PrivateKey::from_raw(\u0026data.x25519_private_raw_1) {\n        // ensure round-trips through byte representation\n        assert_eq!(x25519_private_1, X25519PrivateKey::from_raw(\u0026x25519_private_1.to_bytes()).unwrap());\n        assert_eq!(data.x25519_private_raw_1, x25519_private_1.to_bytes());\n        // ensure round-trips through base64 representation\n        assert_eq!(x25519_private_1, X25519PrivateKey::from_base64(\u0026x25519_private_1.to_base64()).unwrap());\n\n        // ensure converts to e25519 without issue\n        let _ = Ed25519PrivateKey::from_private_x25519(\u0026x25519_private_1).unwrap();\n\n        let x25519_public_1 = X25519PublicKey::from_private_key(\u0026x25519_private_1);\n        // ensure round-trips through byte representation\n        assert_eq!(x25519_public_1, X25519PublicKey::from_raw(x25519_public_1.as_bytes()));\n        // ensure round-trips through base32 representation\n        assert_eq!(x25519_public_1, X25519PublicKey::from_base32(\u0026x25519_public_1.to_base32()).unwrap());\n\n        if let Ok(x25519_private_2) = X25519PrivateKey::from_raw(\u0026data.x25519_private_raw_2) {\n            // ensure round-trips through byte representation\n            assert_eq!(x25519_private_2, X25519PrivateKey::from_raw(\u0026x25519_private_2.to_bytes()).unwrap());\n            assert_eq!(data.x25519_private_raw_2, x25519_private_2.to_bytes());\n            // ensure round-trips through base64 representation\n            assert_eq!(x25519_private_2, X25519PrivateKey::from_base64(\u0026x25519_private_2.to_base64()).unwrap());\n\n            // ensure converts to e25519 without issue\n            let _ = Ed25519PrivateKey::from_private_x25519(\u0026x25519_private_2).unwrap();\n\n            let x25519_public_2 = X25519PublicKey::from_private_key(\u0026x25519_private_2);\n            // ensure round-trips through byte representation\n            assert_eq!(x25519_public_2, X25519PublicKey::from_raw(x25519_public_2.as_bytes()));\n            // ensure round-trips through base32 representation\n            assert_eq!(x25519_public_2, X25519PublicKey::from_base32(\u0026x25519_public_2.to_base32()).unwrap());\n        }\n    }\n\n\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_client.rs"],"content":"// standard\nuse std::boxed::Box;\nuse std::collections::BTreeMap;\nuse std::convert::From;\nuse std::default::Default;\nuse std::io::ErrorKind;\nuse std::net::{SocketAddr, TcpListener};\nuse std::ops::Drop;\nuse std::option::Option;\nuse std::path::Path;\nuse std::string::ToString;\nuse std::sync::{atomic, Arc};\nuse std::time::Duration;\n\n// extern crates\nuse socks::Socks5Stream;\n\n// internal crates\nuse crate::legacy_tor_control_stream::*;\nuse crate::legacy_tor_controller::*;\nuse crate::legacy_tor_process::*;\nuse crate::legacy_tor_version::*;\nuse crate::tor_crypto::*;\nuse crate::tor_provider;\nuse crate::tor_provider::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to create LegacyTorProcess object\")]\n    LegacyTorProcessCreationFailed(#[source] crate::legacy_tor_process::Error),\n\n    #[error(\"failed to create LegacyControlStream object\")]\n    LegacyControlStreamCreationFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"failed to create LegacyTorController object\")]\n    LegacyTorControllerCreationFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to authenticate with the tor process\")]\n    LegacyTorProcessAuthenticationFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to determine the tor process version\")]\n    GetInfoVersionFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"tor process version to old; found {0} but must be at least {1}\")]\n    LegacyTorProcessTooOld(String, String),\n\n    #[error(\"failed to register for STATUS_CLIENT and HS_DESC events\")]\n    SetEventsFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to delete unused onion service\")]\n    DelOnionFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed waiting for async events\")]\n    WaitAsyncEventsFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to begin bootstrap\")]\n    SetConfDisableNetwork0Failed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to add client auth for onion service\")]\n    OnionClientAuthAddFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to remove client auth from onion service\")]\n    OnionClientAuthRemoveFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to get socks listener\")]\n    GetInfoNetListenersSocksFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"no socks listeners available to connect through\")]\n    NoSocksListenersFound(),\n\n    #[error(\"invalid circuit token\")]\n    CircuitTokenInvalid(),\n\n    #[error(\"unable to connect to socks listener\")]\n    Socks5ConnectionFailed(#[source] std::io::Error),\n\n    #[error(\"unable to bind TCP listener\")]\n    TcpListenerBindFailed(#[source] std::io::Error),\n\n    #[error(\"unable to get TCP listener's local address\")]\n    TcpListenerLocalAddrFailed(#[source] std::io::Error),\n\n    #[error(\"failed to create onion service\")]\n    AddOnionFailed(#[source] crate::legacy_tor_controller::Error),\n}\n\nimpl From\u003cError\u003e for crate::tor_provider::Error {\n    fn from(error: Error) -\u003e Self {\n        crate::tor_provider::Error::Generic(error.to_string())\n    }\n}\n\n//\n// CircuitToken Implementation\n//\nstruct LegacyCircuitToken {\n    username: String,\n    password: String,\n}\n\nimpl LegacyCircuitToken {\n    fn new() -\u003e LegacyCircuitToken {\n        const CIRCUIT_TOKEN_USERNAME_LENGTH: usize = 32usize;\n        const CIRCUIT_TOKEN_PASSWORD_LENGTH: usize = 32usize;\n        let username = generate_password(CIRCUIT_TOKEN_USERNAME_LENGTH);\n        let password = generate_password(CIRCUIT_TOKEN_PASSWORD_LENGTH);\n\n        LegacyCircuitToken { username, password }\n    }\n}\n\nimpl Default for LegacyCircuitToken {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n//\n// LegacyOnionListener\n//\n\npub struct LegacyOnionListener {\n    listener: TcpListener,\n    is_active: Arc\u003catomic::AtomicBool\u003e,\n    onion_addr: OnionAddr,\n}\n\nimpl OnionListenerImpl for LegacyOnionListener {\n    fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.listener.set_nonblocking(nonblocking)\n    }\n\n    fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e {\n        match self.listener.accept() {\n            Ok((stream, _socket_addr)) =\u003e Ok(Some(OnionStream {\n                stream,\n                local_addr: Some(self.onion_addr.clone()),\n                peer_addr: None,\n            })),\n            Err(err) =\u003e {\n                if err.kind() == ErrorKind::WouldBlock {\n                    Ok(None)\n                } else {\n                    Err(err)\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for LegacyOnionListener {\n    fn drop(\u0026mut self) {\n        self.is_active.store(false, atomic::Ordering::Relaxed);\n    }\n}\n\npub struct LegacyTorClient {\n    daemon: LegacyTorProcess,\n    version: LegacyTorVersion,\n    controller: LegacyTorController,\n    socks_listener: Option\u003cSocketAddr\u003e,\n    // list of open onion services and their is_active flag\n    onion_services: Vec\u003c(V3OnionServiceId, Arc\u003catomic::AtomicBool\u003e)\u003e,\n    // our list of circuit tokens for the tor daemon\n    circuit_token_counter: usize,\n    circuit_tokens: BTreeMap\u003cCircuitToken, LegacyCircuitToken\u003e,\n}\n\nimpl LegacyTorClient {\n    pub fn new(tor_bin_path: \u0026Path, data_directory: \u0026Path) -\u003e Result\u003cLegacyTorClient, Error\u003e {\n        // launch tor\n        let daemon = LegacyTorProcess::new(tor_bin_path, data_directory)\n            .map_err(Error::LegacyTorProcessCreationFailed)?;\n        // open a control stream\n        let control_stream =\n            LegacyControlStream::new(daemon.get_control_addr(), Duration::from_millis(16))\n                .map_err(Error::LegacyControlStreamCreationFailed)?;\n\n        // create a controler\n        let mut controller = LegacyTorController::new(control_stream)\n            .map_err(Error::LegacyTorControllerCreationFailed)?;\n\n        // authenticate\n        controller\n            .authenticate(daemon.get_password())\n            .map_err(Error::LegacyTorProcessAuthenticationFailed)?;\n\n        // min required version for v3 client auth (see control-spec.txt)\n        let min_required_version = LegacyTorVersion {\n            major: 0u32,\n            minor: 4u32,\n            micro: 6u32,\n            patch_level: 1u32,\n            status_tag: None,\n        };\n\n        let version = controller\n            .getinfo_version()\n            .map_err(Error::GetInfoVersionFailed)?;\n\n        if version \u003c min_required_version {\n            return Err(Error::LegacyTorProcessTooOld(\n                version.to_string(),\n                min_required_version.to_string(),\n            ));\n        }\n\n        // register for STATUS_CLIENT async events\n        controller\n            .setevents(\u0026[\"STATUS_CLIENT\", \"HS_DESC\"])\n            .map_err(Error::SetEventsFailed)?;\n\n        Ok(LegacyTorClient {\n            daemon,\n            version,\n            controller,\n            socks_listener: None,\n            onion_services: Default::default(),\n            circuit_token_counter: 0usize,\n            circuit_tokens: Default::default(),\n        })\n    }\n\n    #[allow(dead_code)]\n    pub fn version(\u0026mut self) -\u003e LegacyTorVersion {\n        self.version.clone()\n    }\n}\n\nimpl TorProvider for LegacyTorClient {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, tor_provider::Error\u003e {\n        let mut i = 0;\n        while i \u003c self.onion_services.len() {\n            // remove onion services with no active listeners\n            if !self.onion_services[i].1.load(atomic::Ordering::Relaxed) {\n                let entry = self.onion_services.swap_remove(i);\n                let service_id = entry.0;\n\n                self.controller\n                    .del_onion(\u0026service_id)\n                    .map_err(Error::DelOnionFailed)?;\n            } else {\n                i += 1;\n            }\n        }\n\n        let mut events: Vec\u003cTorEvent\u003e = Default::default();\n        for async_event in self\n            .controller\n            .wait_async_events()\n            .map_err(Error::WaitAsyncEventsFailed)?\n            .iter()\n        {\n            match async_event {\n                AsyncEvent::StatusClient {\n                    severity,\n                    action,\n                    arguments,\n                } =\u003e {\n                    if severity == \"NOTICE\" \u0026\u0026 action == \"BOOTSTRAP\" {\n                        let mut progress: u32 = 0;\n                        let mut tag: String = Default::default();\n                        let mut summary: String = Default::default();\n                        for (key, val) in arguments.iter() {\n                            match key.as_str() {\n                                \"PROGRESS\" =\u003e progress = val.parse().unwrap_or(0u32),\n                                \"TAG\" =\u003e tag = val.to_string(),\n                                \"SUMMARY\" =\u003e summary = val.to_string(),\n                                _ =\u003e {} // ignore unexpected arguments\n                            }\n                        }\n                        events.push(TorEvent::BootstrapStatus {\n                            progress,\n                            tag,\n                            summary,\n                        });\n                        if progress == 100u32 {\n                            events.push(TorEvent::BootstrapComplete);\n                        }\n                    }\n                }\n                AsyncEvent::HsDesc { action, hs_address } =\u003e {\n                    if action == \"UPLOADED\" {\n                        events.push(TorEvent::OnionServicePublished {\n                            service_id: hs_address.clone(),\n                        });\n                    }\n                }\n                AsyncEvent::Unknown { lines } =\u003e {\n                    println!(\"Received Unknown Event:\");\n                    for line in lines.iter() {\n                        println!(\" {}\", line);\n                    }\n                }\n            }\n        }\n\n        for log_line in self.daemon.wait_log_lines().iter_mut() {\n            events.push(TorEvent::LogReceived {\n                line: std::mem::take(log_line),\n            });\n        }\n\n        Ok(events)\n    }\n\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Ok(self\n            .controller\n            .setconf(\u0026[(\"DisableNetwork\", \"0\")])\n            .map_err(Error::SetConfDisableNetwork0Failed)?)\n    }\n\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Ok(self\n            .controller\n            .onion_client_auth_add(service_id, client_auth, None, \u0026Default::default())\n            .map_err(Error::OnionClientAuthAddFailed)?)\n    }\n\n    fn remove_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Ok(self\n            .controller\n            .onion_client_auth_remove(service_id)\n            .map_err(Error::OnionClientAuthRemoveFailed)?)\n    }\n\n    // connect to an onion service and returns OnionStream\n    fn connect(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, tor_provider::Error\u003e {\n        if self.socks_listener.is_none() {\n            let mut listeners = self\n                .controller\n                .getinfo_net_listeners_socks()\n                .map_err(Error::GetInfoNetListenersSocksFailed)?;\n            if listeners.is_empty() {\n                return Err(Error::NoSocksListenersFound())?;\n            }\n            self.socks_listener = Some(listeners.swap_remove(0));\n        }\n\n        let socks_listener = match self.socks_listener {\n            Some(socks_listener) =\u003e socks_listener,\n            None =\u003e unreachable!(),\n        };\n\n        // our onion domain\n        let target = socks::TargetAddr::Domain(format!(\"{}.onion\", service_id), virt_port);\n        // readwrite stream\n        let stream = match \u0026circuit {\n            None =\u003e Socks5Stream::connect(socks_listener, target),\n            Some(circuit) =\u003e {\n                if let Some(circuit) = self.circuit_tokens.get(circuit) {\n                    Socks5Stream::connect_with_password(\n                        socks_listener,\n                        target,\n                        \u0026circuit.username,\n                        \u0026circuit.password,\n                    )\n                } else {\n                    return Err(Error::CircuitTokenInvalid())?;\n                }\n            }\n        }\n        .map_err(Error::Socks5ConnectionFailed)?;\n\n        Ok(OnionStream {\n            stream: stream.into_inner(),\n            local_addr: None,\n            peer_addr: Some(TargetAddr::OnionService(OnionAddr::V3(OnionAddrV3::new(\n                service_id.clone(),\n                virt_port,\n            )))),\n        })\n    }\n\n    // stand up an onion service and return an LegacyOnionListener\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, tor_provider::Error\u003e {\n        // try to bind to a local address, let OS pick our port\n        let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n        let listener = TcpListener::bind(socket_addr).map_err(Error::TcpListenerBindFailed)?;\n        let socket_addr = listener\n            .local_addr()\n            .map_err(Error::TcpListenerLocalAddrFailed)?;\n\n        let mut flags = AddOnionFlags {\n            discard_pk: true,\n            ..Default::default()\n        };\n        if authorized_clients.is_some() {\n            flags.v3_auth = true;\n        }\n\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(\n            V3OnionServiceId::from_private_key(private_key),\n            virt_port,\n        ));\n\n        // start onion service\n        let (_, service_id) = self\n            .controller\n            .add_onion(\n                Some(private_key),\n                \u0026flags,\n                None,\n                virt_port,\n                Some(socket_addr),\n                authorized_clients,\n            )\n            .map_err(Error::AddOnionFailed)?;\n\n        let is_active = Arc::new(atomic::AtomicBool::new(true));\n        self.onion_services\n            .push((service_id, Arc::clone(\u0026is_active)));\n\n        let onion_listener = Box::new(LegacyOnionListener {\n            listener,\n            is_active,\n            onion_addr,\n        });\n\n        Ok(OnionListener { onion_listener })\n    }\n\n    fn generate_token(\u0026mut self) -\u003e CircuitToken {\n        let new_token = self.circuit_token_counter;\n        self.circuit_token_counter += 1;\n        self.circuit_tokens\n            .insert(new_token, LegacyCircuitToken::new());\n        new_token\n    }\n\n    fn release_token(\u0026mut self, circuit_token: CircuitToken) {\n        self.circuit_tokens.remove(\u0026circuit_token);\n    }\n}\n","traces":[{"line":88,"address":[1617111,1616992],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":89,"address":[1617011,1617069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[1535072,1535253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1535101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1535116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1535280],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":114,"address":[1535288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1535312],"length":1,"stats":{"Line":0},"fn_name":"set_nonblocking"},{"line":130,"address":[1535333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1535748,1535360],"length":1,"stats":{"Line":0},"fn_name":"accept"},{"line":134,"address":[1535390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1535622,1535428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1535459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1535572,1535466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1535612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1535485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1535514,1535815,1535888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1535895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1535863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1371280],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":153,"address":[1371289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[1539474,1538998,1535968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[1536038,1536427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1536389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[1536374,1536499,1539459,1536856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1536792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1537188,1536926,1536738,1539411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1537124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[1537306,1537585,1539377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[1537263,1537101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1537521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[1537503,1537952,1539356,1537658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[1537888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1538026,1537846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1539151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1538067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[1539072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[1538032,1538483,1539048,1536006,1538097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1538419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[1538616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[1538181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[1538285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[1538341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1538379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1538389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[1538556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1539520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1539537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1541034,1539568,1543284],"length":1,"stats":{"Line":0},"fn_name":"update"},{"line":232,"address":[1539607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1539643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1539743,1543740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1543305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[1543345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[1543683,1539599,1541043,1543409,1543512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[1543619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[1543436,1543745,1543732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[1539688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[1539865,1539713,1540119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[1540055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1540425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1541126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[1541716,1541161,1542433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1541774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[1541793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1541800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[1541872,1541961,1542314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1542355,1542450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[1542992,1542466,1542537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[1542509,1542561,1542613,1542819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1542627,1542577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1542208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1542121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1542128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1542168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[1542372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1542438,1542382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1541205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1541233,1543129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[1543161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[1543154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[1541053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[1541073,1541269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1541296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[1541628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[1540517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[1540962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1540828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[1540855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[1543776],"length":1,"stats":{"Line":0},"fn_name":"bootstrap"},{"line":308,"address":[1543793,1543936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[1543908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[1543984,1544377,1544345],"length":1,"stats":{"Line":0},"fn_name":"add_client_auth"},{"line":319,"address":[1544011,1544158,1544205,1544311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[1544052,1544197,1544358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[1544283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[1544400],"length":1,"stats":{"Line":0},"fn_name":"remove_client_auth"},{"line":329,"address":[1544416,1544553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[1544526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[1544592,1547325,1547037],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":342,"address":[1544666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[1544751,1544956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1544925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[1545030,1544902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[1545067,1547357,1547548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[1545036,1545188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[1544712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[1545364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[1545454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[1546324,1546636,1545609,1547068,1545830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[1545620,1545828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[1545748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[1545865,1545764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[1545923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[1545987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[1546189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[1547119,1546007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[1546572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[1546915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[1546710,1546485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[1546717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[1546793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[1546727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[1547552,1549802,1549763],"length":1,"stats":{"Line":0},"fn_name":"listener"},{"line":396,"address":[1547642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[1547755,1547967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[1549790,1547940,1548267,1548068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[1548203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[1548416,1548490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[1548482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[1548500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[1548463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[1549772,1548618,1548688,1549076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[1548622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[1548630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[1548640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[1548672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[1548993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[1549110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[1549199,1549377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[1549210,1549305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1549427,1549641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[1549396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[1549411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[1549649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[1549840],"length":1,"stats":{"Line":0},"fn_name":"generate_token"},{"line":442,"address":[1549860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1549991,1549880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[1549951,1549920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[1549967,1549931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[1550032],"length":1,"stats":{"Line":0},"fn_name":"release_token"},{"line":450,"address":[1550052],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":152},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_control_stream.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::default::Default;\nuse std::io::{ErrorKind, Read, Write};\nuse std::net::{SocketAddr, TcpStream};\nuse std::option::Option;\nuse std::string::ToString;\nuse std::time::Duration;\n\n// extern crates\nuse regex::Regex;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"control stream read timeout must not be zero\")]\n    ReadTimeoutZero(),\n\n    #[error(\"could not connect to control port\")]\n    CreationFailed(#[source] std::io::Error),\n\n    #[error(\"configure control port socket failed\")]\n    ConfigurationFailed(#[source] std::io::Error),\n\n    #[error(\"control port parsing regex creation failed\")]\n    ParsingRegexCreationFailed(#[source] regex::Error),\n\n    #[error(\"control port stream read failure\")]\n    ReadFailed(#[source] std::io::Error),\n\n    #[error(\"control port stream closed by remote\")]\n    ClosedByRemote(),\n\n    #[error(\"received control port response invalid utf8\")]\n    InvalidResponse(#[source] std::str::Utf8Error),\n\n    #[error(\"failed to parse control port reply: {0}\")]\n    ReplyParseFailed(String),\n\n    #[error(\"control port stream write failure\")]\n    WriteFailed(#[source] std::io::Error),\n}\n\npub(crate) struct LegacyControlStream {\n    stream: TcpStream,\n    closed_by_remote: bool,\n    pending_data: Vec\u003cu8\u003e,\n    pending_lines: VecDeque\u003cString\u003e,\n    pending_reply: Vec\u003cString\u003e,\n    reading_multiline_value: bool,\n    // regexes used to parse control port responses\n    single_line_data: Regex,\n    multi_line_data: Regex,\n    end_reply_line: Regex,\n}\n\ntype StatusCode = u32;\npub(crate) struct Reply {\n    pub status_code: StatusCode,\n    pub reply_lines: Vec\u003cString\u003e,\n}\n\nimpl LegacyControlStream {\n    pub fn new(addr: \u0026SocketAddr, read_timeout: Duration) -\u003e Result\u003cLegacyControlStream, Error\u003e {\n        if read_timeout.is_zero() {\n            return Err(Error::ReadTimeoutZero());\n        }\n\n        let stream = TcpStream::connect(addr).map_err(Error::CreationFailed)?;\n        stream\n            .set_read_timeout(Some(read_timeout))\n            .map_err(Error::ConfigurationFailed)?;\n\n        // pre-allocate a kilobyte for the read buffer\n        const READ_BUFFER_SIZE: usize = 1024;\n        let pending_data = Vec::with_capacity(READ_BUFFER_SIZE);\n\n        let single_line_data =\n            Regex::new(r\"^\\d\\d\\d-.*\").map_err(Error::ParsingRegexCreationFailed)?;\n        let multi_line_data =\n            Regex::new(r\"^\\d\\d\\d+.*\").map_err(Error::ParsingRegexCreationFailed)?;\n        let end_reply_line =\n            Regex::new(r\"^\\d\\d\\d .*\").map_err(Error::ParsingRegexCreationFailed)?;\n\n        Ok(LegacyControlStream {\n            stream,\n            closed_by_remote: false,\n            pending_data,\n            pending_lines: Default::default(),\n            pending_reply: Default::default(),\n            reading_multiline_value: false,\n            // regex\n            single_line_data,\n            multi_line_data,\n            end_reply_line,\n        })\n    }\n\n    #[cfg(test)]\n    pub(crate) fn closed_by_remote(\u0026mut self) -\u003e bool {\n        self.closed_by_remote\n    }\n\n    fn read_line(\u0026mut self) -\u003e Result\u003cOption\u003cString\u003e, Error\u003e {\n        // read pending bytes from stream until we have a line to return\n        while self.pending_lines.is_empty() {\n            let byte_count = self.pending_data.len();\n            match self.stream.read_to_end(\u0026mut self.pending_data) {\n                Err(err) =\u003e {\n                    if err.kind() == ErrorKind::WouldBlock || err.kind() == ErrorKind::TimedOut {\n                        if byte_count == self.pending_data.len() {\n                            return Ok(None);\n                        }\n                    } else {\n                        return Err(Error::ReadFailed(err));\n                    }\n                }\n                Ok(0usize) =\u003e {\n                    self.closed_by_remote = true;\n                    return Err(Error::ClosedByRemote());\n                }\n                Ok(_count) =\u003e (),\n            }\n\n            // split our read buffer into individual lines\n            let mut begin = 0;\n            for index in 1..self.pending_data.len() {\n                if self.pending_data[index - 1] == b'\\r' \u0026\u0026 self.pending_data[index] == b'\\n' {\n                    let end = index - 1;\n                    // view into byte vec of just the found line\n                    let line_view: \u0026[u8] = \u0026self.pending_data[begin..end];\n                    // convert to string\n                    let line_string =\n                        std::str::from_utf8(line_view).map_err(Error::InvalidResponse)?;\n\n                    // save in pending list\n                    self.pending_lines.push_back(line_string.to_string());\n                    // update begin (and skip over \\r\\n)\n                    begin = end + 2;\n                }\n            }\n            // leave any leftover bytes in the buffer for the next call\n            self.pending_data.drain(0..begin);\n        }\n\n        Ok(self.pending_lines.pop_front())\n    }\n\n    pub fn read_reply(\u0026mut self) -\u003e Result\u003cOption\u003cReply\u003e, Error\u003e {\n        loop {\n            let current_line = match self.read_line()? {\n                Some(line) =\u003e line,\n                None =\u003e return Ok(None),\n            };\n\n            // make sure the status code matches (if we are not in the\n            // middle of a multi-line read\n            if let Some(first_line) = self.pending_reply.first() {\n                if !self.reading_multiline_value {\n                    let first_status_code = \u0026first_line[0..3];\n                    let current_status_code = \u0026current_line[0..3];\n                    if first_status_code != current_status_code {\n                        return Err(Error::ReplyParseFailed(format!(\n                            \"mismatched status codes, {} != {}\",\n                            first_status_code, current_status_code\n                        )));\n                    }\n                }\n            }\n\n            // end of a response\n            if self.end_reply_line.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found multi-line end reply but not reading a multi-line reply\".to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n                break;\n            // single line data from getinfo and friends\n            } else if self.single_line_data.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found single-line reply but still reading a multi-line reply\".to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n            // begin of multiline data from getinfo and friends\n            } else if self.multi_line_data.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found multi-line start reply but still reading a multi-line reply\"\n                            .to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n                self.reading_multiline_value = true;\n            // multiline data to be squashed to a single entry\n            } else {\n                if !self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found a multi-line intermediate reply but not reading a multi-line reply\"\n                            .to_string(),\n                    ));\n                }\n                // don't bother writing the end of multiline token\n                if current_line == \".\" {\n                    self.reading_multiline_value = false;\n                } else {\n                    let multiline = match self.pending_reply.last_mut() {\n                        Some(multiline) =\u003e multiline,\n                        // if our logic here is right, then\n                        // self.reading_multiline_value == !self.pending_reply.is_empty()\n                        // should always be true regardless of the data received\n                        // from the control port\n                        None =\u003e unreachable!(),\n                    };\n                    multiline.push('\\n');\n                    multiline.push_str(\u0026current_line);\n                }\n            }\n        }\n\n        // take ownership of the reply lines\n        let mut reply_lines: Vec\u003cString\u003e = Default::default();\n        std::mem::swap(\u0026mut self.pending_reply, \u0026mut reply_lines);\n\n        // parse out the response code for easier matching\n        let status_code_string = match reply_lines.first() {\n            Some(line) =\u003e line[0..3].to_string(),\n            // the lines have already been parsed+validated in the above loop\n            None =\u003e unreachable!(),\n        };\n        let status_code: u32 = match status_code_string.parse() {\n            Ok(status_code) =\u003e status_code,\n            Err(_) =\u003e {\n                return Err(Error::ReplyParseFailed(format!(\n                    \"unable to parse '{}' as status code\",\n                    status_code_string\n                )))\n            }\n        };\n\n        // strip the redundant status code from start of lines\n        for line in reply_lines.iter_mut() {\n            if line.starts_with(\u0026status_code_string) {\n                *line = line[4..].to_string();\n            }\n        }\n\n        Ok(Some(Reply {\n            status_code,\n            reply_lines,\n        }))\n    }\n\n    pub fn write(\u0026mut self, cmd: \u0026str) -\u003e Result\u003c(), Error\u003e {\n        if let Err(err) = write!(self.stream, \"{}\\r\\n\", cmd) {\n            self.closed_by_remote = true;\n            return Err(Error::WriteFailed(err));\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":63,"address":[1379568,1377344,1379737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1377383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1377506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1377418,1377656,1377569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1377779,1377366,1377616,1377912,1379722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1377592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1377880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1377851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1377941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1378456,1379656,1378150,1378291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1378777,1378420,1378561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1379139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1378694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1378713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1378753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1378882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1378947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[1379011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1379075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1027456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[1027461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[1379776,1381359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1379806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1379911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1379935,1379979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1379989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1380012,1380251,1380338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1380495,1380315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1380529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1380386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1380036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[1380043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[1380107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1380125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[1380137,1380592,1380715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1380736,1381300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1380857,1381063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1380902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1380974,1381096,1381197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1381128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1381305,1381174,1381292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1380638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1379838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[1381392,1385833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1384054,1381431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1381455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[1381793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1381710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[1381966,1381865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1382062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[1382135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[1382237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[1382347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[1382619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[1382079,1382879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[1382965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1385882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1384274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1384211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1382914,1383007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1383093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[1384083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[1384014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1384041,1383951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1383135,1383810,1383042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[1383189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1383823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1383768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[1383705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[1383803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[1383170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[1383274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1383207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[1383461,1383401,1383234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[1383454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[1383415,1383482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[1383576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1383605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1383622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[1384312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1384361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1384417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1384565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1384690,1384773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[1384842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1385624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[1384983,1384860,1385304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[1385325,1385376,1385609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1385417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[1385183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1385143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[1386032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1386143,1386071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1386255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[1386262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1386341],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":96},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_controller.rs"],"content":"// standard\nuse std::default::Default;\nuse std::net::SocketAddr;\nuse std::option::Option;\n#[cfg(test)]\nuse std::path::Path;\nuse std::str::FromStr;\nuse std::string::ToString;\n#[cfg(test)]\nuse std::time::{Duration, Instant};\n\n// extern crates\nuse regex::Regex;\n#[cfg(test)]\nuse serial_test::serial;\n\n// internal crates\nuse crate::legacy_tor_control_stream::*;\n#[cfg(test)]\nuse crate::legacy_tor_process::*;\nuse crate::legacy_tor_version::*;\nuse crate::tor_crypto::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"response regex creation failed\")]\n    ParsingRegexCreationFailed(#[source] regex::Error),\n\n    #[error(\"control stream read reply failed\")]\n    ReadReplyFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"unexpected synchronous reply recieved\")]\n    UnexpectedSynchonousReplyReceived(),\n\n    #[error(\"control stream write command failed\")]\n    WriteCommandFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"invalid command arguments: {0}\")]\n    InvalidCommandArguments(String),\n\n    #[error(\"command failed: {0} {}\", .1.join(\"\\n\"))]\n    CommandFailed(u32, Vec\u003cString\u003e),\n\n    #[error(\"failed to parse command reply: {0}\")]\n    CommandReplyParseFailed(String),\n\n    #[error(\"failed to parse received tor version\")]\n    TorVersionParseFailed(#[source] crate::legacy_tor_version::Error),\n}\n\n// Per-command data\n#[derive(Default)]\npub(crate) struct AddOnionFlags {\n    pub discard_pk: bool,\n    pub detach: bool,\n    pub v3_auth: bool,\n    pub non_anonymous: bool,\n    pub max_streams_close_circuit: bool,\n}\n\n#[derive(Default)]\npub(crate) struct OnionClientAuthAddFlags {\n    pub permanent: bool,\n}\n\npub(crate) enum AsyncEvent {\n    Unknown {\n        lines: Vec\u003cString\u003e,\n    },\n    StatusClient {\n        severity: String,\n        action: String,\n        arguments: Vec\u003c(String, String)\u003e,\n    },\n    HsDesc {\n        action: String,\n        hs_address: V3OnionServiceId,\n    },\n}\n\npub(crate) struct LegacyTorController {\n    // underlying control stream\n    control_stream: LegacyControlStream,\n    // list of async replies to be handled\n    async_replies: Vec\u003cReply\u003e,\n    // regex for parsing events\n    status_event_pattern: Regex,\n    status_event_argument_pattern: Regex,\n    hs_desc_pattern: Regex,\n}\n\nimpl LegacyTorController {\n    pub fn new(control_stream: LegacyControlStream) -\u003e Result\u003cLegacyTorController, Error\u003e {\n        let status_event_pattern =\n            Regex::new(r#\"^STATUS_CLIENT (?P\u003cseverity\u003eNOTICE|WARN|ERR) (?P\u003caction\u003e[A-Za-z]+)\"#)\n                .map_err(Error::ParsingRegexCreationFailed)?;\n        let status_event_argument_pattern =\n            Regex::new(r#\"(?P\u003ckey\u003e[A-Z]+)=(?P\u003cvalue\u003e[A-Za-z0-9_]+|\"[^\"]+\")\"#)\n                .map_err(Error::ParsingRegexCreationFailed)?;\n        let hs_desc_pattern = Regex::new(\n            r#\"HS_DESC (?P\u003caction\u003eREQUESTED|UPLOAD|RECEIVED|UPLOADED|IGNORE|FAILED|CREATED) (?P\u003chsaddress\u003e[a-z2-7]{56})\"#\n        ).map_err(Error::ParsingRegexCreationFailed)?;\n\n        Ok(LegacyTorController {\n            control_stream,\n            async_replies: Default::default(),\n            // regex\n            status_event_pattern,\n            status_event_argument_pattern,\n            hs_desc_pattern,\n        })\n    }\n\n    // return curently available events, does not block waiting\n    // for an event\n    fn wait_async_replies(\u0026mut self) -\u003e Result\u003cVec\u003cReply\u003e, Error\u003e {\n        let mut replies: Vec\u003cReply\u003e = Default::default();\n        // take any previously received async replies\n        std::mem::swap(\u0026mut self.async_replies, \u0026mut replies);\n\n        // and keep consuming until none are available\n        loop {\n            if let Some(reply) = self\n                .control_stream\n                .read_reply()\n                .map_err(Error::ReadReplyFailed)?\n            {\n                replies.push(reply);\n            } else {\n                // no more replies immediately available so return\n                return Ok(replies);\n            }\n        }\n    }\n\n    fn reply_to_event(\u0026self, reply: \u0026mut Reply) -\u003e Result\u003cAsyncEvent, Error\u003e {\n        if reply.status_code != 650u32 {\n            return Err(Error::UnexpectedSynchonousReplyReceived());\n        }\n\n        // not sure this is what we want but yolo\n        let reply_text = reply.reply_lines.join(\" \");\n        if let Some(caps) = self.status_event_pattern.captures(\u0026reply_text) {\n            let severity = match caps.name(\"severity\") {\n                Some(severity) =\u003e severity.as_str(),\n                None =\u003e unreachable!(),\n            };\n            let action = match caps.name(\"action\") {\n                Some(action) =\u003e action.as_str(),\n                None =\u003e unreachable!(),\n            };\n\n            let mut arguments: Vec\u003c(String, String)\u003e = Default::default();\n            for caps in self\n                .status_event_argument_pattern\n                .captures_iter(\u0026reply_text)\n            {\n                let key = match caps.name(\"key\") {\n                    Some(key) =\u003e key.as_str(),\n                    None =\u003e unreachable!(),\n                };\n                let value = {\n                    let value = match caps.name(\"value\") {\n                        Some(value) =\u003e value.as_str(),\n                        None =\u003e unreachable!(),\n                    };\n                    if value.starts_with('\\\"') \u0026\u0026 value.ends_with('\\\"') {\n                        \u0026value[1..value.len() - 1]\n                    } else {\n                        value\n                    }\n                };\n                arguments.push((key.to_string(), value.to_string()));\n            }\n\n            return Ok(AsyncEvent::StatusClient {\n                severity: severity.to_string(),\n                action: action.to_string(),\n                arguments,\n            });\n        }\n\n        if let Some(caps) = self.hs_desc_pattern.captures(\u0026reply_text) {\n            let action = match caps.name(\"action\") {\n                Some(action) =\u003e action.as_str(),\n                None =\u003e unreachable!(),\n            };\n            let hs_address = match caps.name(\"hsaddress\") {\n                Some(hs_address) =\u003e hs_address.as_str(),\n                None =\u003e unreachable!(),\n            };\n\n            if let Ok(hs_address) = V3OnionServiceId::from_string(hs_address) {\n                return Ok(AsyncEvent::HsDesc {\n                    action: action.to_string(),\n                    hs_address,\n                });\n            }\n        }\n\n        // no luck parsing reply, just return full text\n        let mut reply_lines: Vec\u003cString\u003e = Default::default();\n        std::mem::swap(\u0026mut reply_lines, \u0026mut reply.reply_lines);\n\n        Ok(AsyncEvent::Unknown { lines: reply_lines })\n    }\n\n    pub fn wait_async_events(\u0026mut self) -\u003e Result\u003cVec\u003cAsyncEvent\u003e, Error\u003e {\n        let mut async_replies = self.wait_async_replies()?;\n        let mut async_events: Vec\u003cAsyncEvent\u003e = Default::default();\n\n        for reply in async_replies.iter_mut() {\n            async_events.push(self.reply_to_event(reply)?);\n        }\n\n        Ok(async_events)\n    }\n\n    // wait for a sync reply, save off async replies for later\n    fn wait_sync_reply(\u0026mut self) -\u003e Result\u003cReply, Error\u003e {\n        loop {\n            if let Some(reply) = self\n                .control_stream\n                .read_reply()\n                .map_err(Error::ReadReplyFailed)?\n            {\n                match reply.status_code {\n                    650u32 =\u003e self.async_replies.push(reply),\n                    _ =\u003e return Ok(reply),\n                }\n            }\n        }\n    }\n\n    fn write_command(\u0026mut self, text: \u0026str) -\u003e Result\u003cReply, Error\u003e {\n        self.control_stream\n            .write(text)\n            .map_err(Error::WriteCommandFailed)?;\n        self.wait_sync_reply()\n    }\n\n    //\n    // Tor Commands\n    //\n    // The section where we can find the specification in control-spec.txt\n    // for the underlying command is listed in parentheses\n    //\n    // Each of these command wrapper methods block until completion\n    //\n\n    // SETCONF (3.1)\n    fn setconf_cmd(\u0026mut self, key_values: \u0026[(\u0026str, \u0026str)]) -\u003e Result\u003cReply, Error\u003e {\n        if key_values.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"SETCONF key-value pairs list must not be empty\".to_string(),\n            ));\n        }\n        let mut command_buffer = vec![\"SETCONF\".to_string()];\n\n        for (key, value) in key_values.iter() {\n            command_buffer.push(format!(\"{}={}\", key, value));\n        }\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // GETCONF (3.3)\n    #[cfg(test)]\n    fn getconf_cmd(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if keywords.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"GETCONF keywords list must not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"GETCONF {}\", keywords.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // SETEVENTS (3.4)\n    fn setevents_cmd(\u0026mut self, event_codes: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if event_codes.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"SETEVENTS event codes list mut not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"SETEVENTS {}\", event_codes.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // AUTHENTICATE (3.5)\n    fn authenticate_cmd(\u0026mut self, password: \u0026str) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"AUTHENTICATE \\\"{}\\\"\", password);\n\n        self.write_command(\u0026command)\n    }\n\n    // GETINFO (3.9)\n    fn getinfo_cmd(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if keywords.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"GETINFO keywords list must not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"GETINFO {}\", keywords.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // ADD_ONION (3.27)\n    fn add_onion_cmd(\n        \u0026mut self,\n        key: Option\u003c\u0026Ed25519PrivateKey\u003e,\n        flags: \u0026AddOnionFlags,\n        max_streams: Option\u003cu16\u003e,\n        virt_port: u16,\n        target: Option\u003cSocketAddr\u003e,\n        client_auth: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let mut command_buffer = vec![\"ADD_ONION\".to_string()];\n\n        // set our key or request a new one\n        if let Some(key) = key {\n            command_buffer.push(key.to_key_blob());\n        } else {\n            command_buffer.push(\"NEW:ED25519-V3\".to_string());\n        }\n\n        // set our flags\n        let mut flag_buffer: Vec\u003c\u0026str\u003e = Default::default();\n        if flags.discard_pk {\n            flag_buffer.push(\"DiscardPK\");\n        }\n        if flags.detach {\n            flag_buffer.push(\"Detach\");\n        }\n        if flags.v3_auth {\n            flag_buffer.push(\"V3Auth\");\n        }\n        if flags.non_anonymous {\n            flag_buffer.push(\"NonAnonymous\");\n        }\n        if flags.max_streams_close_circuit {\n            flag_buffer.push(\"MaxStreamsCloseCircuit\");\n        }\n\n        if !flag_buffer.is_empty() {\n            command_buffer.push(format!(\"Flags={}\", flag_buffer.join(\",\")));\n        }\n\n        // set max concurrent streams\n        if let Some(max_streams) = max_streams {\n            command_buffer.push(format!(\"MaxStreams={}\", max_streams));\n        }\n\n        // set our onion service target\n        if let Some(target) = target {\n            command_buffer.push(format!(\"Port={},{}\", virt_port, target));\n        } else {\n            command_buffer.push(format!(\"Port={}\", virt_port));\n        }\n        // setup client auth\n        if let Some(client_auth) = client_auth {\n            for key in client_auth.iter() {\n                command_buffer.push(format!(\"ClientAuthV3={}\", key.to_base32()));\n            }\n        }\n\n        // finally send the command\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // DEL_ONION (3.38)\n    fn del_onion_cmd(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"DEL_ONION {}\", service_id);\n\n        self.write_command(\u0026command)\n    }\n\n    // ONION_CLIENT_AUTH_ADD (3.30)\n    fn onion_client_auth_add_cmd(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        private_key: \u0026X25519PrivateKey,\n        client_name: Option\u003cString\u003e,\n        flags: \u0026OnionClientAuthAddFlags,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let mut command_buffer = vec![\"ONION_CLIENT_AUTH_ADD\".to_string()];\n\n        // set the onion service id\n        command_buffer.push(service_id.to_string());\n\n        // set our client's private key\n        command_buffer.push(format!(\"x25519:{}\", private_key.to_base64()));\n\n        if let Some(client_name) = client_name {\n            command_buffer.push(format!(\"ClientName={}\", client_name));\n        }\n\n        if flags.permanent {\n            command_buffer.push(\"Flags=Permanent\".to_string());\n        }\n\n        // finally send command\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // ONION_CLIENT_AUTH_REMOVE (3.31)\n    fn onion_client_auth_remove_cmd(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"ONION_CLIENT_AUTH_REMOVE {}\", service_id);\n\n        self.write_command(\u0026command)\n    }\n\n    //\n    // Public high-level typesafe command method wrappers\n    //\n\n    pub fn setconf(\u0026mut self, key_values: \u0026[(\u0026str, \u0026str)]) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.setconf_cmd(key_values)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    #[cfg(test)]\n    pub fn getconf(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cVec\u003c(String, String)\u003e, Error\u003e {\n        let reply = self.getconf_cmd(keywords)?;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                let mut key_values: Vec\u003c(String, String)\u003e = Default::default();\n                for line in reply.reply_lines {\n                    match line.find('=') {\n                        Some(index) =\u003e key_values\n                            .push((line[0..index].to_string(), line[index + 1..].to_string())),\n                        None =\u003e key_values.push((line, String::new())),\n                    }\n                }\n                Ok(key_values)\n            }\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn setevents(\u0026mut self, events: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.setevents_cmd(events)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn authenticate(\u0026mut self, password: \u0026str) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.authenticate_cmd(password)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn getinfo(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cVec\u003c(String, String)\u003e, Error\u003e {\n        let reply = self.getinfo_cmd(keywords)?;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                let mut key_values: Vec\u003c(String, String)\u003e = Default::default();\n                for line in reply.reply_lines {\n                    match line.find('=') {\n                        Some(index) =\u003e key_values\n                            .push((line[0..index].to_string(), line[index + 1..].to_string())),\n                        None =\u003e {\n                            if line != \"OK\" {\n                                key_values.push((line, String::new()))\n                            }\n                        }\n                    }\n                }\n                Ok(key_values)\n            }\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn add_onion(\n        \u0026mut self,\n        key: Option\u003c\u0026Ed25519PrivateKey\u003e,\n        flags: \u0026AddOnionFlags,\n        max_streams: Option\u003cu16\u003e,\n        virt_port: u16,\n        target: Option\u003cSocketAddr\u003e,\n        client_auth: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003c(Option\u003cEd25519PrivateKey\u003e, V3OnionServiceId), Error\u003e {\n        let reply = self.add_onion_cmd(key, flags, max_streams, virt_port, target, client_auth)?;\n\n        let mut private_key: Option\u003cEd25519PrivateKey\u003e = None;\n        let mut service_id: Option\u003cV3OnionServiceId\u003e = None;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                for line in reply.reply_lines {\n                    if let Some(mut index) = line.find(\"ServiceID=\") {\n                        if service_id.is_some() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"received duplicate ServiceID entries\".to_string(),\n                            ));\n                        }\n                        index += \"ServiceId=\".len();\n                        let service_id_string = \u0026line[index..];\n                        service_id = match V3OnionServiceId::from_string(service_id_string) {\n                            Ok(service_id) =\u003e Some(service_id),\n                            Err(_) =\u003e {\n                                return Err(Error::CommandReplyParseFailed(format!(\n                                    \"could not parse '{}' as V3OnionServiceId\",\n                                    service_id_string\n                                )))\n                            }\n                        }\n                    } else if let Some(mut index) = line.find(\"PrivateKey=\") {\n                        if private_key.is_some() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"received duplicate PrivateKey entries\".to_string(),\n                            ));\n                        }\n                        index += \"PrivateKey=\".len();\n                        let key_blob_string = \u0026line[index..];\n                        private_key = match Ed25519PrivateKey::from_key_blob_legacy(key_blob_string) {\n                            Ok(private_key) =\u003e Some(private_key),\n                            Err(_) =\u003e {\n                                return Err(Error::CommandReplyParseFailed(format!(\n                                    \"could not parse {} as Ed25519PrivateKey\",\n                                    key_blob_string\n                                )))\n                            }\n                        };\n                    } else if line.contains(\"ClientAuthV3=\") {\n                        if client_auth.unwrap_or_default().is_empty() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"recieved unexpected ClientAuthV3 keys\".to_string(),\n                            ));\n                        }\n                    } else if !line.contains(\"OK\") {\n                        return Err(Error::CommandReplyParseFailed(format!(\n                            \"received unexpected reply line '{}'\",\n                            line\n                        )));\n                    }\n                }\n            }\n            code =\u003e return Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n\n        if flags.discard_pk {\n            if private_key.is_some() {\n                return Err(Error::CommandReplyParseFailed(\n                    \"PrivateKey response should have been discard\".to_string(),\n                ));\n            }\n        } else if private_key.is_none() {\n            return Err(Error::CommandReplyParseFailed(\n                \"did not receive a PrivateKey\".to_string(),\n            ));\n        }\n\n        match service_id {\n            Some(service_id) =\u003e Ok((private_key, service_id)),\n            None =\u003e Err(Error::CommandReplyParseFailed(\n                \"did not receive a ServiceID\".to_string(),\n            )),\n        }\n    }\n\n    pub fn del_onion(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.del_onion_cmd(service_id)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    // more specific encapulsation of specific command invocations\n\n    pub fn getinfo_net_listeners_socks(\u0026mut self) -\u003e Result\u003cVec\u003cSocketAddr\u003e, Error\u003e {\n        let response = self.getinfo(\u0026[\"net/listeners/socks\"])?;\n        for (key, value) in response.iter() {\n            if key.as_str() == \"net/listeners/socks\" {\n                if value.is_empty() {\n                    return Ok(Default::default());\n                }\n                // get our list of double-quoted strings\n                let listeners: Vec\u003c\u0026str\u003e = value.split(' ').collect();\n                let mut result: Vec\u003cSocketAddr\u003e = Default::default();\n                for socket_addr in listeners.iter() {\n                    if !socket_addr.starts_with('\\\"') || !socket_addr.ends_with('\\\"') {\n                        return Err(Error::CommandReplyParseFailed(format!(\n                            \"could not parse '{}' as socket address\",\n                            socket_addr\n                        )));\n                    }\n\n                    // remove leading/trailing double quote\n                    let stripped = \u0026socket_addr[1..socket_addr.len() - 1];\n                    result.push(match SocketAddr::from_str(stripped) {\n                        Ok(result) =\u003e result,\n                        Err(_) =\u003e {\n                            return Err(Error::CommandReplyParseFailed(format!(\n                                \"could not parse '{}' as socket address\",\n                                socket_addr\n                            )))\n                        }\n                    });\n                }\n                return Ok(result);\n            }\n        }\n        Err(Error::CommandReplyParseFailed(\n            \"reply did not find a 'net/listeners/socks' key/value\".to_string(),\n        ))\n    }\n\n    pub fn getinfo_version(\u0026mut self) -\u003e Result\u003cLegacyTorVersion, Error\u003e {\n        let response = self.getinfo(\u0026[\"version\"])?;\n        for (key, value) in response.iter() {\n            if key.as_str() == \"version\" {\n                return LegacyTorVersion::from_str(value).map_err(Error::TorVersionParseFailed);\n            }\n        }\n        Err(Error::CommandReplyParseFailed(\n            \"did not find a 'version' key/value\".to_string(),\n        ))\n    }\n\n    pub fn onion_client_auth_add(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        private_key: \u0026X25519PrivateKey,\n        client_name: Option\u003cString\u003e,\n        flags: \u0026OnionClientAuthAddFlags,\n    ) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.onion_client_auth_add_cmd(service_id, private_key, client_name, flags)?;\n\n        match reply.status_code {\n            250u32..=252u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn onion_client_auth_remove(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.onion_client_auth_remove_cmd(service_id)?;\n\n        match reply.status_code {\n            250u32..=251u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n}\n\n#[test]\n#[serial]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_tor_controller() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_tor_controller\");\n    let tor_process = LegacyTorProcess::new(\u0026tor_path, \u0026data_path)?;\n\n    // create a scope to ensure tor_controller is dropped\n    {\n        let control_stream =\n            LegacyControlStream::new(tor_process.get_control_addr(), Duration::from_millis(16))?;\n\n        // create a tor controller and send authentication command\n        let mut tor_controller = LegacyTorController::new(control_stream)?;\n        tor_controller.authenticate_cmd(tor_process.get_password())?;\n        assert!(\n            tor_controller\n                .authenticate_cmd(\"invalid password\")?\n                .status_code\n                == 515u32\n        );\n\n        // tor controller should have shutdown the connection after failed authentication\n        assert!(\n            tor_controller\n                .authenticate_cmd(tor_process.get_password())\n                .is_err(),\n            \"expected failure due to closed connection\"\n        );\n        assert!(tor_controller.control_stream.closed_by_remote());\n    }\n    // now create a second controller\n    {\n        let control_stream =\n            LegacyControlStream::new(tor_process.get_control_addr(), Duration::from_millis(16))?;\n\n        // create a tor controller and send authentication command\n        // all async events are just printed to stdout\n        let mut tor_controller = LegacyTorController::new(control_stream)?;\n        tor_controller.authenticate(tor_process.get_password())?;\n\n        // ensure everything is matching our default_torrc settings\n        let vals = tor_controller.getconf(\u0026[\"SocksPort\", \"AvoidDiskWrites\", \"DisableNetwork\"])?;\n        for (key, value) in vals.iter() {\n            let expected = match key.as_str() {\n                \"SocksPort\" =\u003e \"auto OnionTrafficOnly\",\n                \"AvoidDiskWrites\" =\u003e \"1\",\n                \"DisableNetwork\" =\u003e \"1\",\n                _ =\u003e panic!(\"unexpected returned key: {}\", key),\n            };\n            assert!(value == expected);\n        }\n\n        let vals = tor_controller.getinfo(\u0026[\"version\", \"config-file\", \"config-text\"])?;\n        let mut expected_torrc_path = data_path.clone();\n        expected_torrc_path.push(\"torrc\");\n        let mut expected_control_port_path = data_path.clone();\n        expected_control_port_path.push(\"control_port\");\n        for (key, value) in vals.iter() {\n            match key.as_str() {\n                \"version\" =\u003e assert!(Regex::new(r\"\\d+\\.\\d+\\.\\d+\\.\\d+\")?.is_match(\u0026value)),\n                \"config-file\" =\u003e assert!(Path::new(\u0026value) == expected_torrc_path),\n                \"config-text\" =\u003e assert!(\n                    value.to_string()\n                        == format!(\n                            \"\\nControlPort auto\\nControlPortWriteToFile {}\\nDataDirectory {}\",\n                            expected_control_port_path.display(),\n                            data_path.display()\n                        )\n                ),\n                _ =\u003e panic!(\"unexpected returned key: {}\", key),\n            }\n        }\n\n        tor_controller.setevents(\u0026[\"STATUS_CLIENT\"])?;\n        // begin bootstrap\n        tor_controller.setconf(\u0026[(\"DisableNetwork\", \"0\")])?;\n\n        // add an onoin service\n        let (private_key, service_id) =\n            match tor_controller.add_onion(None, \u0026Default::default(), None, 22, None, None)? {\n                (Some(private_key), service_id) =\u003e (private_key, service_id),\n                _ =\u003e panic!(\"add_onion did not return expected values\"),\n            };\n        println!(\"private_key: {}\", private_key.to_key_blob());\n        println!(\"service_id: {}\", service_id.to_string());\n\n        assert!(\n            tor_controller\n                .del_onion(\u0026V3OnionServiceId::from_string(\n                    \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd\"\n                )?)\n                .is_err(),\n            \"deleting unknown onion should have failed\"\n        );\n\n        // delete our new onion\n        tor_controller.del_onion(\u0026service_id)?;\n\n        println!(\"listeners: \");\n        for sock_addr in tor_controller.getinfo_net_listeners_socks()?.iter() {\n            println!(\" {}\", sock_addr);\n        }\n\n        // print our event names available to tor\n        for (key, value) in tor_controller.getinfo(\u0026[\"events/names\"])?.iter() {\n            println!(\"{} : {}\", key, value);\n        }\n\n        let stop_time = Instant::now() + std::time::Duration::from_secs(5);\n        while stop_time \u003e Instant::now() {\n            for async_event in tor_controller.wait_async_events()?.iter() {\n                match async_event {\n                    AsyncEvent::Unknown { lines } =\u003e {\n                        println!(\"Unknown: {}\", lines.join(\"\\n\"));\n                    }\n                    AsyncEvent::StatusClient {\n                        severity,\n                        action,\n                        arguments,\n                    } =\u003e {\n                        println!(\"STATUS_CLIENT severity={}, action={}\", severity, action);\n                        for (key, value) in arguments.iter() {\n                            println!(\" {}='{}'\", key, value);\n                        }\n                    }\n                    AsyncEvent::HsDesc { action, hs_address } =\u003e {\n                        println!(\n                            \"HS_DESC action={}, hsaddress={}\",\n                            action,\n                            hs_address.to_string()\n                        );\n                    }\n                }\n            }\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":93,"address":[1425690,1424128,1425607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1424150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1424393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1424357,1425673,1424729,1424502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1424681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1425305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1424950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1424980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1425125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1425177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1425241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1425728,1426357,1426386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[1425757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[1425861,1425802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1426321,1426141,1425876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[1426102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1426196,1426304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1426224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1426400,1430482,1428127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1426455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1426591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1426480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1426546,1426726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1426940,1426839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1426999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[1427118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1427215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[1427332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1427480,1427359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1427381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1428180,1427732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[1428242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1428359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[1428456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[1428908,1428570,1428635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1428693,1428744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[1428619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1428729,1428913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1427916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1427794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[1427825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[1427884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[1429109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[1429411,1429297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[1429473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1429572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[1429669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1429752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[1429952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[1429871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1430214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1430260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[1430331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1430496,1431413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[1430654,1430526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[1430635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[1431081,1430749,1430826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[1431125,1431105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[1430973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[1431440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[1431469,1431992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1431732,1431481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1431704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1431818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1431871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1431899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1432016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1432038,1432171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[1432143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[1432136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1432208,1433434,1433186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[1432301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1432397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1432364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1432662,1432479,1433447,1432321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[1432633,1432879,1432737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1433308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1432850,1433003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1433043,1433130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1424112,1424746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[1424184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1424337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1424310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1424401,1424204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1424712,1424636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1433456,1434094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1433528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[1433685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[1433658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1433548,1433749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[1433984,1434060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[1434429,1434128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[1434227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1434324,1434398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[1434464,1435102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[1434536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[1434693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[1434666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[1434556,1434757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[1434992,1435068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[1436514,1438179,1435136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[1435533,1438192,1435307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[1435494,1435554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[1435570,1435660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[1435708,1435589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[1435689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[1435745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[1435766,1435841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[1435758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[1435859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[1435851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[1435908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[1435900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[1435957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[1435949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1436016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[1435990,1436056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[1436136,1436062,1436249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[1436097,1436523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[1436674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[1436628,1436792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[1437099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[1437276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[1437222,1437386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1437418,1437481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[1437708,1437614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[1437439,1437977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[1438104,1438017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[1438504,1438208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[1438303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[1438398,1438473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[1439709,1440068,1438528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[1438720,1440053,1438605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[1438983,1438920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[1439109,1439015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[1439368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[1439582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[1439514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[1439747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[1439813,1439718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[1439853,1439934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[1440112,1440408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[1440207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[1440302,1440377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[1440432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[1440473,1440653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[1440641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1440720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[1440736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[1433506,1433859,1432112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[1432368,1432153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[1432356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1432440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[1433813,1432643,1432737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[1433141,1432962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[1433262,1433793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[1433533,1433283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[1433204,1433354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[1432987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[1432455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[1440928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[1441149,1440969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[1441137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[1441216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[1441232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[1441424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[1441465,1441645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[1441633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[1441712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[1441728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[1443398,1441920,1443757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[1442186,1441961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[1442171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[1442251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[1442472,1442577,1443711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[1442993,1442814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[1443671,1443082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[1443425,1443103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[1443178,1443056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[1443203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[1442839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[1442278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[1448846,1443808,1446883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[1443946,1444292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[1444246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[1444266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[1444274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[1448803,1444352,1444652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[1445773,1444881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[1445938,1445871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[1446900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[1445971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[1446110,1446009,1445944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[1446048,1446158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[1446367,1446174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[1446231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[1446618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[1446431,1446802,1446553,1446842,1447017,1445905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[1447115,1447182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[1448087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[1447215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[1447253,1447188,1447354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[1447403,1447292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[1447555,1447713,1447655,1447419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[1447461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[1447836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[1448204,1447149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[1448639,1448282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[1448702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[1448667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[1448316,1448249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[1448440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[1444430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[1444915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[1444946,1445175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[1445612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[1445184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[1444920,1444982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[1445050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[1445015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[1444988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[1445244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[1445403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[1445214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[1448880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[1449092,1448912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[1449080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[1449157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[1449172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[1451835,1449360,1451774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[1449391,1449570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[1449690,1449891,1449535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[1449935,1450089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[1450162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[1451791,1450220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[1450258,1450197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[1450309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[1450372,1450472,1450730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[1450885,1450804,1450746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[1450980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[1450930,1451155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[1451392,1451315,1451525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[1451360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[1451539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[1450630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[1449966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[1449864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[1451856,1452674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[1451881,1452046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[1452157,1452017,1452328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[1452369,1452521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[1452585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[1452391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[1452301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[1452704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[1452752,1452941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[1452924,1453150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[1453006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[1453232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[1453453,1453264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[1453436,1453662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[1453518],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":262},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_process.rs"],"content":"// standard\nuse std::default::Default;\nuse std::fs;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader, Read, Write};\nuse std::net::SocketAddr;\nuse std::ops::Drop;\nuse std::path::Path;\nuse std::process;\nuse std::process::{Child, ChildStdout, Command, Stdio};\nuse std::str::FromStr;\nuse std::string::ToString;\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\n\n// extern crates\nuse data_encoding::HEXUPPER;\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse sha1::{Digest, Sha1};\n\n// internal crates\nuse crate::tor_crypto::generate_password;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to read control port file\")]\n    ControlPortFileReadFailed(#[source] std::io::Error),\n\n    #[error(\"provided control port file '{0}' larger than expected ({1} bytes)\")]\n    ControlPortFileTooLarge(String, u64),\n\n    #[error(\"failed to parse '{0}' as control port file\")]\n    ControlPortFileContentsInvalid(String),\n\n    #[error(\"provided tor bin path '{0}' must be an absolute path\")]\n    TorBinPathNotAbsolute(String),\n\n    #[error(\"provided data directory '{0}' must be an absolute path\")]\n    TorDataDirectoryPathNotAbsolute(String),\n\n    #[error(\"failed to create data directory\")]\n    DataDirectoryCreationFailed(#[source] std::io::Error),\n\n    #[error(\"file exists in provided data directory path '{0}'\")]\n    DataDirectoryPathExistsAsFile(String),\n\n    #[error(\"failed to create default_torrc file\")]\n    DefaultTorrcFileCreationFailed(#[source] std::io::Error),\n\n    #[error(\"failed to write default_torrc file\")]\n    DefaultTorrcFileWriteFailed(#[source] std::io::Error),\n\n    #[error(\"failed to create torrc file\")]\n    TorrcFileCreationFailed(#[source] std::io::Error),\n\n    #[error(\"failed to remove control_port file\")]\n    ControlPortFileDeleteFailed(#[source] std::io::Error),\n\n    #[error(\"failed to start legacy tor process\")]\n    LegacyTorProcessStartFailed(#[source] std::io::Error),\n\n    #[error(\"failed to read control addr from control_file '{0}'\")]\n    ControlPortFileMissing(String),\n\n    #[error(\"unable to take legacy tor process stdout\")]\n    LegacyTorProcessStdoutTakeFailed(),\n\n    #[error(\"failed to spawn tor process stdout read thread\")]\n    StdoutReadThreadSpawnFailed(#[source] std::io::Error),\n}\n\nfn read_control_port_file(control_port_file: \u0026Path) -\u003e Result\u003cSocketAddr, Error\u003e {\n    // open file\n    let mut file = File::open(control_port_file).map_err(Error::ControlPortFileReadFailed)?;\n\n    // bail if the file is larger than expected\n    let metadata = file.metadata().map_err(Error::ControlPortFileReadFailed)?;\n    if metadata.len() \u003e= 1024 {\n        return Err(Error::ControlPortFileTooLarge(\n            format!(\"{}\", control_port_file.display()),\n            metadata.len(),\n        ));\n    }\n\n    // read contents to string\n    let mut contents = String::new();\n    file.read_to_string(\u0026mut contents)\n        .map_err(Error::ControlPortFileReadFailed)?;\n\n    if contents.starts_with(\"PORT=\") {\n        let addr_string = \u0026contents.trim_end()[\"PORT=\".len()..];\n        if let Ok(addr) = SocketAddr::from_str(addr_string) {\n            return Ok(addr);\n        }\n    }\n    Err(Error::ControlPortFileContentsInvalid(format!(\n        \"{}\",\n        control_port_file.display()\n    )))\n}\n\n// Encapsulates the tor daemon process\npub(crate) struct LegacyTorProcess {\n    control_addr: SocketAddr,\n    process: Child,\n    password: String,\n    // stdout data\n    stdout_lines: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n}\n\nimpl LegacyTorProcess {\n    const S2K_RFC2440_SPECIFIER_LEN: usize = 9;\n\n    fn hash_tor_password_with_salt(\n        salt: \u0026[u8; Self::S2K_RFC2440_SPECIFIER_LEN],\n        password: \u0026str,\n    ) -\u003e String {\n        assert_eq!(salt[Self::S2K_RFC2440_SPECIFIER_LEN - 1], 0x60);\n\n        // tor-specific rfc 2440 constants\n        const EXPBIAS: u8 = 6u8;\n        const C: u8 = 0x60; // salt[S2K_RFC2440_SPECIFIER_LEN - 1]\n        const COUNT: usize = (16usize + ((C \u0026 15u8) as usize)) \u003c\u003c ((C \u003e\u003e 4) + EXPBIAS);\n\n        // squash together our hash input\n        let mut input: Vec\u003cu8\u003e = Default::default();\n        // append salt (sans the 'C' constant')\n        input.extend_from_slice(\u0026salt[0..Self::S2K_RFC2440_SPECIFIER_LEN - 1]);\n        // append password bytes\n        input.extend_from_slice(password.as_bytes());\n\n        let input = input.as_slice();\n        let input_len = input.len();\n\n        let mut sha1 = Sha1::new();\n        let mut count = COUNT;\n        while count \u003e 0 {\n            if count \u003e input_len {\n                sha1.update(input);\n                count -= input_len;\n            } else {\n                sha1.update(\u0026input[0..count]);\n                break;\n            }\n        }\n\n        let key = sha1.finalize();\n\n        let mut hash = \"16:\".to_string();\n        HEXUPPER.encode_append(salt, \u0026mut hash);\n        HEXUPPER.encode_append(\u0026key, \u0026mut hash);\n\n        hash\n    }\n\n    fn hash_tor_password(password: \u0026str) -\u003e String {\n        let mut salt = [0x00u8; Self::S2K_RFC2440_SPECIFIER_LEN];\n        OsRng.fill_bytes(\u0026mut salt);\n        salt[Self::S2K_RFC2440_SPECIFIER_LEN - 1] = 0x60u8;\n\n        Self::hash_tor_password_with_salt(\u0026salt, password)\n    }\n\n    pub fn get_control_addr(\u0026self) -\u003e \u0026SocketAddr {\n        \u0026self.control_addr\n    }\n\n    pub fn get_password(\u0026self) -\u003e \u0026String {\n        \u0026self.password\n    }\n\n    pub fn new(tor_bin_path: \u0026Path, data_directory: \u0026Path) -\u003e Result\u003cLegacyTorProcess, Error\u003e {\n        if tor_bin_path.is_relative() {\n            return Err(Error::TorBinPathNotAbsolute(format!(\n                \"{}\",\n                tor_bin_path.display()\n            )));\n        }\n        if data_directory.is_relative() {\n            return Err(Error::TorDataDirectoryPathNotAbsolute(format!(\n                \"{}\",\n                data_directory.display()\n            )));\n        }\n\n        // create data directory if it doesn't exist\n        if !data_directory.exists() {\n            fs::create_dir_all(data_directory).map_err(Error::DataDirectoryCreationFailed)?;\n        } else if data_directory.is_file() {\n            return Err(Error::DataDirectoryPathExistsAsFile(format!(\n                \"{}\",\n                data_directory.display()\n            )));\n        }\n\n        // construct paths to torrc files\n        let default_torrc = data_directory.join(\"default_torrc\");\n        let torrc = data_directory.join(\"torrc\");\n        let control_port_file = data_directory.join(\"control_port\");\n\n        // TODO: should we nuke the existing torrc between runs? Do we want\n        // users setting custom nonsense in there?\n        // construct default torrc\n        //  - daemon determines socks port and only allows clients to connect to onion services\n        //  - minimize writes to disk\n        //  - start with network disabled by default\n        if !default_torrc.exists() {\n            const DEFAULT_TORRC_CONTENT: \u0026str = \"SocksPort auto OnionTrafficOnly\\n\\\n            AvoidDiskWrites 1\\n\\\n            DisableNetwork 1\\n\\n\";\n\n            let mut default_torrc_file =\n                File::create(\u0026default_torrc).map_err(Error::DefaultTorrcFileCreationFailed)?;\n            default_torrc_file\n                .write_all(DEFAULT_TORRC_CONTENT.as_bytes())\n                .map_err(Error::DefaultTorrcFileWriteFailed)?;\n        }\n\n        // create empty torrc for user\n        if !torrc.exists() {\n            let _ = File::create(\u0026torrc).map_err(Error::TorrcFileCreationFailed)?;\n        }\n\n        // remove any existing control_port_file\n        if control_port_file.exists() {\n            fs::remove_file(\u0026control_port_file).map_err(Error::ControlPortFileDeleteFailed)?;\n        }\n\n        const CONTROL_PORT_PASSWORD_LENGTH: usize = 32usize;\n        let password = generate_password(CONTROL_PORT_PASSWORD_LENGTH);\n        let password_hash = Self::hash_tor_password(\u0026password);\n\n        let mut process = Command::new(tor_bin_path.as_os_str())\n            .stdout(Stdio::piped())\n            .stdin(Stdio::null())\n            .stderr(Stdio::null())\n            // point to our above written torrc file\n            .arg(\"--defaults-torrc\")\n            .arg(default_torrc)\n            // location of torrc\n            .arg(\"--torrc-file\")\n            .arg(torrc)\n            // root data directory\n            .arg(\"DataDirectory\")\n            .arg(data_directory)\n            // daemon will assign us a port, and we will\n            // read it from the control port file\n            .arg(\"ControlPort\")\n            .arg(\"auto\")\n            // control port file destination\n            .arg(\"ControlPortWriteToFile\")\n            .arg(control_port_file.clone())\n            // use password authentication to prevent other apps\n            // from modifying our daemon's settings\n            .arg(\"HashedControlPassword\")\n            .arg(password_hash)\n            // tor process will shut down after this process shuts down\n            // to avoid orphaned tor daemon\n            .arg(\"__OwningControllerProcess\")\n            .arg(process::id().to_string())\n            .spawn()\n            .map_err(Error::LegacyTorProcessStartFailed)?;\n\n        let mut control_addr = None;\n        let start = Instant::now();\n\n        // try and read the control port from the control port file\n        // or abort after 5 seconds\n        // TODO: make this timeout configurable?\n        while control_addr.is_none() \u0026\u0026 start.elapsed() \u003c Duration::from_secs(5) {\n            if control_port_file.exists() {\n                control_addr = Some(read_control_port_file(control_port_file.as_path())?);\n                fs::remove_file(\u0026control_port_file).map_err(Error::ControlPortFileDeleteFailed)?;\n            }\n        }\n\n        let control_addr = match control_addr {\n            Some(control_addr) =\u003e control_addr,\n            None =\u003e {\n                return Err(Error::ControlPortFileMissing(format!(\n                    \"{}\",\n                    control_port_file.display()\n                )))\n            }\n        };\n\n        let stdout_lines: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e = Default::default();\n\n        {\n            let stdout_lines = Arc::downgrade(\u0026stdout_lines);\n            let stdout = BufReader::new(match process.stdout.take() {\n                Some(stdout) =\u003e stdout,\n                None =\u003e return Err(Error::LegacyTorProcessStdoutTakeFailed()),\n            });\n\n            std::thread::Builder::new()\n                .name(\"tor_stdout_reader\".to_string())\n                .spawn(move || {\n                    LegacyTorProcess::read_stdout_task(\u0026stdout_lines, stdout);\n                })\n                .map_err(Error::StdoutReadThreadSpawnFailed)?;\n        }\n\n        Ok(LegacyTorProcess {\n            control_addr,\n            process,\n            password,\n            stdout_lines,\n        })\n    }\n\n    fn read_stdout_task(\n        stdout_lines: \u0026std::sync::Weak\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n        mut stdout: BufReader\u003cChildStdout\u003e,\n    ) {\n        while let Some(stdout_lines) = stdout_lines.upgrade() {\n            let mut line = String::default();\n            // read line\n            if stdout.read_line(\u0026mut line).is_ok() {\n                // remove trailing '\\n'\n                line.pop();\n                // then acquire the lock on the line buffer\n                let mut stdout_lines = match stdout_lines.lock() {\n                    Ok(stdout_lines) =\u003e stdout_lines,\n                    Err(_) =\u003e unreachable!(),\n                };\n                stdout_lines.push(line);\n            }\n        }\n    }\n\n    pub fn wait_log_lines(\u0026mut self) -\u003e Vec\u003cString\u003e {\n        let mut lines = match self.stdout_lines.lock() {\n            Ok(lines) =\u003e lines,\n            Err(_) =\u003e unreachable!(),\n        };\n        std::mem::take(\u0026mut lines)\n    }\n}\n\nimpl Drop for LegacyTorProcess {\n    fn drop(\u0026mut self) {\n        let _ = self.process.kill();\n    }\n}\n\n#[test]\nfn test_password_hash() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let salt1: [u8; LegacyTorProcess::S2K_RFC2440_SPECIFIER_LEN] = [\n        0xbeu8, 0x2au8, 0x25u8, 0x1du8, 0xe6u8, 0x2cu8, 0xb2u8, 0x7au8, 0x60u8,\n    ];\n    let hash1 = LegacyTorProcess::hash_tor_password_with_salt(\u0026salt1, \"abcdefghijklmnopqrstuvwxyz\");\n    assert_eq!(\n        hash1,\n        \"16:BE2A251DE62CB27A60AC9178A937990E8ED0AB662FA82A5C7DE3EBB23A\"\n    );\n\n    let salt2: [u8; LegacyTorProcess::S2K_RFC2440_SPECIFIER_LEN] = [\n        0x36u8, 0x73u8, 0x0eu8, 0xefu8, 0xd1u8, 0x8cu8, 0x60u8, 0xd6u8, 0x60u8,\n    ];\n    let hash2 = LegacyTorProcess::hash_tor_password_with_salt(\u0026salt2, \"password\");\n    assert_eq!(\n        hash2,\n        \"16:36730EEFD18C60D66052E7EA535438761C0928D316EEA56A190C99B50A\"\n    );\n\n    // ensure same password is hashed to different things\n    assert_ne!(\n        LegacyTorProcess::hash_tor_password(\"password\"),\n        LegacyTorProcess::hash_tor_password(\"password\")\n    );\n\n    Ok(())\n}\n","traces":[{"line":73,"address":[1572413,1570192,1571982],"length":1,"stats":{"Line":0},"fn_name":"read_control_port_file"},{"line":75,"address":[1570399,1570247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1570361,1570533,1570740,1572408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1570809,1570717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1572293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1572106,1572007,1570848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1572224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1570825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1571961,1570953,1570874,1571129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1571097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1571066,1571174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1571264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[1571437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1571558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1571746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1571647,1571233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[1573845,1573752,1572432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1572497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[1572646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[1572668,1572790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[1572855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[1572874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1572945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1572953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[1572972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1573808,1572984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[1573146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1573248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1573766,1573813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1573280,1573166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[1572999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1573304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1573339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1573579,1573505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1573687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1573872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[1573906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1573923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[1573959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[1573964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1573984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[1573992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[1574000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1576366,1574016,1581177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1574125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[1574316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1574232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1574198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1574664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[1574580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1574546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[1574894,1575131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1574995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1575332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1575248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[1575025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[1575095,1575603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[1575611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1575689,1575769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[1576375,1575796,1575857,1576004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[1576299,1576116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[1576109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1576267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[1575831,1576393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1576420,1576481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1576455,1576700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1581072,1576750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1576740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[1577038,1576947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[1577596,1577069,1577853,1577314,1578100,1577376,1577244,1577482,1577967,1577149,1578344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1577168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1577271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[1577333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[1577442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[1577556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[1577838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1577927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1578033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1578285,1577189,1581031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1578417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[1578427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[1578483,1578557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1580532,1578724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1580996,1580774,1580564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1580840,1574093,1580742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1578522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1578769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1578956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1578752,1578830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1579196,1578801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1579204,1579277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[1579358,1579493,1579293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[1579479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[1579398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1579555,1580054,1580402,1579676,1579807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[1579603,1579719,1580456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[1579727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1596121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[1579995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[1580179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[1580107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[1580139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[1580171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[1581967,1582071,1581216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[1581369,1581241,1581316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[1581362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[1581434,1581501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[1581625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[1581632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[1581682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[1581852,1581771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[1582348,1582096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[1582128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[1582160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[1582237,1582316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[1371328],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":344,"address":[1371337],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":24,"coverable":117},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_version.rs"],"content":"// standard\nuse std::cmp::Ordering;\nuse std::option::Option;\nuse std::str::FromStr;\nuse std::string::ToString;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"{}\", .0)]\n    ParseError(String),\n}\n\n// see version-spec.txt\n#[derive(Clone)]\npub struct LegacyTorVersion {\n    pub major: u32,\n    pub minor: u32,\n    pub micro: u32,\n    pub patch_level: u32,\n    pub status_tag: Option\u003cString\u003e,\n}\n\nimpl LegacyTorVersion {\n    fn status_tag_pattern_is_match(status_tag: \u0026str) -\u003e bool {\n        if status_tag.is_empty() {\n            return false;\n        }\n\n        for c in status_tag.chars() {\n            if c.is_whitespace() {\n                return false;\n            }\n        }\n        true\n    }\n\n    fn new(\n        major: u32,\n        minor: u32,\n        micro: u32,\n        patch_level: Option\u003cu32\u003e,\n        status_tag: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cLegacyTorVersion, Error\u003e {\n        let status_tag = if let Some(status_tag) = status_tag {\n            if Self::status_tag_pattern_is_match(status_tag) {\n                Some(status_tag.to_string())\n            } else {\n                return Err(Error::ParseError(\n                    \"tor version status tag may not be empty or contain white-space\".to_string(),\n                ));\n            }\n        } else {\n            None\n        };\n\n        Ok(LegacyTorVersion {\n            major,\n            minor,\n            micro,\n            patch_level: patch_level.unwrap_or(0u32),\n            status_tag,\n        })\n    }\n}\n\nimpl FromStr for LegacyTorVersion {\n    type Err = Error;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cLegacyTorVersion, Self::Err\u003e {\n        // MAJOR.MINOR.MICRO[.PATCHLEVEL][-STATUS_TAG][ (EXTRA_INFO)]*\n        let mut tokens = s.split(' ');\n        let (major, minor, micro, patch_level, status_tag) =\n            if let Some(version_status_tag) = tokens.next() {\n                let mut tokens = version_status_tag.split('-');\n                let (major, minor, micro, patch_level) = if let Some(version) = tokens.next() {\n                    let mut tokens = version.split('.');\n                    let major: u32 = if let Some(major) = tokens.next() {\n                        match major.parse() {\n                            Ok(major) =\u003e major,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MAJOR portion of tor version\",\n                                    major\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MAJOR portion of tor version\".to_string(),\n                        ));\n                    };\n                    let minor: u32 = if let Some(minor) = tokens.next() {\n                        match minor.parse() {\n                            Ok(minor) =\u003e minor,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MINOR portion of tor version\",\n                                    minor\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MINOR portion of tor version\".to_string(),\n                        ));\n                    };\n                    let micro: u32 = if let Some(micro) = tokens.next() {\n                        match micro.parse() {\n                            Ok(micro) =\u003e micro,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MICRO portion of tor version\",\n                                    micro\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MICRO portion of tor version\".to_string(),\n                        ));\n                    };\n                    let patch_level: u32 = if let Some(patch_level) = tokens.next() {\n                        match patch_level.parse() {\n                            Ok(patch_level) =\u003e patch_level,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as PATCHLEVEL portion of tor version\",\n                                    patch_level\n                                )))\n                            }\n                        }\n                    } else {\n                        0u32\n                    };\n                    (major, minor, micro, patch_level)\n                } else {\n                    // if there were '-' the previous next() would have returned the enire string\n                    unreachable!();\n                };\n                let status_tag = tokens.next().map(|status_tag| status_tag.to_string());\n\n                (major, minor, micro, patch_level, status_tag)\n            } else {\n                // if there were no ' ' character the previou snext() would have returned the enire string\n                unreachable!();\n            };\n        for extra_info in tokens {\n            if !extra_info.starts_with('(') || !extra_info.ends_with(')') {\n                return Err(Error::ParseError(format!(\n                    \"failed to parse '{}' as [ (EXTRA_INFO)]\",\n                    extra_info\n                )));\n            }\n        }\n        LegacyTorVersion::new(\n            major,\n            minor,\n            micro,\n            Some(patch_level),\n            status_tag.as_deref(),\n        )\n    }\n}\n\nimpl ToString for LegacyTorVersion {\n    fn to_string(\u0026self) -\u003e String {\n        match \u0026self.status_tag {\n            Some(status_tag) =\u003e format!(\n                \"{}.{}.{}.{}-{}\",\n                self.major, self.minor, self.micro, self.patch_level, status_tag\n            ),\n            None =\u003e format!(\n                \"{}.{}.{}.{}\",\n                self.major, self.minor, self.micro, self.patch_level\n            ),\n        }\n    }\n}\n\nimpl PartialEq for LegacyTorVersion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.major == other.major\n            \u0026\u0026 self.minor == other.minor\n            \u0026\u0026 self.micro == other.micro\n            \u0026\u0026 self.patch_level == other.patch_level\n            \u0026\u0026 self.status_tag == other.status_tag\n    }\n}\n\nimpl PartialOrd for LegacyTorVersion {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        if let Some(order) = self.major.partial_cmp(\u0026other.major) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.minor.partial_cmp(\u0026other.minor) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.micro.partial_cmp(\u0026other.micro) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.patch_level.partial_cmp(\u0026other.patch_level) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        // version-spect.txt *does* say that we should compare tags lexicgraphically\n        // if all of the version numbers are the same when comparing, but we are\n        // going to diverge here and say we can only compare tags for equality.\n        //\n        // In practice we will be comparing tor daemon tags against tagless (stable)\n        // versions so this shouldn't be an issue\n\n        if self.status_tag == other.status_tag {\n            return Some(Ordering::Equal);\n        }\n\n        None\n    }\n}\n\n#[test]\nfn test_version() -\u003e anyhow::Result\u003c()\u003e {\n    assert!(LegacyTorVersion::from_str(\"1.2.3\")? == LegacyTorVersion::new(1, 2, 3, None, None)?);\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4\")? == LegacyTorVersion::new(1, 2, 3, Some(4), None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3-test\")?\n            == LegacyTorVersion::new(1, 2, 3, None, Some(\"test\"))?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-test\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"test\"))?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3 (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, None, None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4 (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-tag (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"tag\"))?\n    );\n\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-tag (extra_info) (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"tag\"))?\n    );\n\n    assert!(LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"spaced tag\")).is_err());\n    assert!(LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"\" /* empty tag */)).is_err());\n    assert!(LegacyTorVersion::from_str(\"\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2-foo\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo bar\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo bar (extra_info)\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo (extra_info) badtext\").is_err());\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(1, 0, 0, Some(0), None)?\n    );\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(0, 1, 0, Some(0), None)?\n    );\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(0, 0, 1, Some(0), None)?\n    );\n\n    // ensure status tags make comparison between equal versions (apart from\n    // tags) unknowable\n    let zero_version = LegacyTorVersion::new(0, 0, 0, Some(0), None)?;\n    let zero_version_tag = LegacyTorVersion::new(0, 0, 0, Some(0), Some(\"tag\"))?;\n\n    assert!(!(zero_version \u003c zero_version_tag));\n    assert!(!(zero_version \u003c= zero_version_tag));\n    assert!(!(zero_version \u003e zero_version_tag));\n    assert!(!(zero_version \u003e= zero_version_tag));\n\n    Ok(())\n}\n","traces":[{"line":24,"address":[1608224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1608247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1608294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1608265,1608301,1608347],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[1608355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1608380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1608340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1609018,1608400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1608778,1608594,1608502],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[1608564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1608738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1608629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1608599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1608579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1608919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[1608801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1608880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1612732,1609040],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":71,"address":[1609079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1609098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1609189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[1609208,1611616,1609300],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[1609332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1609351,1609443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[1609475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1609683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1609835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1609581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1609548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1609704,1610021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[1610053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1610261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1610413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[1610159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1610126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1610282,1610599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[1610631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1610839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1610988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1610737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1610704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[1610857,1611283,1611309,1611174],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[1611206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[1611288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1611377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1611272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1611581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1532774,1532752],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":142,"address":[1611741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[1612233,1611905,1612072],"length":1,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[1612468,1612265,1612387],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[1612528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1612186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[1612204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[1612768],"length":1,"stats":{"Line":0},"fn_name":"to_string"},{"line":167,"address":[1612799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1613366,1613311,1613239,1613421,1613533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[1612905,1612838,1613015,1612960,1613067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1613712],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":182,"address":[1613735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1613759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[1613776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1613793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1613810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1613840],"length":1,"stats":{"Line":1},"fn_name":"partial_cmp"},{"line":192,"address":[1613864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1613911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1613984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1614001,1613943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[1614009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1614082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1614041,1614092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[1614100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1614173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1614186,1614132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[1614194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1614238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1614226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[1614261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1614251],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":67,"coverable":80},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","lib.rs"],"content":"pub mod legacy_tor_client;\nmod legacy_tor_control_stream;\nmod legacy_tor_controller;\nmod legacy_tor_process;\nmod legacy_tor_version;\npub mod mock_tor_client;\npub mod tor_crypto;\npub mod tor_provider;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","mock_tor_client.rs"],"content":"// standard\nuse std::collections::BTreeMap;\nuse std::io::ErrorKind;\nuse std::net::{SocketAddr, TcpListener, TcpStream};\nuse std::sync::{atomic, Arc, Mutex};\n\n// internal crates\nuse crate::tor_crypto::*;\nuse crate::tor_provider;\nuse crate::tor_provider::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"client not bootstrapped\")]\n    ClientNotBootstrapped(),\n\n    #[error(\"client already bootstrapped\")]\n    ClientAlreadyBootstrapped(),\n\n    #[error(\"onion service not found: {}\", .0)]\n    OnionServiceNotFound(OnionAddr),\n\n    #[error(\"onion service not published: {}\", .0)]\n    OnionServiceNotPublished(OnionAddr),\n\n    #[error(\"onion service requires onion auth\")]\n    OnionServiceRequiresOnionAuth(),\n\n    #[error(\"provided onion auth key invalid\")]\n    OnionServiceAuthInvalid(),\n\n    #[error(\"unable to bind TCP listener\")]\n    TcpListenerBindFailed(#[source] std::io::Error),\n\n    #[error(\"unable to get TCP listener's local adress\")]\n    TcpListenerLocalAddrFailed(#[source] std::io::Error),\n}\n\nimpl From\u003cError\u003e for crate::tor_provider::Error {\n    fn from(error: Error) -\u003e Self {\n        crate::tor_provider::Error::Generic(error.to_string())\n    }\n}\n\npub struct MockOnionListener {\n    listener: std::net::TcpListener,\n    is_active: Arc\u003catomic::AtomicBool\u003e,\n    onion_addr: OnionAddr,\n}\n\nimpl OnionListenerImpl for MockOnionListener {\n    fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.listener.set_nonblocking(nonblocking)\n    }\n    fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e {\n        match self.listener.accept() {\n            Ok((stream, _socket_addr)) =\u003e Ok(Some(OnionStream {\n                stream,\n                local_addr: Some(self.onion_addr.clone()),\n                peer_addr: None,\n            })),\n            Err(err) =\u003e {\n                if err.kind() == ErrorKind::WouldBlock {\n                    Ok(None)\n                } else {\n                    Err(err)\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for MockOnionListener {\n    fn drop(\u0026mut self) {\n        self.is_active.store(false, atomic::Ordering::Relaxed);\n    }\n}\n\nstruct MockTorNetwork {\n    onion_services: Option\u003cBTreeMap\u003cOnionAddr, (Vec\u003cX25519PublicKey\u003e, SocketAddr)\u003e\u003e,\n}\n\nimpl MockTorNetwork {\n    const fn new() -\u003e MockTorNetwork {\n        MockTorNetwork {\n            onion_services: None,\n        }\n    }\n\n    fn connect_to_onion(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        client_auth: Option\u003c\u0026X25519PublicKey\u003e,\n    ) -\u003e Result\u003cOnionStream, Error\u003e {\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id.clone(), virt_port));\n\n        match \u0026mut self.onion_services {\n            Some(onion_services) =\u003e {\n                if let Some((client_auth_keys, socket_addr)) = onion_services.get(\u0026onion_addr) {\n                    match (client_auth_keys.len(), client_auth) {\n                        (0, None) =\u003e (),\n                        (_, None) =\u003e return Err(Error::OnionServiceRequiresOnionAuth()),\n                        (0, Some(_)) =\u003e return Err(Error::OnionServiceAuthInvalid()),\n                        (_, Some(client_auth)) =\u003e {\n                            if !client_auth_keys.contains(client_auth) {\n                                return Err(Error::OnionServiceAuthInvalid());\n                            }\n                        }\n                    }\n\n                    if let Ok(stream) = TcpStream::connect(socket_addr) {\n                        Ok(OnionStream {\n                            stream,\n                            local_addr: None,\n                            peer_addr: Some(TargetAddr::OnionService(onion_addr)),\n                        })\n                    } else {\n                        Err(Error::OnionServiceNotFound(onion_addr))\n                    }\n                } else {\n                    Err(Error::OnionServiceNotPublished(onion_addr))\n                }\n            },\n            None =\u003e Err(Error::OnionServiceNotPublished(onion_addr))\n        }\n    }\n\n    fn start_onion(\n        \u0026mut self,\n        service_id: V3OnionServiceId,\n        virt_port: u16,\n        client_auth_keys: Vec\u003cX25519PublicKey\u003e,\n        address: SocketAddr,\n    ) {\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id, virt_port));\n        match \u0026mut self.onion_services {\n            Some(onion_services) =\u003e {\n                onion_services.insert(onion_addr, (client_auth_keys, address));\n            },\n            None =\u003e {\n                let mut onion_services = BTreeMap::new();\n                onion_services.insert(onion_addr, (client_auth_keys, address));\n                self.onion_services = Some(onion_services);\n            }\n        }\n    }\n\n    fn stop_onion(\u0026mut self, onion_addr: \u0026OnionAddr) {\n        if let Some(onion_services) = \u0026mut self.onion_services {\n            onion_services.remove(onion_addr);\n        }\n    }\n}\n\nstatic MOCK_TOR_NETWORK: Mutex\u003cMockTorNetwork\u003e = Mutex::new(MockTorNetwork::new());\n\npub struct MockTorClient {\n    events: Vec\u003cTorEvent\u003e,\n    bootstrapped: bool,\n    client_auth_keys: BTreeMap\u003cV3OnionServiceId, X25519PublicKey\u003e,\n    onion_services: Vec\u003c(OnionAddr, Arc\u003catomic::AtomicBool\u003e)\u003e,\n}\n\nimpl MockTorClient {\n    pub fn new() -\u003e MockTorClient {\n        let mut events: Vec\u003cTorEvent\u003e = Default::default();\n        let line = \"[notice] MockTorClient running\".to_string();\n        events.push(TorEvent::LogReceived { line });\n\n        MockTorClient {\n            events,\n            bootstrapped: false,\n            client_auth_keys: Default::default(),\n            onion_services: Default::default(),\n        }\n    }\n}\n\nimpl Default for MockTorClient {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl TorProvider for MockTorClient {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, tor_provider::Error\u003e {\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                let mut i = 0;\n                while i \u003c self.onion_services.len() {\n                    // remove onion services with no active listeners\n                    if !self.onion_services[i].1.load(atomic::Ordering::Relaxed) {\n                        let entry = self.onion_services.swap_remove(i);\n                        let onion_addr = entry.0;\n                        mock_tor_network.stop_onion(\u0026onion_addr);\n                    } else {\n                        i += 1;\n                    }\n                }\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n\n        Ok(std::mem::take(\u0026mut self.events))\n    }\n\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        if self.bootstrapped {\n            Err(Error::ClientAlreadyBootstrapped())?\n        } else {\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 0u32,\n                tag: \"start\".to_string(),\n                summary: \"bootstrapping started\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 50u32,\n                tag: \"middle\".to_string(),\n                summary: \"bootstrapping continues\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 100u32,\n                tag: \"finished\".to_string(),\n                summary: \"bootstrapping completed\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapComplete);\n            self.bootstrapped = true;\n            Ok(())\n        }\n    }\n\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        let client_auth_public = X25519PublicKey::from_private_key(client_auth);\n        if let Some(key) = self.client_auth_keys.get_mut(service_id) {\n            *key = client_auth_public;\n        } else {\n            self.client_auth_keys\n                .insert(service_id.clone(), client_auth_public);\n        }\n        Ok(())\n    }\n\n    fn remove_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        self.client_auth_keys.remove(service_id);\n        Ok(())\n    }\n\n    fn connect(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        _circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, tor_provider::Error\u003e {\n        let client_auth = self.client_auth_keys.get(service_id);\n\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                Ok(mock_tor_network.connect_to_onion(service_id, virt_port, client_auth)?)\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n    }\n\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, tor_provider::Error\u003e {\n        // convert inputs to relevant types\n        let service_id = V3OnionServiceId::from_private_key(private_key);\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id.clone(), virt_port));\n        let authorized_clients: Vec\u003cX25519PublicKey\u003e = match authorized_clients {\n            Some(keys) =\u003e keys.into(),\n            None =\u003e Default::default(),\n        };\n\n        // try to bind to a local address, let OS pick our port\n        let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n        let listener = TcpListener::bind(socket_addr).map_err(Error::TcpListenerBindFailed)?;\n        let socket_addr = listener\n            .local_addr()\n            .map_err(Error::TcpListenerLocalAddrFailed)?;\n\n        // register the onion service with the mock tor network\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e mock_tor_network.start_onion(\n                service_id.clone(),\n                virt_port,\n                authorized_clients,\n                socket_addr,\n            ),\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n\n        // init flag for signaling when listener goes out of scope so we can tear down onion service\n        let is_active = Arc::new(atomic::AtomicBool::new(true));\n        self.onion_services\n            .push((onion_addr.clone(), Arc::clone(\u0026is_active)));\n\n        // onion service published event\n        self.events\n            .push(TorEvent::OnionServicePublished { service_id });\n\n        let onion_listener = Box::new(MockOnionListener {\n            listener,\n            is_active,\n            onion_addr,\n        });\n\n        Ok(OnionListener { onion_listener })\n    }\n\n    fn generate_token(\u0026mut self) -\u003e CircuitToken {\n        0usize\n    }\n\n    fn release_token(\u0026mut self, _token: CircuitToken) {}\n}\n\nimpl Drop for MockTorClient {\n    fn drop(\u0026mut self) {\n        // remove all our onion services\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                for entry in self.onion_services.iter() {\n                    let onion_addr = \u0026entry.0;\n                    mock_tor_network.stop_onion(onion_addr);\n                }\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n    }\n}\n","traces":[{"line":40,"address":[1617255,1617136],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":41,"address":[1617155,1617213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1597744],"length":1,"stats":{"Line":1},"fn_name":"set_nonblocking"},{"line":53,"address":[1597765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1597792,1598180],"length":1,"stats":{"Line":2},"fn_name":"accept"},{"line":56,"address":[1597822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[1598054,1597860],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[1597891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[1597898,1598004],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[1598044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[1597917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1597946,1598247,1598320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[1598327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1598295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1371376],"length":1,"stats":{"Line":2},"fn_name":"drop"},{"line":75,"address":[1371385],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[1598400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1598448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1598527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[1598606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[1598716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[1598791,1599670,1598728,1598980],"length":1,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[1598837,1599143,1598985],"length":1,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[1599099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1599159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1599208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1599229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1599265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1599309,1599524,1599050],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[1599438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1599335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[1599345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[1599526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[1598883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1598612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1599696,1600523,1600495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[1599821,1599737],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[1599846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[1599889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[1600504,1599901],"length":1,"stats":{"Line":4},"fn_name":null},{"line":142,"address":[1599852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[1600207,1600032],"length":1,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[1600231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[1600560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[1600584],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[1600609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[1601090,1600640],"length":1,"stats":{"Line":3},"fn_name":null},{"line":167,"address":[1600656],"length":1,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[1600686],"length":1,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[1600751],"length":1,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[1600831],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[1600894],"length":1,"stats":{"Line":3},"fn_name":null},{"line":181,"address":[1601136],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":182,"address":[1601144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1601965,1601843,1601168],"length":1,"stats":{"Line":2},"fn_name":"update"},{"line":188,"address":[1601198],"length":1,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[1601224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1601244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[1601253,1601265,1601343],"length":1,"stats":{"Line":6},"fn_name":null},{"line":193,"address":[1601862,1601549,1601369],"length":1,"stats":{"Line":6},"fn_name":null},{"line":194,"address":[1601616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[1601674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1601814,1601738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[1601857,1601867,1601644],"length":1,"stats":{"Line":4},"fn_name":null},{"line":205,"address":[1601456],"length":1,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[1602000,1602810],"length":1,"stats":{"Line":2},"fn_name":"bootstrap"},{"line":209,"address":[1602911,1602029],"length":1,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[1602837,1602913,1602087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[1602216],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[1602035],"length":1,"stats":{"Line":3},"fn_name":null},{"line":215,"address":[1602060],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[1602416],"length":1,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[1602316],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[1602341],"length":1,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[1602616],"length":1,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[1602516],"length":1,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[1602541],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[1602749],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[1602780],"length":1,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[1602784],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[1602976],"length":1,"stats":{"Line":2},"fn_name":"add_client_auth"},{"line":238,"address":[1603040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1603150,1603061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[1603115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[1603187,1603162],"length":1,"stats":{"Line":4},"fn_name":null},{"line":243,"address":[1603170],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[1603221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1603248],"length":1,"stats":{"Line":1},"fn_name":"remove_client_auth"},{"line":252,"address":[1603271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[1603295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[1604082,1603328,1604159],"length":1,"stats":{"Line":2},"fn_name":"connect"},{"line":262,"address":[1603418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[1603441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[1603467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[1603570,1603888,1603485],"length":1,"stats":{"Line":5},"fn_name":null},{"line":272,"address":[1606447,1604192,1606624],"length":1,"stats":{"Line":2},"fn_name":"listener"},{"line":279,"address":[1604268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[1604306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[1604383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[1604433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[1604409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[1604488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[1604628,1606622,1604831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[1604965,1604796,1605172],"length":1,"stats":{"Line":4},"fn_name":null},{"line":291,"address":[1605108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[1605201,1605077],"length":1,"stats":{"Line":4},"fn_name":null},{"line":295,"address":[1605212,1605388],"length":1,"stats":{"Line":4},"fn_name":null},{"line":296,"address":[1605331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[1605348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":305,"address":[1605531,1605565],"length":1,"stats":{"Line":4},"fn_name":null},{"line":306,"address":[1605636,1605835],"length":1,"stats":{"Line":4},"fn_name":null},{"line":307,"address":[1605661,1605729],"length":1,"stats":{"Line":4},"fn_name":null},{"line":310,"address":[1605995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":311,"address":[1605859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[1606320,1606109],"length":1,"stats":{"Line":4},"fn_name":null},{"line":314,"address":[1606014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[1606029],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[1606045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[1606328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[1606656],"length":1,"stats":{"Line":0},"fn_name":"generate_token"},{"line":326,"address":[1606672,1606682],"length":1,"stats":{"Line":0},"fn_name":"release_token"},{"line":330,"address":[1371424,1371951,1371874],"length":1,"stats":{"Line":2},"fn_name":"drop"},{"line":332,"address":[1371444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[1371475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[1371493,1371574,1371734],"length":1,"stats":{"Line":6},"fn_name":null},{"line":335,"address":[1371755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[1371763,1371862],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":113,"coverable":127},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","tor_crypto.rs"],"content":"// standard\nuse std::convert::TryInto;\nuse std::iter;\nuse std::str;\n\n// extern crates\nuse curve25519_dalek::Scalar;\nuse data_encoding::{BASE32, BASE32_NOPAD, BASE64};\nuse data_encoding_macro::new_encoding;\nuse rand::distributions::Alphanumeric;\nuse rand::rngs::OsRng;\nuse rand::Rng;\nuse sha3::{Digest, Sha3_256};\nuse static_assertions::const_assert_eq;\nuse tor_llcrypto::pk::keymanip::*;\nuse tor_llcrypto::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"{0}\")]\n    ParseError(String),\n    #[error(\"{0}\")]\n    ConversionError(String),\n    #[error(\"invalid key\")]\n    KeyInvalid,\n}\n\n/// The number of bytes in an ed25519 secret key\n/// cbindgen:ignore\npub const ED25519_PRIVATE_KEY_SIZE: usize = 64;\n/// The number of bytes in an ed25519 public key\n/// cbindgen:ignore\npub const ED25519_PUBLIC_KEY_SIZE: usize = 32;\n/// The number of bytes in an ed25519 signature\n/// cbindgen:ignore\npub const ED25519_SIGNATURE_SIZE: usize = 64;\n/// The number of bytes needed to store onion service id as an ASCII c-string (not including null-terminator)\npub const V3_ONION_SERVICE_ID_STRING_LENGTH: usize = 56;\n/// The number of bytes needed to store onion service id as an ASCII c-string (including null-terminator)\npub const V3_ONION_SERVICE_ID_STRING_SIZE: usize = 57;\nconst_assert_eq!(V3_ONION_SERVICE_ID_STRING_SIZE, V3_ONION_SERVICE_ID_STRING_LENGTH + 1);\n/// The number of bytes needed to store base64 encoded ed25519 private key as an ASCII c-string (not including null-terminator)\npub const ED25519_PRIVATE_KEYBLOB_BASE64_LENGTH: usize = 88;\n/// key klob header string\nconst ED25519_PRIVATE_KEY_KEYBLOB_HEADER: \u0026str = \"ED25519-V3:\";\n/// The number of bytes needed to store the keyblob header\npub const ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH: usize = 11;\nconst_assert_eq!(ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH, ED25519_PRIVATE_KEY_KEYBLOB_HEADER.len());\n/// The number of bytes needed to store ed25519 private keyblob as an ASCII c-string (not including a null terminator)\npub const ED25519_PRIVATE_KEY_KEYBLOB_LENGTH: usize = 99;\nconst_assert_eq!(ED25519_PRIVATE_KEY_KEYBLOB_LENGTH, ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH + ED25519_PRIVATE_KEYBLOB_BASE64_LENGTH);\n/// The number of bytes needed to store ed25519 private keyblob as an ASCII c-string (including a null terminator)\npub const ED25519_PRIVATE_KEY_KEYBLOB_SIZE: usize = 100;\nconst_assert_eq!(ED25519_PRIVATE_KEY_KEYBLOB_SIZE, ED25519_PRIVATE_KEY_KEYBLOB_LENGTH + 1);\n// number of bytes in an onion service id after base32 decode\nconst V3_ONION_SERVICE_ID_RAW_SIZE: usize = 35;\n// byte index of the start of the public key checksum\nconst V3_ONION_SERVICE_ID_CHECKSUM_OFFSET: usize = 32;\n// byte index of the v3 onion service version\nconst V3_ONION_SERVICE_ID_VERSION_OFFSET: usize = 34;\n/// The number of bytes in a v3 service id's truncated checksum\nconst TRUNCATED_CHECKSUM_SIZE: usize = 2;\n/// The number of bytes in an x25519 private key\n/// cbindgen:ignore\npub const X25519_PRIVATE_KEY_SIZE: usize = 32;\n/// The number of bytes in an x25519 publickey\n/// cbindgen:ignore\npub const X25519_PUBLIC_KEY_SIZE: usize = 32;\n/// The number of bytes needed to store base64 encoded x25519 private key as an ASCII c-string (not including null-terminator)\npub const X25519_PRIVATE_KEY_BASE64_LENGTH: usize = 44;\n/// The number of bytes needed to store base64 encoded x25519 private key as an ASCII c-string (including a null terminator)\npub const X25519_PRIVATE_KEY_BASE64_SIZE: usize = 45;\nconst_assert_eq!(X25519_PRIVATE_KEY_BASE64_SIZE, X25519_PRIVATE_KEY_BASE64_LENGTH + 1);\n/// The number of bytes needed to store base32 encoded x25519 public key as an ASCII c-string (not including null-terminator)\npub const X25519_PUBLIC_KEY_BASE32_LENGTH: usize = 52;\n/// The number of bytes needed to store base32 encoded x25519 public key as an ASCII c-string (including a null terminator)\npub const X25519_PUBLIC_KEY_BASE32_SIZE: usize = 53;\nconst_assert_eq!(X25519_PUBLIC_KEY_BASE32_SIZE, X25519_PUBLIC_KEY_BASE32_LENGTH + 1);\n\nconst ONION_BASE32: data_encoding::Encoding = new_encoding! {\n    symbols: \"abcdefghijklmnopqrstuvwxyz234567\",\n    padding: '=',\n};\n\n// Free functions\n\n// securely generate password using OsRng\npub(crate) fn generate_password(length: usize) -\u003e String {\n    let password: String = iter::repeat(())\n        .map(|()| OsRng.sample(Alphanumeric))\n        .map(char::from)\n        .take(length)\n        .collect();\n\n    password\n}\n\n// Struct deinitions\n\npub struct Ed25519PrivateKey {\n    expanded_keypair: pk::ed25519::ExpandedKeypair,\n}\n\n#[derive(Clone)]\npub struct Ed25519PublicKey {\n    public_key: pk::ed25519::PublicKey,\n}\n\n#[derive(Clone)]\npub struct Ed25519Signature {\n    signature: pk::ed25519::Signature,\n}\n\n#[derive(Clone)]\npub struct X25519PrivateKey {\n    secret_key: pk::curve25519::StaticSecret,\n}\n\n#[derive(Clone, PartialEq, Eq, Hash)]\npub struct X25519PublicKey {\n    public_key: pk::curve25519::PublicKey,\n}\n\n#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct V3OnionServiceId {\n    data: [u8; V3_ONION_SERVICE_ID_STRING_LENGTH],\n}\n\n#[derive(Clone, Copy)]\npub enum SignBit {\n    Zero,\n    One,\n}\n\nimpl From\u003cSignBit\u003e for u8 {\n    fn from(signbit: SignBit) -\u003e Self {\n        match signbit {\n            SignBit::Zero =\u003e 0u8,\n            SignBit::One =\u003e 1u8,\n        }\n    }\n}\n\nimpl From\u003cSignBit\u003e for bool {\n    fn from(signbit: SignBit) -\u003e Self {\n        match signbit {\n            SignBit::Zero =\u003e false,\n            SignBit::One =\u003e true,\n        }\n    }\n}\n\nimpl From\u003cbool\u003e for SignBit {\n    fn from(signbit: bool) -\u003e Self {\n        if signbit {\n            SignBit::One\n        } else {\n            SignBit::Zero\n        }\n    }\n}\n\n// which validation method to use when constructing an ed25519 expanded key from\n// a byte array\nenum FromRawValidationMethod {\n    // expanded ed25519 keys coming from legacy c-tor daemon; the scalar portion\n    // is clamped, but not reduced\n    LegacyCTor,\n    // expanded ed25519 keys coming from ed25519-dalek crate; the scalar portion\n    // has been clamped AND reduced\n    Ed25519Dalek,\n}\n\n// Ed25519 Private Key\n\nimpl Ed25519PrivateKey {\n    pub fn generate() -\u003e Ed25519PrivateKey {\n        let csprng = \u0026mut OsRng;\n        let keypair = pk::ed25519::Keypair::generate(csprng);\n\n        Ed25519PrivateKey {\n            expanded_keypair: pk::ed25519::ExpandedKeypair::from(\u0026keypair),\n        }\n    }\n\n    fn from_raw_impl(raw: \u0026[u8; ED25519_PRIVATE_KEY_SIZE], method: FromRawValidationMethod) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        // see: https://gitlab.torproject.org/tpo/core/arti/-/issues/1343\n        match method {\n            FromRawValidationMethod::LegacyCTor =\u003e {\n                // Verify the scalar portion of the expanded key has been clamped\n                // see: https://gitlab.torproject.org/tpo/core/arti/-/issues/1021\n                if !(raw[0] == raw[0] \u0026 248 \u0026\u0026 raw[31] == (raw[31] \u0026 63) | 64) {\n                    return Err(Error::KeyInvalid);\n                }\n            },\n            FromRawValidationMethod::Ed25519Dalek =\u003e {\n                // Verify the scalar is non-zero and it has been reduced\n                let scalar: [u8; 32] = raw[..32].try_into().unwrap();\n                if scalar.iter().all(|\u0026x| x == 0x00u8) {\n                    return Err(Error::KeyInvalid);\n                }\n                let reduced_scalar = Scalar::from_bytes_mod_order(scalar).to_bytes();\n                if scalar != reduced_scalar {\n                    return Err(Error::KeyInvalid);\n                }\n            }\n        }\n\n        if let Some(expanded_keypair) = pk::ed25519::ExpandedKeypair::from_secret_key_bytes(*raw) {\n            Ok(Ed25519PrivateKey{expanded_keypair})\n        } else {\n            Err(Error::KeyInvalid)\n        }\n    }\n\n    pub fn from_raw(raw: \u0026[u8; ED25519_PRIVATE_KEY_SIZE]) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_raw_impl(raw, FromRawValidationMethod::Ed25519Dalek)\n    }\n\n    fn from_key_blob_impl(key_blob: \u0026str, method: FromRawValidationMethod) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        if key_blob.len() != ED25519_PRIVATE_KEY_KEYBLOB_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received string with length '{}'\",\n                ED25519_PRIVATE_KEY_KEYBLOB_LENGTH,\n                key_blob.len()\n            )));\n        }\n\n        if !key_blob.starts_with(ED25519_PRIVATE_KEY_KEYBLOB_HEADER) {\n            return Err(Error::ParseError(format!(\n                \"expects string that begins with '{}'; received '{}'\",\n                \u0026ED25519_PRIVATE_KEY_KEYBLOB_HEADER, \u0026key_blob\n            )));\n        }\n\n        let base64_key: \u0026str = \u0026key_blob[ED25519_PRIVATE_KEY_KEYBLOB_HEADER.len()..];\n        let private_key_data = match BASE64.decode(base64_key.as_bytes()) {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"could not parse '{}' as base64\",\n                    base64_key\n                )))\n            }\n        };\n        let private_key_data_len = private_key_data.len();\n        let private_key_data_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = match private_key_data.try_into()\n        {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded private key length '{}'; actual '{}'\",\n                    ED25519_PRIVATE_KEY_SIZE, private_key_data_len\n                )))\n            }\n        };\n\n        Ed25519PrivateKey::from_raw_impl(\u0026private_key_data_raw, method)\n    }\n\n    pub (crate) fn from_key_blob_legacy(key_blob: \u0026str) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_key_blob_impl(key_blob, FromRawValidationMethod::LegacyCTor)\n    }\n\n    pub fn from_key_blob(key_blob: \u0026str) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_key_blob_impl(key_blob, FromRawValidationMethod::Ed25519Dalek)\n    }\n\n    pub fn from_private_x25519(\n        x25519_private: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(Ed25519PrivateKey, SignBit), Error\u003e {\n        if let Some((result, signbit)) =\n            convert_curve25519_to_ed25519_private(\u0026x25519_private.secret_key)\n        {\n            Ok((\n                Ed25519PrivateKey {\n                    expanded_keypair: result,\n                },\n                match signbit {\n                    0u8 =\u003e SignBit::Zero,\n                    1u8 =\u003e SignBit::One,\n                    invalid_signbit =\u003e {\n                        return Err(Error::ConversionError(format!(\n                            \"convert_curve25519_to_ed25519_private() returned invalid signbit: {}\",\n                            invalid_signbit\n                        )))\n                    }\n                },\n            ))\n        } else {\n            Err(Error::ConversionError(\n                \"could not convert x25519 private key to ed25519 private key\".to_string(),\n            ))\n        }\n    }\n\n    pub fn to_key_blob(\u0026self) -\u003e String {\n        let mut key_blob = ED25519_PRIVATE_KEY_KEYBLOB_HEADER.to_string();\n        key_blob.push_str(\u0026BASE64.encode(\u0026self.expanded_keypair.to_secret_key_bytes()));\n\n        key_blob\n    }\n\n    pub fn sign_message_ex(\n        \u0026self,\n        _public_key: \u0026Ed25519PublicKey,\n        message: \u0026[u8],\n    ) -\u003e Ed25519Signature {\n        let signature = self\n            .expanded_keypair\n            .sign(message);\n        Ed25519Signature { signature }\n    }\n\n    pub fn sign_message(\u0026self, message: \u0026[u8]) -\u003e Ed25519Signature {\n        let public_key = Ed25519PublicKey::from_private_key(self);\n        self.sign_message_ex(\u0026public_key, message)\n    }\n\n    pub fn to_bytes(\u0026self) -\u003e [u8; ED25519_PRIVATE_KEY_SIZE] {\n        self.expanded_keypair.to_secret_key_bytes()\n    }\n}\n\nimpl PartialEq for Ed25519PrivateKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.to_bytes().eq(\u0026other.to_bytes())\n    }\n}\n\nimpl Clone for Ed25519PrivateKey {\n    fn clone(\u0026self) -\u003e Ed25519PrivateKey {\n        match Ed25519PrivateKey::from_raw(\u0026self.to_bytes()) {\n            Ok(ed25519_private_key) =\u003e ed25519_private_key,\n            Err(_) =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl std::fmt::Debug for Ed25519PrivateKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"--- ed25519 private key ---\")\n    }\n}\n\n// Ed25519 Public Key\n\nimpl Ed25519PublicKey {\n    pub fn from_raw(raw: \u0026[u8; ED25519_PUBLIC_KEY_SIZE]) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        Ok(Ed25519PublicKey {\n            public_key: match pk::ed25519::PublicKey::from_bytes(raw) {\n                Ok(public_key) =\u003e public_key,\n                Err(_) =\u003e {\n                    return Err(Error::ConversionError(\n                        \"failed to create ed25519 public key from bytes\".to_string(),\n                    ))\n                }\n            },\n        })\n    }\n\n    pub fn from_service_id(service_id: \u0026V3OnionServiceId) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        // decode base32 encoded service id\n        let mut decoded_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n        let decoded_byte_count =\n            match ONION_BASE32.decode_mut(service_id.as_bytes(), \u0026mut decoded_service_id) {\n                Ok(decoded_byte_count) =\u003e decoded_byte_count,\n                Err(_) =\u003e {\n                    return Err(Error::ConversionError(format!(\n                        \"failed to decode '{}' as V3OnionServiceId\",\n                        service_id\n                    )))\n                }\n            };\n        if decoded_byte_count != V3_ONION_SERVICE_ID_RAW_SIZE {\n            return Err(Error::ConversionError(format!(\n                \"decoded byte count is '{}', expected '{}'\",\n                decoded_byte_count, V3_ONION_SERVICE_ID_RAW_SIZE\n            )));\n        }\n\n        Ed25519PublicKey::from_raw(\n            decoded_service_id[0..ED25519_PUBLIC_KEY_SIZE]\n                .try_into()\n                .unwrap(),\n        )\n    }\n\n    pub fn from_private_key(private_key: \u0026Ed25519PrivateKey) -\u003e Ed25519PublicKey {\n        Ed25519PublicKey {\n            public_key: *private_key.expanded_keypair.public()\n        }\n    }\n\n    fn from_public_x25519(\n        public_x25519: \u0026X25519PublicKey,\n        signbit: SignBit,\n    ) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        match convert_curve25519_to_ed25519_public(\u0026public_x25519.public_key, signbit.into()) {\n            Some(public_key) =\u003e Ok(Ed25519PublicKey { public_key }),\n            None =\u003e Err(Error::ConversionError(\n                \"failed to create ed25519 public key from x25519 public key and signbit\"\n                    .to_string(),\n            )),\n        }\n    }\n\n    pub fn to_base32(\u0026self) -\u003e String {\n        BASE32.encode(self.as_bytes())\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; ED25519_PUBLIC_KEY_SIZE] {\n        self.public_key.as_bytes()\n    }\n}\n\nimpl PartialEq for Ed25519PublicKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.public_key.eq(\u0026other.public_key)\n    }\n}\n\nimpl std::fmt::Debug for Ed25519PublicKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.public_key.fmt(f)\n    }\n}\n\n// Ed25519 Signature\n\nimpl Ed25519Signature {\n    pub fn from_raw(raw: \u0026[u8; ED25519_SIGNATURE_SIZE]) -\u003e Result\u003cEd25519Signature, Error\u003e {\n        Ok(Ed25519Signature {\n            signature: pk::ed25519::Signature::from_bytes(raw)\n        })\n    }\n\n    pub fn verify(\u0026self, message: \u0026[u8], public_key: \u0026Ed25519PublicKey) -\u003e bool {\n        if let Ok(()) = public_key.public_key.verify_strict(message, \u0026self.signature) {\n            return true;\n        }\n        false\n    }\n\n    // derives an ed25519 public key from the provided x25519 public key and signbit, then\n    // verifies this signature using said ed25519 public key\n    pub fn verify_x25519(\n        \u0026self,\n        message: \u0026[u8],\n        public_key: \u0026X25519PublicKey,\n        signbit: SignBit,\n    ) -\u003e bool {\n        if let Ok(public_key) = Ed25519PublicKey::from_public_x25519(public_key, signbit) {\n            return self.verify(message, \u0026public_key);\n        }\n        false\n    }\n\n    pub fn to_bytes(\u0026self) -\u003e [u8; ED25519_SIGNATURE_SIZE] {\n        self.signature.to_bytes()\n    }\n}\n\nimpl PartialEq for Ed25519Signature {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.signature.eq(\u0026other.signature)\n    }\n}\n\nimpl std::fmt::Debug for Ed25519Signature {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.signature.fmt(f)\n    }\n}\n\n// X25519 Private Key\n\nimpl X25519PrivateKey {\n    pub fn generate() -\u003e X25519PrivateKey {\n        let csprng = \u0026mut OsRng;\n        X25519PrivateKey {\n            secret_key: pk::curve25519::StaticSecret::random_from_rng(csprng),\n        }\n    }\n\n    pub fn from_raw(raw: \u0026[u8; X25519_PRIVATE_KEY_SIZE]) -\u003e Result\u003cX25519PrivateKey, Error\u003e {\n        // see: https://docs.rs/x25519-dalek/2.0.0-pre.1/src/x25519_dalek/x25519.rs.html#197\n        if raw[0] == raw[0] \u0026 240 \u0026\u0026 raw[31] == (raw[31] \u0026 127) | 64 {\n            Ok(X25519PrivateKey {\n                secret_key: pk::curve25519::StaticSecret::from(*raw),\n            })\n        } else {\n            Err(Error::KeyInvalid)\n        }\n    }\n\n    // a base64 encoded keyblob\n    pub fn from_base64(base64: \u0026str) -\u003e Result\u003cX25519PrivateKey, Error\u003e {\n        if base64.len() != X25519_PRIVATE_KEY_BASE64_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received string with length '{}'\",\n                X25519_PRIVATE_KEY_BASE64_LENGTH,\n                base64.len()\n            )));\n        }\n\n        let private_key_data = match BASE64.decode(base64.as_bytes()) {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"could not parse '{}' as base64\",\n                    base64\n                )))\n            }\n        };\n        let private_key_data_len = private_key_data.len();\n        let private_key_data_raw: [u8; X25519_PRIVATE_KEY_SIZE] = match private_key_data.try_into()\n        {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded private key length '{}'; actual '{}'\",\n                    X25519_PRIVATE_KEY_SIZE, private_key_data_len\n                )))\n            }\n        };\n\n        X25519PrivateKey::from_raw(\u0026private_key_data_raw)\n    }\n\n    // security note: only ever sign messages the private key owner controls the contents of!\n    // this function first derives an ed25519 private key from the provided x25519 private key\n    // and signs the message, returning the signature and signbit needed to calculate the\n    // ed25519 public key from our x25519 private key's associated x25519 public key\n    pub fn sign_message(\u0026self, message: \u0026[u8]) -\u003e Result\u003c(Ed25519Signature, SignBit), Error\u003e {\n        let (ed25519_private, signbit) = Ed25519PrivateKey::from_private_x25519(self)?;\n        Ok((ed25519_private.sign_message(message), signbit))\n    }\n\n    pub fn to_base64(\u0026self) -\u003e String {\n        BASE64.encode(\u0026self.secret_key.to_bytes())\n    }\n\n    pub fn to_bytes(\u0026self) -\u003e [u8; X25519_PRIVATE_KEY_SIZE] {\n        self.secret_key.to_bytes()\n    }\n}\n\nimpl PartialEq for X25519PrivateKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.secret_key.to_bytes() == other.secret_key.to_bytes()\n    }\n}\n\nimpl std::fmt::Debug for X25519PrivateKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"--- x25519 private key ---\")\n    }\n}\n\n// X25519 Public Key\nimpl X25519PublicKey {\n    pub fn from_private_key(private_key: \u0026X25519PrivateKey) -\u003e X25519PublicKey {\n        X25519PublicKey {\n            public_key: pk::curve25519::PublicKey::from(\u0026private_key.secret_key),\n        }\n    }\n\n    pub fn from_raw(raw: \u0026[u8; X25519_PUBLIC_KEY_SIZE]) -\u003e X25519PublicKey {\n        X25519PublicKey {\n            public_key: pk::curve25519::PublicKey::from(*raw),\n        }\n    }\n\n    pub fn from_base32(base32: \u0026str) -\u003e Result\u003cX25519PublicKey, Error\u003e {\n        if base32.len() != X25519_PUBLIC_KEY_BASE32_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received '{}' with length '{}'\",\n                X25519_PUBLIC_KEY_BASE32_LENGTH,\n                base32,\n                base32.len()\n            )));\n        }\n\n        let public_key_data = match BASE32_NOPAD.decode(base32.as_bytes()) {\n            Ok(public_key_data) =\u003e public_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"failed to decode '{}' as X25519PublicKey\",\n                    base32\n                )))\n            }\n        };\n        let public_key_data_len = public_key_data.len();\n        let public_key_data_raw: [u8; X25519_PUBLIC_KEY_SIZE] = match public_key_data.try_into() {\n            Ok(public_key_data) =\u003e public_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded public key length '{}'; actual '{}'\",\n                    X25519_PUBLIC_KEY_SIZE, public_key_data_len\n                )))\n            }\n        };\n\n        Ok(X25519PublicKey::from_raw(\u0026public_key_data_raw))\n    }\n\n    pub fn to_base32(\u0026self) -\u003e String {\n        BASE32_NOPAD.encode(self.public_key.as_bytes())\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; X25519_PUBLIC_KEY_SIZE] {\n        self.public_key.as_bytes()\n    }\n}\n\nimpl std::fmt::Debug for X25519PublicKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.to_base32())\n    }\n}\n\n// Onion Service Id\n\nimpl V3OnionServiceId {\n    // see https://github.com/torproject/torspec/blob/main/rend-spec-v3.txt#L2143\n    fn calc_truncated_checksum(\n        public_key: \u0026[u8; ED25519_PUBLIC_KEY_SIZE],\n    ) -\u003e [u8; TRUNCATED_CHECKSUM_SIZE] {\n        let mut hasher = Sha3_256::new();\n\n        // calculate checksum\n        hasher.update(b\".onion checksum\");\n        hasher.update(public_key);\n        hasher.update([0x03u8]);\n        let hash_bytes = hasher.finalize();\n\n        [hash_bytes[0], hash_bytes[1]]\n    }\n\n    pub fn from_string(service_id: \u0026str) -\u003e Result\u003cV3OnionServiceId, Error\u003e {\n        if !V3OnionServiceId::is_valid(service_id) {\n            return Err(Error::ParseError(format!(\n                \"'{}' is not a valid v3 onion service id\",\n                service_id\n            )));\n        }\n        Ok(V3OnionServiceId {\n            data: service_id.as_bytes().try_into().unwrap(),\n        })\n    }\n\n    pub fn from_public_key(public_key: \u0026Ed25519PublicKey) -\u003e V3OnionServiceId {\n        let mut raw_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n\n        raw_service_id[..ED25519_PUBLIC_KEY_SIZE].copy_from_slice(\u0026public_key.as_bytes()[..]);\n        let truncated_checksum = Self::calc_truncated_checksum(public_key.as_bytes());\n        raw_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET] = truncated_checksum[0];\n        raw_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET + 1] = truncated_checksum[1];\n        raw_service_id[V3_ONION_SERVICE_ID_VERSION_OFFSET] = 0x03u8;\n\n        let mut service_id = [0u8; V3_ONION_SERVICE_ID_STRING_LENGTH];\n        // panics on wrong buffer size, but given our constant buffer sizes should be fine\n        ONION_BASE32.encode_mut(\u0026raw_service_id, \u0026mut service_id);\n\n        V3OnionServiceId { data: service_id }\n    }\n\n    pub fn from_private_key(private_key: \u0026Ed25519PrivateKey) -\u003e V3OnionServiceId {\n        Self::from_public_key(\u0026Ed25519PublicKey::from_private_key(private_key))\n    }\n\n    pub fn is_valid(service_id: \u0026str) -\u003e bool {\n        if service_id.len() != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            return false;\n        }\n\n        let mut decoded_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n        match ONION_BASE32.decode_mut(service_id.as_bytes(), \u0026mut decoded_service_id) {\n            Ok(decoded_byte_count) =\u003e {\n                // ensure right size\n                if decoded_byte_count != V3_ONION_SERVICE_ID_RAW_SIZE {\n                    return false;\n                }\n                // ensure correct version\n                if decoded_service_id[V3_ONION_SERVICE_ID_VERSION_OFFSET] != 0x03 {\n                    return false;\n                }\n                // copy public key into own buffer\n                let mut public_key = [0u8; ED25519_PUBLIC_KEY_SIZE];\n                public_key[..].copy_from_slice(\u0026decoded_service_id[..ED25519_PUBLIC_KEY_SIZE]);\n                // ensure checksum is correct\n                let truncated_checksum = Self::calc_truncated_checksum(\u0026public_key);\n                if truncated_checksum[0] != decoded_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET]\n                    || truncated_checksum[1]\n                        != decoded_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET + 1]\n                {\n                    return false;\n                }\n                true\n            }\n            Err(_) =\u003e false,\n        }\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; V3_ONION_SERVICE_ID_STRING_LENGTH] {\n        \u0026self.data\n    }\n}\n\nimpl std::fmt::Display for V3OnionServiceId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        unsafe { write!(f, \"{}\", str::from_utf8_unchecked(\u0026self.data)) }\n    }\n}\n\nimpl std::fmt::Debug for V3OnionServiceId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        unsafe { write!(f, \"{}\", str::from_utf8_unchecked(\u0026self.data)) }\n    }\n}\n","traces":[{"line":88,"address":[1390688],"length":1,"stats":{"Line":0},"fn_name":"generate_password"},{"line":89,"address":[1390712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1527344,1527353],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":136,"address":[1390768],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":137,"address":[1390777],"length":1,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[1390792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[1390799],"length":1,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[1390816],"length":1,"stats":{"Line":2},"fn_name":"from"},{"line":146,"address":[1390825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[1390840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1390847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[1390864],"length":1,"stats":{"Line":2},"fn_name":"from"},{"line":155,"address":[1390876,1390885],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[1390887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[1390880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[1391068,1390912],"length":1,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[1390933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[1390941],"length":1,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[1390965],"length":1,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[1391104],"length":1,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[1391142],"length":1,"stats":{"Line":3},"fn_name":null},{"line":192,"address":[1391483,1391170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1391424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[1391195],"length":1,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[1391360],"length":1,"stats":{"Line":9},"fn_name":null},{"line":200,"address":[1391688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1391585],"length":1,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[1391655],"length":1,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[1391765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1391504,1391837,1391940],"length":1,"stats":{"Line":9},"fn_name":null},{"line":210,"address":[1391875],"length":1,"stats":{"Line":3},"fn_name":null},{"line":212,"address":[1391947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[1392080],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[1392096],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[1392128,1394300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[1392185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[1392447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1392344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1392220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1392801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[1392737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1393021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1393122,1393266],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[1393328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1394351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1393538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1393575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[1393664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1394089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1393900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[1394576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[1394598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1394640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[1394662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[1395392,1394704,1395575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[1395520,1394756],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[1395021],"length":1,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[1394855],"length":1,"stats":{"Line":3},"fn_name":null},{"line":279,"address":[1394861],"length":1,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[1395003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[1395013],"length":1,"stats":{"Line":3},"fn_name":null},{"line":282,"address":[1394919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1395156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1395406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[1394885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1395987,1395616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[1395646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[1395673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[1395953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1396016],"length":1,"stats":{"Line":3},"fn_name":null},{"line":309,"address":[1396082],"length":1,"stats":{"Line":3},"fn_name":null},{"line":315,"address":[1396128],"length":1,"stats":{"Line":3},"fn_name":null},{"line":316,"address":[1396184],"length":1,"stats":{"Line":3},"fn_name":null},{"line":317,"address":[1396215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":320,"address":[1396240],"length":1,"stats":{"Line":3},"fn_name":null},{"line":321,"address":[1396257],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[1396288],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":327,"address":[1396321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[1396384,1396603,1396574],"length":1,"stats":{"Line":2},"fn_name":"clone"},{"line":333,"address":[1396409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[1396455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[1396624],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":342,"address":[1396642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[1397077,1396704],"length":1,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[1396782],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[1396728],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[1396752],"length":1,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[1396943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[1396855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[1397104,1398226],"length":1,"stats":{"Line":3},"fn_name":null},{"line":364,"address":[1397126],"length":1,"stats":{"Line":3},"fn_name":null},{"line":365,"address":[1397247,1397147],"length":1,"stats":{"Line":6},"fn_name":null},{"line":367,"address":[1397312],"length":1,"stats":{"Line":3},"fn_name":null},{"line":369,"address":[1398007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[1397344],"length":1,"stats":{"Line":3},"fn_name":null},{"line":376,"address":[1397772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[1397433],"length":1,"stats":{"Line":3},"fn_name":null},{"line":389,"address":[1398272],"length":1,"stats":{"Line":4},"fn_name":null},{"line":391,"address":[1398310],"length":1,"stats":{"Line":4},"fn_name":null},{"line":395,"address":[1398368],"length":1,"stats":{"Line":3},"fn_name":null},{"line":399,"address":[1398411],"length":1,"stats":{"Line":3},"fn_name":null},{"line":400,"address":[1398610],"length":1,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[1398493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1398464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[1398720,1398874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[1398832,1398750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[1398896],"length":1,"stats":{"Line":4},"fn_name":null},{"line":413,"address":[1398901],"length":1,"stats":{"Line":4},"fn_name":null},{"line":418,"address":[1398912],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":419,"address":[1398926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[1398944],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":425,"address":[1398958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1398976],"length":1,"stats":{"Line":3},"fn_name":null},{"line":433,"address":[1399011],"length":1,"stats":{"Line":3},"fn_name":null},{"line":434,"address":[1399000],"length":1,"stats":{"Line":3},"fn_name":null},{"line":438,"address":[1399088],"length":1,"stats":{"Line":3},"fn_name":null},{"line":439,"address":[1399129],"length":1,"stats":{"Line":3},"fn_name":null},{"line":440,"address":[1399148],"length":1,"stats":{"Line":4},"fn_name":null},{"line":442,"address":[1399177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[1399465,1399200],"length":1,"stats":{"Line":3},"fn_name":null},{"line":453,"address":[1399282],"length":1,"stats":{"Line":3},"fn_name":null},{"line":454,"address":[1399431,1399356],"length":1,"stats":{"Line":6},"fn_name":null},{"line":456,"address":[1399382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[1399488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[1399505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[1399536],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":466,"address":[1399550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1399568],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":472,"address":[1399582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[1399600],"length":1,"stats":{"Line":3},"fn_name":null},{"line":480,"address":[1399614],"length":1,"stats":{"Line":3},"fn_name":null},{"line":482,"address":[1399624],"length":1,"stats":{"Line":3},"fn_name":null},{"line":486,"address":[1399696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[1399805,1399726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1399874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[1399836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[1399742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[1399968,1401515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[1400001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[1400293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[1400190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[1400560,1400036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":508,"address":[1400622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[1401566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[1400832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[1400869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[1400954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[1401311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[1401116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[1402257,1401792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[1402031,1401843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[1402159,1402004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[1402288,1402425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[1402378,1402306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":544,"address":[1402448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[1402465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[1402480],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":551,"address":[1402504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[1402560],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":557,"address":[1402578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[1402640],"length":1,"stats":{"Line":4},"fn_name":null},{"line":565,"address":[1402658],"length":1,"stats":{"Line":4},"fn_name":null},{"line":569,"address":[1402720],"length":1,"stats":{"Line":3},"fn_name":null},{"line":571,"address":[1402738],"length":1,"stats":{"Line":3},"fn_name":null},{"line":575,"address":[1404558,1402832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[1402871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[1403246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[1403133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[1402906,1403532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":586,"address":[1403594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":588,"address":[1404609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[1403804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[1403841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[1403926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[1404351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[1404086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[1404832,1404982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[1404862,1404940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[1405008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":613,"address":[1405013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":618,"address":[1405296,1405024],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":619,"address":[1405058,1405200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[1405328],"length":1,"stats":{"Line":4},"fn_name":null},{"line":630,"address":[1405348],"length":1,"stats":{"Line":4},"fn_name":null},{"line":633,"address":[1405359],"length":1,"stats":{"Line":4},"fn_name":null},{"line":634,"address":[1405382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":635,"address":[1405393],"length":1,"stats":{"Line":4},"fn_name":null},{"line":636,"address":[1405420],"length":1,"stats":{"Line":4},"fn_name":null},{"line":638,"address":[1405510,1405580,1405660],"length":1,"stats":{"Line":8},"fn_name":null},{"line":641,"address":[1405696],"length":1,"stats":{"Line":3},"fn_name":null},{"line":642,"address":[1405723],"length":1,"stats":{"Line":3},"fn_name":null},{"line":643,"address":[1405807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[1406130],"length":1,"stats":{"Line":3},"fn_name":null},{"line":649,"address":[1405962],"length":1,"stats":{"Line":3},"fn_name":null},{"line":653,"address":[1406208,1406759],"length":1,"stats":{"Line":4},"fn_name":null},{"line":654,"address":[1406238],"length":1,"stats":{"Line":4},"fn_name":null},{"line":656,"address":[1406255],"length":1,"stats":{"Line":4},"fn_name":null},{"line":657,"address":[1406365],"length":1,"stats":{"Line":4},"fn_name":null},{"line":658,"address":[1406400],"length":1,"stats":{"Line":4},"fn_name":null},{"line":659,"address":[1406408,1406621],"length":1,"stats":{"Line":4},"fn_name":null},{"line":660,"address":[1406499],"length":1,"stats":{"Line":4},"fn_name":null},{"line":662,"address":[1406504],"length":1,"stats":{"Line":4},"fn_name":null},{"line":664,"address":[1406543,1406642],"length":1,"stats":{"Line":4},"fn_name":null},{"line":669,"address":[1406784],"length":1,"stats":{"Line":3},"fn_name":null},{"line":670,"address":[1406808],"length":1,"stats":{"Line":3},"fn_name":null},{"line":673,"address":[1407610,1406848],"length":1,"stats":{"Line":3},"fn_name":null},{"line":674,"address":[1406881],"length":1,"stats":{"Line":3},"fn_name":null},{"line":675,"address":[1406987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[1406902],"length":1,"stats":{"Line":3},"fn_name":null},{"line":679,"address":[1407051,1406929],"length":1,"stats":{"Line":6},"fn_name":null},{"line":680,"address":[1407114],"length":1,"stats":{"Line":3},"fn_name":null},{"line":682,"address":[1407130],"length":1,"stats":{"Line":3},"fn_name":null},{"line":683,"address":[1407150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[1407148,1407160],"length":1,"stats":{"Line":6},"fn_name":null},{"line":687,"address":[1407225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[1407170],"length":1,"stats":{"Line":3},"fn_name":null},{"line":691,"address":[1407189,1407255],"length":1,"stats":{"Line":6},"fn_name":null},{"line":693,"address":[1407354],"length":1,"stats":{"Line":3},"fn_name":null},{"line":694,"address":[1407395],"length":1,"stats":{"Line":3},"fn_name":null},{"line":695,"address":[1407419,1407431,1407522],"length":1,"stats":{"Line":9},"fn_name":null},{"line":696,"address":[1407535,1407442],"length":1,"stats":{"Line":3},"fn_name":null},{"line":698,"address":[1407421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[1407558],"length":1,"stats":{"Line":3},"fn_name":null},{"line":702,"address":[1407138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[1407632],"length":1,"stats":{"Line":3},"fn_name":null},{"line":712,"address":[1407648],"length":1,"stats":{"Line":3},"fn_name":"fmt"},{"line":713,"address":[1407734,1407674],"length":1,"stats":{"Line":6},"fn_name":null},{"line":718,"address":[1407808],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":719,"address":[1407894,1407834],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":174,"coverable":229},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","tor_provider.rs"],"content":"// standard\nuse std::boxed::Box;\nuse std::io::{Read, Write};\nuse std::net::TcpStream;\nuse std::ops::{Deref, DerefMut};\n\n// internal crates\nuse crate::tor_crypto::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct OnionAddrV3 {\n    service_id: V3OnionServiceId,\n    virt_port: u16,\n}\n\nimpl OnionAddrV3 {\n    pub fn new(service_id: V3OnionServiceId, virt_port: u16) -\u003e OnionAddrV3 {\n        OnionAddrV3 {\n            service_id,\n            virt_port,\n        }\n    }\n\n    pub fn service_id(\u0026self) -\u003e \u0026V3OnionServiceId {\n        \u0026self.service_id\n    }\n}\n\nimpl std::fmt::Display for OnionAddrV3 {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}:{}\", self.service_id, self.virt_port)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub enum OnionAddr {\n    V3(OnionAddrV3),\n}\n\nimpl std::fmt::Display for OnionAddr {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            OnionAddr::V3(onion_addr) =\u003e onion_addr.fmt(f),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub enum TargetAddr {\n    Ip(std::net::SocketAddr),\n    Domain(String, u16),\n    OnionService(OnionAddr),\n}\n\n#[derive(Debug)]\npub enum TorEvent {\n    BootstrapStatus {\n        progress: u32,\n        tag: String,\n        summary: String,\n    },\n    BootstrapComplete,\n    LogReceived {\n        line: String,\n    },\n    OnionServicePublished {\n        service_id: V3OnionServiceId,\n    },\n}\n\npub type CircuitToken = usize;\n\n//\n// OnionStream Implementation\n//\n\npub struct OnionStream {\n    pub(crate) stream: TcpStream,\n    pub(crate) local_addr: Option\u003cOnionAddr\u003e,\n    pub(crate) peer_addr: Option\u003cTargetAddr\u003e,\n}\n\nimpl Deref for OnionStream {\n    type Target = TcpStream;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.stream\n    }\n}\n\nimpl DerefMut for OnionStream {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.stream\n    }\n}\n\nimpl From\u003cOnionStream\u003e for TcpStream {\n    fn from(onion_stream: OnionStream) -\u003e Self {\n        onion_stream.stream\n    }\n}\n\nimpl Read for OnionStream {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.stream.read(buf)\n    }\n}\n\nimpl Write for OnionStream {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.stream.write(buf)\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.stream.flush()\n    }\n}\n\nimpl OnionStream {\n    pub fn peer_addr(\u0026self) -\u003e Option\u003cTargetAddr\u003e {\n        self.peer_addr.clone()\n    }\n\n    pub fn local_addr(\u0026self) -\u003e Option\u003cOnionAddr\u003e {\n        None\n    }\n\n    pub fn try_clone(\u0026self) -\u003e Result\u003cSelf, std::io::Error\u003e {\n        Ok(Self {\n            stream: self.stream.try_clone()?,\n            local_addr: self.local_addr.clone(),\n            peer_addr: self.peer_addr.clone(),\n        })\n    }\n}\n\npub trait OnionListenerImpl: Send {\n    fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e;\n    fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e;\n}\n\npub struct OnionListener {\n    pub(crate) onion_listener: Box\u003cdyn OnionListenerImpl\u003e,\n}\n\nimpl OnionListener {\n    pub fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.onion_listener.set_nonblocking(nonblocking)\n    }\n\n    pub fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e {\n        self.onion_listener.accept()\n    }\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"{0}\")]\n    Generic(String),\n}\n\npub trait TorProvider: Send {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, Error\u003e;\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), Error\u003e;\n    fn remove_client_auth(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e;\n    fn connect(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, Error\u003e;\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, Error\u003e;\n    fn generate_token(\u0026mut self) -\u003e CircuitToken;\n    fn release_token(\u0026mut self, token: CircuitToken);\n}\n","traces":[{"line":17,"address":[1617280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[2127200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2127216],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":31,"address":[2127292,2127336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[2127424],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":43,"address":[2127437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2127472],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":86,"address":[2127480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1617632],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"},{"line":92,"address":[1617640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1456048],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":98,"address":[2403809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[2127504],"length":1,"stats":{"Line":1},"fn_name":"read"},{"line":104,"address":[2127531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[2127552],"length":1,"stats":{"Line":1},"fn_name":"write"},{"line":110,"address":[2127579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[2127600],"length":1,"stats":{"Line":1},"fn_name":"flush"},{"line":114,"address":[2127605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1617760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1617777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1617808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1617816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1617824,1618154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1618060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1617853,1617959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1617931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1618041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1618176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[1618200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1618224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[1618244],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":13,"coverable":31},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","tests","tor_crypto.rs"],"content":"// internal crates\nuse tor_interface::tor_crypto::*;\n\n#[test]\nfn test_ed25519() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let private_key_blob = \"ED25519-V3:rP3u8mZaKohap0lKsB8Z8qXbXqK456JKKGONDBhV+gPBVKa2mHVQqnRTVuFXe3inU3YW6qvc7glYEwe9rK0LhQ==\";\n    let private_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = [\n        0xacu8, 0xfdu8, 0xeeu8, 0xf2u8, 0x66u8, 0x5au8, 0x2au8, 0x88u8, 0x5au8, 0xa7u8, 0x49u8,\n        0x4au8, 0xb0u8, 0x1fu8, 0x19u8, 0xf2u8, 0xa5u8, 0xdbu8, 0x5eu8, 0xa2u8, 0xb8u8, 0xe7u8,\n        0xa2u8, 0x4au8, 0x28u8, 0x63u8, 0x8du8, 0x0cu8, 0x18u8, 0x55u8, 0xfau8, 0x03u8, 0xc1u8,\n        0x54u8, 0xa6u8, 0xb6u8, 0x98u8, 0x75u8, 0x50u8, 0xaau8, 0x74u8, 0x53u8, 0x56u8, 0xe1u8,\n        0x57u8, 0x7bu8, 0x78u8, 0xa7u8, 0x53u8, 0x76u8, 0x16u8, 0xeau8, 0xabu8, 0xdcu8, 0xeeu8,\n        0x09u8, 0x58u8, 0x13u8, 0x07u8, 0xbdu8, 0xacu8, 0xadu8, 0x0bu8, 0x85u8,\n    ];\n    let public_raw: [u8; ED25519_PUBLIC_KEY_SIZE] = [\n        0xf2u8, 0xfdu8, 0xa2u8, 0xdbu8, 0xf3u8, 0x80u8, 0xa6u8, 0xbau8, 0x74u8, 0xa4u8, 0x90u8,\n        0xe1u8, 0x45u8, 0x55u8, 0xeeu8, 0xb9u8, 0x32u8, 0xa0u8, 0x5cu8, 0x39u8, 0x5au8, 0xe2u8,\n        0x02u8, 0x83u8, 0x55u8, 0x27u8, 0x89u8, 0x6au8, 0x1fu8, 0x2fu8, 0x3du8, 0xc5u8,\n    ];\n    let public_base32 = \"6L62FW7TQCTLU5FESDQUKVPOXEZKAXBZLLRAFA2VE6EWUHZPHXCQ====\";\n    let service_id_string = \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd\";\n    assert!(V3OnionServiceId::is_valid(\u0026service_id_string));\n\n    let mut message = [0x00u8; 256];\n    let null_message = [0x00u8; 256];\n    for (i, ptr) in message.iter_mut().enumerate() {\n        *ptr = i as u8;\n    }\n    let signature_raw: [u8; ED25519_SIGNATURE_SIZE] = [\n        0xa6u8, 0xd6u8, 0xc6u8, 0x1au8, 0x03u8, 0xbcu8, 0x43u8, 0x6fu8, 0x38u8, 0x53u8, 0x94u8,\n        0xcdu8, 0xdcu8, 0x86u8, 0x0au8, 0x88u8, 0x64u8, 0x43u8, 0x1du8, 0x18u8, 0x84u8, 0x30u8,\n        0x2fu8, 0xcdu8, 0xa6u8, 0x79u8, 0xcau8, 0x87u8, 0xd0u8, 0x29u8, 0xe7u8, 0x2bu8, 0x32u8,\n        0x9bu8, 0xa2u8, 0xa4u8, 0x3cu8, 0x74u8, 0x6au8, 0x08u8, 0x67u8, 0x0eu8, 0x63u8, 0x60u8,\n        0xcbu8, 0x46u8, 0x22u8, 0x55u8, 0x43u8, 0x5bu8, 0x84u8, 0x68u8, 0x0fu8, 0x47u8, 0xceu8,\n        0x6cu8, 0xd2u8, 0xb8u8, 0xebu8, 0xfeu8, 0xf6u8, 0x9eu8, 0x97u8, 0x0au8,\n    ];\n\n    // test the golden path first\n    let service_id = V3OnionServiceId::from_string(\u0026service_id_string)?;\n\n    let private_key = Ed25519PrivateKey::from_raw(\u0026private_raw)?;\n    assert_eq!(\n        private_key,\n        Ed25519PrivateKey::from_key_blob(\u0026private_key_blob)?\n    );\n    assert_eq!(private_key_blob, private_key.to_key_blob());\n\n    let public_key = Ed25519PublicKey::from_raw(\u0026public_raw)?;\n    assert_eq!(public_key, Ed25519PublicKey::from_service_id(\u0026service_id)?);\n    assert_eq!(public_key, Ed25519PublicKey::from_private_key(\u0026private_key));\n    assert_eq!(service_id, V3OnionServiceId::from_public_key(\u0026public_key));\n    assert_eq!(public_base32, public_key.to_base32());\n\n    let signature = private_key.sign_message(\u0026message);\n    assert_eq!(signature, Ed25519Signature::from_raw(\u0026signature_raw)?);\n    assert!(signature.verify(\u0026message, \u0026public_key));\n    assert!(!signature.verify(\u0026null_message, \u0026public_key));\n\n    // some invalid service ids\n    assert!(!V3OnionServiceId::is_valid(\"\"));\n    assert!(!V3OnionServiceId::is_valid(\n        \"\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n    ));\n    assert!(!V3OnionServiceId::is_valid(\n        \"6L62FW7TQCTLU5FESDQUKVPOXEZKAXBZLLRAFA2VE6EWUHZPHXCZSJYD\"\n    ));\n\n    // generate a new key, get the public key and sign/verify a message\n    let private_key = Ed25519PrivateKey::generate();\n    let public_key = Ed25519PublicKey::from_private_key(\u0026private_key);\n    let signature = private_key.sign_message(\u0026message);\n    assert!(signature.verify(\u0026message, \u0026public_key));\n\n    // test invalid private key blob returns an error\n    // https://gitlab.torproject.org/tpo/core/arti/-/issues/1021\n    let private_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = [\n        0x2eu8, 0x26u8, 0x0au8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x0au8, 0x77u8, 0x77u8,\n        0x77u8, 0x77u8, 0x5du8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8,\n        0x82u8, 0xb4u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8,\n        0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0xffu8,\n        0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8,\n        0xffu8, 0xffu8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x82u8, 0x88u8,\n    ];\n    match Ed25519PrivateKey::from_raw(\u0026private_raw) {\n        Ok(_) =\u003e panic!(\"invalid key accepted\"),\n        Err(tor_interface::tor_crypto::Error::KeyInvalid) =\u003e (),\n        Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_x25519() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // private/public key pair\n    const SECRET_BASE64: \u0026str = \"0GeSReJXdNcgvWRQdnDXhJGdu5UiwP2fefgT93/oqn0=\";\n    const SECRET_RAW: [u8; X25519_PRIVATE_KEY_SIZE] = [\n        0xd0u8, 0x67u8, 0x92u8, 0x45u8, 0xe2u8, 0x57u8, 0x74u8, 0xd7u8, 0x20u8, 0xbdu8, 0x64u8,\n        0x50u8, 0x76u8, 0x70u8, 0xd7u8, 0x84u8, 0x91u8, 0x9du8, 0xbbu8, 0x95u8, 0x22u8, 0xc0u8,\n        0xfdu8, 0x9fu8, 0x79u8, 0xf8u8, 0x13u8, 0xf7u8, 0x7fu8, 0xe8u8, 0xaau8, 0x7du8,\n    ];\n    const PUBLIC_BASE32: \u0026str = \"AEXCBCEDJ5KU34YGGMZ7PVHVDEA7D7YB7VQAPJTMTZGRJLN3JASA\";\n    const PUBLIC_RAW: [u8; X25519_PUBLIC_KEY_SIZE] = [\n        0x01u8, 0x2eu8, 0x20u8, 0x88u8, 0x83u8, 0x4fu8, 0x55u8, 0x4du8, 0xf3u8, 0x06u8, 0x33u8,\n        0x33u8, 0xf7u8, 0xd4u8, 0xf5u8, 0x19u8, 0x01u8, 0xf1u8, 0xffu8, 0x01u8, 0xfdu8, 0x60u8,\n        0x07u8, 0xa6u8, 0x6cu8, 0x9eu8, 0x4du8, 0x14u8, 0xadu8, 0xbbu8, 0x48u8, 0x24u8,\n    ];\n\n    // ensure we can convert from raw as expected\n    assert_eq!(\n        \u0026X25519PrivateKey::from_raw(\u0026SECRET_RAW)?.to_base64(),\n        SECRET_BASE64\n    );\n    assert_eq!(\n        \u0026X25519PublicKey::from_raw(\u0026PUBLIC_RAW).to_base32(),\n        PUBLIC_BASE32\n    );\n\n    // ensure we can round-trip as expected\n    assert_eq!(\n        \u0026X25519PrivateKey::from_base64(\u0026SECRET_BASE64)?.to_base64(),\n        SECRET_BASE64\n    );\n    assert_eq!(\n        \u0026X25519PublicKey::from_base32(\u0026PUBLIC_BASE32)?.to_base32(),\n        PUBLIC_BASE32\n    );\n\n    // ensure we generate the expected public key from private key\n    let private_key = X25519PrivateKey::from_base64(\u0026SECRET_BASE64)?;\n    let public_key = X25519PublicKey::from_private_key(\u0026private_key);\n    assert_eq!(public_key.to_base32(), PUBLIC_BASE32);\n\n    let message = b\"All around me are familiar faces\";\n\n    let (signature, signbit) = private_key.sign_message(message)?;\n    assert!(signature.verify_x25519(message, \u0026public_key, signbit));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","tests","tor_provider.rs"],"content":"// stanndard\nuse std::io::{Read, Write};\n\n// extern crates\nuse serial_test::serial;\n\n// internal crates\nuse tor_interface::legacy_tor_client::*;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\npub(crate) fn bootstrap_test(mut tor: Box\u003cdyn TorProvider\u003e) -\u003e anyhow::Result\u003c()\u003e {\n    tor.bootstrap()?;\n\n    let mut received_log = false;\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in tor.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    received_log = true;\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n    assert!(\n        received_log,\n        \"should have received a log line from tor provider\"\n    );\n\n    Ok(())\n}\n\npub(crate) fn onion_service_test(mut tor: Box\u003cdyn TorProvider\u003e) -\u003e anyhow::Result\u003c()\u003e {\n    tor.bootstrap()?;\n\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in tor.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // vanilla V3 onion service\n    {\n        // create an onion service for this test\n        let private_key = Ed25519PrivateKey::generate();\n\n        println!(\"Starting and listening to onion service\");\n        const VIRT_PORT: u16 = 42069u16;\n        let listener = tor.listener(\u0026private_key, VIRT_PORT, None)?;\n\n        let mut onion_published = false;\n        while !onion_published {\n            for event in tor.update()?.iter() {\n                match event {\n                    TorEvent::LogReceived { line } =\u003e {\n                        println!(\"--- {}\", line);\n                    }\n                    TorEvent::OnionServicePublished { service_id } =\u003e {\n                        let expected_service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n                        if expected_service_id == *service_id {\n                            println!(\"Onion Service {} published\", service_id.to_string());\n                            onion_published = true;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        const MESSAGE: \u0026str = \"Hello World!\";\n\n        {\n            let service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n\n            println!(\"Connecting to onion service\");\n            let mut client = tor.connect(\u0026service_id, VIRT_PORT, None)?;\n            println!(\"Client writing message: '{}'\", MESSAGE);\n            client.write_all(MESSAGE.as_bytes())?;\n            client.flush()?;\n            println!(\"End of client scope\");\n        }\n\n        if let Some(mut server) = listener.accept()? {\n            println!(\"Server reading message\");\n            let mut buffer = Vec::new();\n            server.read_to_end(\u0026mut buffer)?;\n            let msg = String::from_utf8(buffer)?;\n\n            assert!(MESSAGE == msg);\n            println!(\"Message received: '{}'\", msg);\n        } else {\n            panic!(\"no listener\");\n        }\n    }\n\n    // authenticated onion service\n    {\n        // create an onion service for this test\n        let private_key = Ed25519PrivateKey::generate();\n\n        let private_auth_key = X25519PrivateKey::generate();\n        let public_auth_key = X25519PublicKey::from_private_key(\u0026private_auth_key);\n\n        println!(\"Starting and listening to authenticated onion service\");\n        const VIRT_PORT: u16 = 42069u16;\n        let listener = tor.listener(\u0026private_key, VIRT_PORT, Some(\u0026[public_auth_key]))?;\n\n        let mut onion_published = false;\n        while !onion_published {\n            for event in tor.update()?.iter() {\n                match event {\n                    TorEvent::LogReceived { line } =\u003e {\n                        println!(\"--- {}\", line);\n                    }\n                    TorEvent::OnionServicePublished { service_id } =\u003e {\n                        let expected_service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n                        if expected_service_id == *service_id {\n                            println!(\n                                \"Authenticated Onion Service {} published\",\n                                service_id.to_string()\n                            );\n                            onion_published = true;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        const MESSAGE: \u0026str = \"Hello World!\";\n\n        {\n            let service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n\n            println!(\"Connecting to onion service (should fail)\");\n            assert!(\n                tor.connect(\u0026service_id, VIRT_PORT, None).is_err(),\n                \"should not able to connect to an authenticated onion service without auth key\"\n            );\n\n            println!(\"Add auth key for onion service\");\n            tor.add_client_auth(\u0026service_id, \u0026private_auth_key)?;\n\n            println!(\"Connecting to onion service with authentication\");\n            let mut client = tor.connect(\u0026service_id, VIRT_PORT, None)?;\n\n            println!(\"Client writing message: '{}'\", MESSAGE);\n            client.write_all(MESSAGE.as_bytes())?;\n            client.flush()?;\n            println!(\"End of client scope\");\n\n            println!(\"Remove auth key for onion service\");\n            tor.remove_client_auth(\u0026service_id)?;\n        }\n\n        if let Some(mut server) = listener.accept()? {\n            println!(\"Server reading message\");\n            let mut buffer = Vec::new();\n            server.read_to_end(\u0026mut buffer)?;\n            let msg = String::from_utf8(buffer)?;\n\n            assert!(MESSAGE == msg);\n            println!(\"Message received: '{}'\", msg);\n        } else {\n            panic!(\"no listener\");\n        }\n    }\n    Ok(())\n}\n\n#[test]\nfn test_mock_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n    bootstrap_test(Box::new(MockTorClient::new()))\n}\n\n#[test]\nfn test_mock_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    onion_service_test(Box::new(MockTorClient::new()))\n}\n\n#[test]\n#[serial]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_legacy_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_bootstrap\");\n\n    bootstrap_test(Box::new(LegacyTorClient::new(\u0026tor_path, \u0026data_path)?))\n}\n\n#[test]\n#[serial]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_legacy_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_onion_service\");\n\n    onion_service_test(Box::new(LegacyTorClient::new(\u0026tor_path, \u0026data_path)?))\n}\n","traces":[{"line":13,"address":[1000424,1000583,998912],"length":1,"stats":{"Line":1},"fn_name":"bootstrap_test"},{"line":14,"address":[1000570,999023,998919,999083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[999065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[999073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[999148,999081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1000441,999158,999225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[999662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[999719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1000328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1000301,999839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[1000320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[999874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[999886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1000343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[1000518,1000464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[999190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1000491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1012529,1002250,1000608],"length":1,"stats":{"Line":1},"fn_name":"onion_service_test"},{"line":50,"address":[1000646,1012516,1000766,1000818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1000808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1000816,1000883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[1002267,1000963,1000893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[1001409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1001478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1002148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1001604,1002121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[1002140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1001642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1002169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1000925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1002364,1002293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[1002572,1002383,1012498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1002562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1002570,1002637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[1002647,1002769,1003835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[1003215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1003261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1003424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1003362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1003381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1003521,1003822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[1003659,1003559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1003814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1002679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1003865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1003911,1004373,1012455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1004498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1012437,1004601,1004739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1004879,1004788,1012399,1004712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[1004852,1004920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1012298,1004958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1005302,1005403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[1005422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1012055,1005441,1005642,1005525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[1012027,1005579,1005683,1005838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[1005809,1005970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[1006105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1005329,1012184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1006412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1006431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1006494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1006562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1006845,1006608,1011987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[1006835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1006910,1006843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[1007042,1006920,1008108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[1007488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1007534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1007697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1007635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1007654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1008095,1007794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[1007932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1007832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1008087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1006952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1008138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[1008340,1008287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[1008326,1008184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[1008418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1008464,1008597,1011947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1008662,1008570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[1008681,1011926,1009137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1009253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[1009479,1011911,1009356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1009607,1009455,1009522,1011896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[1009580,1009645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[1009664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1000630,1009710,1011861,1009827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1011703,1009889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1010331,1010230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[1010350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1010570,1010369,1010453,1011444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[1010760,1010608,1011419,1010507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[1010886,1010734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[1011006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1010257,1011592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1011373],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":89,"coverable":98}]};
        var previousData = {"files":[{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","build.rs"],"content":"extern crate cbindgen;\nextern crate regex;\nextern crate serde;\nextern crate serde_json;\n\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\n\nuse regex::Regex;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Constant {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    value: usize,\n}\n\n#[derive(Serialize)]\nstruct Alias {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    typename: String,\n}\n\n#[derive(Serialize)]\nstruct Param {\n    name: String,\n    typename: String,\n}\n\n#[derive(Serialize)]\nstruct Function {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    return_param: String,\n    input_params: Vec\u003cParam\u003e,\n}\n\n#[derive(Serialize)]\nstruct Data {\n    constants: Vec\u003cConstant\u003e,\n    aliases: Vec\u003cAlias\u003e,\n    callbacks: Vec\u003cFunction\u003e,\n    functions: Vec\u003cFunction\u003e,\n}\n\nfn parse_param(params_raw: \u0026str) -\u003e Vec\u003cParam\u003e {\n    // function param\n    let param_pattern = Regex::new(r\"(?m)(?P\u003ctype\u003e(\\w+ \\**)+)(?P\u003cname\u003e\\w+)\").unwrap();\n    // pattern for our gosling structs\n    let struct_gosling_pattern = Regex::new(r\"(?m)struct (?P\u003cname\u003egosling_[\\w]+) \").unwrap();\n\n    let mut params: Vec\u003cParam\u003e = Default::default();\n    for param in param_pattern.captures_iter(params_raw) {\n        let t = \u0026param[\"type\"];\n        let t = match struct_gosling_pattern.captures(t) {\n            Some(cap) =\u003e struct_gosling_pattern.replace(t, \u0026cap[\"name\"]).to_string(),\n            None =\u003e t.to_string(),\n        };\n        let t = t.replace(\" *\", \"*\");\n        let n = \u0026param[\"name\"];\n\n        params.push(Param {\n            name: n.to_string(),\n            typename: t.trim().to_string(),\n        });\n    }\n    params\n}\n\nfn parse_header(mut file: File, source: \u0026str) {\n    // hacky-preprocess to exclude relevant platform-specific declarations\n    #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n    let platform_pattern =\n        Regex::new(r\"(?m)#if defined\\(GOSLING_PLATFORM_WINDOWS\\)([^#].*\\n)+#endif\").unwrap();\n    #[cfg(target_os = \"windows\")]\n    let platform_pattern = Regex::new(r\"(?m)#if \\(defined\\(GOSLING_PLATFORM_LINUX\\) \\|\\| defined\\(GOSLING_PLATFORM_MACOS\\)\\)([^#].*\\n)+#endif\").unwrap();\n\n    let source = platform_pattern.replace_all(source, \"\").to_string();\n    let source = source.as_str();\n\n    // all of the lines we cre about have this general form of muliple // style comments,\n    // followed by a single source line we care about\n    let commented_source_pattern =\n        Regex::new(r\"(?m)(?\u003ccomments\u003e(?:\\/\\/.*\\n)+)(?\u003csource\u003e.+)\").unwrap();\n    let comment_pattern =\n        Regex::new(r\"(?m)^\\/\\/[ ]?\").unwrap();\n\n    // constant pattern\n    let constant_pattern =\n        Regex::new(r\"^#define (?P\u003cname\u003e[A-Z0-9_]+) (?P\u003cvalue\u003e[0-9]+)$\").unwrap();\n    // primitive types\n    let typedef_pattern =\n        Regex::new(r\"^typedef (?P\u003ctype\u003e[\\w \\*]+) (?P\u003cname\u003egosling_[\\w]+);$\").unwrap();\n    // callback types\n    let callback_pattern =\n        Regex::new(r\"^typedef (?P\u003creturn\u003e[\\w \\*]+) \\(\\*(?P\u003cname\u003egosling_[\\w]+_t)\\)\\((?P\u003cparams\u003e[\\w ,\\*]*)\\);$\").unwrap();\n    // function declaration\n    let function_pattern =\n        Regex::new(r\"^(?P\u003creturn\u003e[\\w \\*]+( | \\*))(?P\u003cname\u003egosling_[\\w]+)\\((?P\u003cparams\u003e[\\w ,\\*]*)\\);$\").unwrap();\n\n    let mut constants: Vec\u003cConstant\u003e = Default::default();\n    let mut aliases: Vec\u003cAlias\u003e = Default::default();\n    let mut callbacks: Vec\u003cFunction\u003e = Default::default();\n    let mut functions: Vec\u003cFunction\u003e = Default::default();\n\n    for commmented_source in commented_source_pattern.captures_iter(source) {\n        let comments = \u0026commmented_source[\"comments\"];\n        let comments = comment_pattern.replace_all(comments, \"\");\n        let comments = comments.trim();\n        let comments = comments.split('\\n').map(|s| s.to_string()).collect();\n\n        let source = \u0026commmented_source[\"source\"];\n\n        // try parse constant\n        if let Some(constant) = constant_pattern.captures(source) {\n            let name = constant[\"name\"].to_lowercase();\n            let value = constant[\"value\"].parse::\u003cusize\u003e().unwrap();\n            constants.push(Constant {\n                name,\n                value,\n                comments,\n            });\n        // try parse alias\n        } else if let Some(alias) = typedef_pattern.captures(source) {\n            let t = \u0026alias[\"type\"];\n            let n = \u0026alias[\"name\"];\n\n            if t == format!(\"struct {}\", n) {\n                aliases.push(Alias {\n                    name: n.to_string(),\n                    typename: \"uintptr_t\".to_string(),\n                    comments,\n                });\n            } else {\n                aliases.push(Alias {\n                    name: n.to_string(),\n                    typename: t.trim().to_string(),\n                    comments,\n                });\n            }\n        // try parse callback declaration\n        } else if let Some(callback) = callback_pattern.captures(source) {\n            let r = \u0026callback[\"return\"];\n            let n = \u0026callback[\"name\"];\n            let p = \u0026callback[\"params\"];\n\n            // move the pointer char next to the type\n            let r = r.trim().replace(\" *\", \"*\");\n\n            let params = parse_param(p);\n            callbacks.push(Function {\n                name: n.to_string(),\n                return_param: r,\n                input_params: params,\n                comments,\n            });\n        // try parse function declaration\n        } else if let Some(function) = function_pattern.captures(source) {\n            let r = \u0026function[\"return\"];\n            let n = \u0026function[\"name\"];\n            let p = \u0026function[\"params\"];\n\n            // move the pointer char next to the type\n            let r = r.trim().replace(\" *\", \"*\");\n\n            let params = parse_param(p);\n            functions.push(Function {\n                name: n.to_string(),\n                return_param: r,\n                input_params: params,\n                comments,\n            });\n        }\n    }\n\n    let data = Data {\n        constants,\n        aliases,\n        callbacks,\n        functions,\n    };\n    writeln!(file, \"{}\", serde_json::to_string_pretty(\u0026data).unwrap()).unwrap();\n}\n\nfn main() {\n\n    if cfg! (not(feature = \"impl-lib\")) {\n        // set by cargo\n        let crate_dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n        // Set by the user or by cmake.\n        let target_dir = match std::env::var(\"CARGO_TARGET_DIR\") {\n            Ok(target) =\u003e PathBuf::from(target),\n            Err(_) =\u003e Path::new(\u0026crate_dir).join(\"target\"),\n        };\n\n        let header_file_path = target_dir.join(\"include\").join(\"cgosling.h\");\n        println!(\"cargo:rerun-if-changed={}\",header_file_path.display());\n\n        // generate libgosling.h C header\n        match cbindgen::generate(\u0026crate_dir) {\n            Ok(bindings) =\u003e bindings.write_to_file(header_file_path.clone().into_os_string()),\n            Err(cbindgen::Error::ParseSyntaxError { .. }) =\u003e return, // ignore in favor of cargo's syntax check\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        };\n\n        // convert generated header to json IDL\n        let json_file_path = target_dir.join(\"cgosling.json\");\n        println!(\"cargo:rerun-if-changed={}\",json_file_path.display());\n        let json_file = match File::create(json_file_path) {\n            Ok(file) =\u003e file,\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        };\n        let source = std::fs::read_to_string(header_file_path).unwrap();\n\n        parse_header(json_file, source.as_str());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","fuzz","fuzz_targets","fuzz_cgosling.rs"],"content":"#![no_main]\n\nuse std::ffi::{c_char, c_int};\nuse std::ptr;\n\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nuse cgosling::ffi::*;\n\n#[derive(Arbitrary, Debug)]\nenum Handle {\n    Null,\n    Valid(usize),\n    Invalid(usize),\n}\n\n#[derive(Arbitrary, Debug)]\nenum PHandle {\n    Null,\n    Valid,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Callback {\n    Null,\n    Valid,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Buffer\u003cT\u003e {\n    Null,\n    Valid(Vec\u003cT\u003e),\n}\n\n#[derive(Arbitrary, Debug)]\nenum Primitive\u003cT\u003e {\n    Valid(T),\n    Invalid(T),\n}\n\n#[derive(Arbitrary, Debug)]\nenum Function {\n    ErrorGetMessage{\n        error: Handle,\n    },\n    ErrorClone{\n        error_copy: PHandle,\n        orig_error: Handle,\n        out_error: PHandle,\n    },\n    ErrorFree{\n        error: Handle,\n    },\n    Ed25519PrivateKeyFree{\n        private_key: Handle,\n    },\n    X25519PrivateKeyFree{\n        private_key: Handle,\n    },\n    X25519PublicKeyFree{\n        public_key: Handle,\n    },\n    V3OnionServiceIdFree{\n        service_id: Handle,\n    },\n    ContextFree{\n        context: Handle,\n    },\n    TorProviderFree{\n        tor_provider: Handle,\n    },\n    LibraryInit{\n        out_library: PHandle,\n        out_error: PHandle,\n    },\n    LibraryFree{\n        library: Handle,\n    },\n    // Ed25519 Priavate Key Functions\n    Ed25519PrivateKeyGenerate{\n        out_private_key: PHandle,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyClone{\n        out_private_key: PHandle,\n        private_key: Handle,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyFromKeyblob{\n        out_private_key: PHandle,\n        key_blob: Buffer\u003cc_char\u003e,\n        key_blob_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyToKeyblob{\n        private_key: Handle,\n        out_key_blob: Buffer\u003cc_char\u003e,\n        key_blob_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // X25519 Private Key Functions\n    X25519PrivateKeyClone{\n        out_private_key: PHandle,\n        private_key: Handle,\n        out_error: PHandle,\n    },\n    X25519PrivateKeyFromBase64{\n        out_private_key: PHandle,\n        base64: Buffer\u003cc_char\u003e,\n        base64_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    X25519PrivateKeyToBase64{\n        private_key: Handle,\n        out_base64: Buffer\u003cc_char\u003e,\n        base64_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // X25519 Public Key Functions\n    X25519PublicKeyClone{\n        out_public_key: PHandle,\n        public_key: Handle,\n        out_error: PHandle,\n    },\n    X25519PublicKeyFromBase32{\n        out_public_key: PHandle,\n        base32: Buffer\u003cc_char\u003e,\n        base32_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    X25519PublicKeyToBase32{\n        public_key: Handle,\n        out_base32: Buffer\u003cc_char\u003e,\n        base32_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // V3 Onion Service Id Functions\n    V3OnionServiceIdClone{\n        out_service_id: PHandle,\n        service_id: Handle,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdFromString{\n        out_service_id: PHandle,\n        service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdFromEd25519PrivateKey{\n        out_service_id: PHandle,\n        ed25519_private_key: Handle,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdToString{\n        service_id: Handle,\n        out_service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    StringIsValidV3OnionServiceId{\n        service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // TorProvider Functions\n    TorProviderNewMockClient{\n        out_tor_provider: PHandle,\n        out_error: PHandle,\n    },\n    // Context Functions\n    ContextInit{\n        out_context: PHandle,\n        tor_provider: Handle,\n        identity_port: u16,\n        endpoint_port: u16,\n        identity_private_key: Handle,\n        out_error: PHandle,\n    },\n    ContextBootstrapTor{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStartIdentityServer{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStopIdentityServer{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStartEndpointServer{\n        context: Handle,\n        endpoint_private_key: Handle,\n        endpoint_name: Buffer\u003cc_char\u003e,\n        endpoint_name_length: Primitive\u003cusize\u003e,\n        client_identity: Handle,\n        client_auth_public_key: Handle,\n        out_error: PHandle,\n    },\n    ContextStopEndpointServer{\n        context: Handle,\n        endpoint_private_key: Handle,\n        out_error: PHandle,\n    },\n    ContextBeginIdentityHandshake{\n        context: Handle,\n        identity_service_id: Handle,\n        endpoint_name: Buffer\u003cc_char\u003e,\n        endpoint_name_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextAbortIdentityClientHandshake{\n        context: Handle,\n        handshake_handle: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextBeginEndpointHandshake{\n        context: Handle,\n        endpoint_service_id: Handle,\n        client_auth_private_key: Handle,\n        channel_name: Buffer\u003cc_char\u003e,\n        channel_name_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextAbortEndpointClientHandshake{\n        context: Handle,\n        handshake_handle: Primitive\u003cusize\u003e,\n        out_error: PHandle\n    },\n    ContextPollEvents{\n        context: Handle,\n        out_error: PHandle,\n    },\n    // Callback Setters\n    ContextSetTorBootstrapStatusReceivedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetTorBootstrapCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetTorLogReceivedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientChallengeResponseSizeCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientBuildChallengeResponseCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerPublishedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeStartedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerClientAllowedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerEndpointSupportedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerChallengeSizeCallack{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerBuildChallengeCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerVerifyChallengeResponseCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeRejectedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointClientHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointClientHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerPublishedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeStartedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerChannelSupportedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeRejectedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n}\n\nfn handle_as_pointer\u003cT\u003e(value: Handle, handles: \u0026Vec\u003c*mut T\u003e) -\u003e *mut T {\n    let result: *mut T = match value {\n        Handle::Null =\u003e ptr::null_mut(),\n        Handle::Valid(value) =\u003e if !handles.is_empty() {\n            let index = value % handles.len();\n            handles[index]\n        } else {\n            ptr::null_mut()\n        },\n        Handle::Invalid(value) =\u003e if !handles.contains(\u0026(value as *mut T)) {\n            value as *mut T\n        } else {\n            ptr::null_mut()\n        }\n    };\n    result\n}\n\nfn handle_to_pointer\u003cT\u003e(value: Handle, handles: \u0026mut Vec\u003c*mut T\u003e) -\u003e *mut T {\n    let result: *mut T = match value {\n        Handle::Null =\u003e ptr::null_mut(),\n        Handle::Valid(value) =\u003e if !handles.is_empty() {\n            let index = value % handles.len();\n            handles.remove(index) as *mut T\n        } else {\n            ptr::null_mut()\n        },\n        Handle::Invalid(value) =\u003e if !handles.contains(\u0026(value as *mut T)) {\n            value as *mut T\n        } else {\n            ptr::null_mut()\n        },\n    };\n    result\n}\n\nfn phandle_to_out_pointer\u003cT\u003e(value: PHandle, out_pointer: *mut *mut T) -\u003e *mut *mut T {\n    match value {\n        PHandle::Null =\u003e ptr::null_mut(),\n        PHandle::Valid =\u003e out_pointer,\n    }\n}\n\nfn buffer_to_size\u003cT\u003e(buffer: \u0026Buffer\u003cT\u003e, buffer_size: \u0026Primitive\u003cusize\u003e) -\u003e usize {\n    let size: usize = match (buffer, buffer_size) {\n        (Buffer::Null, Primitive::Valid(_)) =\u003e 0usize,\n        (Buffer::Null, Primitive::Invalid(value)) =\u003e *value,\n        (Buffer::Valid(buffer), Primitive::Valid(_)) =\u003e buffer.len(),\n        (Buffer::Valid(buffer), Primitive::Invalid(value)) =\u003e std::cmp::min(*value, buffer.len()),\n    };\n    size\n}\n\nfn buffer_as_pointer\u003cT\u003e(buffer: \u0026Buffer\u003cT\u003e) -\u003e *const T {\n    let pointer: *const T = match buffer {\n        Buffer::Null =\u003e ptr::null(),\n        Buffer::Valid(value) =\u003e value.as_ptr(),\n    };\n    pointer\n}\n\nfn buffer_as_mut_pointer\u003cT\u003e(buffer: \u0026mut Buffer\u003cT\u003e) -\u003e *mut T {\n    let pointer: *mut T = match buffer {\n        Buffer::Null =\u003e ptr::null_mut(),\n        Buffer::Valid(value) =\u003e value.as_mut_ptr(),\n    };\n    pointer\n}\n\nmacro_rules! impl_set_callback {\n    ($context:ident, $callback:ident, $out_error:ident, $contexts:ident, $errors:ident,$setter:ident, $func:ident) =\u003e {\n        let context = handle_as_pointer($context, \u0026$contexts);\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n        let out_error = phandle_to_out_pointer($out_error, \u0026mut error);\n        match $callback {\n            Callback::Null =\u003e $setter(context, None, out_error),\n            Callback::Valid =\u003e $setter(context, Some($func), out_error),\n        }\n        if !error.is_null() {\n            $errors.push(error);\n        }\n    }\n}\n\n// no-op (or minimal op) callbacks for setters\n\nextern \"C\" fn bootstrap_status_received(_context: *mut GoslingContext, _progress: u32, _tag: *const c_char, _tag_length: usize, _summary: *const c_char, _summary_length: usize) {\n\n}\n\nextern \"C\" fn bootstrap_complete(_context: *mut GoslingContext) -\u003e () {\n\n}\n\nextern \"C\" fn tor_log_received(_context: *mut GoslingContext, _line: *const c_char, _line_length: usize) {\n\n}\n\nextern \"C\" fn identity_client_handshake_challenge_response_size(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_buffer: *const u8, _challenge_buffer_size: usize) -\u003e usize {\n    return 0;\n}\n\nextern \"C\" fn identity_client_handshake_build_challenge_response(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_buffer: *const u8, _challenge_buffer_size: usize, _out_challenge_response_buffer: *mut u8, _challenge_response_buffer_size: usize) {\n\n}\n\nextern \"C\" fn identity_client_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _identity_service_id: *const GoslingV3OnionServiceId, _endpoint_service_id: *const GoslingV3OnionServiceId, _endpoint_name: *const c_char, _endpoint_name_length: usize, _client_auth_private_key: *const GoslingX25519PrivateKey) {\n\n}\n\nextern \"C\" fn identity_client_handshake_failed(_context: *mut GoslingContext, _handshake_handle: usize, _error: *const GoslingFFIError) {\n\n}\n\nextern \"C\" fn identity_server_published(_context: *mut GoslingContext) {\n\n}\n\nextern \"C\" fn identity_server_handshake_started(_context: *mut GoslingContext, _handshake_handle: usize) {\n\n}\n\nextern \"C\" fn identity_server_handshake_client_allowed(_context: *mut GoslingContext, _handshake_handle: usize, _client_service_id: *const GoslingV3OnionServiceId) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_endpoint_supported(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_name: *const c_char, _endpoint_name_length: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_handshake_challenge_size(_context: *mut GoslingContext, _handshake_handle: usize) -\u003e usize {\n    0usize\n}\n\nextern \"C\" fn identity_server_handshake_build_challenge(_context: *mut GoslingContext, _handshake_handle: usize, _out_challenge_buffer: *mut u8, _challenge_buffer_size: usize) {\n\n}\n\nextern \"C\" fn identity_server_handshake_verify_challenge_response(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_response_buffer: *const u8, _challenge_response_buffer_size: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_private_key: *const GoslingEd25519PrivateKey, _endpoint_name: *const c_char, _endpoint_name_length: usize, _client_service_id: *const GoslingV3OnionServiceId, _client_auth_public_key: *const GoslingX25519PublicKey) {\n\n}\n\nextern \"C\" fn identity_server_handshake_rejected(_context: *mut GoslingContext, _handshake_handle: usize, _client_allowed: bool, _client_requested_endpoint_valid: bool, _client_proof_signature_valid: bool, _client_auth_signature_valid: bool, _challenge_response_valid: bool) {\n\n}\n\nextern \"C\" fn identity_server_handshake_failed(_cntext: *mut GoslingContext, _handshake_handle: usize, _error: *const GoslingFFIError) {\n\n}\n\nextern \"C\" fn endpoint_client_handhsake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize, _stream: c_int) {\n\n}\n\nextern \"C\" fn endpoint_client_handshake_failed(_context: *mut GoslingContext,\n    _handshake_handle: usize, _error: *const GoslingFFIError) {\n\n}\n\nextern \"C\" fn endpoint_server_published(_context: *mut GoslingContext, _endpoint_service_id: *const GoslingV3OnionServiceId, _endpoint_name: *const c_char, _endpoint_name_length: usize) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_started(_context: *mut GoslingContext, _handshake_handle: usize) {\n\n}\n\nextern \"C\" fn endpoint_server_channel_supported(_context: *mut GoslingContext,\n_handshake_handle: usize, _client_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn endpoint_server_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_service_id: *const GoslingV3OnionServiceId, _client_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize, _stream: c_int) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_rejected(_context: *mut GoslingContext, _handshake_handle: usize, _client_allowed: bool, _client_requested_channel_valid: bool, _client_proof_signature_valid: bool) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_failed(_context: *mut GoslingContext,\n    _handshake_handle: usize, _error: *const GoslingFFIError) {\n\n}\n\n#[derive(Arbitrary, Debug)]\nstruct Data {\n    functions: Vec\u003cFunction\u003e,\n}\n\nfuzz_target!(|data: Data| {\n    let mut libraries: Vec\u003c*mut GoslingLibrary\u003e = Default::default();\n    let mut errors: Vec\u003c*mut GoslingFFIError\u003e = Default::default();\n    let mut contexts: Vec\u003c*mut GoslingContext\u003e = Default::default();\n    let mut ed25519_private_keys: Vec\u003c*mut GoslingEd25519PrivateKey\u003e = Default::default();\n    let mut v3_onion_service_ids: Vec\u003c*mut GoslingV3OnionServiceId\u003e = Default::default();\n    let mut x25519_private_keys: Vec\u003c*mut GoslingX25519PrivateKey\u003e = Default::default();\n    let mut x25519_public_keys : Vec\u003c*mut GoslingX25519PublicKey\u003e = Default::default();\n    let mut tor_providers: Vec\u003c*mut GoslingTorProvider\u003e = Default::default();\n    let mut identity_handshakes: Vec\u003cusize\u003e = Default::default();\n    let mut endpoint_handshakes: Vec\u003cusize\u003e = Default::default();\n\n    for function in data.functions {\n        match function {\n            Function::ErrorGetMessage{error} =\u003e {\n                let error = handle_as_pointer(error, \u0026errors);\n                gosling_error_get_message(error);\n            },\n            Function::ErrorClone{error_copy, orig_error, out_error} =\u003e {\n                let mut dest: *mut GoslingFFIError = ptr::null_mut();\n                let error_copy = phandle_to_out_pointer(error_copy, \u0026mut dest);\n                let orig_error = handle_as_pointer(orig_error, \u0026errors);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_error_clone(error_copy, orig_error, out_error) };\n                if !dest.is_null() {\n                    errors.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ErrorFree{error} =\u003e {\n                let error = handle_to_pointer(error, \u0026mut errors);\n                gosling_error_free(error);\n            },\n            Function::Ed25519PrivateKeyFree{private_key} =\u003e {\n                let private_key = handle_to_pointer(private_key, \u0026mut ed25519_private_keys);\n                gosling_ed25519_private_key_free(private_key);\n            },\n            Function::X25519PrivateKeyFree{private_key} =\u003e {\n                let private_key = handle_to_pointer(private_key, \u0026mut x25519_private_keys);\n                gosling_x25519_private_key_free(private_key);\n            },\n            Function::X25519PublicKeyFree{public_key} =\u003e {\n                let public_key = handle_to_pointer(public_key, \u0026mut x25519_public_keys);\n                gosling_x25519_public_key_free(public_key);\n            },\n            Function::V3OnionServiceIdFree{service_id} =\u003e {\n               let service_id = handle_to_pointer(service_id, \u0026mut v3_onion_service_ids);\n               gosling_v3_onion_service_id_free(service_id);\n            },\n            Function::ContextFree{context} =\u003e {\n                let context = handle_to_pointer(context, \u0026mut contexts);\n                gosling_context_free(context);\n            },\n            Function::TorProviderFree{tor_provider} =\u003e {\n                let tor_provider = handle_to_pointer(tor_provider, \u0026mut tor_providers);\n                gosling_tor_provider_free(tor_provider);\n            },\n            Function::LibraryInit{out_library, out_error} =\u003e {\n                let mut library: *mut GoslingLibrary = ptr::null_mut();\n                let out_library = phandle_to_out_pointer(out_library, \u0026mut library);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_library_init(out_library, out_error) };\n                if !library.is_null() {\n                    libraries.push(library);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::LibraryFree{library} =\u003e {\n                let library = handle_to_pointer(library, \u0026mut libraries);\n                gosling_library_free(library);\n            },\n            Function::Ed25519PrivateKeyGenerate{out_private_key, out_error} =\u003e {\n                let mut private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_generate(out_private_key, out_error) };\n                if !private_key.is_null() {\n                    ed25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyClone{out_private_key, private_key, out_error} =\u003e {\n                let mut dest: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut dest);\n                let private_key = handle_as_pointer(private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_clone(out_private_key, private_key, out_error) };\n                if !dest.is_null() {\n                    ed25519_private_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyFromKeyblob{out_private_key, key_blob, key_blob_length, out_error} =\u003e {\n                let mut private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let key_blob_length = buffer_to_size(\u0026key_blob, \u0026key_blob_length);\n                let key_blob = buffer_as_pointer(\u0026key_blob);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_from_keyblob(out_private_key, key_blob, key_blob_length, out_error) };\n                if !private_key.is_null() {\n                    ed25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyToKeyblob{private_key, mut out_key_blob, key_blob_size, out_error} =\u003e {\n                let private_key = handle_as_pointer(private_key, \u0026ed25519_private_keys);\n                let key_blob_size = buffer_to_size(\u0026out_key_blob, \u0026key_blob_size);\n                let out_key_blob = buffer_as_mut_pointer(\u0026mut out_key_blob);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_ed25519_private_key_to_keyblob(private_key, out_key_blob, key_blob_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyClone{out_private_key, private_key, out_error} =\u003e {\n                let mut dest: *mut GoslingX25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut dest);\n                let private_key = handle_as_pointer(private_key, \u0026x25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_private_key_clone(out_private_key, private_key, out_error) };\n                if !dest.is_null() {\n                    x25519_private_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyFromBase64{out_private_key, base64, base64_length, out_error} =\u003e {\n                let mut private_key: *mut GoslingX25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let base64_length = buffer_to_size(\u0026base64, \u0026base64_length);\n                let base64 = buffer_as_pointer(\u0026base64);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_private_key_from_base64(out_private_key, base64, base64_length, out_error) };\n                if !private_key.is_null() {\n                    x25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyToBase64{private_key, mut out_base64, base64_size, out_error} =\u003e {\n                let private_key = handle_as_pointer(private_key, \u0026x25519_private_keys);\n                let base64_size = buffer_to_size(\u0026out_base64, \u0026base64_size);\n                let out_base64 = buffer_as_mut_pointer(\u0026mut out_base64);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_x25519_private_key_to_base64(private_key, out_base64, base64_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyClone{out_public_key, public_key, out_error} =\u003e {\n                let mut dest: *mut GoslingX25519PublicKey = ptr::null_mut();\n                let out_public_key = phandle_to_out_pointer(out_public_key, \u0026mut dest);\n                let public_key = handle_as_pointer(public_key, \u0026x25519_public_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_public_key_clone(out_public_key, public_key, out_error) };\n                if !dest.is_null() {\n                    x25519_public_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyFromBase32{out_public_key, base32, base32_length, out_error} =\u003e {\n                let mut public_key: *mut GoslingX25519PublicKey = ptr::null_mut();\n                let out_public_key = phandle_to_out_pointer(out_public_key, \u0026mut public_key);\n                let base32_length = buffer_to_size(\u0026base32, \u0026base32_length);\n                let base32 = buffer_as_pointer(\u0026base32);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_public_key_from_base32(out_public_key, base32, base32_length, out_error) };\n                if !out_public_key.is_null() {\n                    x25519_public_keys.push(public_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyToBase32{public_key, mut out_base32, base32_size, out_error} =\u003e {\n                let public_key = handle_as_pointer(public_key, \u0026x25519_public_keys);\n                let base32_size = buffer_to_size(\u0026out_base32, \u0026base32_size);\n                let out_base32 = buffer_as_mut_pointer(\u0026mut out_base32);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_x25519_public_key_to_base32(public_key, out_base32, base32_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdClone{out_service_id, service_id, out_error} =\u003e {\n                let mut dest: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut dest);\n                let service_id = handle_as_pointer(service_id, \u0026v3_onion_service_ids);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_clone(out_service_id, service_id, out_error) };\n                if !dest.is_null() {\n                    v3_onion_service_ids.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdFromString{out_service_id, service_id_string, service_id_string_length, out_error} =\u003e {\n                let mut service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut service_id);\n                let service_id_string_length = buffer_to_size(\u0026service_id_string, \u0026service_id_string_length);\n                let service_id_string = buffer_as_pointer(\u0026service_id_string);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_from_string(out_service_id, service_id_string, service_id_string_length, out_error) };\n                if !out_service_id.is_null() {\n                    v3_onion_service_ids.push(service_id);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdFromEd25519PrivateKey{out_service_id, ed25519_private_key, out_error} =\u003e {\n                let mut service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut service_id);\n                let ed25519_private_key = handle_as_pointer(ed25519_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_from_ed25519_private_key(out_service_id, ed25519_private_key, out_error) };\n                if !out_service_id.is_null() {\n                    v3_onion_service_ids.push(service_id);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdToString{service_id, mut out_service_id_string, service_id_string_size, out_error} =\u003e {\n                let service_id = handle_as_pointer(service_id, \u0026v3_onion_service_ids);\n                let service_id_string_size = buffer_to_size(\u0026out_service_id_string, \u0026service_id_string_size);\n                let out_service_id_string = buffer_as_mut_pointer(\u0026mut out_service_id_string);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_v3_onion_service_id_to_string(service_id, out_service_id_string, service_id_string_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::StringIsValidV3OnionServiceId{service_id_string, service_id_string_length, out_error} =\u003e {\n                let service_id_string_length = buffer_to_size(\u0026service_id_string, \u0026service_id_string_length);\n                let service_id_string = buffer_as_pointer(\u0026service_id_string);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_string_is_valid_v3_onion_service_id(service_id_string, service_id_string_length, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            }\n            Function::TorProviderNewMockClient{out_tor_provider, out_error} =\u003e {\n                let mut tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n                let out_tor_provider = phandle_to_out_pointer(out_tor_provider, \u0026mut tor_provider);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_tor_provider_new_mock_client(out_tor_provider, out_error) };\n                if !tor_provider.is_null() {\n                    tor_providers.push(tor_provider);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextInit{out_context, tor_provider, identity_port, endpoint_port, identity_private_key, out_error} =\u003e {\n                let mut context: *mut GoslingContext = ptr::null_mut();\n                let out_context = phandle_to_out_pointer(out_context, \u0026mut context);\n                let tor_provider = handle_as_pointer(tor_provider, \u0026tor_providers);\n                let identity_private_key = handle_as_pointer(identity_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_context_init(out_context, tor_provider, identity_port, endpoint_port, identity_private_key, out_error) };\n                if !context.is_null() {\n                    contexts.push(context);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBootstrapTor{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_bootstrap_tor(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStartIdentityServer{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_start_identity_server(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStopIdentityServer{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_stop_identity_server(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStartEndpointServer{context, endpoint_private_key, endpoint_name, endpoint_name_length, client_identity, client_auth_public_key, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_private_key = handle_as_pointer(endpoint_private_key, \u0026ed25519_private_keys);\n                let endpoint_name_length = buffer_to_size(\u0026endpoint_name, \u0026endpoint_name_length);\n                let endpoint_name = buffer_as_pointer(\u0026endpoint_name);\n                let client_identity = handle_as_pointer(client_identity, \u0026v3_onion_service_ids);\n                let client_auth_public_key = handle_as_pointer(client_auth_public_key, \u0026x25519_public_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_start_endpoint_server(context, endpoint_private_key, endpoint_name, endpoint_name_length, client_identity, client_auth_public_key, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            }\n            Function::ContextStopEndpointServer{context, endpoint_private_key, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_private_key = handle_as_pointer(endpoint_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_stop_endpoint_server(context, endpoint_private_key, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBeginIdentityHandshake{context, identity_service_id, endpoint_name, endpoint_name_length, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let identity_service_id = handle_as_pointer(identity_service_id, \u0026v3_onion_service_ids);\n                let endpoint_name_length = buffer_to_size(\u0026endpoint_name, \u0026endpoint_name_length);\n                let endpoint_name = buffer_as_pointer(\u0026endpoint_name);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                let handshake_handle = gosling_context_begin_identity_handshake(context, identity_service_id, endpoint_name, endpoint_name_length, out_error);\n                if handshake_handle != !0usize {\n                    identity_handshakes.push(handshake_handle);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextAbortIdentityClientHandshake{context, handshake_handle, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let handshake_handle = match handshake_handle {\n                    Primitive::Valid(value) =\u003e if !identity_handshakes.is_empty() {\n                        let index = value % identity_handshakes.len();\n                        identity_handshakes[index]\n                    } else {\n                        !0usize\n                    },\n                    Primitive::Invalid(value) =\u003e if !identity_handshakes.contains(\u0026value) {\n                        value\n                    } else {\n                        !0usize\n                    }\n                };\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_abort_identity_client_handshake(context, handshake_handle, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBeginEndpointHandshake{context, endpoint_service_id, client_auth_private_key, channel_name, channel_name_length, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_service_id = handle_as_pointer(endpoint_service_id, \u0026v3_onion_service_ids);\n                let client_auth_private_key = handle_as_pointer(client_auth_private_key, \u0026x25519_private_keys);\n                let channel_name_length = buffer_to_size(\u0026channel_name, \u0026channel_name_length);\n                let channel_name = buffer_as_pointer(\u0026channel_name);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                let handshake_handle = gosling_context_begin_endpoint_handshake(context, endpoint_service_id, client_auth_private_key, channel_name, channel_name_length, out_error);\n                if handshake_handle != !0usize {\n                    endpoint_handshakes.push(handshake_handle);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextAbortEndpointClientHandshake{context, handshake_handle, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let handshake_handle = match handshake_handle {\n                    Primitive::Valid(value) =\u003e if !endpoint_handshakes.is_empty() {\n                        let index = value % endpoint_handshakes.len();\n                        endpoint_handshakes[index]\n                    } else {\n                        !0usize\n                    },\n                    Primitive::Invalid(value) =\u003e if !endpoint_handshakes.contains(\u0026value) {\n                        value\n                    } else {\n                        !0usize\n                    }\n                };\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_abort_endpoint_client_handshake(context, handshake_handle, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextPollEvents{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingFFIError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_poll_events(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextSetTorBootstrapStatusReceivedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_bootstrap_status_received_callback, bootstrap_status_received);\n            },\n            Function::ContextSetTorBootstrapCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_bootstrap_completed_callback, bootstrap_complete);\n            },\n            Function::ContextSetTorLogReceivedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_log_received_callback, tor_log_received);\n            },\n            Function::ContextSetIdentityClientChallengeResponseSizeCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_challenge_response_size_callback, identity_client_handshake_challenge_response_size);\n            },\n            Function::ContextSetIdentityClientBuildChallengeResponseCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_build_challenge_response_callback, identity_client_handshake_build_challenge_response);\n            },\n            Function::ContextSetIdentityClientHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_handshake_completed_callback, identity_client_handshake_completed);\n            },\n            Function::ContextSetIdentityClientHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_handshake_failed_callback, identity_client_handshake_failed);\n            },\n            Function::ContextSetIdentityServerPublishedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_published_callback, identity_server_published);\n            },\n            Function::ContextSetIdentityServerHandshakeStartedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_started_callback, identity_server_handshake_started);\n            },\n            Function::ContextSetIdentityServerClientAllowedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_client_allowed_callback, identity_server_handshake_client_allowed);\n            },\n            Function::ContextSetIdentityServerEndpointSupportedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_endpoint_supported_callback, identity_server_endpoint_supported);\n            },\n            Function::ContextSetIdentityServerChallengeSizeCallack{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_challenge_size_callback, identity_server_handshake_challenge_size);\n            },\n            Function::ContextSetIdentityServerBuildChallengeCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_build_challenge_callback, identity_server_handshake_build_challenge);\n            },\n            Function::ContextSetIdentityServerVerifyChallengeResponseCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_verify_challenge_response_callback, identity_server_handshake_verify_challenge_response);\n            },\n            Function::ContextSetIdentityServerHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_completed_callback, identity_server_handshake_completed);\n            },\n            Function::ContextSetIdentityServerHandshakeRejectedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_rejected_callback, identity_server_handshake_rejected);\n            },\n            Function::ContextSetIdentityServerHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_failed_callback, identity_server_handshake_failed);\n            },\n            Function::ContextSetEndpointClientHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_client_handshake_completed_callback, endpoint_client_handhsake_completed);\n            },\n            Function::ContextSetEndpointClientHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_client_handshake_failed_callback, endpoint_client_handshake_failed);\n            },\n            Function::ContextSetEndpointServerPublishedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_published_callback, endpoint_server_published);\n            },\n            Function::ContextSetEndpointServerHandshakeStartedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_started_callback, endpoint_server_handshake_started);\n            },\n            Function::ContextSetEndpointServerChannelSupportedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_channel_supported_callback, endpoint_server_channel_supported);\n            },\n            Function::ContextSetEndpointServerHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_completed_callback, endpoint_server_handshake_completed);\n            },\n            Function::ContextSetEndpointServerHandshakeRejectedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_rejected_callback, endpoint_server_handshake_rejected);\n            },\n            Function::ContextSetEndpointServerHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_failed_callback, endpoint_server_handshake_failed);\n            },\n        }\n    }\n});\n","traces":[{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":43},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","ffi.rs"],"content":"// standard\nuse std::boxed::Box;\nuse std::collections::VecDeque;\nuse std::ffi::CString;\nuse std::io::Cursor;\nuse std::os::raw::c_char;\n#[cfg(unix)]\nuse std::os::unix::io::{IntoRawFd, RawFd};\n#[cfg(windows)]\nuse std::os::windows::io::{IntoRawSocket, RawSocket};\nuse std::panic;\nuse std::path::Path;\nuse std::ptr;\nuse std::str;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Mutex;\nuse std::time::Duration;\n\n// extern crates\nuse anyhow::anyhow;\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\nuse gosling::context::*;\nuse tor_interface::legacy_tor_client::*;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::*;\n\n// internal crates\nuse crate::object_registry::*;\n\n// tags used for types we put in ObjectRegistrys\nconst ERROR_TAG: usize = 0x1;\nconst ED25519_PRIVATE_KEY_TAG: usize = 0x2;\nconst X25519_PRIVATE_KEY_TAG: usize = 0x3;\nconst X25519_PUBLIC_KEY_TAG: usize = 0x4;\nconst V3_ONION_SERVICE_ID_TAG: usize = 0x5;\nconst TOR_PROVIDER_TAG: usize = 0x6;\nconst CONTEXT_TUPLE_TAG: usize = 0x7;\n\n\n// empty bson document layout:\n// {\n//     // document length 5 == 0x00000005\n//     0x05, 0x00, 0x00, 0x00,\n//     // document null-terminator\n//     0x00\n// };\nconst SMALLEST_BSON_DOC_SIZE: usize = 5;\n\n\nmacro_rules! define_registry {\n    ($type:ty) =\u003e {\n        paste::paste! {\n            // ensure tag fits in 3 bits\n            static_assertions::const_assert!([\u003c$type:snake:upper _TAG\u003e] \u003c= 0b111);\n\n            static [\u003c$type:snake:upper _REGISTRY\u003e]: Mutex\u003cObjectRegistry\u003c$type, { [\u003c$type:snake:upper _TAG\u003e] }, 3\u003e\u003e = Mutex::new(ObjectRegistry::new());\n\n            pub fn [\u003cget_ $type:snake _registry\u003e]\u003c'a\u003e() -\u003e std::sync::MutexGuard\u003c'a, ObjectRegistry\u003c$type, { [\u003c$type:snake:upper _TAG\u003e] }, 3\u003e\u003e {\n                match [\u003c$type:snake:upper _REGISTRY\u003e].lock() {\n                    Ok(registry) =\u003e registry,\n                    Err(_) =\u003e unreachable!(\"another thread panicked while holding this registry's mutex\"),\n                }\n            }\n\n            pub fn [\u003cclear_ $type:snake _registry\u003e]() {\n                match [\u003c$type:snake:upper _REGISTRY\u003e].lock() {\n                    Ok(mut registry) =\u003e *registry = ObjectRegistry::new(),\n                    Err(_) =\u003e unreachable!(\"another thread panicked while holding this registry's mutex\"),\n                }\n            }\n        }\n    }\n}\n\n/// Error Handling\n#[derive(Clone)]\npub struct Error {\n    message: CString,\n}\n\nimpl Error {\n    pub fn new(message: \u0026str) -\u003e Error {\n        Error {\n            message: CString::new(message).unwrap_or_default(),\n        }\n    }\n}\n\ndefine_registry! {Error}\n\n/// A wrapper object containing an error message\npub struct GoslingFFIError;\n\n\n/// Get error message from gosling_error\n///\n/// @param error: the error object to get the message from\n/// @return null-terminated string with error message whose\n///  lifetime is tied to the source\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_error_get_message(error: *const GoslingFFIError) -\u003e *const c_char {\n    if !error.is_null() {\n        let key = error as usize;\n\n        let registry = get_error_registry();\n        if registry.contains_key(key) {\n            if let Some(x) = registry.get(key) {\n                return x.message.as_ptr();\n            }\n        }\n    }\n\n    ptr::null()\n}\n\n/// Copy method for gosling_error\n///\n/// @param out_error: returned copy\n/// @param orig_error: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_error_clone(\n    out_error: *mut *mut GoslingFFIError,\n    orig_error: *const GoslingFFIError,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_error.is_null() {\n            bail!(\"out_error must not be null\");\n        }\n        if orig_error.is_null() {\n            bail!(\"orig_error must not be null\");\n        }\n\n        let orig_error = match get_error_registry().get(orig_error as usize) {\n            Some(orig_error) =\u003e orig_error.clone(),\n            None =\u003e bail!(\"error is invalid\"),\n        };\n        let handle = get_error_registry().insert(orig_error);\n        *out_error = handle as *mut GoslingFFIError;\n\n        Ok(())\n    })\n}\n\n// macro for defining the implementation of freeing objects\n// owned by an ObjectRegistry\nmacro_rules! impl_registry_free {\n    ($obj:expr, $type:ty) =\u003e {\n        if $obj.is_null() {\n            return;\n        }\n\n        let key = $obj as usize;\n        paste::paste! {\n            [\u003cget_ $type:snake _registry\u003e]().remove(key);\n        }\n    };\n}\n\n/// Frees gosling_error and invalidates any message strings\n/// returned by gosling_error_get_message() from the given\n/// error object.\n///\n/// @param error: the error object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_error_free(error: *mut GoslingFFIError) {\n    impl_registry_free!(error, Error);\n}\n\n/// A handle for the gosling library\npub struct GoslingLibrary;\n/// An ed25519 private key used to create a v3 onion service\npub struct GoslingEd25519PrivateKey;\n/// An x25519 private key used to decrypt v3 onion service descriptors\npub struct GoslingX25519PrivateKey;\n/// An x25519 public key used to encrypt v3 onoin service descriptors\npub struct GoslingX25519PublicKey;\n/// A v3 onion service id\npub struct GoslingV3OnionServiceId;\n/// A tor provider object used by a context to connect to the tor network\npub struct GoslingTorProvider;\n/// A context object associated with a single peer identity\npub struct GoslingContext;\n/// A handle for an in-progress identity handhskae\npub type GoslingHandshakeHandle = usize;\n#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n/// A native TCP socket handle\npub type GoslingTcpSocket = RawFd;\n#[cfg(any(target_os = \"windows\"))]\n/// A native TCP socket handle\npub type GoslingTcpSocket = RawSocket;\n\ndefine_registry! {Ed25519PrivateKey}\ndefine_registry! {X25519PrivateKey}\ndefine_registry! {X25519PublicKey}\ndefine_registry! {V3OnionServiceId}\n/// cbindgen:ignore\ntype TorProvider = Box\u003cdyn tor_provider::TorProvider\u003e;\ndefine_registry! {TorProvider}\n\n/// cbindgen:ignore\ntype ContextTuple = (Context, EventCallbacks, Option\u003cVecDeque\u003cContextEvent\u003e\u003e);\n\ndefine_registry! {ContextTuple}\n\n/// Frees a gosling_ed25519_private_key object\n///\n/// @param in_private_key: the private key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_ed25519_private_key_free(in_private_key: *mut GoslingEd25519PrivateKey) {\n    impl_registry_free!(in_private_key, Ed25519PrivateKey);\n}\n\n/// Frees a gosling_x25519_private_key object\n///\n/// @param in_private_key: the private key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_private_key_free(in_private_key: *mut GoslingX25519PrivateKey) {\n    impl_registry_free!(in_private_key, X25519PrivateKey);\n}\n/// Frees a gosling_x25519_public_key object\n///\n/// @param public_key: the public key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_public_key_free(in_public_key: *mut GoslingX25519PublicKey) {\n    impl_registry_free!(in_public_key, X25519PublicKey);\n}\n/// Frees a gosling_v3_onion_service_id object\n///\n/// @param in_service_id: the service id object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_v3_onion_service_id_free(in_service_id: *mut GoslingV3OnionServiceId) {\n    impl_registry_free!(in_service_id, V3OnionServiceId);\n}\n/// Frees a gosling_tor_provider object\n///\n/// @param in_tor_provider: the tor provider object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_tor_provider_free(in_tor_provider: *mut GoslingTorProvider) {\n    impl_registry_free!(in_tor_provider, ContextTuple);\n}\n/// Frees a gosling_context object\n///\n/// @param in_context: the context object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_free(in_context: *mut GoslingContext) {\n    impl_registry_free!(in_context, ContextTuple);\n}\n\n/// Wrapper around rust code which may panic or return a failing Result to be used at FFI boundaries.\n/// Converts panics or error Results into GoslingErrors if a memory location is provided.\n///\n/// @param default: The default value to return in the event of failure\n/// @param out_error: A pointer to pointer to GoslingError 'struct' for the C FFI\n/// @param closure: The functionality we need to encapsulate behind the error handling logic\n/// @return The result of closure() on success, or the value of default on failure.\nfn translate_failures\u003cR, F\u003e(default: R, out_error: *mut *mut GoslingFFIError, closure: F) -\u003e R\nwhere\n    F: FnOnce() -\u003e anyhow::Result\u003cR\u003e + panic::UnwindSafe,\n{\n    match panic::catch_unwind(closure) {\n        // handle success\n        Ok(Ok(retval)) =\u003e retval,\n        // handle runtime error\n        Ok(Err(err)) =\u003e {\n            if !out_error.is_null() {\n                // populate error with runtime error message\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", err).as_str()));\n                unsafe {\n                    *out_error = key as *mut GoslingFFIError;\n                };\n            }\n            default\n        }\n        // handle panic\n        Err(_) =\u003e {\n            if !out_error.is_null() {\n                // populate error with panic message\n                let key = get_error_registry().insert(Error::new(\"panic occurred\"));\n                unsafe {\n                    *out_error = key as *mut GoslingFFIError;\n                };\n            }\n            default\n        }\n    }\n}\n\nstatic GOSLING_LIBRARY_INITED: AtomicBool = AtomicBool::new(false);\nconst GOSLING_LIBRARY_HANDLE: usize = {\n    // integer constant in the form 0x6000..5E (GOOOOOSE)\n    (0x60 \u003c\u003c ((std::mem::size_of::\u003cusize\u003e() - 1) * 8)) + 0x5E\n};\n\n/// Initializes the Gosling library. This function must be called before using any of the\n/// other Gosling functions.\n///\n/// @return: returns 0 on success\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_library_init(\n    out_library: *mut *mut GoslingLibrary,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_library.is_null() {\n            bail!(\"out_library may not be null\");\n        }\n\n        if GOSLING_LIBRARY_INITED.load(Ordering::Relaxed) {\n            // error handling\n            bail!(\"gosling is already initialized\");\n        } else {\n            GOSLING_LIBRARY_INITED.store(true, Ordering::Relaxed);\n            *out_library = GOSLING_LIBRARY_HANDLE as *mut GoslingLibrary;\n        }\n        Ok(())\n    })\n}\n\n/// Frees all resources associated with the Gosling library. No-op if the library\n/// is not initialized or if it has already been freed\n#[no_mangle]\n#[allow(unused_variables)]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_library_free(in_library: *mut GoslingLibrary) {\n    if GOSLING_LIBRARY_INITED.load(Ordering::Relaxed) {\n        clear_error_registry();\n\n        clear_ed25519_private_key_registry();\n        clear_x25519_private_key_registry();\n        clear_x25519_public_key_registry();\n        clear_v3_onion_service_id_registry();\n\n        clear_context_tuple_registry();\n\n        GOSLING_LIBRARY_INITED.store(false, Ordering::Relaxed);\n    }\n}\n\n/// Creation method for securely generating a new gosling_ed25510_private_key\n///\n/// @param out_private_key: returned generated ed25519 private key\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_generate(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n\n        let private_key = Ed25519PrivateKey::generate();\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_ed25519_private_key\n///\n/// @param out_private_key: returned copy\n/// @param private_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_clone(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n        if private_key.is_null() {\n            bail!(\"private_key must not be null\");\n        }\n\n        let private_key = match get_ed25519_private_key_registry().get(private_key as usize) {\n            Some(private_key) =\u003e private_key.clone(),\n            None =\u003e bail!(\"private key is invalid\"),\n        };\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting the KeyBlob string returned by ADD_ONION\n/// command into a gosling_ed25519_private_key\n///\n/// @param out_private_key: returned ed25519 private key\n/// @param key_blob: an ed25519 KeyBlob string in the form\n///  \"ED25519-V3:abcd1234...\"\n/// @param key_blob_length: number of chars in key_blob not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_from_keyblob(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    key_blob: *const c_char,\n    key_blob_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n        if key_blob.is_null() {\n            bail!(\"key_blob must not be null\");\n        }\n\n        if key_blob_length != ED25519_PRIVATE_KEY_KEYBLOB_LENGTH {\n            bail!(\"key_blob_length must be exactly ED25519_PRIVATE_KEY_KEYBLOB_LENGTH ({}); received '{}'\", ED25519_PRIVATE_KEY_KEYBLOB_LENGTH, key_blob_length);\n        }\n\n        let key_blob_view = std::slice::from_raw_parts(key_blob as *const u8, key_blob_length);\n        let key_blob_str = std::str::from_utf8(key_blob_view)?;\n        let private_key = Ed25519PrivateKey::from_key_blob(key_blob_str)?;\n\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an ed25519 private key to a null-\n/// terminated KeyBlob string for use with ADD_ONION command\n///\n/// @param private_key: the private key to encode\n/// @param out_key_blob: buffer to be filled with ed25519 KeyBlob in\n///  the form \"ED25519-V3:abcd1234...\\0\"\n/// @param key_blob_size: size of out_key_blob buffer in bytes, must be at\n///  least 100 characters (99 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_ed25519_private_key_to_keyblob(\n    private_key: *const GoslingEd25519PrivateKey,\n    out_key_blob: *mut c_char,\n    key_blob_size: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if private_key.is_null() {\n            bail!(\"private_key must not be null\");\n        }\n        if out_key_blob.is_null() {\n            bail!(\"out_key_blob must not be null\");\n        }\n\n        if key_blob_size \u003c ED25519_PRIVATE_KEY_KEYBLOB_SIZE {\n            bail!(\n                \"key_blob_size must be at least ED25519_PRIVATE_KEY_KEYBLOB_SIZE ('{}'), received '{}'\",\n                ED25519_PRIVATE_KEY_KEYBLOB_SIZE,\n                key_blob_size\n            );\n        }\n\n        let registry = get_ed25519_private_key_registry();\n        match registry.get(private_key as usize) {\n            Some(private_key) =\u003e {\n                let private_key_blob = private_key.to_key_blob();\n                unsafe {\n                    // copy keyblob into output buffer\n                    let key_blob_view =\n                        std::slice::from_raw_parts_mut(out_key_blob as *mut u8, key_blob_size);\n                    std::ptr::copy(\n                        private_key_blob.as_ptr(),\n                        key_blob_view.as_mut_ptr(),\n                        ED25519_PRIVATE_KEY_KEYBLOB_LENGTH,\n                    );\n                    // add final null-terminator\n                    key_blob_view[ED25519_PRIVATE_KEY_KEYBLOB_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail!(\"private_key is invalid\");\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_x25519_private_key\n///\n/// @param out_private_key: returned copy\n/// @param private_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_private_key_clone(\n    out_private_key: *mut *mut GoslingX25519PrivateKey,\n    private_key: *const GoslingX25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n        if private_key.is_null() {\n            bail!(\"private_key must not be null\");\n        }\n\n        let private_key = match get_x25519_private_key_registry().get(private_key as usize) {\n            Some(private_key) =\u003e private_key.clone(),\n            None =\u003e bail!(\"private key is invalid\"),\n        };\n        let handle = get_x25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingX25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting a base64-encoded string used by the\n/// ONION_CLIENT_AUTH_ADD command into a gosling_x25519_private_key\n///\n/// @param out_private_key: returned x25519 private key\n/// @param base64: an x25519 private key encoded as a base64 string\n/// @param base64_length: the number of chars in base64 not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_private_key_from_base64(\n    out_private_key: *mut *mut GoslingX25519PrivateKey,\n    base64: *const c_char,\n    base64_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_private_key.is_null() {\n            bail!(\"out_private_key must not be null\");\n        }\n        if base64.is_null() {\n            bail!(\"base64 must not be null\");\n        }\n\n        if base64_length != X25519_PRIVATE_KEY_BASE64_LENGTH {\n            bail!(\"base64_length must be exactly X25519_PRIVATE_KEY_BASE64_LENGTH ({}); received '{}'\", X25519_PRIVATE_KEY_BASE64_LENGTH, base64_length);\n        }\n\n        let base64_view = std::slice::from_raw_parts(base64 as *const u8, base64_length);\n        let base64_str = std::str::from_utf8(base64_view)?;\n        let private_key = X25519PrivateKey::from_base64(base64_str)?;\n\n        let handle = get_x25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingX25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an x25519 private key to a null-\n/// terminated base64 string for use with ONION_CLIENT_AUTH_ADD command\n///\n/// @param private_key: the private key to encode\n/// @param out_base64: buffer to be filled with x25519 key encoded as base64\n/// @param base64_size: size of out_base64 buffer in bytes, must be at\n///  least 45 characters (44 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_private_key_to_base64(\n    private_key: *const GoslingX25519PrivateKey,\n    out_base64: *mut c_char,\n    base64_size: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if private_key.is_null() {\n            bail!(\"private_key must not be null\");\n        }\n        if out_base64.is_null() {\n            bail!(\"out_base64 must not be null\");\n        }\n\n        if base64_size \u003c X25519_PRIVATE_KEY_BASE64_SIZE {\n            bail!(\n                \"base64_size must be at least '{}', received '{}'\",\n                X25519_PRIVATE_KEY_BASE64_SIZE,\n                base64_size\n            );\n        }\n\n        let registry = get_x25519_private_key_registry();\n        match registry.get(private_key as usize) {\n            Some(private_key) =\u003e {\n                let private_key_blob = private_key.to_base64();\n                unsafe {\n                    // copy base64 into output buffer\n                    let base64_view =\n                        std::slice::from_raw_parts_mut(out_base64 as *mut u8, base64_size);\n                    std::ptr::copy(\n                        private_key_blob.as_ptr(),\n                        base64_view.as_mut_ptr(),\n                        X25519_PRIVATE_KEY_BASE64_LENGTH,\n                    );\n                    // add final null-terminator\n                    base64_view[X25519_PRIVATE_KEY_BASE64_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail!(\"private_key is invalid\");\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_x25519_public_key\n///\n/// @param out_public_key: returned copy\n/// @param public_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_public_key_clone(\n    out_public_key: *mut *mut GoslingX25519PublicKey,\n    public_key: *const GoslingX25519PublicKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_public_key.is_null() {\n            bail!(\"out_public_key must not be null\");\n        }\n        if public_key.is_null() {\n            bail!(\"public_key must not be null\");\n        }\n\n        let public_key = match get_x25519_public_key_registry().get(public_key as usize) {\n            Some(public_key) =\u003e public_key.clone(),\n            None =\u003e bail!(\"public key is invalid\"),\n        };\n        let handle = get_x25519_public_key_registry().insert(public_key);\n        *out_public_key = handle as *mut GoslingX25519PublicKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting a base32-encoded string used by the\n/// ADD_ONION command into a gosling_x25519_public_key\n///\n/// @param out_public_key: returned x25519 public key\n/// @param base32: an x25519 public key encoded as a base32 string\n/// @param base32_length: the number of chars in base32 not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_public_key_from_base32(\n    out_public_key: *mut *mut GoslingX25519PublicKey,\n    base32: *const c_char,\n    base32_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_public_key.is_null() {\n            bail!(\"out_public_key must not be null\");\n        }\n        if base32.is_null() {\n            bail!(\"bas32 must not be null\");\n        }\n\n        if base32_length != X25519_PUBLIC_KEY_BASE32_LENGTH {\n            bail!(\"base32_length must be exactly X25519_PUBLIC_KEY_BASE32_LENGTH ({}); received '{}'\", X25519_PUBLIC_KEY_BASE32_LENGTH, base32_length);\n        }\n\n        let base32_view = std::slice::from_raw_parts(base32 as *const u8, base32_length);\n        let base32_str = std::str::from_utf8(base32_view)?;\n        let public_key = X25519PublicKey::from_base32(base32_str)?;\n\n        let handle = get_x25519_public_key_registry().insert(public_key);\n        *out_public_key = handle as *mut GoslingX25519PublicKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an x25519 public key to a null-\n/// terminated base64 string for use with ADD_ONION command\n///\n/// @param public_key: the public key to encode\n/// @param out_base32: buffer to be filled with x25519 key encoded as base32\n/// @param base32_size: size of out_base32 buffer in bytes, must be at\n///  least 53 characters (52 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_public_key_to_base32(\n    public_key: *const GoslingX25519PublicKey,\n    out_base32: *mut c_char,\n    base32_size: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if public_key.is_null() {\n            bail!(\"public_key must not be null\");\n        }\n        if out_base32.is_null() {\n            bail!(\"out_base32 must not be null\");\n        }\n\n        if base32_size \u003c X25519_PUBLIC_KEY_BASE32_SIZE {\n            bail!(\n                \"base32_size must be at least '{}', received '{}'\",\n                X25519_PUBLIC_KEY_BASE32_SIZE,\n                base32_size\n            );\n        }\n\n        let registry = get_x25519_public_key_registry();\n        match registry.get(public_key as usize) {\n            Some(public_key) =\u003e {\n                let public_base32 = public_key.to_base32();\n                unsafe {\n                    // copy base32 into output buffer\n                    let base32_view =\n                        std::slice::from_raw_parts_mut(out_base32 as *mut u8, base32_size);\n                    std::ptr::copy(\n                        public_base32.as_ptr(),\n                        base32_view.as_mut_ptr(),\n                        X25519_PUBLIC_KEY_BASE32_LENGTH,\n                    );\n                    // add final null-terminator\n                    base32_view[X25519_PUBLIC_KEY_BASE32_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail!(\"public_key is invalid\");\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_v3_onion_service_id\n///\n/// @param out_service_id: returned copy\n/// @param service_id: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_clone(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    service_id: *const GoslingV3OnionServiceId,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_service_id.is_null() {\n            bail!(\"out_service_id must not be null\");\n        }\n        if service_id.is_null() {\n            bail!(\"service_id must not be null\");\n        }\n\n        let service_id = match get_v3_onion_service_id_registry().get(service_id as usize) {\n            Some(service_id) =\u003e service_id.clone(),\n            None =\u003e bail!(\"service_id is invalid\"),\n        };\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting a v3 onion service string into a\n/// gosling_v3_onion_service_id object\n///\n/// @param out_service_id: returned service id object\n/// @param service_id_string: a v3 onion service id string\n/// @param service_id_string_length: the number of chars in service_id_string not including any\n///  null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_from_string(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    service_id_string: *const c_char,\n    service_id_string_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_service_id.is_null() {\n            bail!(\"out_service_id must not be null\");\n        }\n        if service_id_string.is_null() {\n            bail!(\"service_id_string must not be null\");\n        }\n\n        if service_id_string_length != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            bail!(\"service_id_string_length must be exactly V3_ONION_SERVICE_ID_STRING_LENGTH ({}); received '{}'\", V3_ONION_SERVICE_ID_STRING_LENGTH, service_id_string_length);\n        }\n\n        let service_id_view =\n            std::slice::from_raw_parts(service_id_string as *const u8, service_id_string_length);\n        let service_id_str = std::str::from_utf8(service_id_view)?;\n        let service_id = V3OnionServiceId::from_string(service_id_str)?;\n\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an ed25519 private key  into a\n/// gosling_v3_onion_service_id object\n///\n/// @param out_service_id: returned service id object\n/// @param ed25519_private_key: an e25519 private key\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_from_ed25519_private_key(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    ed25519_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_service_id.is_null() {\n            bail!(\"out_service_id must not be null\");\n        }\n        if ed25519_private_key.is_null() {\n            bail!(\"ed25519_private_key must not be null\");\n        }\n\n        let service_id = {\n            let ed25519_private_key_registry = get_ed25519_private_key_registry();\n            let ed25519_private_key =\n                match ed25519_private_key_registry.get(ed25519_private_key as usize) {\n                    Some(ed25519_private_key) =\u003e ed25519_private_key,\n                    None =\u003e bail!(\"ed25519_private_key is invalid\"),\n                };\n            V3OnionServiceId::from_private_key(ed25519_private_key)\n        };\n\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting v3 onion service id to a null-terminated\n/// string\n///\n/// @param service_id: the service id to encode\n/// @param out_service_id_string: buffer to be filled with x25519 key encoded as base32\n/// @param service_id_string_size: size of out_service_id_string buffer in bytes,\n///  must be at least 57 characters (56 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_v3_onion_service_id_to_string(\n    service_id: *const GoslingV3OnionServiceId,\n    out_service_id_string: *mut c_char,\n    service_id_string_size: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if service_id.is_null() {\n            bail!(\"service_id must not be null\");\n        }\n        if out_service_id_string.is_null() {\n            bail!(\"out_service_id_string must not be null\");\n        }\n\n        if service_id_string_size \u003c V3_ONION_SERVICE_ID_STRING_SIZE {\n            bail!(\n                \"service_id_string_size must be at least '{}', received '{}'\",\n                V3_ONION_SERVICE_ID_STRING_SIZE,\n                service_id_string_size\n            );\n        }\n\n        let registry = get_v3_onion_service_id_registry();\n        match registry.get(service_id as usize) {\n            Some(service_id) =\u003e {\n                let service_id_string = service_id.to_string();\n                unsafe {\n                    // copy service_id_string into output buffer\n                    let service_id_string_view = std::slice::from_raw_parts_mut(\n                        out_service_id_string as *mut u8,\n                        service_id_string_size,\n                    );\n                    std::ptr::copy(\n                        service_id_string.as_ptr(),\n                        service_id_string_view.as_mut_ptr(),\n                        V3_ONION_SERVICE_ID_STRING_LENGTH,\n                    );\n                    // add final null-terminator\n                    service_id_string_view[V3_ONION_SERVICE_ID_STRING_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail!(\"service_id is invalid\");\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Checks if a service id string is valid per tor rend spec:\n/// https://gitweb.torproject.org/torspec.git/tree/rend-spec-v3.txt\n///\n/// @param service_id_string: string containing the v3 service id to be validated\n/// @param service_id_string_length: the number of chars in service_id_string not including any\n///  null-terminator; must be V3_ONION_SERVICE_ID_STRING_LENGTH (56)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_string_is_valid_v3_onion_service_id(\n    service_id_string: *const c_char,\n    service_id_string_length: usize,\n    error: *mut *mut GoslingFFIError,\n) -\u003e bool {\n    translate_failures(false, error, || -\u003e anyhow::Result\u003cbool\u003e {\n        if service_id_string.is_null() {\n            bail!(\"service_id_string must not be null\");\n        }\n\n        if service_id_string_length != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            bail!(\n                \"service_id_string_length must be V3_ONION_SERVICE_ID_STRING_LENGTH (56); received '{}'\",\n                service_id_string_length\n            );\n        }\n\n        let service_id_string_slice = unsafe {\n            std::slice::from_raw_parts(service_id_string as *const u8, service_id_string_length)\n        };\n        Ok(V3OnionServiceId::is_valid(str::from_utf8(\n            service_id_string_slice,\n        )?))\n    })\n}\n\n/// Create a new tor provider which uses the legacy tor daemon client.\n///\n/// @param out_tor_provider: returned tor provider\n/// @param tor_bin_path: the file system path to the tor binary; if this is null the tor executable\n///  found in the system PATH variable is used\n/// @param tor_bin_path_length: the number of chars in tor_bin_path not including any null terminator\n/// @param tor_working_directory: the file system path to store tor's data\n/// @param tor_working_directory_length: the number of chars in tor_working_directory not including any\n///  null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_new_legacy_client(\n    out_tor_provider: *mut *mut GoslingTorProvider,\n    tor_bin_path: *const c_char,\n    tor_bin_path_length: usize,\n    tor_working_directory: *const c_char,\n    tor_working_directory_length: usize,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_tor_provider.is_null() {\n            bail!(\"out_tor_provider must not be null\");\n        }\n        if tor_bin_path.is_null() \u0026\u0026 tor_bin_path_length != 0 {\n            bail!(\"tor_bin_path is null so tor_bin_path_length must be 0\");\n        }\n        if !tor_bin_path.is_null() \u0026\u0026 tor_bin_path_length == 0 {\n            bail!(\"tor_bin_path is not null so tor_bin_path_length must be greater than 0\");\n        }\n        if tor_working_directory.is_null() {\n            bail!(\"tor_working_directory must not be null\");\n        }\n        if tor_working_directory_length == 0usize {\n            bail!(\"tor_working_directory_length must not be 0\");\n        }\n\n        let tor_bin_path = if tor_bin_path.is_null() {\n            which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?\n        } else {\n            let tor_bin_path =\n                std::slice::from_raw_parts(tor_bin_path as *const u8, tor_bin_path_length);\n            let tor_bin_path = std::str::from_utf8(tor_bin_path)?;\n            let tor_bin_path = Path::new(tor_bin_path);\n            tor_bin_path.canonicalize()?\n        };\n\n        // tor working dir\n        let tor_working_directory = std::slice::from_raw_parts(\n            tor_working_directory as *const u8,\n            tor_working_directory_length,\n        );\n        let tor_working_directory = std::str::from_utf8(tor_working_directory)?;\n        let tor_working_directory = Path::new(tor_working_directory);\n\n        let tor_client = LegacyTorClient::new(\u0026tor_bin_path, tor_working_directory)?;\n        let tor_provider = Box::new(tor_client);\n\n        let handle = get_tor_provider_registry().insert(tor_provider);\n        *out_tor_provider = handle as *mut GoslingTorProvider;\n\n        Ok(())\n    });\n}\n\n/// Create a mock tor provider for no-internet required in-process testing.\n///\n/// @param out_tor_provider: returned tor provider\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_new_mock_client(\n    out_tor_provider: *mut *mut GoslingTorProvider,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_tor_provider.is_null() {\n            bail!(\"out_tor_provider must not be null\");\n        }\n\n        let tor_client: MockTorClient = Default::default();\n        let tor_provider = Box::new(tor_client);\n\n        let handle = get_tor_provider_registry().insert(tor_provider);\n        *out_tor_provider = handle as *mut GoslingTorProvider;\n\n        Ok(())\n    });\n}\n\n/// Initialize a gosling context.\n///\n/// @param out_context: returned initialied gosling context\n/// @param in_tor_provider: the tor client implementation to use; this function consumes the tor_provider\n///  and it may not be re-used in subsequent gosling_* calls, and it does not need to be freed\n/// @param identity_port: the tor virtual port the identity server listens on\n/// @param endpoint_port: the tor virtual port endpoint servers listen on\n/// @param identity_private_key: the e25519 private key used to start th identity server's onion service\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_context_init(\n    // out context\n    out_context: *mut *mut GoslingContext,\n    in_tor_provider: *mut GoslingTorProvider,\n    identity_port: u16,\n    endpoint_port: u16,\n    identity_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if out_context.is_null() {\n            bail!(\"out_context must not be null\");\n        }\n        if in_tor_provider.is_null() {\n            bail!(\"in_tor_provider must not be null\");\n        }\n        if identity_port == 0u16 {\n            bail!(\"identity_port must not be 0\");\n        }\n        if endpoint_port == 0u16 {\n            bail!(\"endpoint_port must not be 0\");\n        }\n        if identity_private_key.is_null() {\n            bail!(\"identity_private_key must not be null\");\n        }\n\n        // get our tor provider\n        let tor_provider = match get_tor_provider_registry().remove(in_tor_provider as usize) {\n            Some(tor_provider) =\u003e tor_provider,\n            None =\u003e bail!(\"tor_provider is invalid\"),\n        };\n\n        // get our identity key\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let identity_private_key =\n            match ed25519_private_key_registry.get(identity_private_key as usize) {\n                Some(identity_private_key) =\u003e identity_private_key,\n                None =\u003e bail!(\"identity_private_key is invalid\"),\n            };\n\n        // construct context\n        let context = Context::new(\n            tor_provider,\n            identity_port,\n            endpoint_port,\n            Duration::from_secs(60),\n            4096,\n            Some(Duration::from_secs(60)),\n            identity_private_key.clone(),\n        )?;\n\n        let handle = get_context_tuple_registry().insert((context, Default::default(), None));\n        *out_context = handle as *mut GoslingContext;\n\n        Ok(())\n    });\n}\n\n/// Connect a gosling_context to the tor network\n///\n/// @param context: the gosling context object to connect to the tor network\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_bootstrap_tor(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n        Ok(context.0.bootstrap()?)\n    });\n}\n\n/// Start the identity server so that clients may request endpoints\n///\n/// @param context: the gosling context whose identity server to start\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_start_identity_server(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n        Ok(context.0.identity_server_start()?)\n    });\n}\n\n/// Stop the identity server so clients can no longer request endpoints\n///\n/// @param context: the gosling context whose identity server to stop\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_stop_identity_server(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n        Ok(context.0.identity_server_stop()?)\n    });\n}\n\n/// Start an endpoint server so the confirmed contact may connect\n///\n/// @param context: the gosling context with the given endpoint to start\n/// @param endpoint_private_key: the ed25519 private key needed to start the endpoint\n///  onion service\n/// @param endpoint_name: the ascii-encoded name of the endpoint server\n/// @param endpoint_name_length: the number of chars in endpoint name not including any null-terminator\n/// @param client_identity: the v3 onion service id of the gosling client associated with this endpoint\n/// @param client_auth_public_key: the x25519 public key used to encrypt the onion service descriptor\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_start_endpoint_server(\n    context: *mut GoslingContext,\n    endpoint_private_key: *const GoslingEd25519PrivateKey,\n    endpoint_name: *const c_char,\n    endpoint_name_length: usize,\n    client_identity: *const GoslingV3OnionServiceId,\n    client_auth_public_key: *const GoslingX25519PublicKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n        if endpoint_private_key.is_null() {\n            bail!(\"endpoint_private_key mut not be null\");\n        }\n        if endpoint_name.is_null() {\n            bail!(\"endpoint_name must not be null\");\n        }\n        if endpoint_name_length == 0 {\n            bail!(\"endpoint_name_length must not be 0\");\n        }\n        if client_identity.is_null() {\n            bail!(\"client_identity must not be null\");\n        }\n        if client_auth_public_key.is_null() {\n            bail!(\"client_auth_public_key must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n\n        let endpoint_name =\n            unsafe { std::slice::from_raw_parts(endpoint_name as *const u8, endpoint_name_length) };\n        let endpoint_name = std::str::from_utf8(endpoint_name)?.to_string();\n        if !endpoint_name.is_ascii() {\n            bail!(\"endpoint_name must be an ascii string\");\n        }\n\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let endpoint_private_key =\n            match ed25519_private_key_registry.get(endpoint_private_key as usize) {\n                Some(ed25519_private_key) =\u003e ed25519_private_key,\n                None =\u003e bail!(\"endpoint_private_key is invalid\"),\n            };\n\n        let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n        let client_identity = match v3_onion_service_id_registry.get(client_identity as usize) {\n            Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n            None =\u003e bail!(\"client_identity is invalid\"),\n        };\n\n        let x25519_public_key_registry = get_x25519_public_key_registry();\n        let client_auth_public_key =\n            match x25519_public_key_registry.get(client_auth_public_key as usize) {\n                Some(x25519_public_key) =\u003e x25519_public_key,\n                None =\u003e bail!(\"client_auth_public_key is invalid\"),\n            };\n\n        Ok(context.0.endpoint_server_start(\n            endpoint_private_key.clone(),\n            endpoint_name,\n            client_identity.clone(),\n            client_auth_public_key.clone(),\n        )?)\n    });\n}\n\n/// Stops an endpoint server\n///\n/// @param context: the gosling context associated with the endpoint server\n/// @param endpoint_private_key: the ed25519 private key associated with the endpoint server to stop\n/// @param error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_stop_endpoint_server(\n    context: *mut GoslingContext,\n    endpoint_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n        if endpoint_private_key.is_null() {\n            bail!(\"endpoint_private_key must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let endpoint_private_key =\n            match ed25519_private_key_registry.get(endpoint_private_key as usize) {\n                Some(ed25519_private_key) =\u003e ed25519_private_key,\n                None =\u003e bail!(\"endpoint_private_key is invalid\"),\n            };\n\n        let endpoint_identity = V3OnionServiceId::from_private_key(endpoint_private_key);\n        Ok(context.0.endpoint_server_stop(endpoint_identity)?)\n    });\n}\n\n/// Connect to and begin a handshake to request an endpoint from the given identity server\n///\n/// @param context: the context to request an endpoint server for\n/// @param identity_service_id: the service id of the identity server we want to request an endpoint server\n///  from\n/// @param endpoint_name: the name of the endpoint server to request\n/// @param endpoint_name_length: the number of chars in endpoin_name not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_begin_identity_handshake(\n    context: *mut GoslingContext,\n    identity_service_id: *const GoslingV3OnionServiceId,\n    endpoint_name: *const c_char,\n    endpoint_name_length: usize,\n    error: *mut *mut GoslingFFIError,\n) -\u003e GoslingHandshakeHandle {\n    translate_failures(\n        !0usize,\n        error,\n        || -\u003e anyhow::Result\u003cGoslingHandshakeHandle\u003e {\n            if context.is_null() {\n                bail!(\"context must not be null\");\n            }\n            if identity_service_id.is_null() {\n                bail!(\"identity_service_id must not be null\");\n            }\n            if endpoint_name.is_null() {\n                bail!(\"endpoint_name must not be null\");\n            }\n            if endpoint_name_length == 0 {\n                bail!(\"endpoint_name_length must not be 0\");\n            }\n\n            let mut context_tuple_registry = get_context_tuple_registry();\n            let context = match context_tuple_registry.get_mut(context as usize) {\n                Some(context) =\u003e context,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n\n            let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n            let identity_service_id =\n                match v3_onion_service_id_registry.get(identity_service_id as usize) {\n                    Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n                    None =\u003e bail!(\"identity_service_id is invalid\"),\n                };\n\n            let endpoint_name = unsafe {\n                std::slice::from_raw_parts(endpoint_name as *const u8, endpoint_name_length)\n            };\n            let endpoint_name = std::str::from_utf8(endpoint_name)?.to_string();\n            if !endpoint_name.is_ascii() {\n                bail!(\"endpoint_name must be an ascii string\")\n            }\n\n            Ok(context\n                .0\n                .identity_client_begin_handshake(identity_service_id.clone(), endpoint_name)?)\n        },\n    )\n}\n\n/// Abort an in-progress identity client handshake\n///\n/// @param context: the context associated with the identity client handshake handle\n/// @param handshake_handle: the handle associated with the identity client handshake\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_abort_identity_client_handshake(\n    context: *mut GoslingContext,\n    handshake_handle: GoslingHandshakeHandle,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n\n        Ok(context\n            .0\n            .identity_client_abort_handshake(handshake_handle)?)\n    })\n}\n\n/// Connect to and begin a handshake to request a channel from the given endpoint server\n///\n/// @param context: the context which will be opening the channel\n/// @param endpoint_service_id: the endpoint server to open a channel to\n/// @param client_auth_private_key: the x25519 clienth authorization key needed to decrypt the endpoint server's\n///  onion service descriptor\n/// @param channel_name: the ascii-encoded name of the channel to open\n/// @param channel_name_length: the number of chars in channel name not including any null-terminator\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_begin_endpoint_handshake(\n    context: *mut GoslingContext,\n    endpoint_service_id: *const GoslingV3OnionServiceId,\n    client_auth_private_key: *const GoslingX25519PrivateKey,\n    channel_name: *const c_char,\n    channel_name_length: usize,\n    error: *mut *mut GoslingFFIError,\n) -\u003e GoslingHandshakeHandle {\n    translate_failures(\n        !0usize,\n        error,\n        || -\u003e anyhow::Result\u003cGoslingHandshakeHandle\u003e {\n            if context.is_null() {\n                bail!(\"context must not be null\");\n            }\n            if endpoint_service_id.is_null() {\n                bail!(\"endpoint_service_id must not be null\");\n            }\n            if client_auth_private_key.is_null() {\n                bail!(\"client_auth_private_key must not be null\");\n            }\n            if channel_name.is_null() {\n                bail!(\"channel_name must not be null\");\n            }\n            if channel_name_length == 0 {\n                bail!(\"channel_name_length must not be 0\");\n            }\n\n            let mut context_tuple_registry = get_context_tuple_registry();\n            let context = match context_tuple_registry.get_mut(context as usize) {\n                Some(context) =\u003e context,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n\n            let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n            let endpoint_service_id =\n                match v3_onion_service_id_registry.get(endpoint_service_id as usize) {\n                    Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n                    None =\u003e bail!(\"endpoint_service_id is invalid\"),\n                };\n\n            let x25519_private_key_registry = get_x25519_private_key_registry();\n            let client_auth_private_key =\n                match x25519_private_key_registry.get(client_auth_private_key as usize) {\n                    Some(x25519_private_key) =\u003e x25519_private_key,\n                    None =\u003e bail!(\"client_auth_private_key is invalid\"),\n                };\n\n            let channel_name = unsafe {\n                std::slice::from_raw_parts(channel_name as *const u8, channel_name_length)\n            };\n            let channel_name = std::str::from_utf8(channel_name)?.to_string();\n            if !channel_name.is_ascii() {\n                bail!(\"channel_name must be an ascii string\");\n            }\n\n            Ok(context.0.endpoint_client_begin_handshake(\n                endpoint_service_id.clone(),\n                client_auth_private_key.clone(),\n                channel_name,\n            )?)\n        },\n    )\n}\n\n/// Abort an in-progress endpoint client handshake\n///\n/// @param context: the context associated with the endpoint client handshake handle\n/// @param handshake_handle: the handle associated with the identity client handshake\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_abort_endpoint_client_handshake(\n    context: *mut GoslingContext,\n    handshake_handle: GoslingHandshakeHandle,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        if context.is_null() {\n            bail!(\"context must not be null\");\n        }\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail!(\"context is invalid\"),\n        };\n\n        Ok(context\n            .0\n            .endpoint_client_abort_handshake(handshake_handle)?)\n    })\n}\n\nfn handle_context_event(\n    event: ContextEvent,\n    context: *mut GoslingContext,\n    callbacks: \u0026EventCallbacks,\n) -\u003e anyhow::Result\u003c()\u003e {\n    match event {\n        //\n        // Tor Events\n        //\n        ContextEvent::TorBootstrapStatusReceived {\n            progress,\n            tag,\n            summary,\n        } =\u003e {\n            if let Some(callback) = callbacks.tor_bootstrap_status_received_callback {\n                let tag0 = CString::new(tag.as_str()).expect(\n                    \"bootstrap status tag string should not have an intermediate null byte\",\n                );\n                let summary0 = CString::new(summary.as_str()).expect(\n                    \"bootstrap status summary string should not have an intermediate null byte\",\n                );\n                callback(\n                    context,\n                    progress,\n                    tag0.as_ptr(),\n                    tag.len(),\n                    summary0.as_ptr(),\n                    summary.len(),\n                );\n            }\n        }\n        ContextEvent::TorBootstrapCompleted =\u003e {\n            if let Some(callback) = callbacks.tor_bootstrap_completed_callback {\n                callback(context);\n            }\n        }\n        ContextEvent::TorLogReceived { line } =\u003e {\n            if let Some(callback) = callbacks.tor_log_received_callback {\n                let line0 = CString::new(line.as_str())\n                    .expect(\"tor log line string should not have an intermediate null byte\");\n                callback(context, line0.as_ptr(), line.len());\n            }\n        }\n        //\n        // Identity Client Events\n        //\n        ContextEvent::IdentityClientChallengeReceived {\n            handle,\n            endpoint_challenge,\n        } =\u003e {\n            // construct challenge response\n            let challenge_response = if let (\n                Some(challenge_response_size_callback),\n                Some(build_challenge_response_callback),\n            ) = (\n                callbacks.identity_client_challenge_response_size_callback,\n                callbacks.identity_client_build_challenge_response_callback,\n            ) {\n                let mut endpoint_challenge_buffer: Vec\u003cu8\u003e = Default::default();\n                endpoint_challenge.to_writer(\u0026mut endpoint_challenge_buffer).expect(\"endpoint_challenge should be a valid bson::document::Document and therefore serializable to Vec\u003cu8\u003e\");\n\n                // get the size of challenge response bson blob\n                let challenge_response_size = challenge_response_size_callback(\n                    context,\n                    handle,\n                    endpoint_challenge_buffer.as_ptr(),\n                    endpoint_challenge_buffer.len(),\n                );\n\n\n                if challenge_response_size \u003c SMALLEST_BSON_DOC_SIZE {\n                    bail!(\"identity_client_challenge_response_size_callback returned an impossibly small size '{}', smallest possible is {}\", challenge_response_size, SMALLEST_BSON_DOC_SIZE);\n                }\n\n                // get the challenge response bson blob\n                let mut challenge_response_buffer: Vec\u003cu8\u003e = vec![0u8; challenge_response_size];\n                build_challenge_response_callback(\n                    context,\n                    handle,\n                    endpoint_challenge_buffer.as_ptr(),\n                    endpoint_challenge_buffer.len(),\n                    challenge_response_buffer.as_mut_ptr(),\n                    challenge_response_buffer.len(),\n                );\n\n                // convert bson blob to bson object\n                match bson::document::Document::from_reader(Cursor::new(challenge_response_buffer))\n                {\n                    Ok(challenge_response) =\u003e challenge_response,\n                    Err(_) =\u003e bail!(\"failed to parse binary provided by identity_client_build_challenge_response_callback as BSON document\")\n                }\n            } else {\n                bail!(\"missing required identity_client_challenge_response_size() and identity_client_build_challenge_response() callbacks\");\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .identity_client_handle_challenge_received(handle, challenge_response)?,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n        }\n        ContextEvent::IdentityClientHandshakeCompleted {\n            handle,\n            identity_service_id,\n            endpoint_service_id,\n            endpoint_name,\n            client_auth_private_key,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_client_handshake_completed_callback {\n                let (identity_service_id, endpoint_service_id) = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    let identity_service_id =\n                        v3_onion_service_id_registry.insert(identity_service_id);\n                    let endpoint_service_id =\n                        v3_onion_service_id_registry.insert(endpoint_service_id);\n                    (identity_service_id, endpoint_service_id)\n                };\n\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                let client_auth_private_key =\n                    get_x25519_private_key_registry().insert(client_auth_private_key);\n\n                callback(\n                    context,\n                    handle,\n                    identity_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                    client_auth_private_key as *const GoslingX25519PrivateKey,\n                );\n\n                // cleanup\n                {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.remove(identity_service_id);\n                    v3_onion_service_id_registry.remove(endpoint_service_id);\n                }\n                get_x25519_private_key_registry().remove(client_auth_private_key);\n            } else {\n                bail!(\"missing required identity_client_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::IdentityClientHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.identity_client_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingFFIError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Identity Server Events\n        //\n        ContextEvent::IdentityServerPublished =\u003e {\n            if let Some(callback) = callbacks.identity_server_published_callback {\n                callback(context);\n            }\n        }\n        ContextEvent::IdentityServerHandshakeStarted { handle } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_started_callback {\n                callback(context, handle);\n            }\n        }\n        ContextEvent::IdentityServerEndpointRequestReceived {\n            handle,\n            client_service_id,\n            requested_endpoint,\n        } =\u003e {\n            let client_allowed = match callbacks.identity_server_client_allowed_callback {\n                Some(callback) =\u003e {\n                    let client_service_id =\n                        get_v3_onion_service_id_registry().insert(client_service_id);\n                    callback(\n                        context,\n                        handle,\n                        client_service_id as *const GoslingV3OnionServiceId,\n                    )\n                }\n                None =\u003e bail!(\"missing required identity_server_client_allowed() callback\"),\n            };\n\n            let endpoint_supported = match callbacks.identity_server_endpoint_supported_callback {\n                Some(callback) =\u003e {\n                    let requested_endpoint0 = CString::new(requested_endpoint.as_str()).expect(\n                        \"requested_endpoint should be a valid ASCII string and not have an intermediate null byte\",\n                    );\n                    callback(\n                        context,\n                        handle,\n                        requested_endpoint0.as_ptr(),\n                        requested_endpoint.len(),\n                    )\n                }\n                None =\u003e bail!(\"missing required identity_server_endpoint_supported() callback\"),\n            };\n            let endpoint_challenge = if let (\n                Some(challenge_size_callback),\n                Some(build_challenge_callback),\n            ) = (\n                callbacks.identity_server_challenge_size_callback,\n                callbacks.identity_server_build_challenge_callback,\n            ) {\n                // get the challenge size in bytes\n                let challenge_size = challenge_size_callback(context, handle);\n\n                if challenge_size \u003c SMALLEST_BSON_DOC_SIZE {\n                    bail!(\"identity_server_challenge_size_callback returned an impossibly small size '{}', smallest possible is {}\", challenge_size, SMALLEST_BSON_DOC_SIZE);\n                }\n\n                // construct challenge object into buffer\n                let mut challenge_buffer = vec![0u8; challenge_size];\n                build_challenge_callback(\n                    context,\n                    handle,\n                    challenge_buffer.as_mut_ptr(),\n                    challenge_size,\n                );\n\n                // convert bson blob to bson object\n                match bson::document::Document::from_reader(Cursor::new(challenge_buffer)) {\n                    Ok(challenge) =\u003e challenge,\n                    Err(_) =\u003e bail!(\"failed to parse binary provided by identity_server_build_challenge_callback as BSON document\")\n                }\n            } else {\n                bail!(\"missing required identity_server_challenge_size() and identity_server_build_challenge() callbacks\");\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context.0.identity_server_handle_endpoint_request_received(\n                    handle,\n                    client_allowed,\n                    endpoint_supported,\n                    endpoint_challenge,\n                )?,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n        }\n        ContextEvent::IdentityServerChallengeResponseReceived {\n            handle,\n            challenge_response,\n        } =\u003e {\n            let challenge_response_valid = match callbacks\n                .identity_server_verify_challenge_response_callback\n            {\n                Some(callback) =\u003e {\n                    // get response as bytes\n                    let mut challenge_response_buffer: Vec\u003cu8\u003e = Default::default();\n                    challenge_response\n                            .to_writer(\u0026mut challenge_response_buffer).expect(\"challenge_response should be a valid bson::document::Document and therefore serializable to Vec\u003cu8\u003e\");\n\n                    callback(\n                        context,\n                        handle,\n                        challenge_response_buffer.as_ptr(),\n                        challenge_response_buffer.len(),\n                    )\n                }\n                None =\u003e {\n                    bail!(\"missing required identity_server_verify_challenge_response() callback()\")\n                }\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .identity_server_handle_challenge_response_received(\n                        handle,\n                        challenge_response_valid,\n                    )?,\n                None =\u003e bail!(\"context is invalid\"),\n            };\n        }\n        ContextEvent::IdentityServerHandshakeCompleted {\n            handle,\n            endpoint_private_key,\n            endpoint_name,\n            client_service_id,\n            client_auth_public_key,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_completed_callback {\n                let endpoint_private_key = {\n                    let mut ed25519_private_key_registry = get_ed25519_private_key_registry();\n                    ed25519_private_key_registry.insert(endpoint_private_key)\n                };\n\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                let client_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(client_service_id)\n                };\n\n                let client_auth_public_key = {\n                    let mut x25519_public_key_registry = get_x25519_public_key_registry();\n                    x25519_public_key_registry.insert(client_auth_public_key)\n                };\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_private_key as *const GoslingEd25519PrivateKey,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                    client_service_id as *const GoslingV3OnionServiceId,\n                    client_auth_public_key as *const GoslingX25519PublicKey,\n                );\n\n                // cleanup\n                get_ed25519_private_key_registry().remove(endpoint_private_key);\n                get_v3_onion_service_id_registry().remove(client_service_id);\n                get_x25519_public_key_registry().remove(client_auth_public_key);\n            } else {\n                bail!(\"missing required identity_server_handshake_completed_callback()\");\n            }\n        }\n        ContextEvent::IdentityServerHandshakeRejected {\n            handle,\n            client_allowed,\n            client_requested_endpoint_valid,\n            client_proof_signature_valid,\n            client_auth_signature_valid,\n            challenge_response_valid,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_rejected_callback {\n                callback(\n                    context,\n                    handle,\n                    client_allowed,\n                    client_requested_endpoint_valid,\n                    client_proof_signature_valid,\n                    client_auth_signature_valid,\n                    challenge_response_valid,\n                );\n            }\n        }\n        ContextEvent::IdentityServerHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingFFIError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Endpoint Client Events\n        //\n        ContextEvent::EndpointClientHandshakeCompleted {\n            endpoint_service_id,\n            handle,\n            channel_name,\n            stream,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_client_handshake_completed_callback {\n                let endpoint_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(endpoint_service_id)\n                };\n                let channel_name0 = CString::new(channel_name.as_str())\n                    .expect(\"channel_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n                let stream = stream.into_raw_fd();\n                #[cfg(target_os = \"windows\")]\n                let stream = stream.into_raw_socket();\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    channel_name0.as_ptr(),\n                    channel_name.len(),\n                    stream,\n                );\n\n                // cleanup\n                get_v3_onion_service_id_registry().remove(endpoint_service_id);\n            } else {\n                bail!(\"missing required endpoint_client_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::EndpointClientHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.endpoint_client_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingFFIError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Endpoint Server Events\n        //\n        ContextEvent::EndpointServerPublished {\n            endpoint_service_id,\n            endpoint_name,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_published_callback {\n                let endpoint_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(endpoint_service_id)\n                };\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                callback(\n                    context,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                );\n\n                // cleanup\n                get_v3_onion_service_id_registry().remove(endpoint_service_id);\n            }\n        }\n        ContextEvent::EndpointServerHandshakeStarted { handle } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_started_callback {\n                callback(context, handle);\n            }\n        }\n        ContextEvent::EndpointServerChannelRequestReceived {\n            handle,\n            client_service_id,\n            requested_channel,\n        } =\u003e {\n            let channel_supported: bool = match callbacks.endpoint_server_channel_supported_callback\n            {\n                Some(callback) =\u003e {\n                    let client_service_id = {\n                        let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                        v3_onion_service_id_registry.insert(client_service_id)\n                    };\n                    let requested_channel0 = CString::new(requested_channel.as_str()).expect(\"requested_channel should be a valid ASCII string and not have an intermediate null byte\",\n                    );\n                    let channel_supported = callback(\n                        context,\n                        handle,\n                        client_service_id as *const GoslingV3OnionServiceId,\n                        requested_channel0.as_ptr(),\n                        requested_channel.len(),\n                    );\n\n                    // cleanup\n                    get_v3_onion_service_id_registry().remove(client_service_id);\n                    channel_supported\n                }\n                None =\u003e bail!(\"missing required endpoint_server_channel_supported() callback\"),\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .endpoint_server_handle_channel_request_received(handle, channel_supported)?,\n                None =\u003e return Err(anyhow!(\"context is invalid\")),\n            };\n        }\n        ContextEvent::EndpointServerHandshakeCompleted {\n            handle,\n            endpoint_service_id,\n            client_service_id,\n            channel_name,\n            stream,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_completed_callback {\n                let (endpoint_service_id, client_service_id) = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    let endpoint_service_id =\n                        v3_onion_service_id_registry.insert(endpoint_service_id);\n                    let client_service_id = v3_onion_service_id_registry.insert(client_service_id);\n                    (endpoint_service_id, client_service_id)\n                };\n\n                let channel_name0 = CString::new(channel_name.as_str())\n                    .expect(\"channel_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n                let stream = stream.into_raw_fd();\n                #[cfg(target_os = \"windows\")]\n                let stream = stream.into_raw_socket();\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    client_service_id as *const GoslingV3OnionServiceId,\n                    channel_name0.as_ptr(),\n                    channel_name.len(),\n                    stream,\n                );\n\n                // cleanup\n                {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.remove(endpoint_service_id);\n                    v3_onion_service_id_registry.remove(client_service_id);\n                }\n            } else {\n                bail!(\"missing required endpoint_server_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::EndpointServerHandshakeRejected {\n            handle,\n            client_allowed,\n            client_requested_channel_valid,\n            client_proof_signature_valid,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_rejected_callback {\n                callback(\n                    context,\n                    handle,\n                    client_allowed,\n                    client_requested_channel_valid,\n                    client_proof_signature_valid,\n                );\n            }\n        }\n        ContextEvent::EndpointServerHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingFFIError);\n                get_error_registry().remove(key);\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Update the internal gosling context state and process event callbacks\n///\n/// @param context: the context object we are updating\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_poll_events(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingFFIError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        // we need to scope the context registry explicitly here\n        // in case our callbacks want to call any gosling functions\n        // to avoid deadlock (since a mutex is held while the context_tuple_registry\n        // is accesible)\n        let (mut context_events, callbacks) =\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e {\n                    // get our new events\n                    let mut new_events = context.0.update()?;\n                    // get a copy of our callbacks\n                    let callbacks = context.1.clone();\n\n                    // append new_events to any existing events if they exist,\n                    // otherwise just pass through new_events\n                    let context_events = match std::mem::take(\u0026mut context.2) {\n                        Some(mut context_events) =\u003e {\n                            context_events.append(\u0026mut new_events);\n                            context_events\n                        }\n                        None =\u003e {\n                            // no previous events so just pass through the new events\n                            new_events\n                        }\n                    };\n                    (context_events, callbacks)\n                }\n                None =\u003e bail!(\"context is invalid\"),\n            };\n\n        // consume the events and trigger any callbacks\n        while let Some(event) = context_events.pop_front() {\n            let result = handle_context_event(event, context, \u0026callbacks);\n            if result.is_err() {\n                // if we have remaining events to consume, save them off on\n                // the context\n                if !context_events.is_empty() {\n                    if let Some(context) = get_context_tuple_registry().get_mut(context as usize) {\n                        context.2 = Some(context_events);\n                    }\n                }\n                // return the error\n                return result;\n            }\n        }\n        Ok(())\n    });\n}\n\n/// The function pointer type for the tor bootstrap status received callback. This\n/// callback is called when context's tor daemon's bootstrap status has progressed.\n///\n/// @param context: the context associated with this event\n/// @param progress: an unsigned integer from 0 to 100 indicating the current completion\n///  perentage of the context's bootstrap process\n/// @param tag: the null-terminated short name of the current bootstrap stage\n/// @param tag_length: the number of chrs in tag not including any null-terminator\n/// @param summary: the null-terminated description of the current bootstra stage\n/// @param summmary_length: the number of chars in summary not including the null-terminator\npub type GoslingTorBootstrapStatusReceivedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        progress: u32,\n        tag: *const c_char,\n        tag_length: usize,\n        summary: *const c_char,\n        summary_length: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the tor boootstrap completed callback. This callback\n/// is called when the context's tor daemon's bootstrap process has completed.\n///\n/// @param context: the context associated with this event\npub type GoslingTorBootstrapCompletedCallback =\n    Option\u003cextern \"C\" fn(context: *mut GoslingContext) -\u003e ()\u003e;\n\n/// The function pointer type for the tor log received callback. This callback is called\n/// whenever the context's tor daemon prints new log lines.\n///\n/// @param context: the context associated with this event\n/// @param line: the null-terminated received log line\n/// @param line_length: the number of chars in line not including the null-terminator\npub type GoslingTorLogReceivedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, line: *const c_char, line_length: usize) -\u003e (),\n\u003e;\n\n/// The function pointer type for the client handshake challenge response size\n/// callback. This callback is called when a client needs to know how much memory\n/// to allocate for a challenge response.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: pointer to the client handshake handle this callback\n///  invocation is associated with; null if no client handshake init callback was\n///  provided\n/// @param challenge_buffer: the source buffer containing a BSON document received\n///  from the  identity server to serve as an endpoint request challenge\n/// @param challenge_buffer_size: the number of bytes in challenge_buffer\n/// @return the number of bytes required to store the challenge response object\npub type GoslingIdentityClientHandshakeChallengeResponseSizeCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n    ) -\u003e usize,\n\u003e;\n\n/// The function pointer type for the identity client handshake build challlenge\n/// response callback. This callback is called when a client is ready to build a\n/// challenge response object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param endpoint_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @param challenge_buffer: the source buffer containing a BSON document received\n///  from the  identity server to serve as an endpoint request challenge\n/// @param challenge_buffer_size: the number of bytes in challenge_buffer\n/// @param out_challenge_response_buffer: the destination buffer for the callback\n///  to write a BSON document representing the endpoint request challenge response\n///  object\n/// @param out_challenge_response_buffer_size: the number of bytes allocated in\n///  out_challenge_response_buffer\npub type GoslingIdentityClientHandshakeBuildChallengeResponseCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n        out_challenge_response_buffer: *mut u8,\n        out_challenge_response_buffer_size: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity client handshake completed callback. This\n/// callback is called whenever the client successfully completes a handshake with an\n/// identity server and is granted access to an endpoint server.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param identity_service_id: the onion service id of the identity server the client\n///  has successfully completed a hadshake with\n/// @param endpoint_service_id: the onion service id of the endpoint server the client\n///  now has access to\n/// @param endpoint_name: the null-terminated name of the provided endpoint server\n/// @param endpoint_name_length: the number of chars in endpoint_name string not including\n///  the null-terminator\n/// @param client_auth_private_key: the client's x25519 private required to connect to\n///  the provided endpoint server\npub type GoslingIdentityClientHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        identity_service_id: *const GoslingV3OnionServiceId,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_auth_private_key: *const GoslingX25519PrivateKey,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity client handshake handshake failed\n/// callback. This callback is called when a client's identity handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingIdentityClientHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingFFIError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity server published callback. This callback\n/// is called whenever the onion service of the identity server associated with the given\n/// context is published and should be reachable by clients.\n///\n/// @param context: the context associated with this event\npub type GoslingIdentityServerPublishedCallback =\n    Option\u003cextern \"C\" fn(context: *mut GoslingContext) -\u003e ()\u003e;\n\n/// The function pointer type of the identity server handshake started callback. This callback\n/// is called whenever the identity server is initially connected to.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\npub type GoslingIdentityServerHandshakeStartedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e (),\n\u003e;\n\n/// The function pointer type of the identity server handshake client allowed callback.\n/// The result of this callback partially determines if an incoming client handshake\n/// request is possible to complete. For instance an implementation of this function\n//  may reference an allow/block list to determime if identity handshakes can be\n/// completed.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_service_id: the v3 onion service id of the connected client\n/// @return true if the server wants to allow the requesting client to connect client may complete the handshake, false otherwise\npub type GoslingIdentityServerHandshakeClientAllowedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_service_id: *const GoslingV3OnionServiceId,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type of the identity server endpoint supported callback. This\n/// callback is called when the server needs to determine if the client's requested\n/// endpoint is supported. The result of this callback partially determines if an\n/// incoming client handshake request is possible to complete.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param endpoint_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @return true if the server can handle requests for the requested endpoint,\n///  false otherwise\npub type GoslingIdentityServerEndpointSupportedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the server handshake challenge size callback.\n/// This callback is called when a server needs to know how much memory to allocate\n/// for a challenge.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @return the number of bytes required to store the challenge object\npub type GoslingIdentityServerHandshakeChallengeSizeCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e usize,\n\u003e;\n\n/// The function pointer type for the server handshake build challenge callback.\n/// This callback is called when a server needs to build a challenge object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param out_challenge_buffer: the destination buffer for the callback\n///  to write a BSON document representing the endpoint request challenge object\n/// @param out_challenge_buffer_size: the number of bytes allocated in\n///  out_challenge_buffer\npub type GoslingIdentityServerHandshakeBuildChallengeCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        out_challenge_buffer: *mut u8,\n        out_challenge_buffer_size: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function poointer type for the server handshake verify challenge response\n/// callback. This callback is called when a server needs to verify a challenge\n/// response object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param challenge_response_buffer: a buffer containing the BSON document representing\n///  the endpoint request challenge response object\n/// @param challenge_response_buffer_size: the number of bytes in\n///  challenge_response_buffer\n/// @return the result of the challenge response verification\npub type GoslingIdentityServerHandshakeVerifyChallengeResponseCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_response_buffer: *const u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the identity server handshake completed callback. This\n/// callback is called whenever the identity server has successfully completed a\n/// handshake with and granted to a connecting identity client.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_private_key: the ed25519 private key of the endpoint server to host\n///  for the client\n/// @param endoint_name: the null-terminated name of the new endpoint server\n/// @param endpoint_name_length: the length of the endpoint_name string not including\n///  the null-terminator\n/// @param client_service_id: the onion service id of the client we have granted\n///  access to\n/// @param client_auth_public_key: the x25519 public key to use to encrypt the endpoint\n///  server's service descriptor as provided by the connecting client\npub type GoslingIdentityServerHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_private_key: *const GoslingEd25519PrivateKey,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        client_auth_public_key: *const GoslingX25519PublicKey,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type of the identity server handshake rejected callback. This\n/// callback is called whenever the identity server has rejected an identity client's\n/// handshake.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_allowed: true if requesting client is allowed, false otherwies\n/// @param client_requested_endpoint_valid: true if requesting client requested a\n///  valid endpoint, false otherwise\n/// @param client_proof_signature_valid: true if the requesting client properly\n///  signed the identity proof, false otherwise\n/// @param client_auth_signature_valid: true if the requesting client properly signed\n///  the authorization proof, false othewise\n/// @param challenge_response_valid: true if the requesting client's challenge\n///  response was accepted by the server, false otherwise\npub type GoslingIdentityServerHandshakeRejectedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_allowed: bool,\n        client_requested_endpoint_valid: bool,\n        client_proof_signature_valid: bool,\n        client_auth_signature_valid: bool,\n        challenge_response_valid: bool,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity server handshake handshake failed\n/// callback. This callback is called when a server's identity handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingIdentityServerHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingFFIError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint client handshake completed callback.\n/// This callback is called when the client successfully connects to an endpoint server.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_service_id: the onion service id of the endpoint server the client\n///  has connected to\n/// @param channel_name: the null-terminated name of the channel name requested by the\n///  the client\n/// @param channel_name_length: the number of chars in channel_name not including the\n///  null-terminator\n/// @param stream: os-specific tcp socket handle associated with the connection to the\n///  endpoint server\npub type GoslingEndpointClientHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: GoslingTcpSocket,\n    ),\n\u003e;\n\n/// The function pointer type for the endpoint client handshake handshake failed\n/// callback. This callback is called when a client's endpoint handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingEndpointClientHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingFFIError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint server published callback. This callbcak\n/// is called whenever the onion service of the indicated endpoint server associted with\n/// the given context is published and should be reachable by clients.\n///\n/// @param context: the context associated with this event\n/// @param endpoint_service_id: the onion service id of the published endpoint server\n/// @param endpoint_name: the null-terminated name of the endpoint server published\n/// @param endpoint_name_length: the number of chars in endpoint_name string not including the\n///  null-terminator\npub type GoslingEndpointServerPublishedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        enpdoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type of the endpoint server handshake started callback. This\n/// callback is called whenever the endpoint server is initially connected to.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\npub type GoslingEndpointServerHandshakeStartedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e (),\n\u003e;\n\n/// The function pointer type of the endpoint server channel supported callback. This\n/// callback is called when the server needs to determine if the client's requested\n/// channel is supported. The result of this callback partially determines if an\n/// incoming endpoint client handshake request is possible to complete.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_service_id: the onion service id of the connected endpoint client\n/// @param channel_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param channel_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @return true if the server can handle requests for the requested channel,\n///  false otherwise\npub type GoslingEndpointServerChannelSupportedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the endpoint server handshake completed callback.\n/// This callback is called when an endpoint server completes a handshake with an\n/// endpoint client.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_service_id: the onion service id of the endpoint server the\n///  endpoint client has connected to\n/// @param client_service_id: the onion service id of the connected endpoint client\n/// @param channel_name: the null-terminated name of the channel requested by the client\n/// @param channel_name_length: the number of chars in channel_name not including the\n///  null-terminator\n/// @param stream:os-specific tcp socket handle associated with the connection to the\n///  endpoint client\npub type GoslingEndpointServerHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: GoslingTcpSocket,\n    ),\n\u003e;\n\n/// The function pointer type of the endpoint server handshake rejected callback. This\n/// callback is called whenever the endpoint server has rejected an endpoint client's\n/// handshake.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_allowed: true if requesting client is allowed, false otherwies\n/// @param client_requested_channel_valid: true if requesting client requested a\n///  valid endpoint, false otherwise\n/// @param client_proof_signature_valid: true if the requesting client properly\n///  signed the endpoint proof, false otherwise\npub type GoslingEndpointServerHandshakeRejectedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_allowed: bool,\n        client_requested_channel_valid: bool,\n        client_proof_signature_valid: bool,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint server handshake handshake failed\n/// callback. This callback is called when a server's endpoint handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingEndpointServerHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingFFIError,\n    ) -\u003e (),\n\u003e;\n\n#[derive(Default, Clone)]\npub struct EventCallbacks {\n    // tor events\n    tor_bootstrap_status_received_callback: GoslingTorBootstrapStatusReceivedCallback,\n    tor_bootstrap_completed_callback: GoslingTorBootstrapCompletedCallback,\n    tor_log_received_callback: GoslingTorLogReceivedCallback,\n\n    // identity client events\n    identity_client_challenge_response_size_callback:\n        GoslingIdentityClientHandshakeChallengeResponseSizeCallback,\n    identity_client_build_challenge_response_callback:\n        GoslingIdentityClientHandshakeBuildChallengeResponseCallback,\n    identity_client_handshake_completed_callback: GoslingIdentityClientHandshakeCompletedCallback,\n    identity_client_handshake_failed_callback: GoslingIdentityClientHandshakeFailedCallback,\n\n    // identity server events\n    identity_server_published_callback: GoslingIdentityServerPublishedCallback,\n    identity_server_handshake_started_callback: GoslingIdentityServerHandshakeStartedCallback,\n    identity_server_client_allowed_callback: GoslingIdentityServerHandshakeClientAllowedCallback,\n    identity_server_endpoint_supported_callback: GoslingIdentityServerEndpointSupportedCallback,\n    identity_server_challenge_size_callback: GoslingIdentityServerHandshakeChallengeSizeCallback,\n    identity_server_build_challenge_callback: GoslingIdentityServerHandshakeBuildChallengeCallback,\n    identity_server_verify_challenge_response_callback:\n        GoslingIdentityServerHandshakeVerifyChallengeResponseCallback,\n    identity_server_handshake_completed_callback: GoslingIdentityServerHandshakeCompletedCallback,\n    identity_server_handshake_rejected_callback: GoslingIdentityServerHandshakeRejectedCallback,\n    identity_server_handshake_failed_callback: GoslingIdentityServerHandshakeFailedCallback,\n\n    // endpoint client events\n    endpoint_client_handshake_completed_callback: GoslingEndpointClientHandshakeCompletedCallback,\n    endpoint_client_handshake_failed_callback: GoslingEndpointClientHandshakeFailedCallback,\n\n    // endpoint server events\n    endpoint_server_published_callback: GoslingEndpointServerPublishedCallback,\n    endpoint_server_handshake_started_callback: GoslingEndpointServerHandshakeStartedCallback,\n    endpoint_server_channel_supported_callback: GoslingEndpointServerChannelSupportedCallback,\n    endpoint_server_handshake_completed_callback: GoslingEndpointServerHandshakeCompletedCallback,\n    endpoint_server_handshake_rejected_callback: GoslingEndpointServerHandshakeRejectedCallback,\n    endpoint_server_handshake_failed_callback: GoslingEndpointServerHandshakeFailedCallback,\n}\n\nmacro_rules! impl_callback_setter {\n    ($callback_type:tt, $context:expr, $callback:expr, $error:expr) =\u003e {\n        paste::paste! {\n            translate_failures((), $error, || -\u003e anyhow::Result\u003c()\u003e {\n                let mut context_tuple_registry = get_context_tuple_registry();\n                let context = match context_tuple_registry.get_mut($context as usize) {\n                    Some(context) =\u003e context,\n                    None =\u003e {\n                        bail!(\"context is invalid\");\n                    }\n                };\n                context.1.[\u003c$callback_type\u003e] = $callback;\n                Ok(())\n            })\n        }\n    };\n}\n\n/// Set the tor bootstrap status received callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_bootstrap_status_received_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorBootstrapStatusReceivedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        tor_bootstrap_status_received_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the tor bootstrap completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_bootstrap_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorBootstrapCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(tor_bootstrap_completed_callback, context, callback, error);\n}\n\n/// Sets the tor log received callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_log_received_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorLogReceivedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(tor_log_received_callback, context, callback, error);\n}\n\n/// Sets the identity challenge challenge response size callback for the specified\n/// context\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_challenge_response_size_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeChallengeResponseSizeCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_client_challenge_response_size_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity client build challenge response callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_build_challenge_response_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeBuildChallengeResponseCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_client_build_challenge_response_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity client handshake completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_client_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity client handshake failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeFailedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_client_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server published callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_published_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerPublishedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(identity_server_published_callback, context, callback, error);\n}\n\n/// Set the identity server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_started_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeStartedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_started_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server client allowed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_client_allowed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeClientAllowedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_client_allowed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server endpoint supported callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_endpoint_supported_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerEndpointSupportedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_endpoint_supported_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server challenge size callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_challenge_size_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeChallengeSizeCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_challenge_size_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server build challenge callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_build_challenge_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeBuildChallengeCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_build_challenge_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server verify challenge response callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_verify_challenge_response_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeVerifyChallengeResponseCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_verify_challenge_response_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request rejeced callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_rejected_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeRejectedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_rejected_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeFailedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint client handshake completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_client_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointClientHandshakeCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_client_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint client handshake failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_client_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointClientHandshakeFailedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_client_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server published callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_published_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerPublishedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(endpoint_server_published_callback, context, callback, error);\n}\n\n/// Set the endpoint server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_started_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeStartedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_started_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_channel_supported_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerChannelSupportedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_channel_supported_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeCompletedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_rejected_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeRejectedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_rejected_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeFailedCallback,\n    error: *mut *mut GoslingFFIError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n","traces":[{"line":61,"address":[1713428,1715328,1713406,1714624,1716948,1716032,1716926,1712702,1716736,1716244,1714110,1715518,1713216,1714132,1715540,1714814,1714836,1713920,1716222,1712512,1712724],"length":1,"stats":{"Line":6},"fn_name":"get_error_registry"},{"line":62,"address":[1714631,1715335,1713927,1716743,1713223,1712519,1716039],"length":1,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[1714656,1712544,1715360,1713952,1716064,1713248,1716768],"length":1,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[1712643,1715459,1714755,1713347,1716163,1716867,1714051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1717340,1713187,1716960,1713820,1713116,1715299,1714848,1716636,1716003,1715228,1715552,1714144,1716256,1716707,1714595,1717411,1714524,1713440,1712736,1715932,1713891],"length":1,"stats":{"Line":6},"fn_name":"clear_error_registry"},{"line":69,"address":[1714151,1716263,1712743,1713447,1716967,1715559,1714855],"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[1712776,1716626,1713106,1713520,1713810,1714928,1715218,1714514,1712816,1717040,1714224,1714184,1716296,1717330,1713480,1717000,1715592,1715632,1716336,1714888,1715922],"length":1,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[1713125,1715941,1717349,1713829,1715237,1716645,1714533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1683280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1683300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1683751,1683360],"length":1,"stats":{"Line":0},"fn_name":"gosling_error_get_message"},{"line":106,"address":[1683377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1683391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1683404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1683426,1683555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1683596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1683679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[1683498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1683776],"length":1,"stats":{"Line":0},"fn_name":"gosling_error_clone"},{"line":132,"address":[1683808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1739777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1739821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1739802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1739914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1739871,1740015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1740219,1740104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1740077,1740145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1740299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1740537,1740467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1740510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[1684033,1683856],"length":1,"stats":{"Line":0},"fn_name":"gosling_error_free"},{"line":174,"address":[1683870,1683941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1684255,1684064],"length":1,"stats":{"Line":0},"fn_name":"gosling_ed25519_private_key_free"},{"line":219,"address":[1684173,1684084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1684288,1684442],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_private_key_free"},{"line":228,"address":[1684302,1684373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1684606,1684464],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_public_key_free"},{"line":236,"address":[1684549,1684478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[1684789,1684640],"length":1,"stats":{"Line":0},"fn_name":"gosling_v3_onion_service_id_free"},{"line":244,"address":[1684730,1684657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[1684816,1685003],"length":1,"stats":{"Line":0},"fn_name":"gosling_tor_provider_free"},{"line":252,"address":[1684925,1684836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[1685227,1685040],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_free"},{"line":260,"address":[1685149,1685060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1812934,1793803,1751312,1753958,1798256,1800483,1778971,1753984,1767376,1810288,1788790,1763366,1785691,1795550,1787035,1797819,1758928,1803600,1770006,1808942,1804918,1741515,1749547,1744624,1792896,1778080,1791552,1747296,1814278,1798230,1812523,1804507,1742843,1770032,1807195,1811632,1766022,1768686,1811606,1782070,1780726,1810262,1795139,1745523,1776736,1783414,1750875,1773619,1757990,1764694,1771376,1743254,1786102,1807606,1766048,1748614,1768704,1803574,1744187,1760267,1795568,1749958,1769595,1784347,1741952,1802256,1801819,1770939,1748203,1780315,1751286,1799584,1740608,1752203,1799155,1789778,1794240,1792459,1796475,1784758,1779382,1758016,1745934,1762955,1762048,1757579,1748640,1806262,1808531,1791115,1744598,1780752,1760704,1774048,1788379,1774955,1743280,1794214,1778054,1782096,1767350,1805851,1752614,1775366,1787446,1799566,1755328,1765611,1772288,1764720,1772720,1783440,1756235,1759360,1756646,1768275,1790199,1746859,1811195,1779408,1766939,1756672,1783003,1791526,1800912,1761611,1741926,1776710,1745952,1755302,1781659,1802230,1787472,1812960,1763392,1774030,1803163,1784784,1790224,1807632,1788816,1754891,1759345,1775392,1776299,1764283,1747270,1809851,1771350,1806288,1813867,1762022,1753547,1808960,1792870,1796886,1796912,1749984,1772705,1800894,1804944,1786128,1760678,1752640,1777643],"length":1,"stats":{"Line":34},"fn_name":"translate_failures\u003c(), cgosling::ffi::gosling_v3_onion_service_id_from_ed25519_private_key::{closure_env#0}\u003e"},{"line":274,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[1685264],"length":1,"stats":{"Line":1},"fn_name":"gosling_library_init"},{"line":318,"address":[1685291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[1814316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[1814361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[1814333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[1814473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[1814411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[1814524,1814552,1814444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[1814537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1685328],"length":1,"stats":{"Line":1},"fn_name":"gosling_library_free"},{"line":340,"address":[1685337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[1685368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[1685373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[1685378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[1685383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[1685388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[1685393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[1685398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[1685424],"length":1,"stats":{"Line":1},"fn_name":"gosling_ed25519_private_key_generate"},{"line":364,"address":[1685451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[1814604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[1814667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[1814629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[1814767,1814651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[1814931,1814995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[1814972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[1685488],"length":1,"stats":{"Line":1},"fn_name":"gosling_ed25519_private_key_clone"},{"line":389,"address":[1685520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":390,"address":[1815089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[1815133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[1815114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[1815226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[1815183,1815327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[1815416,1815523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[1815459,1815389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[1815587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[1815779,1815846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[1815820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[1685568],"length":1,"stats":{"Line":0},"fn_name":"gosling_ed25519_private_key_from_keyblob"},{"line":424,"address":[1685605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[1815932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[1815978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[1815960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[1816049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1816033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[1816324,1816272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[1816110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[1816440,1816523,1816149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[1816617,1816472,1816714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[1816695,1816866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[1817103,1817038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1817079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[1685664],"length":1,"stats":{"Line":0},"fn_name":"gosling_ed25519_private_key_to_keyblob"},{"line":464,"address":[1685701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[1817196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[1817234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[1817216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[1817301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[1817289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[1817522,1817470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[1817357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[1817388,1817688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[1817775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[1817791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[1817968,1817879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[1818007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[1818177,1818226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[1817748,1817818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[1818251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[1685760],"length":1,"stats":{"Line":1},"fn_name":"gosling_x25519_private_key_clone"},{"line":518,"address":[1685792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[1818321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[1818365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[1818346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[1818458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[1818559,1818415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[1818751,1818648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[1818621,1818687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[1818815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[1819074,1819007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[1819048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[1685840],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_private_key_from_base64"},{"line":552,"address":[1685877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[1819148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[1819194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[1819176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[1819265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[1819249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[1819482,1819534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[1819320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[1819359,1819650,1819740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[1819834,1819925,1819682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[1819906,1820077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[1820311,1820249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[1820288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[1685936],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_private_key_to_base64"},{"line":591,"address":[1685973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[1820412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[1820450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[1820432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[1820517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[1820505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[1820686,1820738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[1820573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[1820904,1820604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[1820991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[1821007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[1821184,1821095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[1821223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[1821410,1821361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[1821034,1820964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[1821435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[1686032],"length":1,"stats":{"Line":1},"fn_name":"gosling_x25519_public_key_clone"},{"line":645,"address":[1686064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":646,"address":[1821505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[1821541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[1821522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[1821634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[1821591,1821729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":654,"address":[1821818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[1821857,1821791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[1821926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":658,"address":[1822119,1822060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[1822101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":673,"address":[1686112],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_public_key_from_base32"},{"line":679,"address":[1686149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[1822188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[1822226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[1822208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[1822297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[1822281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[1822514,1822566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[1822352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[1822682,1822772,1822391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[1822866,1822714,1822944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[1823046,1822898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[1823188,1823134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[1823173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[1686208],"length":1,"stats":{"Line":0},"fn_name":"gosling_x25519_public_key_to_base32"},{"line":718,"address":[1686245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[1823260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[1823298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[1823280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[1823365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[1823353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[1823586,1823534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[1823421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[1823452,1823752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[1823839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[1823855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[1824032,1823943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[1824071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[1824209,1824258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[1823882,1823812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[1824283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[1686304],"length":1,"stats":{"Line":1},"fn_name":"gosling_v3_onion_service_id_clone"},{"line":772,"address":[1686336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":773,"address":[1824353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":774,"address":[1824389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[1824370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[1824482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[1824583,1824439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":781,"address":[1824672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[1824711,1824645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[1824780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[1824914,1824976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[1824957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":801,"address":[1686384],"length":1,"stats":{"Line":0},"fn_name":"gosling_v3_onion_service_id_from_string"},{"line":807,"address":[1686421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[1825036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[1825074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[1825056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[1825145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[1825129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[1825362,1825414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[1825200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[1825239,1825620,1825530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[1825714,1825824,1825562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[1825926,1825778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[1826014,1826068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[1826053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[1686480],"length":1,"stats":{"Line":1},"fn_name":"gosling_v3_onion_service_id_from_ed25519_private_key"},{"line":844,"address":[1686512],"length":1,"stats":{"Line":2},"fn_name":null},{"line":845,"address":[1826145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":846,"address":[1826181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[1826162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[1826274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[1826231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[1826375,1826262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":856,"address":[1826464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[1826507,1826437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[1826480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[1826576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":863,"address":[1826710,1826772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[1826753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":879,"address":[1686560],"length":1,"stats":{"Line":0},"fn_name":"gosling_v3_onion_service_id_to_string"},{"line":885,"address":[1686597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[1826828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[1826866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[1826848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[1826933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[1826921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[1827154,1827102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[1826989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[1827320,1827020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[1827407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[1827423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[1827525,1827600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[1827519,1827511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[1827515,1827522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[1827639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[1827828,1827779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[1827380,1827450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[1827853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[1686656],"length":1,"stats":{"Line":0},"fn_name":"gosling_string_is_valid_v3_onion_service_id"},{"line":943,"address":[1686688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[1827931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[1827965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":948,"address":[1827948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":949,"address":[1828122,1828182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[1828025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[1828280,1828373,1828066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[1686736],"length":1,"stats":{"Line":1},"fn_name":"gosling_tor_provider_new_legacy_client"},{"line":984,"address":[1686783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":985,"address":[1828463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[1828520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":988,"address":[1828502,1828613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":989,"address":[1828623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[1828687,1828587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":992,"address":[1828723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[1828705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[1828813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[1828801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":998,"address":[1828869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[1829601,1828936,1829792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1002,"address":[1829797,1829696,1829117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1005,"address":[1828960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[1828999,1829277,1829408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[1829309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1008,"address":[1829505,1829603,1829333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[1829666,1829899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1013,"address":[1829652,1829660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1014,"address":[1829663,1829656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1016,"address":[1830027,1831096,1829915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1017,"address":[1830004,1830108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1019,"address":[1830148,1830515,1831053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1020,"address":[1830370,1830659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1022,"address":[1830675,1830738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1023,"address":[1830888,1830978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1025,"address":[1830927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[1686848],"length":1,"stats":{"Line":0},"fn_name":"gosling_tor_provider_new_mock_client"},{"line":1039,"address":[1686875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[1831132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1041,"address":[1831353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[1831161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[1831321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[1831453,1831337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1048,"address":[1831659,1831595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1050,"address":[1831636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1065,"address":[1686912],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_init"},{"line":1074,"address":[1686961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1075,"address":[1831775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1076,"address":[1831840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1078,"address":[1831822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1079,"address":[1831919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[1831907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[1831975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[1832039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1085,"address":[1832068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1087,"address":[1832132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1088,"address":[1832194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[1832148,1832309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1093,"address":[1832427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1094,"address":[1832400,1832506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1098,"address":[1832612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1100,"address":[1832674,1832745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1101,"address":[1832850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[1832812,1832987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1106,"address":[1833231,1833354,1833614,1834189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1107,"address":[1832874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[1832930,1832922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1109,"address":[1832941,1832926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1110,"address":[1832957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1112,"address":[1833120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1113,"address":[1833180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1116,"address":[1833694,1833467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1117,"address":[1834119,1834038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1119,"address":[1834079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1129,"address":[1687040],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_bootstrap_tor"},{"line":1133,"address":[1687067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1134,"address":[1834316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1135,"address":[1834367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[1834333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1139,"address":[1834355,1834459],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1140,"address":[1834542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1141,"address":[1834515,1834582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[1834651,1834705,1834555,1834311,1834897],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1153,"address":[1687104],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_start_identity_server"},{"line":1157,"address":[1687131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1158,"address":[1834956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1159,"address":[1835007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[1834973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1163,"address":[1835099,1834995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1164,"address":[1835182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1165,"address":[1835222,1835155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[1835537,1835345,1834951,1835291,1835195],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1177,"address":[1687168],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_stop_identity_server"},{"line":1181,"address":[1687195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[1835596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1183,"address":[1835647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1186,"address":[1835613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1187,"address":[1835635,1835739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[1835822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[1835795,1835862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1191,"address":[1836177,1835591,1835985,1835835,1835931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1207,"address":[1687232],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_start_endpoint_server"},{"line":1216,"address":[1687274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1217,"address":[1836239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1218,"address":[1836304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":[1836286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1221,"address":[1836389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1223,"address":[1836371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1224,"address":[1836468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1226,"address":[1836456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1227,"address":[1836524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":[1836588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1230,"address":[1836648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1232,"address":[1836630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1233,"address":[1836750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1236,"address":[1836704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1237,"address":[1836735,1836865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1238,"address":[1836966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1239,"address":[1836931,1837039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1243,"address":[1836990,1837112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1244,"address":[1839293,1837128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1245,"address":[1837393,1837313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1246,"address":[1837420,1837477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[1837553,1837447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1251,"address":[1837649,1837578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1252,"address":[1837743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1253,"address":[1837788,1837716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1256,"address":[1837764,1837848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1257,"address":[1837873,1837938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1258,"address":[1838026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1259,"address":[1837999,1838071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1262,"address":[1838047,1838131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1264,"address":[1838221,1838156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1265,"address":[1838314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1266,"address":[1838362,1838282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1269,"address":[1839106,1838571,1838670,1838861],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1270,"address":[1838335,1838431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1271,"address":[1838439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1272,"address":[1838495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1273,"address":[1838556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1285,"address":[1687360],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_stop_endpoint_server"},{"line":1290,"address":[1687392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1291,"address":[1839329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1292,"address":[1839365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1294,"address":[1839346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[1839458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1298,"address":[1839415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1299,"address":[1839446,1839559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1300,"address":[1839648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1301,"address":[1839693,1839621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1304,"address":[1839750,1839669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1306,"address":[1839775,1839832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1307,"address":[1839921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1308,"address":[1839894,1839964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1311,"address":[1839937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1312,"address":[1840133,1840388,1839319,1840030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[1687440],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_begin_identity_handshake"},{"line":1336,"address":[1687482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1337,"address":[1840479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1338,"address":[1840528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1340,"address":[1840510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1341,"address":[1840627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1343,"address":[1840609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1344,"address":[1840723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1346,"address":[1840708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1347,"address":[1840793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1350,"address":[1840863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1351,"address":[1840894,1840975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1352,"address":[1841062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1353,"address":[1841107,1841035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1356,"address":[1841178,1841083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1358,"address":[1841203,1841268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1359,"address":[1841364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1360,"address":[1841329,1841428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1364,"address":[1841385,1841500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1366,"address":[1842444,1841516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1367,"address":[1841701,1841769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1368,"address":[1841790,1841845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1371,"address":[1842245,1841964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1373,"address":[1842117,1841924,1841830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1385,"address":[1687552],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_abort_identity_client_handshake"},{"line":1390,"address":[1687584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1391,"address":[1842481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1392,"address":[1842535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1395,"address":[1842498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1396,"address":[1842523,1842627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1397,"address":[1842716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1398,"address":[1842767,1842689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1401,"address":[1842836,1842740,1843018,1843084,1842471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1403,"address":[1842732,1842890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[1687632],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_begin_endpoint_handshake"},{"line":1428,"address":[1687679],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1429,"address":[1843167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1430,"address":[1843216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1432,"address":[1843198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1433,"address":[1843315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1435,"address":[1843297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1436,"address":[1843414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1438,"address":[1843396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1439,"address":[1843510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1441,"address":[1843495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1442,"address":[1843580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1445,"address":[1843650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1446,"address":[1843681,1843768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1447,"address":[1843861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1448,"address":[1843834,1843915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[1843885,1843998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1453,"address":[1844094,1844023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1454,"address":[1844182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1455,"address":[1844227,1844155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1458,"address":[1844203,1844298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1460,"address":[1844388,1844323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1461,"address":[1844484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1462,"address":[1844548,1844449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1466,"address":[1844620,1844505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1468,"address":[1844636,1845670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1469,"address":[1844821,1844889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1470,"address":[1844910,1844965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1473,"address":[1845398,1845109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1474,"address":[1844950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1475,"address":[1845054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1476,"address":[1845069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1489,"address":[1687760],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_abort_endpoint_client_handshake"},{"line":1494,"address":[1687792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1495,"address":[1845697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1496,"address":[1845751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1499,"address":[1845714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1500,"address":[1845739,1845843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1501,"address":[1845932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1502,"address":[1845983,1845905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1505,"address":[1846052,1845956,1845687,1846234,1846300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1507,"address":[1846106,1845948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1511,"address":[1691368,1691449,1687840],"length":1,"stats":{"Line":1},"fn_name":"handle_context_event"},{"line":1516,"address":[1687917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1520,"address":[1688080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1525,"address":[1690621,1688152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1526,"address":[1690648,1690753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1529,"address":[1690866,1690949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1535,"address":[1691145,1691062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1536,"address":[1691168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1537,"address":[1691191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1538,"address":[1691253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1543,"address":[1691478,1688193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1544,"address":[1691490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1547,"address":[1688243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1548,"address":[1688279,1691502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1549,"address":[1691530,1691632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1551,"address":[1691745,1691828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1557,"address":[1688321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1562,"address":[1688395,1691924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1563,"address":[1691983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1564,"address":[1692007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1566,"address":[1688371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1567,"address":[1688375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1569,"address":[1692031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1570,"address":[1692170,1692094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1576,"address":[1692212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1577,"address":[1692227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1581,"address":[1692322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1582,"address":[1694346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1586,"address":[1692333,1692446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1590,"address":[1692462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1591,"address":[1692518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1592,"address":[1692553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1593,"address":[1692568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1597,"address":[1692655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1599,"address":[1692784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1600,"address":[1693011,1694041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1603,"address":[1694513,1691953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1606,"address":[1693235,1693142,1693328],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1607,"address":[1693654,1693546,1693833,1693898,1693426],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1609,"address":[1693705,1693442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1610,"address":[1693388,1693581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1613,"address":[1688491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1620,"address":[1688633,1694581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1621,"address":[1694942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1622,"address":[1694709,1694601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1623,"address":[1694734,1694802],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1625,"address":[1694841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1627,"address":[1694911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1630,"address":[1694998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1633,"address":[1695142,1695223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1641,"address":[1695442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1642,"address":[1695504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1648,"address":[1695593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1649,"address":[1695734,1695655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1650,"address":[1695749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1652,"address":[1695810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1654,"address":[1694623,1696042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1657,"address":[1688675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1658,"address":[1688728,1696198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1659,"address":[1696218,1696490,1696318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1660,"address":[1696835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1661,"address":[1696839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[1697076,1688770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1669,"address":[1697088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1672,"address":[1688820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1673,"address":[1697119,1688840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1674,"address":[1697131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1677,"address":[1688882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1682,"address":[1688976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1683,"address":[1697173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1684,"address":[1697193,1697340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1692,"address":[1697138,1697267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1695,"address":[1697550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1696,"address":[1697610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1697,"address":[1697638,1697729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1703,"address":[1697925,1697842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1704,"address":[1697948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1707,"address":[1697575,1697669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1709,"address":[1698065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1710,"address":[1698185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1711,"address":[1698201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1713,"address":[1698057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1714,"address":[1698061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1717,"address":[1698225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1719,"address":[1698253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1720,"address":[1699974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1724,"address":[1698264,1698377],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1728,"address":[1698393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1729,"address":[1698481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1733,"address":[1698493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1734,"address":[1698618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1735,"address":[1698723,1699688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1738,"address":[1698139,1700124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1741,"address":[1698846,1698939,1698753],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1742,"address":[1699293,1699472,1699537,1699051,1699171],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1746,"address":[1699067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1748,"address":[1699220,1698999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1751,"address":[1689018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1755,"address":[1689068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1758,"address":[1700203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1760,"address":[1700223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1761,"address":[1700431,1700352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1767,"address":[1700473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1768,"address":[1700488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1772,"address":[1700294,1700168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1776,"address":[1700734,1700601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1777,"address":[1701194,1700958,1701137,1700836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1783,"address":[1700794,1700885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1786,"address":[1689244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1793,"address":[1689304,1701215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1795,"address":[1701346,1701235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1796,"address":[1701371,1701423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1799,"address":[1701539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1803,"address":[1701764,1701683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1804,"address":[1701857,1701789],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1808,"address":[1701903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1809,"address":[1701965,1702036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1816,"address":[1702106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1817,"address":[1702168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1823,"address":[1702257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1824,"address":[1702439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1825,"address":[1702602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1827,"address":[1701257,1702865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1830,"address":[1689414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1838,"address":[1703034,1689474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1850,"address":[1689516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1851,"address":[1703103,1689569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1852,"address":[1703226,1703126,1703398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1853,"address":[1703743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[1703747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1860,"address":[1689672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1866,"address":[1689726,1703976],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1868,"address":[1703999,1704107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1869,"address":[1704200,1704132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1871,"address":[1704254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1875,"address":[1704486,1704398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1883,"address":[1704509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1884,"address":[1704571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1889,"address":[1704646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1891,"address":[1704021,1704863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1894,"address":[1689771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1895,"address":[1689824,1705019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1896,"address":[1705314,1705042,1705142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1897,"address":[1705659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1898,"address":[1705663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1904,"address":[1689869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1908,"address":[1705892,1689943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1910,"address":[1705915,1706015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1911,"address":[1706040,1706108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1913,"address":[1706162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1919,"address":[1706330,1706413],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1920,"address":[1706436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1924,"address":[1706495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1927,"address":[1689996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1928,"address":[1706704,1690016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1929,"address":[1706719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1932,"address":[1690081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1937,"address":[1690155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1939,"address":[1706761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1941,"address":[1706931,1706784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1942,"address":[1706956,1707027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1944,"address":[1707081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1950,"address":[1707332,1707249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1951,"address":[1707355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1955,"address":[1707445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1958,"address":[1706726,1706858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1961,"address":[1707760,1707627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1962,"address":[1708007,1708243,1707862,1708186,1687901],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1964,"address":[1708058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1965,"address":[1707820,1707911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1968,"address":[1690220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1975,"address":[1690345,1708264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1976,"address":[1708628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1977,"address":[1708395,1708287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1978,"address":[1708488,1708420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1980,"address":[1708527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1981,"address":[1708597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1984,"address":[1708684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1988,"address":[1708924,1708828],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1997,"address":[1708955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1998,"address":[1709017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2004,"address":[1709106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2005,"address":[1709247,1709168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2006,"address":[1709262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2009,"address":[1708309,1709377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2012,"address":[1690458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2018,"address":[1690478,1709571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2028,"address":[1690523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2029,"address":[1690576,1709621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2030,"address":[1709641,1709735,1709892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2031,"address":[1710198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2032,"address":[1710202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2036,"address":[1691432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2045,"address":[1710400],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_poll_events"},{"line":2049,"address":[1710427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2054,"address":[1847492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2055,"address":[1846468,1846364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2056,"address":[1846557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2058,"address":[1846578,1848538,1846669,1846804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2060,"address":[1846779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2064,"address":[1847008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2065,"address":[1847139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2066,"address":[1847187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2067,"address":[1847415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2071,"address":[1847065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2074,"address":[1847197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2076,"address":[1846530,1846605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2080,"address":[1847653,1847771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2081,"address":[1847735,1847786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2082,"address":[1847802,1847857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2085,"address":[1847889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2086,"address":[1847910,1848393,1847967,1848049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2087,"address":[1848132,1848241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2091,"address":[1847926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2094,"address":[1848446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2595,"address":[1849443,1849747,1854640,1855248,1853120,1854307,1850688,1850384,1855827,1851600,1854611,1855219,1853395,1853424,1849472,1850355,1854944,1852816,1850080,1853091,1849776,1855856,1848835,1853728,1854032,1851875,1852483,1850051,1850963,1852179,1852512,1852208,1848864,1855523,1851267,1850992,1852787,1853699,1854003,1855552,1856131,1854915,1851904,1849139,1851571,1849168,1848560,1850659,1854336,1851296],"length":1,"stats":{"Line":19},"fn_name":"{closure#0}"},{"line":2596,"address":[1851921,1849185,1855265,1854961,1852529,1854049,1855569,1852225,1854657,1851009,1848577,1850097,1851313,1851617,1848881,1852833,1850401,1849489,1853441,1849793,1853745,1854353,1850705,1853137,1855873],"length":1,"stats":{"Line":19},"fn_name":null},{"line":2597,"address":[1851639,1848599,1850786,1854738,1848658,1854130,1851943,1850482,1850119,1849815,1852306,1851031,1852610,1855287,1852551,1848962,1854375,1855346,1853522,1848903,1849874,1849511,1854679,1850423,1850727,1851090,1851698,1855954,1855591,1854983,1851394,1853463,1855042,1852914,1854434,1850178,1853159,1853218,1849207,1853767,1849266,1854071,1855650,1853826,1852855,1852002,1852247,1849570,1855895,1851335],"length":1,"stats":{"Line":38},"fn_name":null},{"line":2598,"address":[1849642,1852074,1850554,1855722,1851770,1854810,1855418,1849338,1852986,1854202,1853290,1849946,1853898,1854506,1852378,1848730,1849034,1853594,1855114,1850250,1850858,1851162,1852682,1856026,1851466],"length":1,"stats":{"Line":19},"fn_name":null},{"line":2600,"address":[1849314,1852736,1850608,1854178,1850000,1851746,1851824,1851138,1850304,1854560,1855698,1849696,1852354,1855394,1852432,1852658,1849392,1851216,1856080,1849010,1848706,1852128,1853648,1856002,1855472,1849618,1855090,1854256,1850226,1850530,1850834,1853952,1855776,1852050,1854864,1854482,1853266,1850912,1848784,1851442,1851520,1853570,1849922,1854786,1853344,1849088,1853874,1855168,1853040,1852962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2603,"address":[1849055,1850879,1854831,1853615,1855743,1855135,1853919,1854223,1855439,1856047,1853311,1849359,1850575,1848751,1852703,1852095,1849663,1852399,1850271,1853007,1851183,1851791,1851487,1849967,1854527],"length":1,"stats":{"Line":19},"fn_name":null},{"line":2604,"address":[1851190,1853318,1853014,1853926,1852102,1849974,1854534,1850886,1852710,1849366,1854838,1856054,1849062,1851494,1855750,1855446,1853622,1850582,1854230,1852406,1849670,1851798,1848758,1850278,1855142],"length":1,"stats":{"Line":19},"fn_name":null},{"line":2617,"address":[1710464],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_tor_bootstrap_status_received_callback"},{"line":2622,"address":[1710496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2624,"address":[1848650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2625,"address":[1848743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2637,"address":[1710544],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_tor_bootstrap_completed_callback"},{"line":2642,"address":[1710576],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2652,"address":[1710624],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_tor_log_received_callback"},{"line":2657,"address":[1710656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2668,"address":[1710704],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_client_challenge_response_size_callback"},{"line":2673,"address":[1710736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2675,"address":[1849562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2676,"address":[1849655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2688,"address":[1710784],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_client_build_challenge_response_callback"},{"line":2693,"address":[1710816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2695,"address":[1849866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2696,"address":[1849959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2708,"address":[1710864],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_client_handshake_completed_callback"},{"line":2713,"address":[1710896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2715,"address":[1850170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2716,"address":[1850263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2728,"address":[1710944],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_client_handshake_failed_callback"},{"line":2733,"address":[1710976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2735,"address":[1850474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2736,"address":[1850567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2748,"address":[1711024],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_server_published_callback"},{"line":2753,"address":[1711056],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2763,"address":[1711104],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_handshake_started_callback"},{"line":2768,"address":[1711136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2770,"address":[1851082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2771,"address":[1851175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2783,"address":[1711184],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_server_client_allowed_callback"},{"line":2788,"address":[1711216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2790,"address":[1851386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2791,"address":[1851479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2803,"address":[1711264],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_server_endpoint_supported_callback"},{"line":2808,"address":[1711296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2810,"address":[1851690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2811,"address":[1851783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2823,"address":[1711344],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_server_challenge_size_callback"},{"line":2828,"address":[1711376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2830,"address":[1851994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2831,"address":[1852087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2843,"address":[1711424],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_server_build_challenge_callback"},{"line":2848,"address":[1711456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2850,"address":[1852298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2851,"address":[1852391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2863,"address":[1711504],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_server_verify_challenge_response_callback"},{"line":2868,"address":[1711536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2870,"address":[1852602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2871,"address":[1852695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2883,"address":[1711584],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_server_handshake_completed_callback"},{"line":2888,"address":[1711616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2890,"address":[1852906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2891,"address":[1852999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2903,"address":[1711664],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_identity_server_handshake_rejected_callback"},{"line":2908,"address":[1711696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2910,"address":[1853210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2911,"address":[1853303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2923,"address":[1711744],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_identity_server_handshake_failed_callback"},{"line":2928,"address":[1711776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2930,"address":[1853514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2931,"address":[1853607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2943,"address":[1711824],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_endpoint_client_handshake_completed_callback"},{"line":2948,"address":[1711856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2950,"address":[1853818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2951,"address":[1853911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2963,"address":[1711904],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_endpoint_client_handshake_failed_callback"},{"line":2968,"address":[1711936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2970,"address":[1854122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2971,"address":[1854215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2983,"address":[1711984],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_endpoint_server_published_callback"},{"line":2988,"address":[1712016],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2998,"address":[1712064],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_server_handshake_started_callback"},{"line":3003,"address":[1712096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3005,"address":[1854730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3006,"address":[1854823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3018,"address":[1712144],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_endpoint_server_channel_supported_callback"},{"line":3023,"address":[1712176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3025,"address":[1855034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3026,"address":[1855127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3038,"address":[1712224],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_endpoint_server_handshake_completed_callback"},{"line":3043,"address":[1712256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3045,"address":[1855338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3046,"address":[1855431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3058,"address":[1712304],"length":1,"stats":{"Line":0},"fn_name":"gosling_context_set_endpoint_server_handshake_rejected_callback"},{"line":3063,"address":[1712336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3065,"address":[1855642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3066,"address":[1855735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3078,"address":[1712384],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_set_endpoint_server_handshake_failed_callback"},{"line":3083,"address":[1712416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3085,"address":[1855946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3086,"address":[1856039],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":432,"coverable":817},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","lib.rs"],"content":"// some internal functions take a lot of args but thats ok\n#![allow(clippy::too_many_arguments)]\n// we don't generate Rust docs since this crate should never be used from\n// Rust, only from languages where the c-ffi is the only option; developers\n// should consult the Doxygen generated docs\n#![allow(clippy::missing_safety_doc)]\n\npub mod ffi;\nmod object_registry;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","object_registry.rs"],"content":"// standard\nuse std::collections::BTreeMap;\nuse std::option::Option;\n\n// An ObjectRegistry\u003cT\u003e maintains ownership of objects and maps them to usize keys\n// which can be safely handed out to external consumers as opaque pointer.\n// Keys are represented as a usize; the high bits are a unique identifier (calculated\n// as the number of keys handed out at the time of key creation, but this is an implementation\n// detail) while the low bits are a user-provided tag used to disambiguate keys from different\n// ObjectRegistry's.\n//\n// T: the type we are storing in the registry\n// TAG: a usize constant which occupy the low bits of returned keys\n// TAG_BITS: the number of bits needed to store the tag (the remainder of the usize bits are used\n//   for the unique id portion of the returne dkeys)\npub struct ObjectRegistry\u003cT, const TAG: usize, const TAG_BITS: u32\u003e {\n    // our internal mapping from handles to Ts\n    map: Option\u003cBTreeMap\u003cusize, T\u003e\u003e,\n    // number of Ts registered to this registry over its lifetime\n    counter: usize,\n}\n\n// Rust only supports 8-bit bytes\nconst BITS_PER_BYTE: u32 = 8;\n\nimpl\u003cT, const TAG: usize, const TAG_BITS: u32\u003e ObjectRegistry\u003cT, TAG, TAG_BITS\u003e {\n    // the number of bits available to the counter portion of an object key\n    const COUNTER_BITS: u32 = std::mem::size_of::\u003cusize\u003e() as u32 * BITS_PER_BYTE - TAG_BITS;\n    // the largest value the counter portion of the key can be without rolling over to 0\n    const COUNTER_MAX: usize = !0usize \u003e\u003e TAG_BITS;\n\n    // return the next key to return on successful insertion\n    fn next_key(\u0026mut self) -\u003e usize {\n        assert!(self.counter \u003c Self::COUNTER_MAX);\n        self.counter += 1;\n        (self.counter \u003c\u003c TAG_BITS) | TAG\n    }\n\n    // returns a new empty ObjectRegisry\n    pub const fn new() -\u003e ObjectRegistry\u003cT, TAG, TAG_BITS\u003e {\n        assert!(TAG_BITS == 0 || (TAG \u003c\u003c Self::COUNTER_BITS) \u003e\u003e Self::COUNTER_BITS == TAG);\n\n        ObjectRegistry {\n            map: None,\n            counter: 0,\n        }\n    }\n\n    // determine if the registry has an object with the specified key\n    pub fn contains_key(\u0026self, key: usize) -\u003e bool {\n        match \u0026self.map {\n            Some(map) =\u003e map.contains_key(\u0026key),\n            None =\u003e false,\n        }\n    }\n\n    // remove and return an object with the specified key\n    pub fn remove(\u0026mut self, key: usize) -\u003e Option\u003cT\u003e {\n        match \u0026mut self.map {\n            Some(map) =\u003e map.remove(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    // add object into registry and return key to reference it\n    pub fn insert(\u0026mut self, val: T) -\u003e usize {\n        let key = self.next_key();\n        match \u0026mut self.map {\n            Some(map) =\u003e if map.insert(key, val).is_some() {\n                panic!();\n            },\n            None =\u003e {\n                let mut map = BTreeMap::new();\n                map.insert(key, val);\n                self.map = Some(map);\n            }\n        }\n        key\n    }\n\n    // gets a reference to a value by the given key\n    pub fn get(\u0026self, key: usize) -\u003e Option\u003c\u0026T\u003e {\n        match \u0026self.map {\n            Some(map) =\u003e map.get(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    // gets a mutable reference to a value by the given key\n    pub fn get_mut(\u0026mut self, key: usize) -\u003e Option\u003c\u0026mut T\u003e {\n        match \u0026mut self.map {\n            Some(map) =\u003e map.get_mut(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    #[cfg(test)]\n    // gets just the tag portion of a key assuming it came from\n    // this registry\n    fn get_tag_from_key(\u0026self, key: usize) -\u003e usize {\n        // zero out the counter bits and return tag\n        (key \u003c\u003c Self::COUNTER_BITS) \u003e\u003e Self::COUNTER_BITS\n    }\n\n    #[cfg(test)]\n    // gets the counter portion of a key assuming it came from\n    // this registry\n    fn get_counter_from_key(\u0026self, key: usize) -\u003e usize {\n        // rotate out the tag bits\n        key \u003e\u003e TAG_BITS\n    }\n\n    #[cfg(test)]\n    // calculate the key given the counter assuming it would be used\n    // by this registry\n    fn get_key_from_counter(\u0026self, counter: usize) -\u003e usize {\n        (counter \u003c\u003c TAG_BITS) | TAG\n    }\n}\n\n#[test]\nfn test_object_registry() -\u003e anyhow::Result\u003c()\u003e {\n    // create a new ObjectRegistry\n    type Int32Registry0_16 = ObjectRegistry\u003ci32, 1234usize, 16\u003e;\n    let mut registry = Int32Registry0_16::new();\n    assert_eq!(\n        Int32Registry0_16::COUNTER_BITS,\n        std::mem::size_of::\u003cusize\u003e() as u32 * BITS_PER_BYTE - 16\n    );\n\n    // add some objects to the registry and get their keys\n    let key1 = registry.insert(10);\n    let key2 = registry.insert(20);\n    let key3 = registry.insert(30);\n\n    // check that the registry contains the keys we just added\n    assert!(registry.contains_key(key1));\n    assert!(registry.contains_key(key2));\n    assert!(registry.contains_key(key3));\n\n    // check that we can get the objects back using their keys\n    assert_eq!(registry.get(key1), Some(\u002610));\n    assert_eq!(registry.get(key2), Some(\u002620));\n    assert_eq!(registry.get(key3), Some(\u002630));\n\n    // check that we can get mutable references to the objects and modify them\n    let obj = registry.get_mut(key1).unwrap();\n    *obj = 100;\n    assert_eq!(registry.get(key1), Some(\u0026100));\n\n    // check that we can remove objects from the registry and they are no longer contained\n    let obj = registry.remove(key2).unwrap();\n    assert_eq!(obj, 20);\n    assert!(!registry.contains_key(key2));\n\n    // check that the tag bits of the keys match the TAG constant we provided\n    assert_eq!(registry.get_tag_from_key(key1), 1234usize);\n    assert_eq!(registry.get_tag_from_key(key2), 1234usize);\n    assert_eq!(registry.get_tag_from_key(key3), 1234usize);\n\n    // check that the counter bits of the keys are unique and increasing\n    let counter1 = registry.get_counter_from_key(key1);\n    let counter2 = registry.get_counter_from_key(key2);\n    let counter3 = registry.get_counter_from_key(key3);\n    assert!(counter1 \u003c counter2 \u0026\u0026 counter2 \u003c counter3);\n\n    // check that we can calculate the key given the counter and it matches the key we got from insert()\n    assert_eq!(registry.get_key_from_counter(1), key1);\n    assert_eq!(registry.get_key_from_counter(2), key2);\n    assert_eq!(registry.get_key_from_counter(3), key3);\n\n    Ok(())\n}\n\n#[test]\nfn test_object_registry_key_collision() -\u003e anyhow::Result\u003c()\u003e {\n    // create two registries with different TAG values\n    let mut registry_a: ObjectRegistry\u003cString, 1usize, 8\u003e = ObjectRegistry::new();\n    let mut registry_b: ObjectRegistry\u003cString, 2usize, 8\u003e = ObjectRegistry::new();\n\n    // insert objects into the registries\n    let key_a_1 = registry_a.insert(\"a1\".to_string());\n    let key_a_2 = registry_a.insert(\"a2\".to_string());\n    let key_b_1 = registry_b.insert(\"b1\".to_string());\n    let key_b_2 = registry_b.insert(\"b2\".to_string());\n\n    // counter portions should be the same\n    assert_eq!(\n        registry_a.get_counter_from_key(key_a_1),\n        registry_b.get_counter_from_key(key_b_1)\n    );\n    assert_eq!(\n        registry_a.get_counter_from_key(key_a_2),\n        registry_b.get_counter_from_key(key_b_2)\n    );\n\n    // ensure the keys do not collide\n    assert!(key_a_1 != key_b_1);\n    assert!(key_a_2 != key_b_2);\n    assert!(key_a_1 != key_b_2);\n    assert!(key_a_2 != key_b_1);\n\n    Ok(())\n}\n#[test]\nfn test_object_registry_empty_tag() -\u003e anyhow::Result\u003c()\u003e {\n    // create a registry with tag 0 and tag bits 0\n    let mut reg = ObjectRegistry::\u003ci32, 0, 0\u003e::new();\n\n    // add some values and check their keys\n    let key1 = reg.insert(1);\n    let key2 = reg.insert(2);\n    assert_eq!(key1, 1);\n    assert_eq!(key2, 2);\n\n    Ok(())\n}\n","traces":[{"line":33,"address":[1719376,1719088,1718944,1719664,1720240,1719232,1719520,1719952,1720096,1719808,1718800],"length":1,"stats":{"Line":10},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":38},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","tests","ffi.rs"],"content":"// standard\nuse std::ffi::{CStr, CString};\nuse std::io::{BufRead, BufReader, Write};\nuse std::net::TcpStream;\nuse std::os::raw::c_char;\n#[cfg(unix)]\nuse std::os::unix::io::{FromRawFd, RawFd};\n#[cfg(windows)]\nuse std::os::windows::io::{FromRawSocket, RawSocket};\nuse std::ptr;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\n// external crates\nuse anyhow::bail;\n\n// internal crates\nuse cgosling::ffi::*;\n\nmacro_rules! require_noerror {\n    ($func:ident($($arg:tt)*)) =\u003e {\n        // println!(\"--- {}{}\", stringify!($func), stringify!(($($arg)*)));\n        unsafe {\n            let mut error: *mut GoslingFFIError = ptr::null_mut();\n            $func($($arg)*, \u0026mut error);\n            if !error.is_null() {\n                let msg = gosling_error_get_message(error);\n                let msg = format!(\"{:?}\", CStr::from_ptr(msg));\n                gosling_error_free(error);\n                anyhow::bail!(msg);\n            }\n        }\n    }\n}\n\n// simple bson document: { msg : \"hello world\" }\nconst CHALLENGE_BSON: [u8; 26] = [\n    0x1a, 0x00, 0x00, 0x00, // document length 26 == 0x0000001a\n    0x02, b'm', b's', b'g', 0x00, // string msg\n    0x0c, 0x00, 0x00, 0x00, // strlen(\"hello world\\x00\") 12 = 0x0000000c\n    b'h', b'e', b'l', b'l', b'o', b' ', b'w', b'o', b'r', b'l', b'd', 0x00, // \"hello world\"\n    0x00, // document null-terminator\n];\n\n// empty bson document: {}\nconst CHALLENGE_RESPONSE_BSON: [u8; 5] = [\n    0x05, 0x00, 0x00, 0x00, // document length 5 == 0x00000005\n    0x00, // document null-terminator\n];\n\nstatic ENDPOINT_NAME: \u0026CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"endpoint_name\\0\") };\nstatic CHANNEL_NAME: \u0026CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"channel_name\\0\") };\n\nfn create_client_identity_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn challenge_response_size_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        _challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n    ) -\u003e usize {\n        assert!(!context.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n\n        CHALLENGE_RESPONSE_BSON.len()\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_challenge_response_size_callback(\n            context,\n            Some(challenge_response_size_callback)\n        )\n    );\n\n    extern \"C\" fn build_challenge_response_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n        out_challenge_response_buffer: *mut u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!challenge_buffer.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n        let challenge_buffer = unsafe {\n            std::slice::from_raw_parts(challenge_buffer as *const u8, challenge_buffer_size)\n        };\n        assert_eq!(challenge_buffer, CHALLENGE_BSON);\n        assert!(!out_challenge_response_buffer.is_null());\n        let out_challenge_response_buffer = unsafe {\n            std::slice::from_raw_parts_mut(\n                out_challenge_response_buffer as *mut u8,\n                challenge_response_buffer_size,\n            )\n        };\n\n        out_challenge_response_buffer.clone_from_slice(\u0026CHALLENGE_RESPONSE_BSON);\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_build_challenge_response_callback(\n            context,\n            Some(build_challenge_response_callback)\n        )\n    );\n\n    Ok(())\n}\n\nfn create_server_identity_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn client_allowed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!client_service_id.is_null());\n\n        true\n    }\n    require_noerror!(gosling_context_set_identity_server_client_allowed_callback(\n        context,\n        Some(client_allowed_callback)\n    ));\n\n    extern \"C\" fn endpoint_supported_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        if endpoint_name == ENDPOINT_NAME {\n            return true;\n        }\n        false\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_endpoint_supported_callback(\n            context,\n            Some(endpoint_supported_callback)\n        )\n    );\n\n    extern \"C\" fn challenge_size_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n    ) -\u003e usize {\n        assert!(!context.is_null());\n        CHALLENGE_BSON.len()\n    }\n    require_noerror!(gosling_context_set_identity_server_challenge_size_callback(\n        context,\n        Some(challenge_size_callback)\n    ));\n\n    extern \"C\" fn build_challenge_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        out_challenge_buffer: *mut u8,\n        challenge_buffer_size: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!out_challenge_buffer.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n\n        let out_challenge_buffer = unsafe {\n            std::slice::from_raw_parts_mut(out_challenge_buffer as *mut u8, challenge_buffer_size)\n        };\n        out_challenge_buffer.clone_from_slice(\u0026CHALLENGE_BSON);\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_build_challenge_callback(\n            context,\n            Some(build_challenge_callback)\n        )\n    );\n\n    extern \"C\" fn verify_challenge_response_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        challenge_response_buffer: *const u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!challenge_response_buffer.is_null());\n        if challenge_response_buffer_size != CHALLENGE_RESPONSE_BSON.len() {\n            return false;\n        }\n\n        let challenge_response_buffer = unsafe {\n            std::slice::from_raw_parts(challenge_response_buffer, challenge_response_buffer_size)\n        };\n        if challenge_response_buffer != CHALLENGE_RESPONSE_BSON {\n            return false;\n        }\n        true\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_verify_challenge_response_callback(\n            context,\n            Some(verify_challenge_response_callback)\n        )\n    );\n\n    Ok(())\n}\n\nfn create_server_endpoint_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn channel_supported_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!channel_name.is_null());\n        assert!(!client_service_id.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        if channel_name == CHANNEL_NAME {\n            return true;\n        }\n        false\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_channel_supported_callback(\n            context,\n            Some(channel_supported_callback)\n        )\n    );\n\n    Ok(())\n}\n\n#[test]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_gosling_ffi_handshake() -\u003e anyhow::Result\u003c()\u003e {\n    // init libary\n\n    println!(\"--- init gosling library\");\n    let mut library: *mut GoslingLibrary = ptr::null_mut();\n    require_noerror!(gosling_library_init(\u0026mut library));\n\n    println!(\"--- library: {:?}\", library);\n\n    // init alice\n\n    println!(\"--- init alice\");\n    let mut alice_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    require_noerror!(gosling_ed25519_private_key_generate(\u0026mut alice_private_key));\n\n    let mut alice_identity: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    require_noerror!(gosling_v3_onion_service_id_from_ed25519_private_key(\n        \u0026mut alice_identity,\n        alice_private_key\n    ));\n\n    let mut alice_working_dir = std::env::temp_dir();\n    alice_working_dir.push(\"gosling_context_test_alice\");\n    let alice_working_dir: CString = CString::new(alice_working_dir.to_str().unwrap())?;\n\n    let mut alice_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_new_legacy_client(\n        \u0026mut alice_tor_provider,\n        ptr::null(),\n        0usize,\n        alice_working_dir.as_ptr(),\n        alice_working_dir.as_bytes().len()\n    ));\n\n    let mut alice_context: *mut GoslingContext = ptr::null_mut();\n    require_noerror!(gosling_context_init(\n        \u0026mut alice_context,\n        alice_tor_provider,\n        420,\n        420,\n        alice_private_key\n    ));\n\n    create_server_identity_handshake(alice_context)?;\n    create_server_endpoint_handshake(alice_context)?;\n    // init pat\n\n    println!(\"--- init pat\");\n    let mut pat_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    require_noerror!(gosling_ed25519_private_key_generate(\u0026mut pat_private_key));\n\n    let mut pat_identity: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    require_noerror!(gosling_v3_onion_service_id_from_ed25519_private_key(\n        \u0026mut pat_identity,\n        pat_private_key\n    ));\n\n    let mut pat_working_dir = std::env::temp_dir();\n    pat_working_dir.push(\"gosling_context_test_pat\");\n    let pat_working_dir: CString = CString::new(pat_working_dir.to_str().unwrap())?;\n\n    let mut pat_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_new_legacy_client(\n        \u0026mut pat_tor_provider,\n        ptr::null(),\n        0usize,\n        pat_working_dir.as_ptr(),\n        pat_working_dir.as_bytes().len()\n    ));\n\n    let mut pat_context: *mut GoslingContext = ptr::null_mut();\n    require_noerror!(gosling_context_init(\n        \u0026mut pat_context,\n        pat_tor_provider,\n        420,\n        420,\n        pat_private_key\n    ));\n\n    create_client_identity_handshake(pat_context)?;\n\n    // bootstrap alice\n\n    static ALICE_BOOTSTRAP_COMPLETE: AtomicBool = AtomicBool::new(false);\n    extern \"C\" fn alice_bootstrap_complete_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n        ALICE_BOOTSTRAP_COMPLETE.store(true, Ordering::Relaxed);\n        println!(\"--- alice bootstraped\");\n    }\n    require_noerror!(gosling_context_set_tor_bootstrap_completed_callback(\n        alice_context,\n        Some(alice_bootstrap_complete_callback)\n    ));\n\n    println!(\"--- begin alice bootstrap\");\n    require_noerror!(gosling_context_bootstrap_tor(alice_context));\n    while !ALICE_BOOTSTRAP_COMPLETE.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(alice_context));\n    }\n\n    // init alice's identity server\n    static ALICE_IDENTITY_SERVER_READY: AtomicBool = AtomicBool::new(false);\n    extern \"C\" fn alice_identity_server_published_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n        println!(\"--- alice identity server published\");\n\n        ALICE_IDENTITY_SERVER_READY.store(true, Ordering::Relaxed);\n    }\n    require_noerror!(gosling_context_set_identity_server_published_callback(\n        alice_context,\n        Some(alice_identity_server_published_callback)\n    ));\n\n    println!(\"--- start alice identity server\");\n    require_noerror!(gosling_context_start_identity_server(alice_context));\n\n    while !ALICE_IDENTITY_SERVER_READY.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(alice_context));\n    }\n\n    // bootstrap pat\n\n    static PAT_BOOTSTRAP_COMPLETE: AtomicBool = AtomicBool::new(false);\n    extern \"C\" fn pat_bootstrap_complete_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n\n        println!(\"--- pat bootstrapped\");\n\n        PAT_BOOTSTRAP_COMPLETE.store(true, Ordering::Relaxed);\n    }\n    require_noerror!(gosling_context_set_tor_bootstrap_completed_callback(\n        pat_context,\n        Some(pat_bootstrap_complete_callback)\n    ));\n\n    println!(\"--- begin pat bootstrap\");\n    require_noerror!(gosling_context_bootstrap_tor(pat_context));\n    while !PAT_BOOTSTRAP_COMPLETE.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    // pat requests an endpoint from alice\n\n    static mut PAT_ENDPOINT_REQUEST_COMPLETE: bool = false;\n    static mut ALICE_ENDPOINT_SERVICE_ID: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    static mut PAT_ONION_AUTH_PRIVATE_KEY: *mut GoslingX25519PrivateKey = ptr::null_mut();\n    extern \"C\" fn pat_identity_client_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        identity_service_id: *const GoslingV3OnionServiceId,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_auth_private_key: *const GoslingX25519PrivateKey,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!identity_service_id.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!endpoint_name.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n        assert!(!client_auth_private_key.is_null());\n\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n\n        let mut alice_endpoint_service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n        unsafe {\n            gosling_v3_onion_service_id_clone(\n                \u0026mut alice_endpoint_service_id,\n                endpoint_service_id,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!alice_endpoint_service_id.is_null());\n        unsafe {\n            ALICE_ENDPOINT_SERVICE_ID = alice_endpoint_service_id;\n        }\n\n        let mut pat_onion_auth_private_key: *mut GoslingX25519PrivateKey = ptr::null_mut();\n        unsafe {\n            gosling_x25519_private_key_clone(\n                \u0026mut pat_onion_auth_private_key,\n                client_auth_private_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_onion_auth_private_key.is_null());\n        unsafe {\n            PAT_ONION_AUTH_PRIVATE_KEY = pat_onion_auth_private_key;\n        }\n\n        println!(\"--- pat identity handshake completed\");\n\n        unsafe {\n            PAT_ENDPOINT_REQUEST_COMPLETE = true;\n        }\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_handshake_completed_callback(\n            pat_context,\n            Some(pat_identity_client_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn pat_identity_client_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingFFIError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n\n        panic!(\"--- pat identity handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_handshake_failed_callback(\n            pat_context,\n            Some(pat_identity_client_handshake_failed_callback)\n        )\n    );\n\n    static mut ALICE_ENDPOINT_REQUEST_COMPLETE: bool = false;\n    static mut ALICE_ENDPOINT_PRIVATE_KEY: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    static mut PAT_IDENTITY_SERVICE_ID: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    static mut PAT_ONION_AUTH_PUBLIC_KEY: *mut GoslingX25519PublicKey = ptr::null_mut();\n\n    extern \"C\" fn alice_identity_server_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_private_key: *const GoslingEd25519PrivateKey,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        client_auth_public_key: *const GoslingX25519PublicKey,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_private_key.is_null());\n        assert!(!endpoint_name.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n        assert!(!client_service_id.is_null());\n        assert!(!client_auth_public_key.is_null());\n\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n\n        let mut alice_endpoint_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n        unsafe {\n            gosling_ed25519_private_key_clone(\n                \u0026mut alice_endpoint_private_key,\n                endpoint_private_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!alice_endpoint_private_key.is_null());\n        unsafe {\n            ALICE_ENDPOINT_PRIVATE_KEY = alice_endpoint_private_key;\n        }\n\n        let mut pat_identity_service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n        unsafe {\n            gosling_v3_onion_service_id_clone(\n                \u0026mut pat_identity_service_id,\n                client_service_id,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_identity_service_id.is_null());\n        unsafe {\n            PAT_IDENTITY_SERVICE_ID = pat_identity_service_id;\n        }\n\n        let mut pat_onion_auth_public_key: *mut GoslingX25519PublicKey = ptr::null_mut();\n        unsafe {\n            gosling_x25519_public_key_clone(\n                \u0026mut pat_onion_auth_public_key,\n                client_auth_public_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_onion_auth_public_key.is_null());\n        unsafe {\n            PAT_ONION_AUTH_PUBLIC_KEY = pat_onion_auth_public_key;\n        }\n\n        println!(\"--- alice identity handshake completed\");\n\n        unsafe {\n            ALICE_ENDPOINT_REQUEST_COMPLETE = true;\n        }\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_handshake_completed_callback(\n            alice_context,\n            Some(alice_identity_server_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_identity_server_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingFFIError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n\n        panic!(\"--- alice identity handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_handshake_failed_callback(\n            alice_context,\n            Some(alice_identity_server_handshake_failed_callback)\n        )\n    );\n\n    let mut pat_begin_identity_handshake_succeeded = false;\n    for k in 1..=3 {\n        println!(\"--- pat begin identity handshake attempt {}\", k);\n\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n        gosling_context_begin_identity_handshake(\n            pat_context,\n            alice_identity,\n            ENDPOINT_NAME.as_ptr(),\n            ENDPOINT_NAME.to_bytes().len(),\n            \u0026mut error,\n        );\n\n        if error.is_null() {\n            pat_begin_identity_handshake_succeeded = true;\n            break;\n        } else {\n            let error_message = unsafe {\n                CStr::from_ptr(gosling_error_get_message(error))\n                    .to_str()\n                    .unwrap()\n            };\n            println!(\"--- pat begin identity hanshake failed: {}\", error_message);\n            gosling_error_free(error);\n        }\n    }\n    assert!(pat_begin_identity_handshake_succeeded);\n\n    while unsafe { !ALICE_ENDPOINT_REQUEST_COMPLETE } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    // start alice's enddpoint server\n\n    static mut ALICE_ENDPOINT_PUBLISHED: bool = false;\n\n    extern \"C\" fn alice_endpoint_server_published_callback(\n        context: *mut GoslingContext,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n\n        println!(\"--- alice endpoint server published\");\n        unsafe {\n            ALICE_ENDPOINT_PUBLISHED = true;\n        }\n    }\n    require_noerror!(gosling_context_set_endpoint_server_published_callback(\n        alice_context,\n        Some(alice_endpoint_server_published_callback)\n    ));\n\n    println!(\"--- start init alice endpoint server\");\n    require_noerror!(gosling_context_start_endpoint_server(\n        alice_context,\n        ALICE_ENDPOINT_PRIVATE_KEY,\n        ENDPOINT_NAME.as_ptr(),\n        ENDPOINT_NAME.to_bytes().len(),\n        PAT_IDENTITY_SERVICE_ID,\n        PAT_ONION_AUTH_PUBLIC_KEY\n    ));\n\n    while unsafe { !PAT_ENDPOINT_REQUEST_COMPLETE || !ALICE_ENDPOINT_PUBLISHED } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    #[cfg(target_os = \"windows\")]\n    type TcpSocket = RawSocket;\n    #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n    type TcpSocket = RawFd;\n\n    static mut PAT_SOCKET: Option\u003cTcpSocket\u003e = None;\n    static mut ALICE_SOCKET: Option\u003cTcpSocket\u003e = None;\n\n    extern \"C\" fn pat_enpdoint_client_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: TcpSocket,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!channel_name.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        assert_eq!(channel_name, CHANNEL_NAME);\n\n        unsafe {\n            PAT_SOCKET = Some(stream);\n        }\n        println!(\"--- pat endpoint handshake complete\");\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_client_handshake_completed_callback(\n            pat_context,\n            Some(pat_enpdoint_client_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn pat_endpoint_client_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingFFIError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n        panic!(\"--- pat endpoint handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_client_handshake_failed_callback(\n            pat_context,\n            Some(pat_endpoint_client_handshake_failed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_endpoint_server_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: TcpSocket,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!client_service_id.is_null());\n        assert!(!channel_name.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        assert_eq!(channel_name, CHANNEL_NAME);\n\n        unsafe { ALICE_SOCKET = Some(stream) };\n        println!(\"--- alice endpoint hanshake complete\");\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_handshake_completed_callback(\n            alice_context,\n            Some(alice_endpoint_server_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_endpoint_server_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingFFIError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n        panic!(\"--- alice endpoint handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_handshake_failed_callback(\n            alice_context,\n            Some(alice_endpoint_server_handshake_failed_callback)\n        )\n    );\n\n    let mut pat_begin_endpoint_handshake_succeeded = false;\n    for k in 1..=3 {\n        println!(\"--- pat begin endpoint handshake attempt {}\", k);\n\n        let mut error: *mut GoslingFFIError = ptr::null_mut();\n        unsafe {\n            gosling_context_begin_endpoint_handshake(\n                pat_context,\n                ALICE_ENDPOINT_SERVICE_ID,\n                PAT_ONION_AUTH_PRIVATE_KEY,\n                CHANNEL_NAME.as_ptr(),\n                CHANNEL_NAME.to_bytes().len(),\n                \u0026mut error,\n            );\n        }\n\n        if error.is_null() {\n            pat_begin_endpoint_handshake_succeeded = true;\n            break;\n        } else {\n            let error_message = unsafe {\n                CStr::from_ptr(gosling_error_get_message(error))\n                    .to_str()\n                    .unwrap()\n            };\n            println!(\"--- pat begin endpoint hanshake failed: {}\", error_message);\n            gosling_error_free(error);\n        }\n    }\n    assert!(pat_begin_endpoint_handshake_succeeded);\n\n    while unsafe { PAT_SOCKET.is_none() || ALICE_SOCKET.is_none() } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    #[cfg(unix)]\n    let (mut pat_stream, alice_stream) = unsafe {\n        (\n            TcpStream::from_raw_fd(PAT_SOCKET.unwrap()),\n            TcpStream::from_raw_fd(ALICE_SOCKET.unwrap()),\n        )\n    };\n    #[cfg(windows)]\n    let (mut pat_stream, alice_stream) = unsafe {\n        (\n            TcpStream::from_raw_socket(PAT_SOCKET.unwrap()),\n            TcpStream::from_raw_socket(ALICE_SOCKET.unwrap()),\n        )\n    };\n\n    println!(\"--- pat writes message\");\n\n    static MESSAGE: \u0026str = \"Hello Alice!\\n\";\n\n    pat_stream.write(MESSAGE.as_bytes())?;\n    pat_stream.flush()?;\n\n    println!(\"--- alice waits for message\");\n\n    alice_stream.set_nonblocking(false)?;\n    let mut alice_reader = BufReader::new(alice_stream);\n    let mut alice_read_string: String = Default::default();\n    let mut alice_message_read: bool = false;\n    while !alice_message_read {\n        match alice_reader.read_line(\u0026mut alice_read_string) {\n            Ok(0) =\u003e {\n                println!(\"--- alice reads 0\");\n            }\n            Ok(val) =\u003e {\n                assert_eq!(val, MESSAGE.len());\n                assert_eq!(alice_read_string, MESSAGE);\n                // remove trailing new-line\n                alice_read_string.truncate(alice_read_string.len() - 1);\n\n                println!(\"--- alice received '{}'\", alice_read_string);\n                alice_message_read = true;\n            }\n            Err(err) =\u003e bail!(\"{}\", err),\n        }\n    }\n\n    // we have to free gosling library at the end or else the backing TorProvider will go away\n    // and then pat_stream and alice_stream will no longer be valid\n    println!(\"--- free gosling library\");\n    gosling_library_free(library);\n\n    Ok(())\n}\n","traces":[{"line":53,"address":[1272315,1271504],"length":1,"stats":{"Line":1},"fn_name":"create_client_identity_handshake"},{"line":54,"address":[1272912],"length":1,"stats":{"Line":1},"fn_name":"challenge_response_size_callback"},{"line":60,"address":[1272942,1273027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1272952,1273065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1271633,1271777,1271616,1272293,1271524,1272031,1272337],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[1271621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1273120],"length":1,"stats":{"Line":1},"fn_name":"build_challenge_response_callback"},{"line":80,"address":[1273187,1273213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1273316,1273202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[1273241,1273354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[1273399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1273426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1273651,1273571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[1273618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1272614,1272868,1272465,1271982,1272353,1271959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[1271967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1272600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1274557,1273680],"length":1,"stats":{"Line":1},"fn_name":"create_server_identity_handshake"},{"line":108,"address":[1277216],"length":1,"stats":{"Line":1},"fn_name":"client_allowed_callback"},{"line":113,"address":[1277240,1277267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[1277255,1277307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1273857,1274270,1273840,1273700,1274535,1274579,1274001],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[1273845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[1277344],"length":1,"stats":{"Line":1},"fn_name":"endpoint_supported_callback"},{"line":129,"address":[1277385,1277500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[1277400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[1277415,1277537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1277577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[1274198,1274707,1274221,1274595,1274982,1275238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[1274206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1277616],"length":1,"stats":{"Line":1},"fn_name":"challenge_size_callback"},{"line":148,"address":[1277650,1277630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1275669,1274933,1275282,1274910,1275925,1275394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[1274918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1277680],"length":1,"stats":{"Line":1},"fn_name":"build_challenge_callback"},{"line":162,"address":[1277715,1277741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1277730,1277843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1277769,1277880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1277925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1277958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1276081,1275620,1276612,1275969,1276356,1275597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[1275605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1278000],"length":1,"stats":{"Line":1},"fn_name":"verify_challenge_response_callback"},{"line":184,"address":[1278033,1278058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1278047,1278099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1278091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1278179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1278136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1278177,1278152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[1278169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1276917,1276656,1277171,1276307,1276768,1276284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[1276292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1276903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1278208,1278872],"length":1,"stats":{"Line":1},"fn_name":"create_server_endpoint_handshake"},{"line":209,"address":[1278912],"length":1,"stats":{"Line":1},"fn_name":"channel_supported_callback"},{"line":216,"address":[1278993,1278966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1278981,1279042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1279026,1279175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1279075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1279090,1279212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[1279252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[1278588,1278316,1278894,1278299,1278460,1278223,1278850],"length":1,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[1278304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[1278574],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":63,"coverable":64},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling-proc-macros","src","lib.rs"],"content":"use proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, ItemFn};\n\n// This macro renames a function call to a _impl variant.\n//\n// Why is this necessary? Basically, cargo  cannot currently be relied\n// on to build cdylibs correctly due to various issues limited to but\n// probably not including:\n// - not setting soname for linux shared libraries\n// - naming import libs incorrectly for mingw windows\n// - not generating correct symlinks based on version and major version for linux and macos\n//\n// The recommended solution is to use the cdylib_link_lines crate to work around\n// some of these problems, but I've run into other fun issues with that crate:\n// - import libs output to wrong directory for mingw windows\n// - import_name being set incorrectly for macos\n// - hasn't been updated in some years and seems abandoned\n//\n// So now dear reader, we come to this monstrosity. This is just one part of\n// the rest of the build system hack to solve all the above problems; namely\n// we will only use rustc to generate a static library, and from there build\n// a shared library using native C tools via CMake which handles all of the\n// above problems.\n//\n// So we need to build our cgosling crate as a static lib twice: first with the\n// ordinary functions names and second with the functions renamed in the form\n// foo() to foo_impl(). The foo_impl() variant will then be linked into a shared\n// library and called through exported functions of the foo() variety using\n// the ordinary toolchain.\n//\n// The cgosling shared library target will call the underlying functions via simple\n// passthrough with the final (logical) call chain being like a so:\n// - shared_library::foo() -\u003e static_library::foo_impl()\n//\n// Static library callers will have the following call chain:\n// - static_library::foo()\n//\n// I'm sorry it had to be this way\n#[proc_macro_attribute]\npub fn rename_impl(_attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    // parse the input as a function\n    let mut impl_fn: ItemFn = parse_macro_input!(item);\n\n    // append \"_impl\" to the original function name for the _impl function\n    impl_fn.sig.ident = syn::Ident::new(\n      \u0026format!(\"{}_impl\", impl_fn.sig.ident),\n      impl_fn.sig.ident.span(),\n    );\n\n    let expanded = quote! {\n        #impl_fn\n    };\n\n    // Return the combined TokenStream\n    TokenStream::from(expanded)\n}\n","traces":[{"line":41,"address":[272337,272221,271248],"length":1,"stats":{"Line":0},"fn_name":"rename_impl"},{"line":43,"address":[271322,271274,272230,271494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[271981,271845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[271607,271419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[271808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[272032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[272151],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","arbitrary_types.rs"],"content":"// extern\nuse bson::Document;\nuse bson::spec::BinarySubtype::Generic;\nuse curve25519_dalek::Scalar;\nuse tor_interface::tor_crypto::*;\n\n// fuzzing\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::{Arbitrary, Error, Unstructured};\n\n// Generate Arbitray Types\n\n// Ed25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519PrivateKey {\n    pub value: Ed25519PrivateKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519PrivateKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        // expanded secret key raw bytes\n        let mut raw: [u8; 64] = [0u8; 64];\n\n        // construct a valid Scalar\n        let mut scalar: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut scalar)?;\n\n        scalar = curve25519_dalek::scalar::clamp_integer(scalar.clone());\n        scalar = Scalar::from_bytes_mod_order(scalar).to_bytes();\n        raw[00..32].copy_from_slice(\u0026scalar);\n\n        let mut hash: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut hash)?;\n\n        raw[32..64].copy_from_slice(\u0026hash);\n\n        let value = Ed25519PrivateKey::from_raw(\u0026raw).unwrap();\n\n        Ok(ArbitraryEd25519PrivateKey{value})\n    }\n}\n\n// Ed25519 Public Key\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519PublicKey {\n    pub value: Ed25519PublicKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519PublicKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = Ed25519PublicKey::from_private_key(\u0026private.value);\n\n        Ok(ArbitraryEd25519PublicKey{value})\n    }\n}\n\n// Ed25519 Signature\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519Signature {\n    pub value: Ed25519Signature,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519Signature {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut message: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut message)?;\n\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = private.value.sign_message(\u0026message);\n\n        Ok(ArbitraryEd25519Signature{value})\n    }\n}\n\n// V3OnionServicId\n// x25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryV3OnionServiceId {\n    pub value: V3OnionServiceId,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryV3OnionServiceId {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = V3OnionServiceId::from_private_key(\u0026private.value);\n\n        Ok(ArbitraryV3OnionServiceId{value})\n    }\n}\n\n// x25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryX25519PrivateKey {\n    pub value: X25519PrivateKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryX25519PrivateKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut raw: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut raw)?;\n\n        raw[0] \u0026= 240;\n        raw[31] \u0026= 127;\n        raw[31] |= 64;\n\n        let value = X25519PrivateKey::from_raw(\u0026raw).unwrap();\n\n        Ok(ArbitraryX25519PrivateKey{value})\n    }\n}\n\n// x25519 Public Key\n#[derive(Debug)]\npub(crate) struct ArbitraryX25519PublicKey {\n    pub value: X25519PublicKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryX25519PublicKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut raw: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut raw)?;\n\n        let value = X25519PublicKey::from_raw(\u0026raw);\n\n        Ok(ArbitraryX25519PublicKey{value})\n    }\n}\n\n// Bson\n#[derive(Debug)]\npub(crate) struct ArbitraryBSON {\n    pub value: bson::Bson,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryBSON {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        #[derive(Arbitrary)]\n        enum BSONType {\n            Null, // 0\n            Boolean, // 1\n            Int32, // 2\n            Int64, // 3\n            Double, // 4\n            String, // 5\n            Binary, // 6\n            Array, // 7\n            Document, // 8\n        }\n\n        let value = match BSONType::arbitrary(u)? {\n            BSONType::Null =\u003e bson::Bson::Null,\n            BSONType::Boolean =\u003e bson::Bson::Boolean(bool::arbitrary(u)?),\n            BSONType::Int32 =\u003e bson::Bson::Int32(i32::arbitrary(u)?),\n            BSONType::Int64 =\u003e bson::Bson::Int64(i64::arbitrary(u)?),\n            BSONType::Double =\u003e bson::Bson::Double(f64::arbitrary(u)?),\n            BSONType::String =\u003e {\n                match std::ffi::CString::arbitrary(u)?.into_string() {\n                    Ok(value) =\u003e bson::Bson::String(value),\n                    Err(_) =\u003e bson::Bson::Null,\n                }\n            },\n            BSONType::Binary =\u003e bson::Bson::Binary(bson::Binary {subtype: Generic, bytes: Vec::\u003cu8\u003e::arbitrary(u)?}),\n            BSONType::Array =\u003e bson::Bson::Array(Vec::\u003cArbitraryBSON\u003e::arbitrary(u)?.drain(..).map(|val| val.value).collect()),\n            BSONType::Document =\u003e bson::Bson::Document(ArbitraryBSONDocument::arbitrary(u)?.value),\n        };\n\n        Ok(ArbitraryBSON{value})\n    }\n}\n\n#[derive(Debug)]\npub(crate) struct ArbitraryBSONDocument {\n    pub value: Document,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryBSONDocument {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut value = Document::new();\n        for key in Vec::\u003cstd::ffi::CString\u003e::arbitrary(u)?.drain(..) {\n            match key.into_string() {\n                Ok(key) =\u003e value.insert(key, ArbitraryBSON::arbitrary(u)?.value),\n                Err(_) =\u003e None,\n            };\n        }\n        Ok(ArbitraryBSONDocument{value})\n    }\n}\n\n// argument for a bson doc\n#[derive(Arbitrary, Debug)]\npub(crate) enum Argument\u003cT\u003e {\n    // no value\n    Missing,\n    // a valid value\n    Valid,\n    // an invalid value of the same type\n    Invalid(T),\n    // an invalid value of an arbitrary type\n    Random(ArbitraryBSON),\n}","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":61},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_endpoint_client.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\n\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nstruct ErrorSection {\n    cookie: Argument\u003ci64\u003e,\n    code: Argument\u003ci32\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nstruct ResponseSection {\n    cookie: Argument\u003ci64\u003e,\n    state: Argument\u003ci32\u003e,\n    result: Argument\u003cArbitraryBSON\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Response {\n    Noise(Vec\u003cu8\u003e),\n    Document(ArbitraryBSONDocument),\n    HonkRPC {\n        single_message: bool,\n        pending: Option\u003cResponseSection\u003e,\n        complete: Option\u003cResponseSection\u003e,\n        error: Option\u003cErrorSection\u003e,\n    },\n}\n\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    alice_endpoint_ed25519: ArbitraryEd25519PrivateKey,\n    server_cookie: Cookie,\n\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n\n    begin_handshake_response: Response,\n    send_response_response: Response,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a malicious/broken server, Bob is a valid client\nfuzz_target!(|data: HandshakeData| {\n\n    // Bob client data\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_service_id_string = bob_service_id.to_string();\n    let bob_private_x25519 = data.bob_private_x25519.value;\n    let bob_public_x25519 = X25519PublicKey::from_private_key(\u0026bob_private_x25519);\n\n    // Alice server data\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_endpoint_ed25519 = data.alice_endpoint_ed25519.value;\n    let alice_endpoint_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_endpoint_ed25519);\n    let alice_endpoint_onion_service_id_string = alice_endpoint_onion_service_id.to_string();\n\n    //\n    // Init malicious Alice server and Bob client\n    //\n\n    // init alice\n    let mut alice_tor = MockTorClient::new();\n\n    // bootstrap alice\n    alice_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n\n    let alice_listener = alice_tor.listener(\u0026alice_endpoint_ed25519, 420, Some(\u0026[bob_public_x25519])).unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::OnionServicePublished{service_id} =\u003e {\n                    assert_eq!(service_id, alice_endpoint_onion_service_id);\n                    identity_server_published = true;\n                },\n                _ =\u003e ()\n            }\n        }\n    }\n\n    // init bob\n    let bob_tor = MockTorClient::new();\n\n    // create bob gosling context\n    let mut bob = Context::new(Box::new(bob_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, Some(std::time::Duration::from_millis(32)), bob_private_key).unwrap();\n    bob.bootstrap().unwrap();\n    let mut bootstrap_complete: bool = false;\n    while !bootstrap_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n    //\n    // Bob initiates handshake\n    //\n    let handshake_handle = bob.endpoint_client_begin_handshake(alice_endpoint_onion_service_id.clone(), bob_private_x25519, VALID_CHANNEL.to_string()).unwrap();\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // alice waits for connect, return OnionStream\n    let mut alice_stream : TcpStream = match alice_listener.accept().unwrap() {\n        Some(stream) =\u003e stream.into(),\n        None =\u003e panic!(\"listener accept failed\"),\n    };\n    alice_stream.set_nonblocking(false).unwrap();\n    alice_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n\n    //\n    // Alice receives begin_handshake() and build responses\n    //\n\n    let begin_handshake_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let begin_handshake_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_ENDPOINT_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_ENDPOINT_BEGIN_HANDSHAKE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        assert_eq!(arguments.get_str(\"client_identity\").unwrap(), bob_service_id_string);\n        assert_eq!(arguments.get_str(\"channel\").unwrap(), VALID_CHANNEL);\n        begin_handshake_cookie\n    };\n\n\n\n    // messages can be built such that multiple errors exist so lets track\n    // all the layers of possible errors\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.begin_handshake_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE \u0026\u0026 state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        let mut result = Document::new();\n                        result.insert(\"server_cookie\", Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.server_cookie.to_vec()}));\n                        Some(Bson::Document(result))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!begin_handshake_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives begin_handshake() response and builds reply\n    //\n    for event in bob.update().unwrap().drain(..) {\n        match event {\n            ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                assert_eq!(handshake_handle, handle);\n                match reason {\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                        assert!(expect_timeout, \"{:?}\", reason);\n                    }\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                        assert!(expect_bson_too_small, \"{:?}\", reason);\n                    },\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                        assert!(expect_bson_too_large, \"{:?}\", reason);\n                    },\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                        assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                    },\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                        assert!(expect_unknown_error_section, \"{:?}\", reason);\n                    },\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                        assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                    },\n                    error =\u003e panic!(\"unexpected error: {:?}\", error),\n                }\n                // bob should have closed the connection on alice after handshake failure\n                return;\n            }\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    // handle dangling unexpected response\n    for event in bob.update().unwrap().drain(..) {\n        match event {\n            ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                assert_eq!(handshake_handle, handle);\n                match reason {\n                    gosling::Error::EndpointClientError(\n                        endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                        assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                    },\n                    error =\u003e panic!(\"unexpected error: {:?}\", error),\n                }\n                // bob should have closed the connection on alice after handshake failure\n                return;\n            }\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // give it a chance to timeout if it is mean to\n    while expect_timeout {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e (),\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    // println!(\"expect_timeout: {}\", expect_timeout);\n\n    // Alice receives send_reponse() and builds response\n    let send_response_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let send_response_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_ENDPOINT_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_ENDPOINT_SEND_RESPONSE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        let client_cookie = arguments.get_binary_generic(\"client_cookie\").unwrap();\n        let client_identity_proof_signature = arguments.get_binary_generic(\"client_identity_proof_signature\").unwrap();\n\n        send_response_cookie\n    };\n\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.send_response_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE \u0026\u0026 state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        Some(Bson::Document(doc!{}))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!send_response_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives send_response() response and finishes handshake\n    //\n    let mut send_response_complete: bool = false;\n    while !send_response_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointClientError(\n                            endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                },\n                ContextEvent::EndpointClientHandshakeCompleted{handle, endpoint_service_id, channel_name, stream: _} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(channel_name, VALID_CHANNEL);\n                    send_response_complete = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_endpoint_server.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse data_encoding::HEXLOWER;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\nuse honk_rpc::honk_rpc::{get_message_overhead, get_response_section_size};\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nenum BeginHandshakeMessage {\n    // random bytes\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc request\n    Request{\n        version: Argument\u003cString\u003e,\n        client_identity: Argument\u003cArbitraryV3OnionServiceId\u003e,\n        channel: Argument\u003cString\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nenum SendResponseMessage {\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc requst\n    Request{\n        client_cookie: Argument\u003cCookie\u003e,\n        client_identity_proof_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    alice_endpoint_ed25519: ArbitraryEd25519PrivateKey,\n    channel_supported: bool,\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n    client_cookie: Cookie,\n    // client messages\n    begin_handshake_cookie: i64,\n    begin_handshake: BeginHandshakeMessage,\n    send_response_cookie: i64,\n    send_response: SendResponseMessage,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a valid server, Bob connects and sends garbage at certain point in the form of bad data in correctly structured+ordered gosling bison messages or noise\nfuzz_target!(|data: HandshakeData| {\n\n    // alice server data\n    let alice_identity_ed25519 = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_identity_ed25519);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_endpoint_ed25519 = data.alice_endpoint_ed25519.value;\n    let alice_endpoint_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_endpoint_ed25519);\n    let alice_endpoint_onion_service_id_string = alice_endpoint_onion_service_id.to_string();\n\n\n    // bob client data\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_onion_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_onion_service_id_string = bob_onion_service_id.to_string();\n    let bob_private_x25519 = data.bob_private_x25519.value;\n    let bob_public_x25519 = X25519PublicKey::from_private_key(\u0026bob_private_x25519);\n\n    //\n    // Init Alice server and malicious Bob client\n    //\n\n    // init alice\n    let alice_tor = MockTorClient::new();\n\n    // create alice gosling context\n    let mut alice = Context::new(Box::new(alice_tor), 420, 420, std::time::Duration::from_millis(32), ENDPOINT_MAX_MESSAGE_SIZE, Some(std::time::Duration::from_millis(32)), alice_identity_ed25519.clone()).unwrap();\n\n    // bootstrap alice\n    alice.bootstrap().unwrap();\n    let mut endpoint_server_published: bool = false;\n    while !endpoint_server_published {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    // start alice endpoint server\n                    match alice.endpoint_server_start(alice_endpoint_ed25519.clone(), VALID_ENDPOINT.to_string(), bob_onion_service_id.clone(), bob_public_x25519.clone()) {\n                        Ok(()) =\u003e (),\n                        Err(gosling::Error::InvalidArgument(_)) =\u003e {\n                            assert_eq!(alice_onion_service_id_string, alice_endpoint_onion_service_id_string);\n                            return;\n                        },\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                ContextEvent::EndpointServerPublished{endpoint_service_id, endpoint_name} =\u003e {\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    endpoint_server_published = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n\n    // init bob\n    let mut bob_tor = MockTorClient::new();\n\n    // bootstrap bob\n    bob_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in bob_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n    bob_tor.add_client_auth(\u0026alice_endpoint_onion_service_id, \u0026bob_private_x25519).unwrap();\n\n    // bob connects to alice\n    let mut bob_stream = bob_tor.connect(\u0026alice_endpoint_onion_service_id, 420, None).unwrap();\n    bob_stream.set_nonblocking(false).unwrap();\n    bob_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n\n    //\n    // Alice waits for handshake started\n    //\n    let mut alice_handshake_started: bool = false;\n    let mut alice_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    while !alice_handshake_started {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerHandshakeStarted{handle} =\u003e {\n                    alice_handshake_started = true;\n                    alice_handshake_handle = handle;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob sends begin_handshake()\n    //\n    #[derive(PartialEq, Debug)]\n    enum ExpectedBeginHandshakeResponse {\n        // Success Case\n        EndpointRequestReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorBadGoslingVersion,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = ExpectedBeginHandshakeResponse::EndpointRequestReceived;\n\n    let message = match \u0026data.begin_handshake {\n        BeginHandshakeMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedBeginHandshakeResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedBeginHandshakeResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedBeginHandshakeResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedBeginHandshakeResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        BeginHandshakeMessage::Request{\n            version,\n            client_identity,\n            channel} =\u003e {\n            match (\u0026version, \u0026client_identity, \u0026channel) {\n                (Argument::Valid, Argument::Valid | Argument::Invalid(_), Argument::Valid | Argument::Invalid(_)) =\u003e (),\n                (Argument::Missing | Argument::Invalid(_) | Argument::Random(_), _, _) =\u003e  expected_response = ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion,\n                _ =\u003e expected_response = ExpectedBeginHandshakeResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_endpoint\".to_string()));\n            section.insert(\"function\", Bson::String(\"begin_handshake\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.begin_handshake_cookie));\n\n            let mut arguments = Document::new();\n            let version = match version {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(GOSLING_VERSION.to_string())),\n                Argument::Invalid(invalid) =\u003e {\n                    if invalid == GOSLING_VERSION {\n                        Some(Bson::String(\"invalid_version\".to_string()))\n                    } else {\n                        Some(Bson::String(invalid.clone()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(version) = version {\n                arguments.insert(\"version\", version);\n            }\n\n            let client_identity = match client_identity {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(bob_onion_service_id_string.clone())),\n                Argument::Invalid(invalid) =\u003e {\n                    let invalid = invalid.value.to_string();\n                    Some(Bson::String(invalid))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(client_identity) = client_identity {\n                arguments.insert(\"client_identity\", client_identity);\n            }\n\n            let channel = match channel {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(VALID_CHANNEL.to_string())),\n                Argument::Invalid(value) =\u003e {\n                    if value == VALID_CHANNEL {\n                        Some(Bson::String(\"invalid_channel\".to_string()))\n                    } else if value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::String(Default::default()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(value)}) =\u003e {\n                    if !value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::Null)\n                    }\n                },\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(channel) = channel {\n                arguments.insert(\"channel\", channel);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedBeginHandshakeResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n\n    //\n    // Alice handles begin_handshake()\n    //\n    let mut alice_begin_handshake_handled: bool = false;\n    while !alice_begin_handshake_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerChannelRequestReceived{handle, client_service_id: _, requested_channel} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(expected_response, ExpectedBeginHandshakeResponse::EndpointRequestReceived);\n                    #[derive(PartialEq, Debug)]\n                    enum ExpectedHandleEndpointRequestReceiveResult {\n                        Success,\n                        // Error Cases\n                        ErrorSectionTooLarge,\n                    }\n\n                    let mut expected_result = ExpectedHandleEndpointRequestReceiveResult::Success;\n\n                    // calculate the expected size of our reponse message\n                    let begin_handshake_complete_message_size = {\n                        let result = doc!{\n                            \"server_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: [0u8; COOKIE_SIZE].to_vec()}),\n                        };\n                        let response_section_size = get_response_section_size(Some(Bson::Document(result))).unwrap();\n                        get_message_overhead().unwrap() + response_section_size\n                    };\n                    if begin_handshake_complete_message_size \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expected_result = ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge;\n                    }\n\n                    match alice.endpoint_server_handle_channel_request_received(\n                        alice_handshake_handle,\n                        data.channel_supported \u0026\u0026 requested_channel == VALID_CHANNEL) {\n                        Ok(()) =\u003e assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::Success),\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n\n                    alice_begin_handshake_handled = true;\n                }\n                ContextEvent::EndpointServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(endpoint_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedBeginHandshakeResponse::ErrorBadClient ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_begin_handshake_handled = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n        // Alice sends Bob begin_handshake() response (or does nothing)\n    for event in alice.update().unwrap().drain(..) {\n        match event {\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    //\n    // Bob reads begin_handshake() response or error sections\n    //\n\n    // bob receives begin_handshake() pending response\n    let begin_handshake_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure =\u003e {\n            match begin_handshake_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_BAD_VERSION,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived |\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n\n    // bob receives begin_handshake() result\n    let begin_handshake_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    let mut server_cookie: Cookie = Default::default();\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion |\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let section = \u0026sections[0];\n                    match section {\n                        Bson::Document(section) =\u003e {\n                            assert_eq!(section.get_i32(\"id\"), Ok(RESPONSE_SECTION));\n                            let response = section;\n                            assert_eq!(response.get_i64(\"cookie\"), Ok(data.begin_handshake_cookie));\n                            assert_eq!(response.get_i32(\"state\"), Ok(COMPLETE_REQUEST_STATE));\n                            let result = response.get_document(\"result\").unwrap();\n                            server_cookie = result.get_binary_generic(\"server_cookie\").unwrap().clone().try_into().unwrap();\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    //\n    // Bsob sends send_response()\n    //\n\n    #[derive(PartialEq, Debug)]\n    enum ExpectedSendResponseResponse {\n        // Success Case\n        EmptyDocumentReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = match (data.channel_supported, data.begin_handshake) {\n        (true, BeginHandshakeMessage::Request{version: Argument::Valid, client_identity: Argument::Valid, channel: Argument::Valid}) =\u003e ExpectedSendResponseResponse::EmptyDocumentReceived,\n        _ =\u003e ExpectedSendResponseResponse::ErrorBadClient,\n    };\n\n    let message = match data.send_response {\n        SendResponseMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedSendResponseResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedSendResponseResponse::ErrorBsonTooSmall\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        ExpectedSendResponseResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedSendResponseResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedSendResponseResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedSendResponseResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes\n        },\n        SendResponseMessage::Request{\n            client_cookie,\n            client_identity_proof_signature} =\u003e {\n            match (\u0026client_cookie, \u0026client_identity_proof_signature) {\n                (Argument::Valid, Argument::Valid) =\u003e (),\n                (Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_)) =\u003e expected_response = ExpectedSendResponseResponse::ErrorBadClient,\n                _ =\u003e expected_response = ExpectedSendResponseResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_endpoint\".to_string()));\n            section.insert(\"function\", Bson::String(\"send_response\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.send_response_cookie));\n\n            let mut arguments = Document::new();\n            let client_cookie = match client_cookie {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.client_cookie.to_vec()})),\n                Argument::Invalid(value) =\u003e {\n                    // ensure the cookie is actually invalid\n                    if value == data.client_cookie {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.map(|x| !x).to_vec()}))\n                    } else {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.to_vec()}))\n                    }\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_cookie) = client_cookie {\n                arguments.insert(\"client_cookie\", client_cookie);\n            }\n\n            let client_identity_proof_signature = match client_identity_proof_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_identity_proof = build_client_proof(\"gosling-endpoint\", VALID_CHANNEL, \u0026bob_onion_service_id, \u0026alice_endpoint_onion_service_id, \u0026data.client_cookie, \u0026server_cookie);\n                    let client_identity_proof_signature = bob_private_key.sign_message(\u0026client_identity_proof);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_identity_proof_signature) = client_identity_proof_signature {\n                arguments.insert(\"client_identity_proof_signature\", client_identity_proof_signature);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedSendResponseResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Alice handles send_response()\n    //\n\n    let mut alice_send_response_handled: bool = false;\n    while !alice_send_response_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::EndpointServerError(endpoint_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedSendResponseResponse::ErrorBadClient ||\n                                    expected_response == ExpectedSendResponseResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_send_response_handled = true;\n                },\n                ContextEvent::EndpointServerHandshakeCompleted{handle, endpoint_service_id, client_service_id, channel_name, stream: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(client_service_id, bob_onion_service_id);\n                    assert_eq!(channel_name, VALID_CHANNEL);\n                    alice_send_response_handled = true;\n                    assert_eq!(expected_response, ExpectedSendResponseResponse::EmptyDocumentReceived);\n                },\n                ContextEvent::EndpointServerHandshakeRejected { handle, client_allowed: _, client_requested_channel_valid: _, client_proof_signature_valid: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice_send_response_handled = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob reads send_response() response or error sections\n    //\n\n    // first read response (pending) or error section\n    let send_response_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure =\u003e {\n            match send_response_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EmptyDocumentReceived =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"state\": COMPLETE_REQUEST_STATE,\n                                \"result\": doc!{},\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // success!\n    ()\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_identity_client.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\n\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nstruct ErrorSection {\n    cookie: Argument\u003ci64\u003e,\n    code: Argument\u003ci32\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nstruct ResponseSection {\n    cookie: Argument\u003ci64\u003e,\n    state: Argument\u003ci32\u003e,\n    result: Argument\u003cArbitraryBSON\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Response {\n    Noise(Vec\u003cu8\u003e),\n    Document(ArbitraryBSONDocument),\n    HonkRPC {\n        single_message: bool,\n        pending: Option\u003cResponseSection\u003e,\n        complete: Option\u003cResponseSection\u003e,\n        error: Option\u003cErrorSection\u003e,\n    },\n}\n\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    server_cookie: Cookie,\n    endpoint_challenge: ArbitraryBSONDocument,\n    endpoint_service_id: ArbitraryV3OnionServiceId,\n\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    endpoint_challenge_response: ArbitraryBSONDocument,\n\n    begin_handshake_response: Response,\n    send_response_response: Response,\n\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a malicious/broken server, Bob is a valid client\nfuzz_target!(|data: HandshakeData| {\n\n    //\n    // Init malicious Alice server and Bon client\n    //\n\n    // init alice\n    let mut alice_tor = MockTorClient::new();\n\n    // bootstrap alice\n    alice_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_listener = alice_tor.listener(\u0026alice_private_key, 420, None).unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::OnionServicePublished{service_id} =\u003e {\n                    assert_eq!(service_id, alice_onion_service_id);\n                    identity_server_published = true;\n                },\n                _ =\u003e ()\n            }\n        }\n    }\n\n    // init bob\n    let bob_tor = MockTorClient::new();\n\n    // create bob gosling context\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_service_id_string = bob_service_id.to_string();\n    let mut bob = Context::new(Box::new(bob_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, None, bob_private_key).unwrap();\n    bob.bootstrap().unwrap();\n    let mut bootstrap_complete: bool = false;\n    while !bootstrap_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob initiates handshake\n    //\n    let handshake_handle = bob.identity_client_begin_handshake(alice_onion_service_id.clone(), VALID_ENDPOINT.to_string()).unwrap();\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // alice waits for connect, return OnionStream\n    let mut alice_stream : TcpStream = match alice_listener.accept().unwrap() {\n        Some(stream) =\u003e stream.into(),\n        None =\u003e panic!(\"listener accept failed\"),\n    };\n    alice_stream.set_nonblocking(false).unwrap();\n    alice_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n    //\n    // Alice receives begin_handshake() and build responses\n    //\n\n    let begin_handshake_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let begin_handshake_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_IDENTITY_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_IDENTITY_BEGIN_HANDSHAKE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        assert_eq!(arguments.get_str(\"client_identity\").unwrap(), bob_service_id_string);\n        assert_eq!(arguments.get_str(\"endpoint\").unwrap(), VALID_ENDPOINT);\n        begin_handshake_cookie\n    };\n\n    // messages can be built such that multiple errors exist so lets track\n    // all the layers of possible errors\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.begin_handshake_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        let mut result = Document::new();\n                        result.insert(\"server_cookie\", Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.server_cookie.to_vec()}));\n                        result.insert(\"endpoint_challenge\", data.endpoint_challenge.value.clone());\n                        Some(Bson::Document(result))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!begin_handshake_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives begin_handshake() response and builds reply\n    //\n    let mut begin_handshake_complete: bool = false;\n    while !begin_handshake_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                }\n                ContextEvent::IdentityClientChallengeReceived{handle, endpoint_challenge} =\u003e {\n                    assert!(!begin_handshake_complete);\n                    assert!(!expect_timeout);\n                    assert!(!expect_bson_too_small);\n                    assert!(!expect_bson_too_large);\n                    assert!(!expect_honkrpc_message_parse_failure);\n                    assert!(!expect_gosling_unexpected_response);\n                    assert_eq!(handshake_handle, handle);\n                    // compare the raw bytes ince an arbitrary bson doc may have Double(NaN) which fails equality test\n                    assert_eq!({\n                        let mut bytes: Vec\u003cu8\u003e = Default::default();\n                        endpoint_challenge.to_writer(\u0026mut bytes).unwrap();\n                        bytes\n                    },{\n                        let mut bytes: Vec\u003cu8\u003e = Default::default();\n                        data.endpoint_challenge.value.to_writer(\u0026mut bytes).unwrap();\n                        bytes\n                    });\n\n                    // just reply with an empty challenge response\n                    match bob.identity_client_handle_challenge_received(handle, data.endpoint_challenge_response.value.clone()) {\n                        Ok(()) =\u003e begin_handshake_complete = true,\n                        // there is a limit to how large a response can be based on the honk-rpc max message size\n                        Err(gosling::Error::IdentityClientError(identity_client::Error::EndpointChallengeResponseTooLarge(_,_))) =\u003e return,\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n\n    // Alice receives send_reponse() and builds response\n    let send_response_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let send_response_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_IDENTITY_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_IDENTITY_SEND_RESPONSE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        let client_cookie = arguments.get_binary_generic(\"client_cookie\").unwrap();\n        let client_identity_proof_signature = arguments.get_binary_generic(\"client_identity_proof_signature\").unwrap();\n        let client_authorization_key = arguments.get_binary_generic(\"client_authorization_key\").unwrap();\n        let client_authorization_key_signbit = arguments.get_bool(\"client_authorization_key_signbit\").unwrap();\n        let client_authorization_signature = arguments.get_binary_generic(\"client_authorization_signature\").unwrap();\n        let challenge_response = arguments.get_document(\"challenge_response\").unwrap();\n\n        send_response_cookie\n    };\n\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.send_response_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        Some(Bson::String(data.endpoint_service_id.value.to_string()))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!send_response_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives send_response() response and finishes handshake\n    //\n    let mut send_response_complete: bool = false;\n    while !send_response_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityClientError(\n                            identity_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                },\n                ContextEvent::IdentityClientHandshakeCompleted{handle, identity_service_id, endpoint_service_id, endpoint_name, client_auth_private_key} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    assert_eq!(identity_service_id, alice_onion_service_id);\n                    assert_eq!(endpoint_service_id, data.endpoint_service_id.value);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    send_response_complete = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_identity_server.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse data_encoding::HEXLOWER;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\nuse honk_rpc::honk_rpc::{get_message_overhead, get_response_section_size};\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nenum BeginHandshakeMessage {\n    // random bytes\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc request\n    Request{\n        version: Argument\u003cString\u003e,\n        client_identity: Argument\u003cArbitraryV3OnionServiceId\u003e,\n        endpoint: Argument\u003cString\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nenum SendResponseMessage {\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc requst\n    Request{\n        client_cookie: Argument\u003cCookie\u003e,\n        client_identity_proof_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n        client_authorization_key: Argument\u003cArbitraryX25519PrivateKey\u003e,\n        client_authorization_key_signbit: Argument\u003cbool\u003e,\n        client_authorization_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n        challenge_response: Argument\u003cArbitraryBSONDocument\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    client_allowed: bool,\n    endpoint_supported: bool,\n    endpoint_challenge: ArbitraryBSONDocument,\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n    client_cookie: Cookie,\n    // client messages\n    begin_handshake_cookie: i64,\n    begin_handshake: BeginHandshakeMessage,\n    send_response_cookie: i64,\n    send_response: SendResponseMessage,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a valid server, Bob connects and sends garbage at certain point in the form of bad data in correctly structured+ordered gosling bison messages or noise\nfuzz_target!(|data: HandshakeData| {\n\n    //\n    // Init Alice server and malicious Bob client\n    //\n\n    // init alice\n    let alice_tor = MockTorClient::new();\n\n    // create alice gosling context\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let mut alice = Context::new(Box::new(alice_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, None, alice_private_key).unwrap();\n\n    // bootstrap alice\n    alice.bootstrap().unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    // start alice identity server\n                    alice.identity_server_start().unwrap();\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                ContextEvent::IdentityServerPublished =\u003e {\n                    identity_server_published = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    // init bob\n    let mut bob_tor = MockTorClient::new();\n\n    // bootstrap bob\n    bob_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in bob_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_onion_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_onion_service_id_string = bob_onion_service_id.to_string();\n\n    // bob connects to alice\n    let mut bob_stream = bob_tor.connect(\u0026alice_onion_service_id, 420, None).unwrap();\n    bob_stream.set_nonblocking(false).unwrap();\n    bob_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n    //\n    // Alice waits for handshake started\n    //\n    let mut alice_handshake_started: bool = false;\n    let mut alice_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    while !alice_handshake_started {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerHandshakeStarted{handle} =\u003e {\n                    alice_handshake_started = true;\n                    alice_handshake_handle = handle;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob sends begin_handshake()\n    //\n    #[derive(PartialEq, Debug)]\n    enum ExpectedBeginHandshakeResponse {\n        // Success Case\n        EndpointRequestReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorBadGoslingVersion,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = ExpectedBeginHandshakeResponse::EndpointRequestReceived;\n\n    let message = match \u0026data.begin_handshake {\n        BeginHandshakeMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedBeginHandshakeResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedBeginHandshakeResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedBeginHandshakeResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedBeginHandshakeResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        BeginHandshakeMessage::Request{\n            version,\n            client_identity,\n            endpoint} =\u003e {\n            match (\u0026version, \u0026client_identity, \u0026endpoint) {\n                (Argument::Valid, Argument::Valid | Argument::Invalid(_), Argument::Valid | Argument::Invalid(_)) =\u003e (),\n                (Argument::Missing | Argument::Invalid(_) | Argument::Random(_), _, _) =\u003e  expected_response = ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion,\n                _ =\u003e expected_response = ExpectedBeginHandshakeResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_identity\".to_string()));\n            section.insert(\"function\", Bson::String(\"begin_handshake\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.begin_handshake_cookie));\n\n            let mut arguments = Document::new();\n            let version = match version {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(GOSLING_VERSION.to_string())),\n                Argument::Invalid(invalid) =\u003e {\n                    if invalid == GOSLING_VERSION {\n                        Some(Bson::String(\"invalid_version\".to_string()))\n                    } else {\n                        Some(Bson::String(invalid.clone()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(version) = version {\n                arguments.insert(\"version\", version);\n            }\n\n            let client_identity = match client_identity {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(bob_onion_service_id_string.clone())),\n                Argument::Invalid(invalid) =\u003e {\n                    let invalid = invalid.value.to_string();\n                    Some(Bson::String(invalid))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(client_identity) = client_identity {\n                arguments.insert(\"client_identity\", client_identity);\n            }\n\n            let endpoint = match endpoint {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(VALID_ENDPOINT.to_string())),\n                Argument::Invalid(value) =\u003e {\n                    if value == VALID_ENDPOINT {\n                        Some(Bson::String(\"invalid_endpoint\".to_string()))\n                    } else if value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::String(Default::default()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(value)}) =\u003e {\n                    if !value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::Null)\n                    }\n                },\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(endpoint) = endpoint {\n                arguments.insert(\"endpoint\", endpoint);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedBeginHandshakeResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Alice handles begin_handshake()\n    //\n    let mut alice_begin_handshake_handled: bool = false;\n    while !alice_begin_handshake_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerEndpointRequestReceived{handle, client_service_id: _, requested_endpoint} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(expected_response, ExpectedBeginHandshakeResponse::EndpointRequestReceived);\n                    #[derive(PartialEq, Debug)]\n                    enum ExpectedHandleEndpointRequestReceiveResult {\n                        Success,\n                        // Error Cases\n                        ErrorSectionTooLarge,\n                    }\n\n                    let mut expected_result = ExpectedHandleEndpointRequestReceiveResult::Success;\n\n                    // calculate the expected size of our reponse message\n                    let begin_handshake_complete_message_size = {\n                        let result = doc!{\n                            \"server_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: [0u8; COOKIE_SIZE].to_vec()}),\n                            \"endpoint_challenge\" : data.endpoint_challenge.value.clone(),\n                        };\n                        let response_section_size = get_response_section_size(Some(Bson::Document(result))).unwrap();\n                        get_message_overhead().unwrap() + response_section_size\n                    };\n                    if begin_handshake_complete_message_size \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expected_result = ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge;\n                    }\n\n                    match alice.identity_server_handle_endpoint_request_received(\n                        alice_handshake_handle,\n                        data.client_allowed,\n                        data.endpoint_supported \u0026\u0026 requested_endpoint == VALID_ENDPOINT,\n                        data.endpoint_challenge.value.clone()) {\n                        Err(gosling::Error::IdentityServerError(identity_server::Error::EndpointChallengeTooLarge(_,_))) =\u003e {\n                            assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge);\n                            return;\n                        },\n                        Ok(()) =\u003e {\n                            assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::Success);\n                        }\n                        result =\u003e panic!(\"unexpected result: {:?}\", result)\n                    }\n\n                    alice_begin_handshake_handled = true;\n                }\n                ContextEvent::IdentityServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(identity_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedBeginHandshakeResponse::ErrorBadClient ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_begin_handshake_handled = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n        // Alice sends Bob begin_handshake() response (or does nothing)\n    for event in alice.update().unwrap().drain(..) {\n        match event {\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    //\n    // Bob reads begin_handshake() response or error sections\n    //\n\n    // bob receives begin_handshake() pending response\n    let begin_handshake_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure =\u003e {\n            match begin_handshake_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_BAD_VERSION,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived |\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // bob receives begin_handshake() result\n    let begin_handshake_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    let mut server_cookie: Cookie = Default::default();\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion |\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let section = \u0026sections[0];\n                    match section {\n                        Bson::Document(section) =\u003e {\n                            assert_eq!(section.get_i32(\"id\"), Ok(RESPONSE_SECTION));\n                            let response = section;\n                            assert_eq!(response.get_i64(\"cookie\"), Ok(data.begin_handshake_cookie));\n                            assert_eq!(response.get_i32(\"state\"), Ok(COMPLETE_REQUEST_STATE));\n                            let result = response.get_document(\"result\").unwrap();\n                            server_cookie = result.get_binary_generic(\"server_cookie\").unwrap().clone().try_into().unwrap();\n                            let endpoint_challenge = result.get_document(\"endpoint_challenge\").unwrap();\n                            // compare the raw bytes ince an arbitrary bson doc may have Double(NaN) which fails equality test\n                            assert_eq!({\n                                let mut bytes: Vec\u003cu8\u003e = Default::default();\n                                endpoint_challenge.to_writer(\u0026mut bytes).unwrap();\n                                bytes\n                            },{\n                                let mut bytes: Vec\u003cu8\u003e = Default::default();\n                                data.endpoint_challenge.value.to_writer(\u0026mut bytes).unwrap();\n                                bytes\n                            });\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n\n    }\n\n    //\n    // Bsob sends send_response()\n    //\n\n    #[derive(PartialEq, Debug)]\n    enum ExpectedSendResponseResponse {\n        // Success Case\n        EndpointOnionServiceIdReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = match (data.client_allowed \u0026\u0026 data.endpoint_supported, data.begin_handshake) {\n        (true, BeginHandshakeMessage::Request{version: Argument::Valid, client_identity: Argument::Valid, endpoint: Argument::Valid}) =\u003e ExpectedSendResponseResponse::EndpointOnionServiceIdReceived,\n        _ =\u003e ExpectedSendResponseResponse::ErrorBadClient,\n    };\n\n    let message = match data.send_response {\n        SendResponseMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedSendResponseResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedSendResponseResponse::ErrorBsonTooSmall\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        ExpectedSendResponseResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedSendResponseResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedSendResponseResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedSendResponseResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes\n        },\n        SendResponseMessage::Request{\n            client_cookie,\n            client_identity_proof_signature,\n            client_authorization_key,\n            client_authorization_key_signbit,\n            client_authorization_signature,\n            challenge_response} =\u003e {\n            match (\u0026client_cookie, \u0026client_identity_proof_signature, \u0026client_authorization_key, \u0026client_authorization_key_signbit, \u0026client_authorization_signature, \u0026challenge_response) {\n                (Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid) =\u003e (),\n                (Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_)) =\u003e expected_response = ExpectedSendResponseResponse::ErrorBadClient,\n                _ =\u003e expected_response = ExpectedSendResponseResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_identity\".to_string()));\n            section.insert(\"function\", Bson::String(\"send_response\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.send_response_cookie));\n\n            let mut arguments = Document::new();\n            let client_cookie = match client_cookie {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.client_cookie.to_vec()})),\n                Argument::Invalid(value) =\u003e {\n                    // ensure the cookie is actually invalid\n                    if value == data.client_cookie {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.map(|x| !x).to_vec()}))\n                    } else {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.to_vec()}))\n                    }\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_cookie) = client_cookie {\n                arguments.insert(\"client_cookie\", client_cookie);\n            }\n\n            let client_identity_proof_signature = match client_identity_proof_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_identity_proof = build_client_proof(\"gosling-identity\", VALID_ENDPOINT, \u0026bob_onion_service_id, \u0026alice_onion_service_id, \u0026data.client_cookie, \u0026server_cookie);\n                    let client_identity_proof_signature = bob_private_key.sign_message(\u0026client_identity_proof);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_identity_proof_signature) = client_identity_proof_signature {\n                arguments.insert(\"client_identity_proof_signature\", client_identity_proof_signature);\n            }\n\n            let client_authorization_key = match client_authorization_key {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_authorization_key = X25519PublicKey::from_private_key(\u0026data.bob_private_x25519.value);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    let client_authorization_key = X25519PublicKey::from_private_key(\u0026invalid.value);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}))\n                },\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_key) = client_authorization_key {\n                arguments.insert(\"client_authorization_key\", client_authorization_key);\n            }\n\n            let client_authorization_signing_key_private = Ed25519PrivateKey::from_private_x25519(\u0026data.bob_private_x25519.value).unwrap();\n            let client_authorization_key_signbit = match client_authorization_key_signbit {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let signbit = client_authorization_signing_key_private.1;\n                    Some(Bson::Boolean(bool::from(signbit)))\n                },\n                Argument::Invalid(_) =\u003e {\n                    let signbit = client_authorization_signing_key_private.1;\n                    Some(Bson::Boolean(!bool::from(signbit)))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::Boolean(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_key_signbit) = client_authorization_key_signbit {\n                arguments.insert(\"client_authorization_key_signbit\", client_authorization_key_signbit);\n            }\n\n            let client_authorization_signature = match client_authorization_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_authorization_signature = client_authorization_signing_key_private.0.sign_message(bob_onion_service_id_string.as_bytes());\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                },\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_signature) = client_authorization_signature {\n                arguments.insert(\"client_authorization_signature\", client_authorization_signature);\n            }\n\n            let challenge_response = match challenge_response {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Document(Document::new())),\n                Argument::Invalid(ArbitraryBSONDocument{value}) =\u003e {\n                    // server is expecting an empty response so to be invalid\n                    // it must contain *some* member\n                    if value == Document::new() {\n                        Some(Bson::Document(doc!{\"foo\": Bson::Null}))\n                    } else {\n                        Some(Bson::Document(value))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::Document(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(challenge_response) = challenge_response {\n                arguments.insert(\"challenge_response\", challenge_response);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedSendResponseResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n\n    //\n    // Alice handles send_response()\n    //\n\n    let mut alice_send_response_handled: bool = false;\n    while !alice_send_response_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        gosling::Error::IdentityServerError(identity_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedSendResponseResponse::ErrorBadClient ||\n                                    expected_response == ExpectedSendResponseResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_send_response_handled = true;\n                },\n                ContextEvent::IdentityServerChallengeResponseReceived{handle, challenge_response} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice.identity_server_handle_challenge_response_received(handle, challenge_response == Document::new()).unwrap();\n                },\n                ContextEvent::IdentityServerHandshakeCompleted{handle, endpoint_private_key: _, endpoint_name, client_service_id: _, client_auth_public_key: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    alice_send_response_handled = true;\n                    assert_eq!(expected_response, ExpectedSendResponseResponse::EndpointOnionServiceIdReceived);\n                },\n                ContextEvent::IdentityServerHandshakeRejected { handle, client_allowed: _, client_requested_endpoint_valid: _, client_proof_signature_valid: _, client_auth_signature_valid: _, challenge_response_valid: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice_send_response_handled = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob reads send_response() response or error sections\n    //\n\n    // first read response (pending) or error section\n    let send_response_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure =\u003e {\n            match send_response_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EndpointOnionServiceIdReceived |\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // next read response (result) or error section\n    let send_response_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure |\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EndpointOnionServiceIdReceived =\u003e {\n            match send_response_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let response = \u0026sections[0];\n                    match response {\n                        Bson::Document(response) =\u003e {\n                            assert_eq!(response.get_i32(\"id\").unwrap(), RESPONSE_SECTION, \"{:?}\", message);\n                            assert_eq!(response.get_i64(\"cookie\").unwrap(), data.send_response_cookie, \"{:?}\", message);\n                            assert_eq!(response.get_i32(\"state\").unwrap(), COMPLETE_REQUEST_STATE, \"{:?}\", message);\n                            match response.get(\"result\") {\n                                Some(Bson::String(serviceid)) =\u003e {\n                                    // ensure returned valueis a valid service id\n                                    V3OnionServiceId::from_string(serviceid).unwrap();\n                                },\n                                Some(bson) =\u003e panic!(\"unexpected result: {:?}\", bson),\n                                None =\u003e panic!(\"unexpected send_response result message: {:?}\", message),\n                            }\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n    }\n\n    // success!\n    ()\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","utils.rs"],"content":"// extern\nuse data_encoding::HEXLOWER;\nuse tor_interface::tor_crypto::*;\n\n\n// honk-rpc constants\npub(crate) const HONK_RPC: i32 = 1;\npub(crate) const ERROR_SECTION: i32 = 0;\npub(crate) const ERROR_CODE_BAD_VERSION: i32 = 0;\npub(crate) const ERROR_CODE_REQUEST_COOKIE_REQUIRED: i32 = 1;\npub(crate) const ERROR_CODE_INVALID_ARG: i32 = 2;\npub(crate) const ERROR_CODE_FAILURE: i32 = 3;\npub(crate) const REQUEST_SECTION: i32 = 1;\npub(crate) const RESPONSE_SECTION: i32 = 2;\npub(crate) const PENDING_REQUEST_STATE: i32 = 0;\npub(crate) const COMPLETE_REQUEST_STATE: i32 = 1;\n\n// gosling constants\npub(crate) const GOSLING_VERSION: \u0026str = gosling::gosling::GOSLING_PROTOCOL_VERSION;\npub(crate) const GOSLING_IDENTITY_NAMESPACE: \u0026str = \"gosling_identity\";\npub(crate) const GOSLING_IDENTITY_BEGIN_HANDSHAKE_FUNCTION: \u0026str = \"begin_handshake\";\npub(crate) const GOSLING_IDENTITY_SEND_RESPONSE_FUNCTION: \u0026str = \"send_response\";\npub(crate) const GOSLING_ENDPOINT_NAMESPACE: \u0026str = \"gosling_endpoint\";\npub(crate) const GOSLING_ENDPOINT_BEGIN_HANDSHAKE_FUNCTION: \u0026str = \"begin_handshake\";\npub(crate) const GOSLING_ENDPOINT_SEND_RESPONSE_FUNCTION: \u0026str = \"send_response\";\npub(crate) const VALID_ENDPOINT: \u0026str = \"valid_endpoint\";\npub(crate) const VALID_CHANNEL: \u0026str = \"valid_channel\";\npub(crate) const IDENTITY_MAX_MESSAGE_SIZE: i32 = 1024;\npub(crate) const ENDPOINT_MAX_MESSAGE_SIZE: i32 = 384;\npub(crate) const COOKIE_SIZE: usize = 32usize;\npub(crate) type Cookie = [u8; COOKIE_SIZE];\n\n\npub(crate) fn build_client_proof(\n    domain_separator: \u0026str,\n    request: \u0026str,\n    client_service_id: \u0026V3OnionServiceId,\n    server_service_id: \u0026V3OnionServiceId,\n    client_cookie: \u0026Cookie,\n    server_cookie: \u0026Cookie,\n) -\u003e Vec\u003cu8\u003e {\n    let mut client_proof: Vec\u003cu8\u003e= Default::default();\n\n    client_proof.extend_from_slice(domain_separator.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(request.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(client_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(server_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(client_cookie).as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(server_cookie).as_bytes());\n\n    client_proof\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","ascii_string.rs"],"content":"#[cfg(test)]\nuse anyhow::bail;\nuse std::ops::Deref;\n\n#[derive(thiserror::Error, Debug)]\npub(crate) enum Error {\n    #[error(\"input string is not ASCII: {0}\")]\n    InvalidAscii(String),\n}\n\n/// An immutable wrapper around a String guaranteed to be ASCII encoded\n#[derive(Clone, PartialEq)]\npub(crate) struct AsciiString {\n    value: String,\n}\n\nimpl AsciiString {\n    pub fn new(value: String) -\u003e Result\u003cAsciiString, Error\u003e {\n        if value.is_ascii() {\n            Ok(Self { value })\n        } else {\n            Err(Error::InvalidAscii(value))\n        }\n    }\n}\n\nimpl Deref for AsciiString {\n    type Target = String;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.value\n    }\n}\n\nimpl std::fmt::Debug for AsciiString {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.value.fmt(f)\n    }\n}\n\nimpl std::fmt::Display for AsciiString {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.value.fmt(f)\n    }\n}\n\n#[test]\nfn test_ascii_string() -\u003e anyhow::Result\u003c()\u003e {\n    let valid_ascii: [String; 8] = [\n        \"\".to_string(),\n        \" !\\\"#$%\u0026'()*+,-./\".to_string(),\n        \"0123456789\".to_string(),\n        \":\u003c=\u003e?@\".to_string(),\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".to_string(),\n        \"[\\\\]^_`\".to_string(),\n        \"abcdefghijklmnopqstuvwxyz\".to_string(),\n        \"{|}~\".to_string(),\n    ];\n\n    for string in valid_ascii {\n        match AsciiString::new(string) {\n            Ok(string) =\u003e println!(\"ascii: '{}'\", string),\n            Err(err) =\u003e bail!(\"unexpected error: {}\", err),\n        }\n    }\n\n    let utf8: [String; 2] = [\"\".to_string(), \"heart \".to_string()];\n\n    for string in utf8 {\n        match AsciiString::new(string) {\n            Ok(string) =\u003e bail!(\"this is not ascii: {}\", string),\n            Err(_) =\u003e (),\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":18,"address":[3015712,3015360],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[2396269,2396130,2396062],"length":1,"stats":{"Line":7},"fn_name":null},{"line":20,"address":[3017817],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[3015489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1434464],"length":1,"stats":{"Line":3},"fn_name":"deref"},{"line":36,"address":[2396432],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":37,"address":[2396446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2396464],"length":1,"stats":{"Line":3},"fn_name":"fmt"},{"line":43,"address":[2396478],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":7,"coverable":9},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","context.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::collections::{BTreeMap, HashMap, VecDeque};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// extern crates\nuse honk_rpc::honk_rpc::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::endpoint_client::*;\nuse crate::endpoint_server::*;\nuse crate::gosling::Error;\nuse crate::identity_client::*;\nuse crate::identity_server::*;\n\n/// cbindgen:ignore\npub type HandshakeHandle = usize;\npub const INVALID_HANDSHAKE_HANDLE: HandshakeHandle = !0usize;\nconst DEFAULT_ENDPOINT_TIMEOUT: Duration = Duration::from_secs(60);\nconst DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE: i32 = 384;\n//\n// The root Gosling Context object\n//\npub struct Context {\n    // our tor instance\n    tor_provider: Box\u003cdyn TorProvider\u003e,\n    bootstrap_complete: bool,\n    identity_port: u16,\n    endpoint_port: u16,\n    identity_timeout: Duration,\n    identity_max_message_size: i32,\n    endpoint_timeout: Duration,\n\n    //\n    // Servers and Clients for in-process handshakes\n    //\n    next_handshake_handle: HandshakeHandle,\n    identity_clients: BTreeMap\u003cHandshakeHandle, IdentityClient\u003e,\n    identity_servers: BTreeMap\u003cHandshakeHandle, IdentityServer\u003e,\n    endpoint_clients: BTreeMap\u003cHandshakeHandle, EndpointClient\u003e,\n    endpoint_servers: BTreeMap\u003cHandshakeHandle, EndpointServer\u003e,\n\n    //\n    // Listeners for incoming connections\n    //\n    identity_listener: Option\u003cOnionListener\u003e,\n    identity_server_published: bool,\n    // maps the endpoint service id to the (enpdoint name, alowed client, onion listener tuple, published)\n    endpoint_listeners: HashMap\u003cV3OnionServiceId, (String, V3OnionServiceId, OnionListener, bool)\u003e,\n\n    //\n    // Server Config Data\n    //\n\n    // Private key behind the identity onion service\n    identity_private_key: Ed25519PrivateKey,\n    // Identity server's service id\n    identity_service_id: V3OnionServiceId,\n}\n\n#[derive(Debug)]\npub enum ContextEvent {\n    //\n    // Tor Events\n    //\n\n    // bootstrap progress\n    TorBootstrapStatusReceived {\n        progress: u32,\n        tag: String,\n        summary: String,\n    },\n\n    // bootstrapping finished\n    TorBootstrapCompleted,\n\n    // tor log\n    TorLogReceived {\n        line: String,\n    },\n\n    //\n    // Identity Client Events\n    //\n\n    // identity client has received a challenge request from an identy server\n    // to continue the handshake, call Context::identity_client_handle_challenge_received\n    IdentityClientChallengeReceived {\n        handle: HandshakeHandle,\n        endpoint_challenge: bson::document::Document,\n    },\n\n    // identity client successfully completes identity handshake\n    IdentityClientHandshakeCompleted {\n        handle: HandshakeHandle,\n        identity_service_id: V3OnionServiceId,\n        endpoint_service_id: V3OnionServiceId,\n        endpoint_name: String,\n        client_auth_private_key: X25519PrivateKey,\n    },\n\n    // identity client handshake failed\n    IdentityClientHandshakeFailed {\n        handle: HandshakeHandle,\n        reason: Error,\n    },\n\n    // identity server onion service published\n    IdentityServerPublished,\n\n    // identity server has received incoming connection\n    IdentityServerHandshakeStarted {\n        handle: HandshakeHandle,\n    },\n\n    // identity server receives request from identity client\n    // to continue the handshake, call Context::identity_server_handle_endpoint_request_received()\n    IdentityServerEndpointRequestReceived {\n        handle: HandshakeHandle,\n        client_service_id: V3OnionServiceId,\n        requested_endpoint: String,\n    },\n\n    // identity server receives challenge response from identity client\n    // to continue the handshake, call Context::identity_server_handle_challenge_response_received()\n    IdentityServerChallengeResponseReceived {\n        handle: HandshakeHandle,\n        challenge_response: bson::document::Document,\n    },\n\n    // identity server supplies a new endpoint server to an identity client\n    IdentityServerHandshakeCompleted {\n        handle: HandshakeHandle,\n        endpoint_private_key: Ed25519PrivateKey,\n        endpoint_name: String,\n        client_service_id: V3OnionServiceId,\n        client_auth_public_key: X25519PublicKey,\n    },\n\n    // identity server handshake explicitly rejected client handshake\n    IdentityServerHandshakeRejected {\n        handle: HandshakeHandle,\n        client_allowed: bool,\n        client_requested_endpoint_valid: bool,\n        client_proof_signature_valid: bool,\n        client_auth_signature_valid: bool,\n        challenge_response_valid: bool,\n    },\n\n    // identity server handshake failed due to error\n    IdentityServerHandshakeFailed {\n        handle: HandshakeHandle,\n        reason: Error,\n    },\n\n    //\n    // Endpoint Client Events\n    //\n\n    // endpoint client successfully opens a channel on an endpoint server\n    EndpointClientHandshakeCompleted {\n        handle: HandshakeHandle,\n        endpoint_service_id: V3OnionServiceId,\n        channel_name: String,\n        stream: TcpStream,\n    },\n\n    // identity client handshake aborted\n    EndpointClientHandshakeFailed {\n        handle: HandshakeHandle,\n        reason: Error,\n    },\n\n    //\n    // Endpint Server Events\n    //\n\n    // endpoint server onion service published\n    EndpointServerPublished {\n        endpoint_service_id: V3OnionServiceId,\n        endpoint_name: String,\n    },\n\n    EndpointServerHandshakeStarted {\n        handle: HandshakeHandle,\n    },\n\n    // endpoint server receives request from endpoint client\n    // to continue the handshake, call Context::endpoint_server_handle_channel_request_received()\n    EndpointServerChannelRequestReceived {\n        handle: HandshakeHandle,\n        client_service_id: V3OnionServiceId,\n        requested_channel: String,\n    },\n\n    // endpoint server has acepted incoming channel request from identity client\n    EndpointServerHandshakeCompleted {\n        handle: HandshakeHandle,\n        endpoint_service_id: V3OnionServiceId,\n        client_service_id: V3OnionServiceId,\n        channel_name: String,\n        stream: TcpStream,\n    },\n\n    // endpoint server handshake explicitly rejected client handshake\n    EndpointServerHandshakeRejected {\n        handle: HandshakeHandle,\n        client_allowed: bool,\n        client_requested_channel_valid: bool,\n        client_proof_signature_valid: bool,\n    },\n\n    // endpoint server request failed\n    EndpointServerHandshakeFailed {\n        handle: HandshakeHandle,\n        reason: Error,\n    },\n}\n\nimpl Context {\n    pub fn new(\n        tor_provider: Box\u003cdyn TorProvider\u003e,\n        identity_port: u16,\n        endpoint_port: u16,\n        identity_timeout: Duration,\n        identity_max_message_size: i32,\n        endpoint_timeout: Option\u003cDuration\u003e,\n        identity_private_key: Ed25519PrivateKey,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        let identity_service_id = V3OnionServiceId::from_private_key(\u0026identity_private_key);\n\n        Ok(Self {\n            tor_provider,\n            bootstrap_complete: false,\n            identity_port,\n            identity_max_message_size,\n            endpoint_port,\n            identity_timeout,\n            endpoint_timeout: match endpoint_timeout {\n                Some(timeout) =\u003e timeout,\n                None =\u003e DEFAULT_ENDPOINT_TIMEOUT,\n            },\n\n            next_handshake_handle: Default::default(),\n            identity_clients: Default::default(),\n            identity_servers: Default::default(),\n            endpoint_clients: Default::default(),\n            endpoint_servers: Default::default(),\n\n            identity_listener: None,\n            identity_server_published: false,\n            endpoint_listeners: Default::default(),\n\n            identity_private_key,\n            identity_service_id,\n        })\n    }\n\n    pub fn bootstrap(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.tor_provider.bootstrap()?;\n        Ok(())\n    }\n\n    pub fn identity_client_begin_handshake(\n        \u0026mut self,\n        identity_server_id: V3OnionServiceId,\n        endpoint: String,\n    ) -\u003e Result\u003cHandshakeHandle, Error\u003e {\n        let endpoint = match AsciiString::new(endpoint) {\n            Ok(endpoint) =\u003e endpoint,\n            Err(_) =\u003e {\n                return Err(Error::InvalidArgument(\n                    \"endpoint must be an ASCII string\".to_string(),\n                ))\n            }\n        };\n\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        // open tcp stream to remove ident server\n        let stream: TcpStream = self\n            .tor_provider\n            .connect(\u0026identity_server_id, self.identity_port, None)?\n            .into();\n        stream.set_nonblocking(true)?;\n        let mut client_rpc = Session::new(stream);\n        client_rpc.set_max_wait_time(self.identity_timeout);\n        client_rpc.set_max_message_size(self.identity_max_message_size)?;\n\n        let ident_client = IdentityClient::new(\n            client_rpc,\n            identity_server_id,\n            endpoint,\n            self.identity_private_key.clone(),\n            X25519PrivateKey::generate(),\n        )?;\n\n        let handshake_handle = self.next_handshake_handle;\n        self.next_handshake_handle += 1;\n        self.identity_clients.insert(handshake_handle, ident_client);\n\n        Ok(handshake_handle)\n    }\n\n    pub fn identity_client_abort_handshake(\n        \u0026mut self,\n        handle: HandshakeHandle,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(_identity_client) = self.identity_clients.remove(\u0026handle) {\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    // sends an endpoint challenge response to a connected identity server as\n    // part of an identity handshake session\n    pub fn identity_client_handle_challenge_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        challenge_response: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_client) = self.identity_clients.get_mut(\u0026handle) {\n            identity_client.send_response(challenge_response)?;\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    // no-op if identity server is already running\n    pub fn identity_server_start(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n        if self.identity_listener.is_some() {\n            return Err(Error::IncorrectUsage(\n                \"identity server already started\".to_string(),\n            ));\n        }\n\n        let identity_listener =\n            self.tor_provider\n                .listener(\u0026self.identity_private_key, self.identity_port, None)?;\n        identity_listener.set_nonblocking(true)?;\n\n        self.identity_listener = Some(identity_listener);\n        Ok(())\n    }\n\n    pub fn identity_server_stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if self.identity_listener.is_none() {\n            return Err(Error::IncorrectUsage(\n                \"identity server is not started\".to_string(),\n            ));\n        }\n\n        // clear out current identity listener\n        self.identity_listener = None;\n        // clear out published flag\n        self.identity_server_published = false;\n        // clear out any in-process identity handshakes\n        self.identity_servers = Default::default();\n        Ok(())\n    }\n\n    // sends an endpoint challenge to a connected identity client as part of\n    // an identity handshake session abd save off wheether the requested endpoint\n    // is supported\n    pub fn identity_server_handle_endpoint_request_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        client_allowed: bool,\n        endpoint_supported: bool,\n        endpoint_challenge: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_server) = self.identity_servers.get_mut(\u0026handle) {\n            Ok(identity_server.handle_endpoint_request_received(\n                client_allowed,\n                endpoint_supported,\n                endpoint_challenge,\n            )?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    // confirm that a received endpoint challenge response is valid\n    pub fn identity_server_handle_challenge_response_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        challenge_response_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_server) = self.identity_servers.get_mut(\u0026handle) {\n            Ok(identity_server.handle_challenge_response_received(challenge_response_valid)?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    pub fn endpoint_client_begin_handshake(\n        \u0026mut self,\n        endpoint_server_id: V3OnionServiceId,\n        client_auth_key: X25519PrivateKey,\n        channel: String,\n    ) -\u003e Result\u003cHandshakeHandle, Error\u003e {\n        let channel = match AsciiString::new(channel) {\n            Ok(channel) =\u003e channel,\n            Err(_) =\u003e {\n                return Err(Error::InvalidArgument(\n                    \"channel must be an ASCII string\".to_string(),\n                ))\n            }\n        };\n\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        self.tor_provider\n            .add_client_auth(\u0026endpoint_server_id, \u0026client_auth_key)?;\n        let stream: TcpStream = self\n            .tor_provider\n            .connect(\u0026endpoint_server_id, self.endpoint_port, None)?\n            .into();\n        stream.set_nonblocking(true)?;\n\n        let mut session = Session::new(stream);\n        session.set_max_wait_time(self.endpoint_timeout);\n        session.set_max_message_size(DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE)?;\n\n        let endpoint_client = EndpointClient::new(\n            session,\n            endpoint_server_id,\n            channel,\n            self.identity_private_key.clone(),\n        );\n\n        let handshake_handle = self.next_handshake_handle;\n        self.next_handshake_handle += 1;\n        self.endpoint_clients\n            .insert(handshake_handle, endpoint_client);\n        Ok(handshake_handle)\n    }\n\n    pub fn endpoint_client_abort_handshake(\n        \u0026mut self,\n        handle: HandshakeHandle,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(_endpoint_client) = self.endpoint_clients.remove(\u0026handle) {\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    pub fn endpoint_server_start(\n        \u0026mut self,\n        endpoint_private_key: Ed25519PrivateKey,\n        endpoint_name: String,\n        client_identity: V3OnionServiceId,\n        client_auth: X25519PublicKey,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        let endpoint_public_key = Ed25519PublicKey::from_private_key(\u0026endpoint_private_key);\n        let endpoint_service_id = V3OnionServiceId::from_public_key(\u0026endpoint_public_key);\n\n        if endpoint_service_id == self.identity_service_id {\n            return Err(Error::InvalidArgument(\n                \"endpoint server must be different from identity server\".to_string(),\n            ));\n        }\n\n        if self.endpoint_listeners.contains_key(\u0026endpoint_service_id) {\n            return Err(Error::IncorrectUsage(\n                \"endpoint server already started\".to_string(),\n            ));\n        }\n\n        let endpoint_listener = self.tor_provider.listener(\n            \u0026endpoint_private_key,\n            self.endpoint_port,\n            Some(\u0026[client_auth]),\n        )?;\n        endpoint_listener.set_nonblocking(true)?;\n\n        self.endpoint_listeners.insert(\n            endpoint_service_id,\n            (endpoint_name, client_identity, endpoint_listener, false),\n        );\n        Ok(())\n    }\n\n    pub fn endpoint_server_handle_channel_request_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        channel_supported: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(endpoint_server) = self.endpoint_servers.get_mut(\u0026handle) {\n            Ok(endpoint_server.handle_channel_request_received(channel_supported)?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    pub fn endpoint_server_stop(\n        \u0026mut self,\n        endpoint_identity: V3OnionServiceId,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        if let Some(_listener) = self.endpoint_listeners.remove(\u0026endpoint_identity) {\n            Ok(())\n        } else {\n            Err(Error::InvalidArgument(format!(\n                \"endpoint server with service id {} not found\",\n                endpoint_identity\n            )))\n        }\n    }\n\n    fn identity_server_handle_accept(\n        identity_listener: \u0026OnionListener,\n        identity_timeout: Duration,\n        identity_max_message_size: i32,\n        identity_private_key: \u0026Ed25519PrivateKey,\n    ) -\u003e Result\u003cOption\u003cIdentityServer\u003e, Error\u003e {\n        if let Some(stream) = identity_listener.accept()? {\n            let stream: TcpStream = stream.into();\n            if stream.set_nonblocking(true).is_err() {\n                return Ok(None);\n            }\n\n            let mut server_rpc = Session::new(stream);\n            server_rpc.set_max_wait_time(identity_timeout);\n            server_rpc.set_max_message_size(identity_max_message_size)?;\n            let service_id = V3OnionServiceId::from_private_key(identity_private_key);\n            let identity_server = IdentityServer::new(server_rpc, service_id);\n\n            Ok(Some(identity_server))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn endpoint_server_handle_accept(\n        endpoint_listener: \u0026OnionListener,\n        endpoint_timeout: Duration,\n        client_service_id: \u0026V3OnionServiceId,\n        endpoint_service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003cOption\u003cEndpointServer\u003e, Error\u003e {\n        if let Some(stream) = endpoint_listener.accept()? {\n            let stream: TcpStream = stream.into();\n            if stream.set_nonblocking(true).is_err() {\n                return Ok(None);\n            }\n\n            let mut server_rpc = Session::new(stream);\n            server_rpc.set_max_wait_time(endpoint_timeout);\n            server_rpc.set_max_message_size(DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE)?;\n\n            let endpoint_server = EndpointServer::new(\n                server_rpc,\n                client_service_id.clone(),\n                endpoint_service_id.clone(),\n            );\n\n            Ok(Some(endpoint_server))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cVecDeque\u003cContextEvent\u003e, Error\u003e {\n        // events to return\n        let mut events: VecDeque\u003cContextEvent\u003e = Default::default();\n\n        // first handle new identity connections\n        if let Some(identity_listener) = \u0026self.identity_listener {\n            match Self::identity_server_handle_accept(\n                identity_listener,\n                self.identity_timeout,\n                self.identity_max_message_size,\n                \u0026self.identity_private_key,\n            ) {\n                Ok(Some(identity_server)) =\u003e {\n                    let handle = self.next_handshake_handle;\n                    self.next_handshake_handle += 1;\n                    self.identity_servers.insert(handle, identity_server);\n                    events.push_back(ContextEvent::IdentityServerHandshakeStarted { handle });\n                }\n                Ok(None) =\u003e {}\n                // identity listener failed, remove it\n                // TODO: signal caller identity listener is down\n                Err(_) =\u003e self.identity_listener = None,\n            }\n        }\n\n        // next handle new endpoint connections\n        self.endpoint_listeners.retain(\n            |endpoint_service_id, (_endpoint_name, allowed_client, listener, _published)| -\u003e bool {\n                match Self::endpoint_server_handle_accept(\n                    listener,\n                    self.endpoint_timeout,\n                    allowed_client,\n                    endpoint_service_id,\n                ) {\n                    Ok(Some(endpoint_server)) =\u003e {\n                        let handle = self.next_handshake_handle;\n                        self.next_handshake_handle += 1;\n                        self.endpoint_servers.insert(handle, endpoint_server);\n                        events.push_back(ContextEvent::EndpointServerHandshakeStarted { handle });\n                        true\n                    }\n                    Ok(None) =\u003e true,\n                    // endpoint listener failed, remove it\n                    // TODO: signal caller endpoint listener is down\n                    Err(_) =\u003e false,\n                }\n            },\n        );\n\n        // consume tor events\n        // TODO: so curently the only failure mode of this function is a result of the\n        // LegacyTorClient failing; we should probably consider a LegacyTorClient failure fatal, since\n        // reading the LegacyTorClient::update() function it seems the only failure modes are a\n        // failure to DEL_ONION (which realistically speaking could only be due to a logic\n        // error on our part by deleting an onion that doesn't exist, or a parse error of\n        // the response) and a failure to read async events which is either again a parsing\n        // bug on our end or a malformed/buggy tor daemon which we also cannot recover\n        // from.\n        for event in self.tor_provider.update()?.drain(..) {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e {\n                    events.push_back(ContextEvent::TorBootstrapStatusReceived {\n                        progress,\n                        tag,\n                        summary,\n                    });\n                }\n                TorEvent::BootstrapComplete =\u003e {\n                    events.push_back(ContextEvent::TorBootstrapCompleted);\n                    self.bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    events.push_back(ContextEvent::TorLogReceived { line });\n                }\n                TorEvent::OnionServicePublished { service_id } =\u003e {\n                    if service_id == self.identity_service_id {\n                        if !self.identity_server_published {\n                            events.push_back(ContextEvent::IdentityServerPublished);\n                            self.identity_server_published = true;\n                        }\n                    } else if let Some((endpoint_name, _, _, published)) =\n                        self.endpoint_listeners.get_mut(\u0026service_id)\n                    {\n                        // ingore duplicate publish events\n                        if !*published {\n                            events.push_back(ContextEvent::EndpointServerPublished {\n                                endpoint_service_id: service_id,\n                                endpoint_name: endpoint_name.clone(),\n                            });\n                            *published = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        // update the ident client handshakes\n        self.identity_clients\n            .retain(|handle, identity_client| -\u003e bool {\n                let handle = *handle;\n                match identity_client.update() {\n                    Ok(Some(IdentityClientEvent::ChallengeReceived { endpoint_challenge })) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientChallengeReceived {\n                            handle,\n                            endpoint_challenge,\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                        identity_service_id,\n                        endpoint_service_id,\n                        endpoint_name,\n                        client_auth_private_key,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientHandshakeCompleted {\n                            handle,\n                            identity_service_id,\n                            endpoint_service_id,\n                            endpoint_name,\n                            client_auth_private_key,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the ident server handshakes\n        self.identity_servers\n            .retain(|handle, identity_server| -\u003e bool {\n                let handle = *handle;\n                match identity_server.update() {\n                    Ok(Some(IdentityServerEvent::EndpointRequestReceived {\n                        client_service_id,\n                        requested_endpoint,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerEndpointRequestReceived {\n                            handle,\n                            client_service_id,\n                            requested_endpoint: requested_endpoint.to_string(),\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityServerEvent::ChallengeResponseReceived {\n                        challenge_response,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerChallengeResponseReceived {\n                            handle,\n                            challenge_response,\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityServerEvent::HandshakeCompleted {\n                        endpoint_private_key,\n                        endpoint_name,\n                        client_service_id,\n                        client_auth_public_key,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeCompleted {\n                            handle,\n                            endpoint_private_key,\n                            endpoint_name: endpoint_name.to_string(),\n                            client_service_id,\n                            client_auth_public_key,\n                        });\n                        false\n                    }\n                    Ok(Some(IdentityServerEvent::HandshakeRejected {\n                        client_allowed,\n                        client_requested_endpoint_valid,\n                        client_proof_signature_valid,\n                        client_auth_signature_valid,\n                        challenge_response_valid,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeRejected {\n                            handle,\n                            client_allowed,\n                            client_requested_endpoint_valid,\n                            client_proof_signature_valid,\n                            client_auth_signature_valid,\n                            challenge_response_valid,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the endpoint client handshakes\n        self.endpoint_clients\n            .retain(|handle, endpoint_client| -\u003e bool {\n                let handle = *handle;\n                match endpoint_client.update() {\n                    Ok(Some(EndpointClientEvent::HandshakeCompleted { stream })) =\u003e {\n                        events.push_back(ContextEvent::EndpointClientHandshakeCompleted {\n                            handle,\n                            endpoint_service_id: endpoint_client.server_service_id.clone(),\n                            channel_name: endpoint_client.requested_channel.to_string(),\n                            stream,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::EndpointClientHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the endpoint server handshakes\n        self.endpoint_servers\n            .retain(|handle, endpoint_server| -\u003e bool {\n                let handle = *handle;\n                match endpoint_server.update() {\n                    Ok(Some(EndpointServerEvent::ChannelRequestReceived {\n                        requested_channel,\n                        client_service_id,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerChannelRequestReceived {\n                            handle,\n                            client_service_id,\n                            requested_channel: requested_channel.to_string(),\n                        });\n                        true\n                    }\n                    Ok(Some(EndpointServerEvent::HandshakeCompleted {\n                        client_service_id,\n                        channel_name,\n                        stream,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeCompleted {\n                            handle,\n                            endpoint_service_id: endpoint_server.server_identity.clone(),\n                            client_service_id,\n                            channel_name: channel_name.to_string(),\n                            stream,\n                        });\n                        false\n                    }\n                    Ok(Some(EndpointServerEvent::HandshakeRejected {\n                        client_allowed,\n                        client_requested_channel_valid,\n                        client_proof_signature_valid,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeRejected {\n                            handle,\n                            client_allowed,\n                            client_requested_channel_valid,\n                            client_proof_signature_valid,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        Ok(events)\n    }\n}\n","traces":[{"line":225,"address":[2287903,2286672,2287862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[2286819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[2287381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[2286892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[2286926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[2286976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[2286951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[2287061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[2287080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[2287140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[2287200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[2287260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[2287272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[2287340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[2287936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[2287952,2288038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[2288025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[2288096,2290405,2290661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[2288174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[2288254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[2290733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[2288365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2288400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[2288476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[2288595,2288544,2290633,2288518,2288847],"length":1,"stats":{"Line":6},"fn_name":null},{"line":289,"address":[2288532,2288815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[2288895,2289067,2290577,2288970],"length":1,"stats":{"Line":4},"fn_name":null},{"line":292,"address":[2289028,2289109],"length":1,"stats":{"Line":4},"fn_name":null},{"line":293,"address":[2289117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[2290512,2289469,2288166,2289188],"length":1,"stats":{"Line":4},"fn_name":null},{"line":297,"address":[2289287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[2289343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[2289390],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[2289435,2289651],"length":1,"stats":{"Line":4},"fn_name":null},{"line":301,"address":[2289659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[2289937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":305,"address":[2289954,2290229,2290139],"length":1,"stats":{"Line":4},"fn_name":null},{"line":306,"address":[2290298,2290143],"length":1,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[2290327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":311,"address":[2290880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2290910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2291005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[2291033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[2291152,2291732,2291760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[2291286,2291484,2291199,2291557],"length":1,"stats":{"Line":6},"fn_name":null},{"line":330,"address":[2291186,2291334,2291567,2291705,2291489],"length":1,"stats":{"Line":6},"fn_name":null},{"line":331,"address":[2291550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[2291441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[2291776,2292664,2292696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[2291806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[2291828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[2291859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[2292062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[2292032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[2291937,2292145,2291900,2292283],"length":1,"stats":{"Line":6},"fn_name":null},{"line":350,"address":[2291908,2292235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[2292201,2291798,2292481,2292355],"length":1,"stats":{"Line":6},"fn_name":null},{"line":353,"address":[2292520,2292418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[2292617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[2292720,2293193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[2292756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[2292840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[2292810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[2292777,2292912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[2293003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[2293010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[2293173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[2293216,2293856,2293885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[2293294,2293604,2293677,2293381],"length":1,"stats":{"Line":6},"fn_name":null},{"line":384,"address":[2293521,2293828,2293609,2293262,2293790],"length":1,"stats":{"Line":6},"fn_name":null},{"line":387,"address":[2293442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":390,"address":[2293561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[2293904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[2294160,2293960,2294146],"length":1,"stats":{"Line":4},"fn_name":null},{"line":401,"address":[2294153,2294162,2294026,2293938],"length":1,"stats":{"Line":6},"fn_name":null},{"line":403,"address":[2294103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[2294224,2296388,2296804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[2294292,2294396],"length":1,"stats":{"Line":4},"fn_name":null},{"line":414,"address":[2294407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[2296667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[2294521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[2294556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[2294632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[2294679,2296572,2294890,2294722],"length":1,"stats":{"Line":4},"fn_name":null},{"line":427,"address":[2294858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[2294794,2294821,2296570,2295171,2294919],"length":1,"stats":{"Line":6},"fn_name":null},{"line":430,"address":[2295139,2294809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[2296514,2295391,2295219,2295294],"length":1,"stats":{"Line":4},"fn_name":null},{"line":434,"address":[2295352,2295433],"length":1,"stats":{"Line":4},"fn_name":null},{"line":435,"address":[2295441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[2295508,2294284,2295788],"length":1,"stats":{"Line":4},"fn_name":null},{"line":439,"address":[2295606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[2295662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[2295709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[2295754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[2296062],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[2296201,2296079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[2296182,2296113],"length":1,"stats":{"Line":4},"fn_name":null},{"line":448,"address":[2296124,2296270],"length":1,"stats":{"Line":4},"fn_name":null},{"line":449,"address":[2296304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[2296832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[2296862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[2296960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[2296988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[2297104,2298338,2298595],"length":1,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[2297154],"length":1,"stats":{"Line":2},"fn_name":null},{"line":471,"address":[2297192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[2297223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[2297302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[2297334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":478,"address":[2298442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[2297402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[2297436,2297375],"length":1,"stats":{"Line":4},"fn_name":null},{"line":484,"address":[2298354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[2297555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[2297769,2298347,2297585,2297457,2297523],"length":1,"stats":{"Line":6},"fn_name":null},{"line":492,"address":[2297472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":494,"address":[2297146,2297844,2297703,2298187],"length":1,"stats":{"Line":6},"fn_name":null},{"line":496,"address":[2298147,2297921],"length":1,"stats":{"Line":4},"fn_name":null},{"line":497,"address":[2297925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[2297989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":500,"address":[2298250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":503,"address":[2298608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":508,"address":[2298864,2298850,2298664],"length":1,"stats":{"Line":4},"fn_name":null},{"line":509,"address":[2298642,2298730,2298857,2298866],"length":1,"stats":{"Line":6},"fn_name":null},{"line":511,"address":[2298807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[2299693,2299661,2298928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[2298963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[2298985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[2299105,2299021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[2299225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[2299444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[2299712,2301110,2301028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[2299802,2300245],"length":1,"stats":{"Line":4},"fn_name":null},{"line":540,"address":[2300142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":541,"address":[2300181,2300296],"length":1,"stats":{"Line":4},"fn_name":null},{"line":542,"address":[2301042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[2300419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":546,"address":[2300470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[2300655,2299763,2300534],"length":1,"stats":{"Line":4},"fn_name":null},{"line":548,"address":[2300628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[2300796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[2300867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[2300215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":557,"address":[2302701,2302558,2301200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":563,"address":[2301275,2301726],"length":1,"stats":{"Line":4},"fn_name":null},{"line":564,"address":[2301623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":565,"address":[2301777,2301662],"length":1,"stats":{"Line":4},"fn_name":null},{"line":566,"address":[2302633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[2301900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":570,"address":[2301951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[2302179,2301236,2302011],"length":1,"stats":{"Line":4},"fn_name":null},{"line":574,"address":[2302105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":575,"address":[2302164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":576,"address":[2302374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[2302436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":581,"address":[2301696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":585,"address":[2302784,2303598,2305557],"length":1,"stats":{"Line":2},"fn_name":null},{"line":587,"address":[2302829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[2302853,2303727],"length":1,"stats":{"Line":4},"fn_name":null},{"line":591,"address":[2302942,2304605,2303084],"length":1,"stats":{"Line":4},"fn_name":null},{"line":593,"address":[2302913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":594,"address":[2302920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[2302927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":597,"address":[2303211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[2303250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":599,"address":[2303387,2303267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":600,"address":[2303301,2303457],"length":1,"stats":{"Line":4},"fn_name":null},{"line":601,"address":[2303481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":606,"address":[2303143,2303612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[2302957,2303021],"length":1,"stats":{"Line":4},"fn_name":null},{"line":612,"address":[2302964],"length":1,"stats":{"Line":6},"fn_name":null},{"line":613,"address":[2731018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":615,"address":[2731009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":619,"address":[2731090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":620,"address":[2731126],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[2731146,2731217,2731310],"length":1,"stats":{"Line":4},"fn_name":null},{"line":622,"address":[2731224,2731380],"length":1,"stats":{"Line":4},"fn_name":null},{"line":623,"address":[2731409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":624,"address":[2731458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":626,"address":[2731083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":629,"address":[2731076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[2304288,2303759],"length":1,"stats":{"Line":4},"fn_name":null},{"line":644,"address":[2304254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":645,"address":[2304607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":650,"address":[2305047,2304685],"length":1,"stats":{"Line":4},"fn_name":null},{"line":656,"address":[2305064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":657,"address":[2304811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[2305057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":660,"address":[2304846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":661,"address":[2305069,2304878],"length":1,"stats":{"Line":4},"fn_name":null},{"line":663,"address":[2304957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":664,"address":[2305021,2305078],"length":1,"stats":{"Line":4},"fn_name":null},{"line":665,"address":[2305122,2305536],"length":1,"stats":{"Line":4},"fn_name":null},{"line":666,"address":[2305492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":667,"address":[2305529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[2305153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":673,"address":[2305477,2305234],"length":1,"stats":{"Line":4},"fn_name":null},{"line":674,"address":[2305331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":675,"address":[2305248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":676,"address":[2305312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":678,"address":[2305474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":686,"address":[2304329,2304312],"length":1,"stats":{"Line":4},"fn_name":null},{"line":687,"address":[2304321],"length":1,"stats":{"Line":4},"fn_name":null},{"line":688,"address":[2731649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":689,"address":[2731927,2731673],"length":1,"stats":{"Line":4},"fn_name":null},{"line":690,"address":[2732005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":691,"address":[2732042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":695,"address":[2732125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":698,"address":[2732135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":699,"address":[2732162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":700,"address":[2732199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":701,"address":[2732238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":703,"address":[2732302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[2732525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":712,"address":[2731764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[2731838,2731796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[2731804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[2731913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[2731920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":724,"address":[2304370,2304353],"length":1,"stats":{"Line":4},"fn_name":null},{"line":725,"address":[2304362],"length":1,"stats":{"Line":4},"fn_name":null},{"line":726,"address":[2732673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":727,"address":[2732697,2732951,2733052],"length":1,"stats":{"Line":4},"fn_name":null},{"line":729,"address":[2733059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":730,"address":[2733123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":732,"address":[2733149,2733800],"length":1,"stats":{"Line":4},"fn_name":null},{"line":735,"address":[2733157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":737,"address":[2733941],"length":1,"stats":{"Line":2},"fn_name":null},{"line":740,"address":[2733187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":742,"address":[2733224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":746,"address":[2733307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":749,"address":[2733317],"length":1,"stats":{"Line":2},"fn_name":null},{"line":750,"address":[2733377],"length":1,"stats":{"Line":2},"fn_name":null},{"line":751,"address":[2733403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":752,"address":[2733467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":754,"address":[2734036,2733499],"length":1,"stats":{"Line":4},"fn_name":null},{"line":756,"address":[2733515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":757,"address":[2733517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":761,"address":[2734270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":764,"address":[2733557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[2733574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[2733591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[2733606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[2733621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[2733640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[2733736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[2732788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[2732820,2732862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[2732828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[2732937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[2732944],"length":1,"stats":{"Line":2},"fn_name":null},{"line":792,"address":[2304394,2304414],"length":1,"stats":{"Line":4},"fn_name":null},{"line":793,"address":[2304406],"length":1,"stats":{"Line":4},"fn_name":null},{"line":794,"address":[2734438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":795,"address":[2734470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":796,"address":[2734720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":797,"address":[2734907,2734739],"length":1,"stats":{"Line":4},"fn_name":null},{"line":799,"address":[2734747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":800,"address":[2734856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":801,"address":[2734892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":803,"address":[2735055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":805,"address":[2734551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[2734579,2734621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[2734587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[2734696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[2734703],"length":1,"stats":{"Line":2},"fn_name":null},{"line":817,"address":[2304438,2304458],"length":1,"stats":{"Line":4},"fn_name":null},{"line":818,"address":[2304450],"length":1,"stats":{"Line":4},"fn_name":null},{"line":819,"address":[2735254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":820,"address":[2735536,2735645,2735286],"length":1,"stats":{"Line":4},"fn_name":null},{"line":822,"address":[2735652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":823,"address":[2735678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":825,"address":[2735739,2736124],"length":1,"stats":{"Line":4},"fn_name":null},{"line":828,"address":[2735747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":830,"address":[2736265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":833,"address":[2735787],"length":1,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[2735848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":835,"address":[2735874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":837,"address":[2735896,2736404],"length":1,"stats":{"Line":4},"fn_name":null},{"line":839,"address":[2735904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":841,"address":[2736352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":842,"address":[2736389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":844,"address":[2736616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[2735939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[2735954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[2735969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[2735988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[2736060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[2735377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[2735447,2735405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":862,"address":[2735413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[2735522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":866,"address":[2735529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":870,"address":[2304482],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":222,"coverable":295},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","endpoint_client.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{RequestCookie, Response, Session};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Endpoint Client\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"client received unexpected response: {0}\")]\n    UnexpectedResponseReceived(String),\n\n    #[error(\"client is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n}\n\npub(crate) enum EndpointClientEvent {\n    HandshakeCompleted { stream: TcpStream },\n}\n\n#[derive(Debug, PartialEq)]\nenum EndpointClientState {\n    BeginHandshake,\n    WaitingForServerCookie,\n    WaitingForProofVerification,\n    HandshakeComplete,\n}\n\npub(crate) struct EndpointClient {\n    // session data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    pub server_service_id: V3OnionServiceId,\n    pub requested_channel: AsciiString,\n    client_service_id: V3OnionServiceId,\n    client_ed25519_private: Ed25519PrivateKey,\n\n    // state machine data\n    state: EndpointClientState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n}\n\nimpl EndpointClient {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, send_response_request_cookie: {:?} }}\", self.state, self.begin_handshake_request_cookie, self.send_response_request_cookie)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        server_service_id: V3OnionServiceId,\n        requested_channel: AsciiString,\n        client_ed25519_private: Ed25519PrivateKey,\n    ) -\u003e Self {\n        Self {\n            rpc: Some(rpc),\n            server_service_id,\n            requested_channel,\n            client_service_id: V3OnionServiceId::from_private_key(\u0026client_ed25519_private),\n            client_ed25519_private,\n\n            state: EndpointClientState::BeginHandshake,\n            begin_handshake_request_cookie: None,\n            send_response_request_cookie: None,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cEndpointClientEvent\u003e, Error\u003e {\n        if self.state == EndpointClientState::HandshakeComplete {\n            return Err(Error::IncorrectUsage(\"update() may not be called after HandshakeComplete has been returned from previous update() call\".to_string()));\n        }\n\n        // update our rpc session\n        if let Some(rpc) = self.rpc.as_mut() {\n            rpc.update(None)?;\n\n            // client state machine\n            match (\n                \u0026self.state,\n                self.begin_handshake_request_cookie,\n                self.send_response_request_cookie,\n            ) {\n                (\u0026EndpointClientState::BeginHandshake, None, None) =\u003e {\n                    self.begin_handshake_request_cookie = Some(rpc.client_call(\n                        \"gosling_endpoint\",\n                        \"begin_handshake\",\n                        0,\n                        doc! {\n                            \"version\" : bson::Bson::String(GOSLING_PROTOCOL_VERSION.to_string()),\n                            \"client_identity\" : bson::Bson::String(self.client_service_id.to_string()),\n                            \"channel\" : bson::Bson::String(self.requested_channel.to_string()),\n                        },\n                    ).unwrap());\n                    self.state = EndpointClientState::WaitingForServerCookie;\n                    Ok(None)\n                }\n                (\n                    \u0026EndpointClientState::WaitingForServerCookie,\n                    Some(begin_handshake_request_cookie),\n                    None, // send_response_request_cookie\n                ) =\u003e {\n                    if let Some(response) = rpc.client_next_response() {\n                        let result = match response {\n                            Response::Pending { cookie } =\u003e {\n                                if cookie == begin_handshake_request_cookie {\n                                    return Ok(None);\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected pending response\".to_string(),\n                                    ));\n                                }\n                            }\n                            Response::Error { cookie, error_code } =\u003e {\n                                if cookie != begin_handshake_request_cookie {\n                                    return Err(Error::UnexpectedResponseReceived(format!(\n                                        \"received unexpected error response; rpc error_code: {}\",\n                                        error_code\n                                    )));\n                                }\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            Response::Success { cookie, result } =\u003e {\n                                if cookie == begin_handshake_request_cookie {\n                                    result\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected success response\".to_string(),\n                                    ));\n                                }\n                            }\n                        };\n\n                        if let bson::Bson::Document(result) = result {\n                            if let Some(Bson::Binary(Binary {\n                                subtype: BinarySubtype::Generic,\n                                bytes: server_cookie,\n                            })) = result.get(\"server_cookie\")\n                            {\n                                // build arguments for send_response()\n\n                                // client_cookie\n                                let mut client_cookie: ClientCookie = Default::default();\n                                OsRng.fill_bytes(\u0026mut client_cookie);\n\n                                // client_identity_proof_signature\n                                let server_cookie: ServerCookie =\n                                    match server_cookie.clone().try_into() {\n                                        Ok(server_cookie) =\u003e server_cookie,\n                                        Err(_) =\u003e {\n                                            return Err(Error::UnexpectedResponseReceived(format!(\n                                                \"unable to convert '{:?}' to server cookie\",\n                                                server_cookie\n                                            )))\n                                        }\n                                    };\n                                let client_identity_proof = build_client_proof(\n                                    DomainSeparator::GoslingEndpoint,\n                                    \u0026self.requested_channel,\n                                    \u0026self.client_service_id,\n                                    \u0026self.server_service_id,\n                                    \u0026client_cookie,\n                                    \u0026server_cookie,\n                                );\n                                let client_identity_proof_signature = self\n                                    .client_ed25519_private\n                                    .sign_message(\u0026client_identity_proof);\n\n                                // build our args object for rpc call\n                                let args = doc! {\n                                    \"client_cookie\" : Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_cookie.to_vec()}),\n                                    \"client_identity_proof_signature\" : Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}),\n                                };\n\n                                // make rpc call\n                                self.send_response_request_cookie = Some(\n                                    rpc.client_call(\"gosling_endpoint\", \"send_response\", 0, args)\n                                        .unwrap(),\n                                );\n\n                                self.state = EndpointClientState::WaitingForProofVerification;\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"begin_handshake() returned unexpected value: {}\",\n                                    result\n                                )));\n                            }\n                        } else {\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"begin_handshake() returned unexpected value: {}\",\n                                result\n                            )));\n                        }\n                    }\n                    Ok(None)\n                }\n                (\n                    \u0026EndpointClientState::WaitingForProofVerification,\n                    Some(_begin_handshake_request_cookie),\n                    Some(send_response_request_cookie),\n                ) =\u003e {\n                    if let Some(response) = rpc.client_next_response() {\n                        let result = match response {\n                            Response::Pending { cookie } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    return Ok(None);\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected pending response\".to_string(),\n                                    ));\n                                }\n                            }\n                            Response::Error { cookie, error_code } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    return Err(Error::UnexpectedResponseReceived(format!(\n                                        \"received unexpected error response; rpc error_code: {}\",\n                                        error_code\n                                    )));\n                                }\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            Response::Success { cookie, result } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    result\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected success response\".to_string(),\n                                    ));\n                                }\n                            }\n                        };\n\n                        if let Bson::Document(result) = result {\n                            if result.is_empty() {\n                                self.state = EndpointClientState::HandshakeComplete;\n                                let stream = std::mem::take(\u0026mut self.rpc).unwrap().into_stream();\n                                return Ok(Some(EndpointClientEvent::HandshakeCompleted {\n                                    stream,\n                                }));\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected data from send_response(): {:?}\",\n                                    result\n                                )));\n                            }\n                        } else {\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"received unexpected data from send_response(): {:?}\",\n                                result\n                            )));\n                        }\n                    }\n                    Ok(None)\n                }\n                _ =\u003e Err(Error::InvalidState(self.get_state())),\n            }\n        } else {\n            Err(Error::InvalidState(self.get_state()))\n        }\n    }\n}\n","traces":[{"line":65,"address":[2710928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[2711118,2711066,2710952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2711652,2711216,2711693],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[2711265],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[2711300],"length":1,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[2713787,2711712],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[2711792],"length":1,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[2711899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2712021,2712262,2711847],"length":1,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[2712410,2712045,2711784,2714178],"length":1,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[2718624,2713817,2712300,2712588],"length":1,"stats":{"Line":12},"fn_name":null},{"line":99,"address":[2712275],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[2712285],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[2712292],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[2713323,2713673],"length":1,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[2713223,2713031,2712839,2712659,2712703],"length":1,"stats":{"Line":12},"fn_name":null},{"line":109,"address":[2712676,2712747],"length":1,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[2712913],"length":1,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[2713105],"length":1,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[2713716],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[2713737],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[2713840],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[2717185,2713864],"length":1,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[2714061],"length":1,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[2714188],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[2714204],"length":1,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[2714491],"length":1,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[2714397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[2714364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2714306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2714350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[2718372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[2718138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2714218],"length":1,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[2714284],"length":1,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[2714573],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[2714708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[2714546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[2714811,2714607],"length":1,"stats":{"Line":6},"fn_name":null},{"line":157,"address":[2715093,2714915],"length":1,"stats":{"Line":6},"fn_name":null},{"line":159,"address":[2715275],"length":1,"stats":{"Line":3},"fn_name":null},{"line":165,"address":[2715295],"length":1,"stats":{"Line":3},"fn_name":null},{"line":166,"address":[2715314],"length":1,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[2715346],"length":1,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[2715418],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[2717266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[2715593],"length":1,"stats":{"Line":3},"fn_name":null},{"line":181,"address":[2715601],"length":1,"stats":{"Line":3},"fn_name":null},{"line":182,"address":[2715611],"length":1,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[2715621],"length":1,"stats":{"Line":3},"fn_name":null},{"line":187,"address":[2715806,2715681],"length":1,"stats":{"Line":6},"fn_name":null},{"line":189,"address":[2715692],"length":1,"stats":{"Line":3},"fn_name":null},{"line":192,"address":[2715825,2715884,2716112,2716429],"length":1,"stats":{"Line":9},"fn_name":null},{"line":193,"address":[2715844,2715928],"length":1,"stats":{"Line":6},"fn_name":null},{"line":194,"address":[2716178],"length":1,"stats":{"Line":3},"fn_name":null},{"line":198,"address":[2716963],"length":1,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[2716599],"length":1,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[2717007],"length":1,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[2717544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[2717784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[2718569],"length":1,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[2718663],"length":1,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[2718684],"length":1,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[2718865],"length":1,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[2718998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[2719014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[2719289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[2719195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[2719162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[2719104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[2719148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[2721065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[2720831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2719028],"length":1,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[2719085],"length":1,"stats":{"Line":3},"fn_name":null},{"line":249,"address":[2719363],"length":1,"stats":{"Line":3},"fn_name":null},{"line":251,"address":[2719498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[2719336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[2719601,2719397],"length":1,"stats":{"Line":6},"fn_name":null},{"line":259,"address":[2719854,2719705],"length":1,"stats":{"Line":6},"fn_name":null},{"line":260,"address":[2719943],"length":1,"stats":{"Line":3},"fn_name":null},{"line":261,"address":[2719964,2720256],"length":1,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[2720298],"length":1,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[2720000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[2720477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[2718954],"length":1,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[2712478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[2712157],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":62,"coverable":88},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","endpoint_server.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{ApiSet, ErrorCode, RequestCookie, Session};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Endpoint Server\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"server is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"client sent invalid request\")]\n    BadClient,\n}\n\npub(crate) enum EndpointServerEvent {\n    ChannelRequestReceived {\n        client_service_id: V3OnionServiceId,\n        requested_channel: AsciiString,\n    },\n    // endpoint server has acepted incoming channel request from identity client\n    HandshakeCompleted {\n        client_service_id: V3OnionServiceId,\n        channel_name: AsciiString,\n        stream: TcpStream,\n    },\n    // endpoint server has reject an incoming channel request\n    HandshakeRejected {\n        client_allowed: bool,\n        client_requested_channel_valid: bool,\n        client_proof_signature_valid: bool,\n    },\n}\n\n#[derive(Debug, PartialEq)]\nenum EndpointServerState {\n    // valid/expected states\n    WaitingForBeginHandshake,\n    ValidatingChannelRequest,\n    ChannelRequestValidated,\n    WaitingForSendResponse,\n    HandledSendResponse,\n    HandshakeComplete,\n    // failure state\n    HandshakeFailed,\n}\n\npub(crate) struct EndpointServer {\n    // Session Data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    pub server_identity: V3OnionServiceId,\n    allowed_client_identity: V3OnionServiceId,\n\n    // State Machine Data\n    state: EndpointServerState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    client_identity: Option\u003cV3OnionServiceId\u003e,\n    requested_channel: Option\u003cAsciiString\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    handshake_succeeded: Option\u003cbool\u003e,\n\n    // Verification flags\n\n    // Client not on the block-list\n    client_allowed: bool,\n    // The requested endpoint is valid\n    client_requested_channel_valid: bool,\n    // The client proof is valid and signed with client's public key\n    client_proof_signature_valid: bool,\n}\n\nimpl EndpointServer {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, client_identity: {:?}, requested_channel: {:?}, server_cookie: {:?}, handshake_succeeded:{:?} }}\", self.state, self.begin_handshake_request_cookie, self.client_identity, self.requested_channel, self.server_cookie, self.handshake_succeeded)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        client_identity: V3OnionServiceId,\n        server_identity: V3OnionServiceId,\n    ) -\u003e Self {\n        // generate server cookie\n        let mut server_cookie: ServerCookie = Default::default();\n        OsRng.fill_bytes(\u0026mut server_cookie);\n\n        EndpointServer {\n            rpc: Some(rpc),\n            server_identity,\n            allowed_client_identity: client_identity,\n            state: EndpointServerState::WaitingForBeginHandshake,\n            begin_handshake_request_cookie: None,\n            requested_channel: None,\n            client_identity: None,\n            server_cookie: None,\n            handshake_succeeded: None,\n            client_allowed: false,\n            // TODO: hookup this to event and callback\n            client_requested_channel_valid: true,\n            client_proof_signature_valid: false,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cEndpointServerEvent\u003e, Error\u003e {\n        if let Some(mut rpc) = std::mem::take(\u0026mut self.rpc) {\n            match rpc.update(Some(\u0026mut [self])) {\n                Ok(()) =\u003e {\n                    self.rpc = Some(rpc);\n                }\n                Err(err) =\u003e {\n                    self.rpc = Some(rpc);\n                    return Err(err.into());\n                }\n            }\n        }\n\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_channel.as_ref(),\n              self.server_cookie.as_ref(),\n              self.handshake_succeeded) {\n            (\u0026EndpointServerState::WaitingForBeginHandshake,\n             None, // begin_handshake_request_cookie\n             None, // client_identity\n             None, // requested_channel\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::WaitingForBeginHandshake,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {\n                self.state = EndpointServerState::ValidatingChannelRequest;\n                return Ok(\n                        Some(\n                            EndpointServerEvent::ChannelRequestReceived\n                            {\n                                client_service_id: client_identity.clone(),\n                                requested_channel: requested_channel.clone()\n                            }));\n            },\n            (\u0026EndpointServerState::ValidatingChannelRequest,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::ChannelRequestValidated,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             Some(_server_cookie),\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             Some(_server_cookie),\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::HandledSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_channel),\n             Some(_server_cookie),\n             Some(handshake_succeeded))\n            =\u003e {\n                self.state = EndpointServerState::HandshakeComplete;\n                if handshake_succeeded {\n                    let stream = std::mem::take(\u0026mut self.rpc).unwrap().into_stream();\n                    return Ok(Some(EndpointServerEvent::HandshakeCompleted{\n                        client_service_id: client_identity.clone(),\n                        channel_name: requested_channel.clone(),\n                        stream}));\n                } else {\n                    return Ok(Some(EndpointServerEvent::HandshakeRejected{\n                        client_allowed: self.client_allowed,\n                        client_requested_channel_valid: self.client_requested_channel_valid,\n                        client_proof_signature_valid: self.client_proof_signature_valid}));\n                }\n            },\n            _ =\u003e {\n                if self.state == EndpointServerState::HandshakeFailed {\n                    return Err(Error::BadClient);\n                } else {\n                    return Err(Error::InvalidState(self.get_state()));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    pub fn handle_channel_request_received(\n        \u0026mut self,\n        client_requested_channel_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_channel.as_ref(),\n              self.server_cookie.as_ref(),\n              self.handshake_succeeded) {\n            (\u0026EndpointServerState::ValidatingChannelRequest,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(_requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {\n                let mut server_cookie: ServerCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut server_cookie);\n                self.server_cookie = Some(server_cookie);\n                self.client_allowed = *client_identity == self.allowed_client_identity;\n                self.client_requested_channel_valid = client_requested_channel_valid;\n                self.state = EndpointServerState::ChannelRequestValidated;\n                Ok(())\n            },\n            _ =\u003e Err(Error::IncorrectUsage(\"handle_channel_request_received() may only be called after ChannelRequestReceived has been returned from update(), and it may only be called once\".to_string()))\n        }\n    }\n}\n\nimpl ApiSet for EndpointServer {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"gosling_endpoint\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        let request_cookie = match request_cookie {\n            Some(request_cookie) =\u003e request_cookie,\n            None =\u003e return Err(ErrorCode::Runtime(RpcError::RequestCookieRequired as i32)),\n        };\n\n        match\n            (name, version,\n             \u0026self.state,\n             self.client_identity.as_ref(),\n             self.requested_channel.as_ref(),\n             self.server_cookie.as_ref()) {\n            // handle begin_handshake call\n            (\"begin_handshake\", 0,\n            \u0026EndpointServerState::WaitingForBeginHandshake,\n            None, // client_identity\n            None, // requested_channel\n            None) // server_cookie\n            =\u003e {\n                let valid_version = match args.remove(\"version\") {\n                    Some(Bson::String(value)) =\u003e value == GOSLING_PROTOCOL_VERSION,\n                    _ =\u003e false,\n                };\n                if !valid_version {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    return Err(ErrorCode::Runtime(RpcError::BadVersion as i32));\n                }\n\n                if let (\n                    Some(Bson::String(client_identity)),\n                    Some(Bson::String(channel_name))\n                ) = (\n                    args.remove(\"client_identity\"),\n                    args.remove(\"channel\")\n                ) {\n                    // client_identiity\n                    self.client_identity = match V3OnionServiceId::from_string(\u0026client_identity) {\n                        Ok(client_identity) =\u003e Some(client_identity),\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    let channel_name = match AsciiString::new(channel_name) {\n                        Ok(channel_name) =\u003e channel_name,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // save cookie\n                    self.begin_handshake_request_cookie = Some(request_cookie);\n\n                    // save channel name\n                    self.requested_channel = Some(channel_name);\n\n                    Ok(None)\n                } else {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    Err(ErrorCode::Runtime(RpcError::InvalidArg as i32))\n                }\n            },\n            (\"send_response\", 0,\n            \u0026EndpointServerState::WaitingForSendResponse,\n            Some(client_identity),\n            Some(requested_channel),\n            Some(server_cookie))\n            =\u003e {\n                if let (Some(Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: client_cookie})),\n                        Some(Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature}))) =\n                       (args.remove(\"client_cookie\"),\n                        args.remove(\"client_identity_proof_signature\")) {\n                    // client_cookie\n                    let client_cookie : ClientCookie = match client_cookie.try_into() {\n                        Ok(client_cookie) =\u003e client_cookie,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // client_identity_proof_signature\n                    let client_identity_proof_signature : [u8; ED25519_SIGNATURE_SIZE] = match client_identity_proof_signature.try_into() {\n                        Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n                    let client_identity_proof_signature = match Ed25519Signature::from_raw(\u0026client_identity_proof_signature) {\n                        Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // convert client_identity to client's public ed25519 key\n                    let client_identity_key = match Ed25519PublicKey::from_service_id(client_identity) {\n                        Ok(client_identity_key) =\u003e client_identity_key,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // construct + verify client proof\n                    let client_proof = build_client_proof(\n                        DomainSeparator::GoslingEndpoint,\n                        requested_channel,\n                        client_identity,\n                        \u0026self.server_identity,\n                        \u0026client_cookie,\n                        server_cookie,\n                    );\n                    self.client_proof_signature_valid =\n                        client_identity_proof_signature.verify(\u0026client_proof, \u0026client_identity_key);\n\n                    if self.client_allowed\n                        \u0026\u0026 self.client_requested_channel_valid\n                        \u0026\u0026 self.client_proof_signature_valid\n                    {\n                        self.handshake_succeeded = Some(true);\n                        self.state = EndpointServerState::HandledSendResponse;\n                        // success, return empty doc\n                        Ok(Some(Bson::Document(doc! {})))\n                    } else {\n                        self.handshake_succeeded = Some(false);\n                        self.state = EndpointServerState::HandledSendResponse;\n                        Err(ErrorCode::Runtime(RpcError::Failure as i32))\n                    }\n                } else {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    Err(ErrorCode::Runtime(RpcError::InvalidArg as i32))\n                }\n            },\n            _ =\u003e {\n                self.state = EndpointServerState::HandshakeFailed;\n                Err(ErrorCode::Runtime(RpcError::Failure as i32))\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie.as_ref(),\n        ) {\n            (\n                \u0026EndpointServerState::ChannelRequestValidated,\n                Some(begin_handshake_request_cookie),\n                Some(server_cookie),\n            ) =\u003e {\n                self.state = EndpointServerState::WaitingForSendResponse;\n                Some((\n                    begin_handshake_request_cookie,\n                    Some(Bson::Document(doc! {\n                        \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                    })),\n                    ErrorCode::Success,\n                ))\n            }\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":95,"address":[2400304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[2400337,2400522,2400714,2400457,2400587,2400652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[2401358,2400864],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[2400896],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[2400953],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2400984],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[2402600,2401392],"length":1,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[2401443],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[2401755,2401593],"length":1,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[2402138,2401790],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[2401906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[2402026,2402238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2402321,2402520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2402671,2403864,2403683,2402975,2404258,2402818,2403297,2404061],"length":1,"stats":{"Line":18},"fn_name":null},{"line":139,"address":[2402685],"length":1,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[2402702],"length":1,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[2402731],"length":1,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[2402760],"length":1,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[2402812],"length":1,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[2403400],"length":1,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[2403453],"length":1,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[2403635],"length":1,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[2403601],"length":1,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[2403505],"length":1,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[2403474],"length":1,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[2403492],"length":1,"stats":{"Line":3},"fn_name":null},{"line":167,"address":[2403827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[2403859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[2404024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[2404056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[2404237],"length":1,"stats":{"Line":3},"fn_name":null},{"line":187,"address":[2404253],"length":1,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[2404452],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[2404487],"length":1,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[2404508],"length":1,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[2404679,2404771],"length":1,"stats":{"Line":6},"fn_name":null},{"line":198,"address":[2404882],"length":1,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[2404800],"length":1,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[2404864],"length":1,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[2404871],"length":1,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[2404542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[2404524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[2404530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[2404536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[2402943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[2405179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[2405061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[2403231],"length":1,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[2405232],"length":1,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[2405415,2405596,2405285],"length":1,"stats":{"Line":9},"fn_name":null},{"line":226,"address":[2405300],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[2405317],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[2405340],"length":1,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[2405363],"length":1,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[2405409],"length":1,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[2405749],"length":1,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[2405762],"length":1,"stats":{"Line":3},"fn_name":null},{"line":239,"address":[2405787],"length":1,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[2405814],"length":1,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[2405921],"length":1,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[2405961],"length":1,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[2405970],"length":1,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[2405991],"length":1,"stats":{"Line":3},"fn_name":null},{"line":246,"address":[2405477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[2406032],"length":1,"stats":{"Line":3},"fn_name":"namespace"},{"line":256,"address":[2407214,2414288,2406064],"length":1,"stats":{"Line":3},"fn_name":"exec_function"},{"line":263,"address":[2406191],"length":1,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[2406339],"length":1,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[2406274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2406744,2410641,2410703,2406831,2410620,2406723,2406802,2410736,2406773,2410670],"length":1,"stats":{"Line":30},"fn_name":null},{"line":269,"address":[2406779,2410647,2406808,2410630,2406577,2406750,2406733,2410713,2410680],"length":1,"stats":{"Line":27},"fn_name":null},{"line":270,"address":[2406360],"length":1,"stats":{"Line":3},"fn_name":null},{"line":271,"address":[2406377],"length":1,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[2406474],"length":1,"stats":{"Line":3},"fn_name":null},{"line":273,"address":[2406505],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[2406632],"length":1,"stats":{"Line":3},"fn_name":null},{"line":281,"address":[2406849],"length":1,"stats":{"Line":3},"fn_name":null},{"line":282,"address":[2406976],"length":1,"stats":{"Line":3},"fn_name":null},{"line":283,"address":[2406963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[2407339],"length":1,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[2407421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[2407442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[2407858,2407696],"length":1,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[2407951],"length":1,"stats":{"Line":3},"fn_name":null},{"line":292,"address":[2407991],"length":1,"stats":{"Line":3},"fn_name":null},{"line":294,"address":[2407510],"length":1,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[2407549],"length":1,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[2408047,2408115,2408300],"length":1,"stats":{"Line":9},"fn_name":null},{"line":299,"address":[2408164],"length":1,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[2408395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[2408416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[2408498],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[2408572],"length":1,"stats":{"Line":3},"fn_name":null},{"line":309,"address":[2408708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[2408729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2408817],"length":1,"stats":{"Line":3},"fn_name":null},{"line":318,"address":[2409024,2408860],"length":1,"stats":{"Line":3},"fn_name":null},{"line":320,"address":[2409149],"length":1,"stats":{"Line":3},"fn_name":null},{"line":322,"address":[2407782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[2407803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[2410796],"length":1,"stats":{"Line":3},"fn_name":null},{"line":332,"address":[2411334],"length":1,"stats":{"Line":4},"fn_name":null},{"line":335,"address":[2410856],"length":1,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[2411450,2411382],"length":1,"stats":{"Line":6},"fn_name":null},{"line":338,"address":[2411468],"length":1,"stats":{"Line":3},"fn_name":null},{"line":340,"address":[2411567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[2411588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[2411665],"length":1,"stats":{"Line":3},"fn_name":null},{"line":347,"address":[2411754],"length":1,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[2411917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[2411938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[2412015],"length":1,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[2412064],"length":1,"stats":{"Line":3},"fn_name":null},{"line":356,"address":[2412227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[2412248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[2412335],"length":1,"stats":{"Line":3},"fn_name":null},{"line":363,"address":[2412365],"length":1,"stats":{"Line":3},"fn_name":null},{"line":365,"address":[2412470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[2412491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[2412589],"length":1,"stats":{"Line":3},"fn_name":null},{"line":375,"address":[2412597],"length":1,"stats":{"Line":3},"fn_name":null},{"line":379,"address":[2412767],"length":1,"stats":{"Line":3},"fn_name":null},{"line":380,"address":[2412724,2412641],"length":1,"stats":{"Line":6},"fn_name":null},{"line":382,"address":[2412776,2413130,2412898],"length":1,"stats":{"Line":7},"fn_name":null},{"line":383,"address":[2412908],"length":1,"stats":{"Line":3},"fn_name":null},{"line":384,"address":[2412929],"length":1,"stats":{"Line":3},"fn_name":null},{"line":386,"address":[2412950],"length":1,"stats":{"Line":3},"fn_name":null},{"line":387,"address":[2412971],"length":1,"stats":{"Line":3},"fn_name":null},{"line":389,"address":[2412992,2413030],"length":1,"stats":{"Line":6},"fn_name":null},{"line":391,"address":[2412801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[2412822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[2412843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[2411089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[2411110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[2410542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[2410563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[2415103,2414304],"length":1,"stats":{"Line":3},"fn_name":"next_result"},{"line":408,"address":[2414467,2414402],"length":1,"stats":{"Line":6},"fn_name":null},{"line":409,"address":[2414342],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[2414357],"length":1,"stats":{"Line":3},"fn_name":null},{"line":411,"address":[2414374],"length":1,"stats":{"Line":3},"fn_name":null},{"line":413,"address":[2414515],"length":1,"stats":{"Line":3},"fn_name":null},{"line":418,"address":[2414533],"length":1,"stats":{"Line":3},"fn_name":null},{"line":419,"address":[2415011],"length":1,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[2414548,2414602,2414830],"length":1,"stats":{"Line":6},"fn_name":null},{"line":422,"address":[2414646,2414570],"length":1,"stats":{"Line":6},"fn_name":null},{"line":424,"address":[2415000],"length":1,"stats":{"Line":3},"fn_name":null},{"line":427,"address":[2414449],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":113,"coverable":148},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","gosling.rs"],"content":"// standard\n#[cfg(test)]\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// extern crates\n#[cfg(test)]\nuse bson::doc;\nuse data_encoding::HEXLOWER;\n#[cfg(test)]\nuse honk_rpc::honk_rpc::Session;\nuse num_enum::TryFromPrimitive;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::context;\nuse crate::endpoint_client;\n#[cfg(test)]\nuse crate::endpoint_client::*;\nuse crate::endpoint_server;\n#[cfg(test)]\nuse crate::endpoint_server::*;\nuse crate::identity_client;\n#[cfg(test)]\nuse crate::identity_client::*;\nuse crate::identity_server;\n#[cfg(test)]\nuse crate::identity_server::*;\n\n#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]\n#[repr(i32)]\n/// cbindgen:ignore\npub enum RpcError {\n    // bad gosling version\n    BadVersion,\n    // cookie required\n    RequestCookieRequired,\n    // invalid or missing arguments\n    InvalidArg,\n    // generic runtime error\n    Failure,\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"invalid argument: {0}\")]\n    InvalidArgument(String),\n\n    #[error(\n        \"context is not connected, must call bootstrap() and wait for TorBootstrapCompleted event\"\n    )]\n    TorNotConnected(),\n\n    #[error(\"handshake handle {0} not found\")]\n    HandshakeHandleNotFound(context::HandshakeHandle),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(transparent)]\n    Io(#[from] std::io::Error),\n\n    #[error(transparent)]\n    HonkRpc(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(transparent)]\n    TorCrypto(#[from] tor_interface::tor_crypto::Error),\n\n    #[error(transparent)]\n    TorProvider(#[from] tor_interface::tor_provider::Error),\n\n    #[error(transparent)]\n    IdentityClientError(#[from] identity_client::Error),\n\n    #[error(transparent)]\n    IdentityServerError(#[from] identity_server::Error),\n\n    #[error(transparent)]\n    EndpointClientError(#[from] endpoint_client::Error),\n\n    #[error(transparent)]\n    EndpointServerError(#[from] endpoint_server::Error),\n}\n\npub const GOSLING_CRATE_VERSION: \u0026str = std::env!(\"CARGO_PKG_VERSION\");\npub const GOSLING_PROTOCOL_VERSION: \u0026str = \"0.1.0\";\n\n\npub(crate) const CLIENT_COOKIE_SIZE: usize = 32usize;\npub(crate) const SERVER_COOKIE_SIZE: usize = 32usize;\n\npub(crate) type ClientCookie = [u8; CLIENT_COOKIE_SIZE];\npub(crate) type ServerCookie = [u8; SERVER_COOKIE_SIZE];\npub(crate) type ClientProof = Vec\u003cu8\u003e;\n\npub(crate) enum DomainSeparator {\n    GoslingIdentity,\n    GoslingEndpoint,\n}\n\nimpl From\u003cDomainSeparator\u003e for \u0026[u8] {\n    fn from(sep: DomainSeparator) -\u003e \u0026'static [u8] {\n        match sep {\n            DomainSeparator::GoslingIdentity =\u003e b\"gosling-identity\",\n            DomainSeparator::GoslingEndpoint =\u003e b\"gosling-endpoint\",\n        }\n    }\n}\n\npub(crate) fn build_client_proof(\n    domain_separator: DomainSeparator,\n    request: \u0026AsciiString,\n    client_service_id: \u0026V3OnionServiceId,\n    server_service_id: \u0026V3OnionServiceId,\n    client_cookie: \u0026ClientCookie,\n    server_cookie: \u0026ServerCookie,\n) -\u003e ClientProof {\n    let mut client_proof: ClientProof = Default::default();\n\n    client_proof.extend_from_slice(domain_separator.into());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(request.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(client_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(server_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(client_cookie).as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(server_cookie).as_bytes());\n\n    client_proof\n}\n\n//\n// Tests\n//\n\n#[cfg(test)]\nfn identity_test(\n    client_blocked: bool,\n    client_requested_endpoint: \u0026str,\n    client_requested_endpoint_valid: bool,\n    server_challenge: bson::document::Document,\n    client_response: bson::document::Document,\n    server_expected_response: bson::document::Document,\n    should_fail: bool,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // test sockets\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    // client setup\n    let client_ed25519_private = Ed25519PrivateKey::generate();\n\n    // server setup\n    let server_ed25519_private = Ed25519PrivateKey::generate();\n    let server_ed25519_public = Ed25519PublicKey::from_private_key(\u0026server_ed25519_private);\n    let server_service_id = V3OnionServiceId::from_public_key(\u0026server_ed25519_public);\n\n    let client_requested_endpoint = match AsciiString::new(client_requested_endpoint.to_string()) {\n        Ok(ascii) =\u003e ascii,\n        Err(_) =\u003e {\n            assert!(should_fail);\n            return Ok(());\n        }\n    };\n\n    // rpc setup\n    let client_rpc = Session::new(stream1);\n    let mut ident_client = IdentityClient::new(\n        client_rpc,\n        server_service_id.clone(),\n        client_requested_endpoint.clone(),\n        client_ed25519_private,\n        X25519PrivateKey::generate(),\n    )\n    .unwrap();\n\n    let server_rpc = Session::new(stream2);\n    let mut ident_server = IdentityServer::new(server_rpc, server_service_id.clone());\n\n    let mut failure_ocurred = false;\n    let mut server_complete = false;\n    let mut client_complete = false;\n    while !server_complete \u0026\u0026 !client_complete {\n        if !server_complete {\n            match ident_server.update() {\n                Ok(Some(IdentityServerEvent::EndpointRequestReceived {\n                    client_service_id,\n                    requested_endpoint,\n                })) =\u003e {\n                    println!(\n                        \"server challenge send: client_service_id {}, requested_endpoint: {}\",\n                        client_service_id.to_string(),\n                        requested_endpoint\n                    );\n                    let client_allowed = !client_blocked;\n                    ident_server.handle_endpoint_request_received(\n                        client_allowed,\n                        client_requested_endpoint_valid,\n                        server_challenge.clone(),\n                    )?;\n                }\n                Ok(Some(IdentityServerEvent::ChallengeResponseReceived { challenge_response })) =\u003e {\n                    println!(\"server challenge repsonse received\");\n                    ident_server.handle_challenge_response_received(\n                        challenge_response == server_expected_response,\n                    )?;\n                }\n                Ok(Some(IdentityServerEvent::HandshakeCompleted {\n                    endpoint_private_key: _,\n                    endpoint_name,\n                    client_service_id,\n                    client_auth_public_key: _,\n                })) =\u003e {\n                    assert!(endpoint_name == client_requested_endpoint);\n                    println!(\n                        \"server complete! client_service_id : {}\",\n                        client_service_id.to_string()\n                    );\n                    server_complete = true;\n                }\n                Ok(Some(IdentityServerEvent::HandshakeRejected {\n                    client_allowed,\n                    client_requested_endpoint_valid,\n                    client_proof_signature_valid,\n                    client_auth_signature_valid,\n                    challenge_response_valid,\n                })) =\u003e {\n                    println!(\"server complete! client request rejected\");\n                    println!(\" client_allowed: {}\", client_allowed);\n                    println!(\n                        \" client_requested_endpoint_valid: {}\",\n                        client_requested_endpoint_valid\n                    );\n                    println!(\n                        \" client_proof_signature_valid: {}\",\n                        client_proof_signature_valid\n                    );\n                    println!(\n                        \" client_auth_signature_valid: {}\",\n                        client_auth_signature_valid\n                    );\n                    println!(\" client_response_valid: {}\", challenge_response_valid);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"server failure: {:?}\", err);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n\n        if !client_complete {\n            match ident_client.update() {\n                Ok(Some(IdentityClientEvent::ChallengeReceived { endpoint_challenge })) =\u003e {\n                    println!(\n                        \"client challenge request received: endpoint_challenge: {}\",\n                        endpoint_challenge\n                    );\n                    ident_client.send_response(client_response.clone())?;\n                }\n                Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                    identity_service_id,\n                    endpoint_service_id,\n                    endpoint_name,\n                    client_auth_private_key: _,\n                })) =\u003e {\n                    assert!(identity_service_id == server_service_id);\n                    assert!(endpoint_name == client_requested_endpoint.clone().to_string());\n                    println!(\n                        \"client complete! endpoint_server : {}\",\n                        endpoint_service_id.to_string()\n                    );\n                    client_complete = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"client failure: {:?}\", err);\n                    client_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n    }\n\n    assert!(failure_ocurred == should_fail);\n    Ok(())\n}\n\n#[test]\nfn test_identity_handshake() -\u003e anyhow::Result\u003c()\u003e {\n    println!(\"Sucessful ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = false;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Bad Endpoint ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = false;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Bad Challenge Response ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Friend?\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Blocked Client ---\");\n    {\n        let client_blocked: bool = true;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Non-ASCII endpoint ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nfn endpoint_test(\n    should_fail: bool,\n    client_allowed: bool,\n    channel: \u0026str,\n    channel_allowed: bool,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // test sockets\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    // server+client setup\n    let server_ed25519_private = Ed25519PrivateKey::generate();\n    let server_ed25519_public = Ed25519PublicKey::from_private_key(\u0026server_ed25519_private);\n    let server_service_id = V3OnionServiceId::from_public_key(\u0026server_ed25519_public);\n\n    let client_ed25519_private = Ed25519PrivateKey::generate();\n    let client_ed25519_public = Ed25519PublicKey::from_private_key(\u0026client_ed25519_private);\n    let client_service_id = V3OnionServiceId::from_public_key(\u0026client_ed25519_public);\n\n    // ensure our client is in the allow list\n    let allowed_client = if client_allowed {\n        client_service_id.clone()\n    } else {\n        let ed25519_private = Ed25519PrivateKey::generate();\n        let ed25519_public = Ed25519PublicKey::from_private_key(\u0026ed25519_private);\n        V3OnionServiceId::from_public_key(\u0026ed25519_public)\n    };\n\n    let server_rpc = Session::new(stream1);\n\n    let mut endpoint_server = EndpointServer::new(\n        server_rpc,\n        allowed_client.clone(),\n        server_service_id.clone(),\n    );\n\n    let client_rpc = Session::new(stream2);\n\n    let channel = match AsciiString::new(channel.to_string()) {\n        Ok(channel) =\u003e channel,\n        Err(_) =\u003e {\n            assert!(should_fail);\n            return Ok(());\n        }\n    };\n\n    let mut endpoint_client = EndpointClient::new(\n        client_rpc,\n        server_service_id.clone(),\n        channel.clone(),\n        client_ed25519_private,\n    );\n\n    let mut failure_ocurred = false;\n    let mut server_complete = false;\n    let mut client_complete = false;\n    while !server_complete \u0026\u0026 !client_complete {\n        if !server_complete {\n            match endpoint_server.update() {\n                Ok(Some(EndpointServerEvent::ChannelRequestReceived {\n                    client_service_id: ret_client_service_id,\n                    requested_channel,\n                })) =\u003e {\n                    assert_eq!(ret_client_service_id, client_service_id);\n                    assert!(requested_channel == channel);\n                    endpoint_server.handle_channel_request_received(channel_allowed)?;\n                }\n                Ok(Some(EndpointServerEvent::HandshakeCompleted {\n                    client_service_id: ret_client_service_id,\n                    channel_name: ret_channel,\n                    stream: _,\n                })) =\u003e {\n                    assert!(ret_client_service_id == client_service_id);\n                    assert!(ret_channel == channel);\n                    server_complete = true;\n                }\n                Ok(Some(EndpointServerEvent::HandshakeRejected {\n                    client_allowed,\n                    client_requested_channel_valid,\n                    client_proof_signature_valid,\n                })) =\u003e {\n                    println!(\"handshake rejected: client_allowed: {}, client_requested_channel_valid: {}, client_proof_signature_valid: {}\", client_allowed, client_requested_channel_valid, client_proof_signature_valid);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"server failure: {:?}\", err);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n\n        if !client_complete {\n            match endpoint_client.update() {\n                Ok(Some(EndpointClientEvent::HandshakeCompleted { stream: _ })) =\u003e {\n                    client_complete = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"client failure: {:?}\", err);\n                    client_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n    }\n\n    println!(\"server_complete: {}\", server_complete);\n    println!(\"client_complete: {}\", client_complete);\n\n    assert!(should_fail == failure_ocurred);\n\n    Ok(())\n}\n\n#[test]\nfn test_endpoint_handshake() -\u003e anyhow::Result\u003c()\u003e {\n    println!(\"Success ---\");\n    {\n        let should_fail = false;\n        let client_allowed = true;\n        let channel = \"channel\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Client Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = false;\n        let channel = \"channel\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Channel Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = true;\n        let channel = \"channel\";\n        let channel_allowed = false;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Client and Channel Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = false;\n        let channel = \"channel\";\n        let channel_allowed = false;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Non-Ascii Channel ---\");\n    {\n        let should_fail = true;\n        let client_allowed = true;\n        let channel = \"\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n\n    Ok(())\n}\n","traces":[{"line":102,"address":[2232528],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":103,"address":[2232537,2232596],"length":1,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[1160968],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[1160991],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[1162278,1161024],"length":1,"stats":{"Line":3},"fn_name":"build_client_proof"},{"line":118,"address":[1161134],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[2232742,2232842],"length":1,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[2232861],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[2232887],"length":1,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[2232954],"length":1,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[2232980],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[2233116],"length":1,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[2233142],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[2233278],"length":1,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[2233304],"length":1,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[2233543],"length":1,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[2233572],"length":1,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[2233827],"length":1,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[1172816,1167076,1162304],"length":1,"stats":{"Line":1},"fn_name":"identity_test"},{"line":150,"address":[1162465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1162839,1165710,1162696,1172768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1162812,1163068,1162924,1172731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[1163009,1163109,1163210,1172694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[1163178,1163300,1172625,1163391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[1163448,1172607,1163364,1163604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[1163572,1163694,1163777,1172526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[1163758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1163818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1163886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1163954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1164005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[1164046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[1172308,1164162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1172341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1164175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1164292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[1164346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[1164410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1164425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[1164471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1164928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1172228,1164998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[1165144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1165152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1165160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[1165168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1165218,1169055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[1165244,1165306,1165641],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[1165776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1166314,1166501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1165808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1166627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1166674,1166905,1167009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1166653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1165838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1167129,1165934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[1167185,1167406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1167164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1165996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1166076,1167675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[1167821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1167711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1167976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1166121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1168002,1166163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[1168116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[1168287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[1168446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1168605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1168764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1168840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[1168848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[1165401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1168917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1168993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[1169001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[1171639,1165251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[1169693,1169357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[1169732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[1170150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1170242,1162418,1170570,1170360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[1169970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1170082,1170866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1170921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1171272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1171170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[1171421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1169459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[1171501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[1171577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1171585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1171915,1165195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[1171948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[1179889,1172832,1174678],"length":1,"stats":{"Line":1},"fn_name":"endpoint_test"},{"line":409,"address":[1172945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[1173106,1176105,1173274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[1173503,1179879,1173359,1173247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[1173544,1179842,1173645,1173444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[1179773,1173613,1173735,1173826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[1174039,1173883,1173799,1179755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[1179674,1174212,1174007,1174129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[1174193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[1174253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[1174324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[1174351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[1174370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[1174446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[1174480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[1174521,1174687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[1174486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[1174531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[1174602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[1174648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[1174689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[1174743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[1174807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[1174955,1174869],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[1174971,1175032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[1175050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[1179365,1175166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[1179398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[1175179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[1175241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[1175357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[1175364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[1175473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[1175481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[1175489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[1175497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[1178027,1175601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[1175627,1175693,1176028],"length":1,"stats":{"Line":3},"fn_name":null},{"line":467,"address":[1176171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1176599,1176211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[1176687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[1176747,1172896,1176852,1177062],"length":1,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[1176300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[1176412,1177350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":481,"address":[1177405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[1177459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[1176457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1177704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[1177812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[1177820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[1175788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[1177889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[1177965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[1177973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[1175634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[1178329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[1178644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[1178636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[1178405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[1178696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[1178772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[1178780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[1178921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[1179078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[1179161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[1179209],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":140,"coverable":159},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","identity_client.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{\n    get_message_overhead, get_request_section_size, RequestCookie, Response, Session,\n};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Identity Client\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to convert x25519 private key to ed25519 private key\")]\n    ClientCreationFailed(#[source] tor_interface::tor_crypto::Error),\n\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"client received unexpected response: {0}\")]\n    UnexpectedResponseReceived(String),\n\n    #[error(\"client is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"provided endpoint challenge response too large; encoded size would be {0} but session's maximum honk-rpc message size is {1}\")]\n    EndpointChallengeResponseTooLarge(usize, usize),\n}\n\npub(crate) enum IdentityClientEvent {\n    ChallengeReceived {\n        endpoint_challenge: bson::document::Document,\n    },\n    HandshakeCompleted {\n        identity_service_id: V3OnionServiceId,\n        endpoint_service_id: V3OnionServiceId,\n        endpoint_name: String,\n        client_auth_private_key: X25519PrivateKey,\n    },\n}\n\n#[derive(Debug, PartialEq)]\npub(crate) enum IdentityClientState {\n    BeginHandshake,\n    WaitingForChallenge,\n    WaitingForChallengeResponse,\n    WaitingForChallengeVerification,\n    HandshakeComplete,\n}\n\n//\n// An identity client object used for connecting\n// to an identity server\n//\npub(crate) struct IdentityClient {\n    // session data\n    rpc: Session\u003cTcpStream\u003e,\n    server_service_id: V3OnionServiceId,\n    requested_endpoint: AsciiString,\n    client_service_id: V3OnionServiceId,\n    client_identity_ed25519_private: Ed25519PrivateKey,\n    client_authorization_key_private: X25519PrivateKey,\n    client_authorization_signing_key_private: (Ed25519PrivateKey, SignBit),\n\n    // state machine data\n    state: IdentityClientState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    endpoint_challenge_response: Option\u003cbson::document::Document\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n}\n\nimpl IdentityClient {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?},  begin_handshake_request_cookie: {:?},  server_cookie: {:?}, endpoint_challenge_response: {:?},  send_response_request_cookie: {:?} }}\", self.state,  self.begin_handshake_request_cookie, self.server_cookie, self.endpoint_challenge_response, self.send_response_request_cookie)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        server_service_id: V3OnionServiceId,\n        requested_endpoint: AsciiString,\n        client_identity_ed25519_private: Ed25519PrivateKey,\n        client_authorization_key_private: X25519PrivateKey,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(Self {\n            rpc,\n            server_service_id,\n            requested_endpoint,\n            client_service_id: V3OnionServiceId::from_private_key(\u0026client_identity_ed25519_private),\n            client_identity_ed25519_private,\n            client_authorization_signing_key_private: Ed25519PrivateKey::from_private_x25519(\n                \u0026client_authorization_key_private,\n            )\n            .map_err(Error::ClientCreationFailed)?,\n            client_authorization_key_private,\n\n            state: IdentityClientState::BeginHandshake,\n            begin_handshake_request_cookie: None,\n            server_cookie: None,\n            send_response_request_cookie: None,\n            endpoint_challenge_response: None,\n        })\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cIdentityClientEvent\u003e, Error\u003e {\n        if self.state == IdentityClientState::HandshakeComplete {\n            return Err(Error::IncorrectUsage(\"update() may not be called after HandshakeComplete has been returned from previous update() call\".to_string()));\n        }\n\n        // update our rpc session\n        self.rpc.update(None)?;\n\n        // client state machine\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie,\n            self.endpoint_challenge_response.take(),\n            self.send_response_request_cookie,\n        ) {\n            // send initial handshake request\n            (\n                \u0026IdentityClientState::BeginHandshake,\n                None, // begin_handshake_request_cookie\n                None, // server_cookie\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                self.begin_handshake_request_cookie = Some(self.rpc.client_call(\n                    \"gosling_identity\",\n                    \"begin_handshake\",\n                    0,\n                    doc! {\n                        \"version\" : bson::Bson::String(GOSLING_PROTOCOL_VERSION.to_string()),\n                        \"client_identity\" : bson::Bson::String(self.client_service_id.to_string()),\n                        \"endpoint\" : bson::Bson::String(self.requested_endpoint.clone().to_string()),\n                    },\n                )?);\n                self.state = IdentityClientState::WaitingForChallenge;\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallenge,\n                Some(begin_handshake_request_cookie),\n                None, // server_cookie\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                if let Some(response) = self.rpc.client_next_response() {\n                    // check for response for the begin_handshake() call\n                    let mut response = match response {\n                        Response::Pending { cookie } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected pending response\".to_string(),\n                                ));\n                            }\n                            return Ok(None);\n                        }\n                        Response::Error { cookie, error_code } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected error response; rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"received unexpected rpc error_code: {}\",\n                                error_code\n                            )));\n                        }\n                        Response::Success { cookie, result } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected success response\".to_string(),\n                                ));\n                            }\n                            match result {\n                                Bson::Document(result) =\u003e result,\n                                _ =\u003e {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"begin_handshake() response is unexpected bson type\"\n                                            .to_string(),\n                                    ))\n                                }\n                            }\n                        }\n                    };\n\n                    // save off the server cookie\n                    self.server_cookie = match response.get(\"server_cookie\") {\n                        Some(Bson::Binary(Binary {\n                            subtype: BinarySubtype::Generic,\n                            bytes: server_cookie,\n                        })) =\u003e match server_cookie.clone().try_into() {\n                            Ok(server_cookie) =\u003e Some(server_cookie),\n                            Err(_) =\u003e {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"unable to convert '{:?}' to server cookie\",\n                                    server_cookie\n                                )))\n                            }\n                        },\n                        Some(_) =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"server_cookie is unxpected bson type\".to_string(),\n                            ))\n                        }\n                        None =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"missing server_cookie\".to_string(),\n                            ))\n                        }\n                    };\n\n                    // get the endpoint challenge\n                    let endpoint_challenge = match response.get_mut(\"endpoint_challenge\") {\n                        Some(Bson::Document(endpoint_challenge)) =\u003e {\n                            std::mem::take(endpoint_challenge)\n                        }\n                        Some(_) =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"endpoint challenge is unexpected bson type\".to_string(),\n                            ))\n                        }\n                        None =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"missing endpoint_challenge\".to_string(),\n                            ))\n                        }\n                    };\n\n                    self.state = IdentityClientState::WaitingForChallengeResponse;\n                    return Ok(Some(IdentityClientEvent::ChallengeReceived {\n                        endpoint_challenge,\n                    }));\n                }\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(_server_cookie),\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                // no-op, waiting for response for challenge response from caller\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(server_cookie),\n                Some(endpoint_challenge_response),\n                None,\n            ) =\u003e {\n                // client_cookie\n                let mut client_cookie: ClientCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut client_cookie);\n                let client_cookie = client_cookie;\n\n                // client_identity_proof_signature\n                let client_identity_proof = build_client_proof(\n                    DomainSeparator::GoslingIdentity,\n                    \u0026self.requested_endpoint,\n                    \u0026self.client_service_id,\n                    \u0026self.server_service_id,\n                    \u0026client_cookie,\n                    \u0026server_cookie,\n                );\n                let client_identity_proof_signature = self\n                    .client_identity_ed25519_private\n                    .sign_message(\u0026client_identity_proof);\n\n                // client_authorization_key\n                let client_authorization_key =\n                    X25519PublicKey::from_private_key(\u0026self.client_authorization_key_private);\n\n                // client_authorization_signature\n                let client_identity = self.client_service_id.to_string();\n                let (client_authorization_signature, signbit) = (\n                    self.client_authorization_signing_key_private\n                        .0\n                        .sign_message(client_identity.as_bytes()),\n                    self.client_authorization_signing_key_private.1,\n                );\n\n                // build our args object for rpc call\n                let args = doc! {\n                    \"client_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_cookie.to_vec()}),\n                    \"client_identity_proof_signature\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}),\n                    \"client_authorization_key\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}),\n                    \"client_authorization_key_signbit\" : bson::Bson::Boolean(signbit.into()),\n                    \"client_authorization_signature\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_signature.to_bytes().to_vec()}),\n                    \"challenge_response\" : endpoint_challenge_response,\n                };\n\n                // make rpc call\n                self.send_response_request_cookie =\n                    Some(\n                        self.rpc\n                            .client_call(\"gosling_identity\", \"send_response\", 0, args)?,\n                    );\n                self.state = IdentityClientState::WaitingForChallengeVerification;\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeVerification,\n                Some(_begin_handshake_request_cookie),\n                Some(_server_cookie),\n                None, // endpoint_challenge_response\n                Some(send_response_request_cookie),\n            ) =\u003e {\n                if let Some(response) = self.rpc.client_next_response() {\n                    let endpoint_service_id = match response {\n                        Response::Pending { cookie } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                return Ok(None);\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpectd pending response\".to_string(),\n                                ));\n                            }\n                        }\n                        Response::Error { cookie, error_code } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected error response; rpc error_code: {}\",\n                                    error_code\n                                )));\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                        }\n                        Response::Success { cookie, result } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                match result {\n                                    Bson::String(endpoint_service_id) =\u003e {\n                                        match V3OnionServiceId::from_string(\u0026endpoint_service_id) {\n                                            Ok(endpoint_service_id) =\u003e endpoint_service_id,\n                                            Err(_) =\u003e return Err(Error::UnexpectedResponseReceived(format!(\"unable to parse received endpoint service id '{}' as v3 onion service id\", endpoint_service_id))),\n                                        }\n                                    }\n                                    _ =\u003e {\n                                        return Err(Error::UnexpectedResponseReceived(\n                                            \"endpoint service id is unexpected bson type\".to_string(),\n                                        ))\n                                    }\n                                }\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected success response\".to_string(),\n                                ));\n                            }\n                        }\n                    };\n                    self.state = IdentityClientState::HandshakeComplete;\n                    return Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                        identity_service_id: self.server_service_id.clone(),\n                        endpoint_service_id,\n                        endpoint_name: self.requested_endpoint.clone().to_string(),\n                        client_auth_private_key: self.client_authorization_key_private.clone(),\n                    }));\n                }\n            }\n            _ =\u003e {\n                return Err(Error::InvalidState(self.get_state()));\n            }\n        }\n        Ok(None)\n    }\n\n    pub fn send_response(\n        \u0026mut self,\n        challenge_response: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie,\n            self.endpoint_challenge_response.as_ref(),\n            self.send_response_request_cookie,\n        ) {\n            (\u0026IdentityClientState::WaitingForChallengeResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_server_cookie),\n             None, // endpoint_challenge_response\n             None  // end_response_request_cookie\n            ) =\u003e {\n                // calculate required size of request message and ensure it fits our\n                // specified message size budget\n                let arguments = doc!{\n                    \"client_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; CLIENT_COOKIE_SIZE].to_vec()}),\n                    \"client_identity_proof_signature\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; ED25519_SIGNATURE_SIZE].to_vec()}),\n                    \"client_authorization_key\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; X25519_PUBLIC_KEY_SIZE].to_vec()}),\n                    \"client_authorization_key_signbit\" : Bson::Boolean(false),\n                    \"client_authorization_signature\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; ED25519_SIGNATURE_SIZE].to_vec()}),\n                    \"challenge_response\" : challenge_response.clone(),\n                };\n                let request_section_size = get_request_section_size(Some(0i64), Some(\"gosling_identity\".to_string()), \"send_response\".to_string(), Some(0i32), Some(arguments))?;\n                let message_size = get_message_overhead()? + request_section_size;\n                let max_message_size = self.rpc.get_max_message_size();\n                if message_size \u003e max_message_size {\n                    Err(Error::EndpointChallengeResponseTooLarge(message_size, max_message_size))\n                } else {\n                    self.endpoint_challenge_response = Some(challenge_response);\n                    Ok(())\n                }\n            }\n            _ =\u003e Err(Error::IncorrectUsage(\"send_response() may only be called after ChallengeReceived event has been returned from update(), and it may only be called once\".to_string()))\n        }\n    }\n}\n","traces":[{"line":90,"address":[2375264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2375488,2375553,2375423,2375293,2375608,2375358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2375744,2377092,2377135],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[2375780,2376255],"length":1,"stats":{"Line":6},"fn_name":null},{"line":102,"address":[2375832],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[2375844],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[2375867],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[2375935],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[2376787,2375969,2376029],"length":1,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[2376675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2376142],"length":1,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[2376197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[2376205],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[2376217],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[2376225],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[2376237],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[2389912,2377168,2379548],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[2377248],"length":1,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[2377411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2377240,2377965,2379946,2377303],"length":1,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[2378051,2377726,2383211,2379557,2386511],"length":1,"stats":{"Line":15},"fn_name":null},{"line":131,"address":[2377566],"length":1,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[2377583],"length":1,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[2377613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[2377656],"length":1,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[2377712],"length":1,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[2379294],"length":1,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[2379072,2379419,2379502],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[2378624,2378432,2378747,2378883,2378187,2378299],"length":1,"stats":{"Line":12},"fn_name":null},{"line":150,"address":[2378272,2378340],"length":1,"stats":{"Line":6},"fn_name":null},{"line":151,"address":[2378506],"length":1,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[2378698,2378791],"length":1,"stats":{"Line":6},"fn_name":null},{"line":155,"address":[2379273],"length":1,"stats":{"Line":3},"fn_name":null},{"line":157,"address":[2379641],"length":1,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[2379665],"length":1,"stats":{"Line":3},"fn_name":null},{"line":166,"address":[2379851],"length":1,"stats":{"Line":3},"fn_name":null},{"line":167,"address":[2379956],"length":1,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[2379972],"length":1,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[2380216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[2380181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[2380140],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[2380074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[2380118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[2383011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2382795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[2379986],"length":1,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[2380052],"length":1,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[2382500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[2380375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[2380330],"length":1,"stats":{"Line":3},"fn_name":null},{"line":194,"address":[2380405],"length":1,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[2382361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2380503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[2380707,2380533,2380898,2381221,2380643],"length":1,"stats":{"Line":15},"fn_name":null},{"line":209,"address":[2380946],"length":1,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[2380966],"length":1,"stats":{"Line":3},"fn_name":null},{"line":211,"address":[2381038],"length":1,"stats":{"Line":3},"fn_name":null},{"line":213,"address":[2381930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[2382195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[2380916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[2380767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[2380680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[2381264,2381375],"length":1,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[2381545],"length":1,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[2381565],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[2381756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[2381584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[2381431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[2381348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[2381622],"length":1,"stats":{"Line":3},"fn_name":null},{"line":249,"address":[2381643],"length":1,"stats":{"Line":3},"fn_name":null},{"line":254,"address":[2383300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[2383369],"length":1,"stats":{"Line":3},"fn_name":null},{"line":271,"address":[2383513],"length":1,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[2383573],"length":1,"stats":{"Line":3},"fn_name":null},{"line":273,"address":[2383613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":277,"address":[2383645],"length":1,"stats":{"Line":3},"fn_name":null},{"line":278,"address":[2383653],"length":1,"stats":{"Line":3},"fn_name":null},{"line":279,"address":[2383663],"length":1,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[2383673],"length":1,"stats":{"Line":3},"fn_name":null},{"line":284,"address":[2383850,2383733],"length":1,"stats":{"Line":6},"fn_name":null},{"line":286,"address":[2383747],"length":1,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[2383877],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[2383911],"length":1,"stats":{"Line":3},"fn_name":null},{"line":294,"address":[2384091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[2383945,2384058],"length":1,"stats":{"Line":6},"fn_name":null},{"line":297,"address":[2383967],"length":1,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[2384085],"length":1,"stats":{"Line":3},"fn_name":null},{"line":302,"address":[2385168,2384534,2385819,2384851,2384247,2384306,2385649,2385332],"length":1,"stats":{"Line":21},"fn_name":null},{"line":303,"address":[2384266,2384350],"length":1,"stats":{"Line":6},"fn_name":null},{"line":304,"address":[2384600],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[2384917],"length":1,"stats":{"Line":3},"fn_name":null},{"line":306,"address":[2385241],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[2385398],"length":1,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[2385715],"length":1,"stats":{"Line":3},"fn_name":null},{"line":312,"address":[2386187],"length":1,"stats":{"Line":3},"fn_name":null},{"line":313,"address":[2386167],"length":1,"stats":{"Line":3},"fn_name":null},{"line":314,"address":[2386016,2386380],"length":1,"stats":{"Line":3},"fn_name":null},{"line":315,"address":[2386268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[2386217],"length":1,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[2386595],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[2386664],"length":1,"stats":{"Line":3},"fn_name":null},{"line":327,"address":[2386850],"length":1,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[2386944],"length":1,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[2386960],"length":1,"stats":{"Line":3},"fn_name":null},{"line":330,"address":[2387151],"length":1,"stats":{"Line":3},"fn_name":null},{"line":332,"address":[2387200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[2387116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[2387058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[2387102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[2389521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[2389311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[2386974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[2387039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[2387341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[2387627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[2387675,2387776],"length":1,"stats":{"Line":4},"fn_name":null},{"line":355,"address":[2387813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[2388626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[2388912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[2387692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[2387469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[2387314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[2388049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[2388283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[2388070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[2388119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[2388220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[2389745,2378041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[2379461],"length":1,"stats":{"Line":3},"fn_name":null},{"line":388,"address":[2393607,2393748,2389952],"length":1,"stats":{"Line":3},"fn_name":null},{"line":392,"address":[2390229,2390007,2390371],"length":1,"stats":{"Line":9},"fn_name":null},{"line":393,"address":[2390039],"length":1,"stats":{"Line":3},"fn_name":null},{"line":394,"address":[2390054],"length":1,"stats":{"Line":3},"fn_name":null},{"line":395,"address":[2390078],"length":1,"stats":{"Line":3},"fn_name":null},{"line":396,"address":[2390121],"length":1,"stats":{"Line":3},"fn_name":null},{"line":397,"address":[2390205],"length":1,"stats":{"Line":3},"fn_name":null},{"line":399,"address":[2390429],"length":1,"stats":{"Line":3},"fn_name":null},{"line":407,"address":[2391052,2390477,2391834,2390535,2391341,2390763,2391459,2391748],"length":1,"stats":{"Line":21},"fn_name":null},{"line":408,"address":[2390496,2390579],"length":1,"stats":{"Line":6},"fn_name":null},{"line":409,"address":[2390829],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[2391118],"length":1,"stats":{"Line":3},"fn_name":null},{"line":411,"address":[2391407],"length":1,"stats":{"Line":3},"fn_name":null},{"line":412,"address":[2391525],"length":1,"stats":{"Line":3},"fn_name":null},{"line":413,"address":[2391827],"length":1,"stats":{"Line":3},"fn_name":null},{"line":415,"address":[2392123,2393585,2392659,2393570,2392031],"length":1,"stats":{"Line":6},"fn_name":null},{"line":416,"address":[2393087,2392800,2392632,2393547],"length":1,"stats":{"Line":6},"fn_name":null},{"line":417,"address":[2393129,2393071],"length":1,"stats":{"Line":6},"fn_name":null},{"line":418,"address":[2393416,2393137],"length":1,"stats":{"Line":3},"fn_name":null},{"line":419,"address":[2393364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[2393156,2393423],"length":1,"stats":{"Line":3},"fn_name":null},{"line":422,"address":[2393510],"length":1,"stats":{"Line":3},"fn_name":null},{"line":425,"address":[2390341,2393643],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":114,"coverable":153},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","identity_server.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{\n    get_message_overhead, get_response_section_size, ApiSet, ErrorCode, RequestCookie, Session,\n};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Identity Server\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"server is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"client sent invalid request\")]\n    BadClient,\n\n    #[error(\"provided endpoint challenge too large; encoded size would be {0} but session's maximum honk-rpc message size is {1}\")]\n    EndpointChallengeTooLarge(usize, usize),\n}\n\npub(crate) enum IdentityServerEvent {\n    EndpointRequestReceived {\n        client_service_id: V3OnionServiceId,\n        requested_endpoint: AsciiString,\n    },\n\n    ChallengeResponseReceived {\n        challenge_response: bson::document::Document,\n    },\n\n    HandshakeCompleted {\n        endpoint_private_key: Ed25519PrivateKey,\n        endpoint_name: AsciiString,\n        client_service_id: V3OnionServiceId,\n        client_auth_public_key: X25519PublicKey,\n    },\n\n    HandshakeRejected {\n        // Client not on the block-list\n        client_allowed: bool,\n        // The requested endpoint is valid\n        client_requested_endpoint_valid: bool,\n        // The client proof is valid and signed with client's public key\n        client_proof_signature_valid: bool,\n        // The client authorization signature is valid\n        client_auth_signature_valid: bool,\n        // The challenge response is valid\n        challenge_response_valid: bool,\n    },\n}\n\n#[derive(Debug, PartialEq)]\nenum IdentityServerState {\n    // valid/expected states\n    WaitingForBeginHandshake,\n    GettingChallenge,\n    ChallengeReady,\n    WaitingForSendResponse,\n    GettingChallengeVerification,\n    ChallengeVerificationReady,\n    ChallengeVerificationResponseSent,\n    HandshakeComplete,\n    // failure state\n    HandshakeFailed,\n}\n\npub(crate) struct IdentityServer {\n    // Session Data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    server_identity: V3OnionServiceId,\n\n    // State Machine Data\n    state: IdentityServerState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    client_identity: Option\u003cV3OnionServiceId\u003e,\n    requested_endpoint: Option\u003cAsciiString\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    endpoint_challenge: Option\u003cbson::document::Document\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n    client_auth_key: Option\u003cX25519PublicKey\u003e,\n    challenge_response: Option\u003cbson::document::Document\u003e,\n    endpoint_private_key: Option\u003cEd25519PrivateKey\u003e,\n\n    // Verification flags\n\n    // Client not on the block-list\n    client_allowed: bool,\n    // The requested endpoint is valid\n    client_requested_endpoint_valid: bool,\n    // The client proof is valid and signed with client's public key\n    client_proof_signature_valid: bool,\n    // The client authorization signature is valid\n    client_auth_signature_valid: bool,\n    // The challenge response is valid\n    challenge_response_valid: bool,\n}\n\nimpl IdentityServer {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, client_identity: {:?}, requested_endpoint: {:?}, server_cookie: {:?}, endpoint_challenge: {:?}, send_response_request_cookie: {:?}, client_auth_key: {:?}, challenge_response: {:?}, endpoint_private_key: {:?} }}\", self.state, self.begin_handshake_request_cookie, self.client_identity, self.requested_endpoint, self.server_cookie, self.endpoint_challenge, self.send_response_request_cookie, self.client_auth_key, self.challenge_response, self.endpoint_private_key)\n    }\n\n    pub fn new(rpc: Session\u003cTcpStream\u003e, server_identity: V3OnionServiceId) -\u003e Self {\n        IdentityServer {\n            // Session Data\n            rpc: Some(rpc),\n            server_identity,\n\n            // State Machine Data\n            state: IdentityServerState::WaitingForBeginHandshake,\n            begin_handshake_request_cookie: None,\n            client_identity: None,\n            requested_endpoint: None,\n            server_cookie: None,\n            endpoint_challenge: None,\n            send_response_request_cookie: None,\n            client_auth_key: None,\n            challenge_response: None,\n            endpoint_private_key: None,\n\n            // Verification Flags\n            client_allowed: false,\n            client_requested_endpoint_valid: false,\n            client_proof_signature_valid: false,\n            client_auth_signature_valid: false,\n            challenge_response_valid: false,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cIdentityServerEvent\u003e, Error\u003e {\n        // need to remove ownership of the HonkRPC session from Self\n        // before being able to pass self into the session update method\n        if let Some(mut rpc) = std::mem::take(\u0026mut self.rpc) {\n            match rpc.update(Some(\u0026mut [self])) {\n                Ok(()) =\u003e {\n                    self.rpc = Some(rpc);\n                }\n                Err(err) =\u003e {\n                    self.rpc = Some(rpc);\n                    return Err(err.into());\n                }\n            }\n        }\n\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_endpoint.as_ref(),\n              self.server_cookie.as_ref(),\n              self.endpoint_challenge.as_ref(),\n              self.send_response_request_cookie,\n              self.client_auth_key.as_ref(),\n              self.challenge_response.as_mut(),\n              self.endpoint_private_key.as_ref()) {\n            (\u0026IdentityServerState::WaitingForBeginHandshake,\n             None, // begin_handshake_request_cookie\n             None, // client_identity\n             None, // requested_endpoint\n             None, // server_cookie\n             None, // endpoint_challenge\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                // no-op, waiting for client to connect and begin handshake\n            },\n            (\u0026IdentityServerState::WaitingForBeginHandshake,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_endpoint),\n             None, // server_cookie\n             None, // endpoint_challenge\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::GettingChallenge;\n                return Ok(Some(IdentityServerEvent::EndpointRequestReceived{client_service_id: client_identity.clone(), requested_endpoint: requested_endpoint.clone()}));\n            },\n            (\u0026IdentityServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                // no-op, waiting for client to send challenge response\n            },\n            (\u0026IdentityServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(_client_auth_key),\n             Some(challenge_response),\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::GettingChallengeVerification;\n                return Ok(Some(IdentityServerEvent::ChallengeResponseReceived{\n                    challenge_response: std::mem::take(challenge_response),\n                }));\n            },\n            (\u0026IdentityServerState::ChallengeVerificationResponseSent,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(client_auth_key),\n             Some(_challenge_response),\n             Some(endpoint_private_key))\n            =\u003e {\n                self.state = IdentityServerState::HandshakeComplete;\n                return Ok(Some(IdentityServerEvent::HandshakeCompleted{\n                    endpoint_private_key: endpoint_private_key.clone(),\n                    endpoint_name: requested_endpoint.clone(),\n                    client_service_id: client_identity.clone(),\n                    client_auth_public_key: client_auth_key.clone(),\n                }));\n            },\n            (\u0026IdentityServerState::ChallengeVerificationResponseSent,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(_client_auth_key),\n             Some(_challenge_response),\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::HandshakeComplete;\n                return Ok(Some(IdentityServerEvent::HandshakeRejected{\n                    client_allowed: self.client_allowed,\n                    client_requested_endpoint_valid: self.client_requested_endpoint_valid,\n                    client_proof_signature_valid: self.client_proof_signature_valid,\n                    client_auth_signature_valid: self.client_auth_signature_valid,\n                    challenge_response_valid: self.challenge_response_valid,\n                }));\n            },\n             _ =\u003e {\n                if self.state == IdentityServerState::HandshakeFailed {\n                    return Err(Error::BadClient);\n                } else {\n                    return Err(Error::InvalidState(self.get_state()));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    pub fn handle_endpoint_request_received(\n        \u0026mut self,\n        client_allowed: bool,\n        endpoint_valid: bool,\n        endpoint_challenge: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.rpc.as_ref(),\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            (\n                \u0026IdentityServerState::GettingChallenge,\n                Some(rpc),\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_endpoint_name),\n                None, // server_cookie\n                None, // endpoint_challenge\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                let mut server_cookie: ServerCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut server_cookie);\n\n                // calculate required size of response message and ensure if fits our\n                // specified message size budget\n                let result = doc!{\n                    \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                    \"endpoint_challenge\" : endpoint_challenge.clone(),\n                };\n                let response_section_size = get_response_section_size(Some(Bson::Document(result)))?;\n                let message_size = get_message_overhead()? + response_section_size;\n                let max_message_size = rpc.get_max_message_size();\n                if message_size \u003e max_message_size {\n                    Err(Error::EndpointChallengeTooLarge(message_size, max_message_size))\n                } else {\n                    self.server_cookie = Some(server_cookie);\n                    self.endpoint_challenge = Some(endpoint_challenge);\n                    self.client_allowed = client_allowed;\n                    self.client_requested_endpoint_valid = endpoint_valid;\n                    self.state = IdentityServerState::ChallengeReady;\n                    Ok(())\n                }\n            }\n            _ =\u003e {\n                Err(Error::IncorrectUsage(\"handle_endpoint_request_received() may only be called after EndpointRequestReceived has been returned from update(), and it may only be called once\".to_string()))\n            }\n        }\n    }\n\n    pub fn handle_challenge_response_received(\n        \u0026mut self,\n        challenge_response_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            (\n                \u0026IdentityServerState::GettingChallengeVerification,\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(_server_cookie),\n                Some(_endpoint_challenge),\n                Some(_client_auth_key),\n                Some(_challenge_response),\n                None,\n            ) =\u003e\n            // endpoint_private_key\n            {\n                self.challenge_response_valid = challenge_response_valid;\n                self.state = IdentityServerState::ChallengeVerificationReady;\n                Ok(())\n            }\n            _ =\u003e {\n                Err(Error::IncorrectUsage(\"handle_challenge_response_received() may only be called after ChallengeResponseReceived event has been returned from update(), and it may only be called once\".to_string()))\n            }\n        }\n    }\n}\n\nimpl ApiSet for IdentityServer {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"gosling_identity\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        let request_cookie = match request_cookie {\n            Some(request_cookie) =\u003e request_cookie,\n            None =\u003e return Err(ErrorCode::Runtime(RpcError::RequestCookieRequired as i32)),\n        };\n\n        match (\n            name,\n            version,\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            // handle begin_handshake call\n            (\n                \"begin_handshake\",\n                0,\n                \u0026IdentityServerState::WaitingForBeginHandshake,\n                None, // begin_handshake_request_cookie\n                None, // client_identity\n                None, // requested_endpoint\n                None, // server_cookie\n                None, // endpoint_challenge\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                let valid_version = match args.remove(\"version\") {\n                    Some(Bson::String(value)) =\u003e value == GOSLING_PROTOCOL_VERSION,\n                    _ =\u003e false,\n                };\n                if !valid_version {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    return Err(ErrorCode::Runtime(RpcError::BadVersion as i32));\n                }\n\n                if let (Some(Bson::String(client_identity)), Some(Bson::String(endpoint_name))) =\n                    (args.remove(\"client_identity\"), args.remove(\"endpoint\"))\n                {\n                    // client_identiity\n                    let client_identity = match V3OnionServiceId::from_string(\u0026client_identity) {\n                        Ok(client_identity) =\u003e client_identity,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // endpoint name\n                    let endpoint_name = match AsciiString::new(endpoint_name) {\n                        Ok(endpoint_name) =\u003e endpoint_name,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // save cookie\n                    self.begin_handshake_request_cookie = Some(request_cookie);\n\n                    // save results\n                    self.client_identity = Some(client_identity);\n                    self.requested_endpoint = Some(endpoint_name);\n                    Ok(None)\n                } else {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    Err(ErrorCode::Runtime(RpcError::InvalidArg as i32))\n                }\n            }\n            // handle send_response call\n            (\n                \"send_response\",\n                0,\n                \u0026IdentityServerState::WaitingForSendResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(client_identity),\n                Some(requested_endpoint),\n                Some(server_cookie),\n                Some(_endpoint_challenge),\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                // arg validation\n                if let (\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_cookie,\n                    })),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_identity_proof_signature,\n                    })),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_authorization_key,\n                    })),\n                    Some(Bson::Boolean(client_authorization_key_signbit)),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_authorization_signature,\n                    })),\n                    Some(Bson::Document(challenge_response)),\n                ) = (\n                    args.remove(\"client_cookie\"),\n                    args.remove(\"client_identity_proof_signature\"),\n                    args.remove(\"client_authorization_key\"),\n                    args.remove(\"client_authorization_key_signbit\"),\n                    args.remove(\"client_authorization_signature\"),\n                    args.remove(\"challenge_response\"),\n                ) {\n                    // client_cookie\n                    let client_cookie: ClientCookie = match client_cookie.try_into() {\n                        Ok(client_cookie) =\u003e client_cookie,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                        }\n                    };\n\n                    // client_identity_proof_signature\n                    let client_identity_proof_signature: [u8; ED25519_SIGNATURE_SIZE] =\n                        match client_identity_proof_signature.try_into() {\n                            Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n                    let client_identity_proof_signature =\n                        match Ed25519Signature::from_raw(\u0026client_identity_proof_signature) {\n                            Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n\n                    // client_authorization_key\n                    let client_authorization_key: [u8; X25519_PUBLIC_KEY_SIZE] =\n                        match client_authorization_key.try_into() {\n                            Ok(client_authorization_key) =\u003e client_authorization_key,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n                    let client_authorization_key =\n                        X25519PublicKey::from_raw(\u0026client_authorization_key);\n\n                    // client_authorization_key_signbit\n                    let client_authorization_key_signbit: SignBit =\n                        client_authorization_key_signbit.into();\n\n                    // client_authorization_signature\n                    let client_authorization_signature: [u8; ED25519_SIGNATURE_SIZE] =\n                        match client_authorization_signature.try_into() {\n                            Ok(client_authorization_signature) =\u003e client_authorization_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n                    let client_authorization_signature =\n                        match Ed25519Signature::from_raw(\u0026client_authorization_signature) {\n                            Ok(client_authorization_signature) =\u003e client_authorization_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Err(ErrorCode::Runtime(RpcError::InvalidArg as i32));\n                            }\n                        };\n\n                    // save  cookie\n                    self.send_response_request_cookie = Some(request_cookie);\n\n                    // convert client_identity to client's public ed25519 key\n                    if let Ok(client_identity_key) =\n                        Ed25519PublicKey::from_service_id(client_identity)\n                    {\n                        // construct + verify client proof\n                        let client_proof = build_client_proof(\n                            DomainSeparator::GoslingIdentity,\n                            requested_endpoint,\n                            client_identity,\n                            \u0026self.server_identity,\n                            \u0026client_cookie,\n                            server_cookie,\n                        );\n                        self.client_proof_signature_valid = client_identity_proof_signature\n                            .verify(\u0026client_proof, \u0026client_identity_key);\n                    }\n\n                    // evaluate the client authorization signature\n                    self.client_auth_signature_valid = client_authorization_signature\n                        .verify_x25519(\n                            client_identity.as_bytes(),\n                            \u0026client_authorization_key,\n                            client_authorization_key_signbit,\n                        );\n\n                    // save off client auth key for future endpoint generation\n                    self.client_auth_key = Some(client_authorization_key);\n\n                    // safe off challenge response for verification\n                    self.challenge_response = Some(challenge_response);\n\n                    Ok(None)\n                } else {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    Err(ErrorCode::Runtime(RpcError::InvalidArg as i32))\n                }\n            }\n            _ =\u003e {\n                self.state = IdentityServerState::HandshakeFailed;\n                Err(ErrorCode::Runtime(RpcError::Failure as i32))\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_mut(),\n            self.send_response_request_cookie,\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n        ) {\n            // return challenge from begin_handshake\n            (\n                \u0026IdentityServerState::ChallengeReady,\n                Some(begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(server_cookie),\n                Some(endpoint_challenge),\n                None, // send_response_request_cookie\n                None, // client_auth_key\n                None,\n            ) =\u003e\n            // challenge_response\n            {\n                self.state = IdentityServerState::WaitingForSendResponse;\n                Some((\n                    begin_handshake_request_cookie,\n                    Some(Bson::Document(doc! {\n                        \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                        \"endpoint_challenge\" : std::mem::take(endpoint_challenge),\n                    })),\n                    ErrorCode::Success,\n                ))\n            }\n            (\u0026IdentityServerState::ChallengeReady, _, _, _, _, _, _, _, _) =\u003e unreachable!(),\n            (\n                \u0026IdentityServerState::ChallengeVerificationReady,\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(_server_cookie),\n                Some(_endpoint_challenge),\n                Some(send_response_request_cookie),\n                Some(_client_auth_key),\n                Some(_challenge_response),\n            ) =\u003e {\n                let mut success = true;\n                success \u0026= self.client_allowed;\n                success \u0026= self.client_requested_endpoint_valid;\n                success \u0026= self.client_proof_signature_valid;\n                success \u0026= self.client_auth_signature_valid;\n                success \u0026= self.challenge_response_valid;\n\n                self.state = IdentityServerState::ChallengeVerificationResponseSent;\n                if success {\n                    let endpoint_private_key = Ed25519PrivateKey::generate();\n                    let endpoint_service_id =\n                        V3OnionServiceId::from_private_key(\u0026endpoint_private_key);\n                    self.endpoint_private_key = Some(endpoint_private_key);\n                    Some((\n                        send_response_request_cookie,\n                        Some(Bson::String(endpoint_service_id.to_string())),\n                        ErrorCode::Success,\n                    ))\n                } else {\n                    Some((\n                        send_response_request_cookie,\n                        None,\n                        ErrorCode::Runtime(RpcError::Failure as i32),\n                    ))\n                }\n            }\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":121,"address":[2666448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2666695,2667136,2666890,2666625,2666760,2667010,2666945,2667068,2666825,2666486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2667392],"length":1,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[2667414],"length":1,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[2669231,2667952],"length":1,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[2668011],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[2668164,2668326],"length":1,"stats":{"Line":6},"fn_name":null},{"line":158,"address":[2668727,2668361],"length":1,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[2668486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[2668833,2668606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2669121,2668922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[2669302,2669768,2670991,2670625,2670146,2669564,2671333],"length":1,"stats":{"Line":21},"fn_name":null},{"line":168,"address":[2669312],"length":1,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[2669319],"length":1,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[2669348],"length":1,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[2669377],"length":1,"stats":{"Line":3},"fn_name":null},{"line":172,"address":[2669406],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[2669435],"length":1,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[2669453],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[2669482],"length":1,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[2669511],"length":1,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[2670383],"length":1,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[2670420],"length":1,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[2670441],"length":1,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[2670954],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[2671177],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[2671193],"length":1,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[2671228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[2671214],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[2671994],"length":1,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[2672063],"length":1,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[2672246],"length":1,"stats":{"Line":3},"fn_name":null},{"line":246,"address":[2672084],"length":1,"stats":{"Line":3},"fn_name":null},{"line":247,"address":[2672114],"length":1,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[2672178],"length":1,"stats":{"Line":3},"fn_name":null},{"line":249,"address":[2672239],"length":1,"stats":{"Line":3},"fn_name":null},{"line":252,"address":[2671635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[2671715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[2671768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[2671736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[2671743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[2671750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[2671756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[2671762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[2669736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[2672629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2672486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[2670105],"length":1,"stats":{"Line":3},"fn_name":null},{"line":284,"address":[2675815,2672704,2675696],"length":1,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[2673162,2673326,2672790],"length":1,"stats":{"Line":9},"fn_name":null},{"line":291,"address":[2672806],"length":1,"stats":{"Line":3},"fn_name":null},{"line":292,"address":[2672824],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[2672896],"length":1,"stats":{"Line":3},"fn_name":null},{"line":294,"address":[2672913],"length":1,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[2672941],"length":1,"stats":{"Line":3},"fn_name":null},{"line":296,"address":[2672969],"length":1,"stats":{"Line":3},"fn_name":null},{"line":297,"address":[2672997],"length":1,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[2673025],"length":1,"stats":{"Line":3},"fn_name":null},{"line":299,"address":[2673053],"length":1,"stats":{"Line":3},"fn_name":null},{"line":300,"address":[2673081],"length":1,"stats":{"Line":3},"fn_name":null},{"line":302,"address":[2673577],"length":1,"stats":{"Line":3},"fn_name":null},{"line":314,"address":[2673625],"length":1,"stats":{"Line":3},"fn_name":null},{"line":315,"address":[2673644],"length":1,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[2673963,2673676,2674049,2673735],"length":1,"stats":{"Line":9},"fn_name":null},{"line":320,"address":[2673779,2673695],"length":1,"stats":{"Line":6},"fn_name":null},{"line":321,"address":[2674042],"length":1,"stats":{"Line":3},"fn_name":null},{"line":323,"address":[2674238,2674601,2675675],"length":1,"stats":{"Line":3},"fn_name":null},{"line":324,"address":[2674574,2674742,2675028,2675660],"length":1,"stats":{"Line":6},"fn_name":null},{"line":325,"address":[2675069,2675013],"length":1,"stats":{"Line":6},"fn_name":null},{"line":326,"address":[2675077,2675473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":327,"address":[2675421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[2675096],"length":1,"stats":{"Line":3},"fn_name":null},{"line":330,"address":[2675483,2675211],"length":1,"stats":{"Line":3},"fn_name":null},{"line":331,"address":[2675590],"length":1,"stats":{"Line":3},"fn_name":null},{"line":332,"address":[2675601],"length":1,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[2675610],"length":1,"stats":{"Line":3},"fn_name":null},{"line":334,"address":[2675631],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[2673296,2675710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[2675856],"length":1,"stats":{"Line":3},"fn_name":null},{"line":347,"address":[2676337,2676125],"length":1,"stats":{"Line":6},"fn_name":null},{"line":348,"address":[2675910],"length":1,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[2675920],"length":1,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[2675937],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[2675960],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[2675983],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[2676006],"length":1,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[2676029],"length":1,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[2676052],"length":1,"stats":{"Line":3},"fn_name":null},{"line":356,"address":[2676075],"length":1,"stats":{"Line":3},"fn_name":null},{"line":358,"address":[2676582],"length":1,"stats":{"Line":3},"fn_name":null},{"line":371,"address":[2676691],"length":1,"stats":{"Line":3},"fn_name":null},{"line":372,"address":[2676700],"length":1,"stats":{"Line":3},"fn_name":null},{"line":373,"address":[2676721],"length":1,"stats":{"Line":3},"fn_name":null},{"line":376,"address":[2676218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[2676752],"length":1,"stats":{"Line":3},"fn_name":"namespace"},{"line":387,"address":[2676784,2678399,2690259],"length":1,"stats":{"Line":3},"fn_name":"exec_function"},{"line":394,"address":[2676932],"length":1,"stats":{"Line":3},"fn_name":null},{"line":395,"address":[2677128],"length":1,"stats":{"Line":3},"fn_name":null},{"line":396,"address":[2677063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[2677761,2681796,2677567],"length":1,"stats":{"Line":9},"fn_name":null},{"line":402,"address":[2677152],"length":1,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[2677169],"length":1,"stats":{"Line":3},"fn_name":null},{"line":404,"address":[2677192],"length":1,"stats":{"Line":3},"fn_name":null},{"line":405,"address":[2677289],"length":1,"stats":{"Line":3},"fn_name":null},{"line":406,"address":[2677323],"length":1,"stats":{"Line":3},"fn_name":null},{"line":407,"address":[2677357],"length":1,"stats":{"Line":3},"fn_name":null},{"line":408,"address":[2677391],"length":1,"stats":{"Line":3},"fn_name":null},{"line":409,"address":[2677422],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[2677453],"length":1,"stats":{"Line":3},"fn_name":null},{"line":413,"address":[2677670],"length":1,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[2678034],"length":1,"stats":{"Line":3},"fn_name":null},{"line":427,"address":[2678161],"length":1,"stats":{"Line":3},"fn_name":null},{"line":428,"address":[2678148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[2678524],"length":1,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[2678606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[2678627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[2678695],"length":1,"stats":{"Line":3},"fn_name":null},{"line":439,"address":[2679232,2679300],"length":1,"stats":{"Line":6},"fn_name":null},{"line":440,"address":[2679337],"length":1,"stats":{"Line":3},"fn_name":null},{"line":442,"address":[2679436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[2679457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[2679539],"length":1,"stats":{"Line":3},"fn_name":null},{"line":449,"address":[2679613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":451,"address":[2679749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[2679770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[2679861],"length":1,"stats":{"Line":3},"fn_name":null},{"line":460,"address":[2679904],"length":1,"stats":{"Line":3},"fn_name":null},{"line":461,"address":[2680036,2680200],"length":1,"stats":{"Line":3},"fn_name":null},{"line":462,"address":[2680325],"length":1,"stats":{"Line":3},"fn_name":null},{"line":464,"address":[2678967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[2678988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[2682077],"length":1,"stats":{"Line":3},"fn_name":null},{"line":483,"address":[2682834,2682996],"length":1,"stats":{"Line":3},"fn_name":null},{"line":486,"address":[2683493],"length":1,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[2683533],"length":1,"stats":{"Line":3},"fn_name":null},{"line":494,"address":[2683581],"length":1,"stats":{"Line":3},"fn_name":null},{"line":496,"address":[2683629],"length":1,"stats":{"Line":3},"fn_name":null},{"line":499,"address":[2683647],"length":1,"stats":{"Line":3},"fn_name":null},{"line":501,"address":[2683695],"length":1,"stats":{"Line":3},"fn_name":null},{"line":503,"address":[2682172],"length":1,"stats":{"Line":3},"fn_name":null},{"line":504,"address":[2682211],"length":1,"stats":{"Line":3},"fn_name":null},{"line":505,"address":[2682294],"length":1,"stats":{"Line":3},"fn_name":null},{"line":506,"address":[2682374],"length":1,"stats":{"Line":3},"fn_name":null},{"line":507,"address":[2682454],"length":1,"stats":{"Line":3},"fn_name":null},{"line":508,"address":[2682534],"length":1,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[2683807,2683875],"length":1,"stats":{"Line":6},"fn_name":null},{"line":512,"address":[2683893],"length":1,"stats":{"Line":3},"fn_name":null},{"line":514,"address":[2683992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[2684013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[2684090],"length":1,"stats":{"Line":3},"fn_name":null},{"line":522,"address":[2684179],"length":1,"stats":{"Line":3},"fn_name":null},{"line":524,"address":[2684342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[2684363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[2684440],"length":1,"stats":{"Line":3},"fn_name":null},{"line":530,"address":[2684489],"length":1,"stats":{"Line":3},"fn_name":null},{"line":532,"address":[2684652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[2684673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[2684755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":540,"address":[2684840],"length":1,"stats":{"Line":3},"fn_name":null},{"line":542,"address":[2684939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[2684960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[2685037],"length":1,"stats":{"Line":3},"fn_name":null},{"line":550,"address":[2685068],"length":1,"stats":{"Line":3},"fn_name":null},{"line":554,"address":[2685109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":556,"address":[2685198],"length":1,"stats":{"Line":3},"fn_name":null},{"line":558,"address":[2685361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[2685382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[2685459],"length":1,"stats":{"Line":3},"fn_name":null},{"line":564,"address":[2685508],"length":1,"stats":{"Line":3},"fn_name":null},{"line":566,"address":[2685671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[2685692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[2685795],"length":1,"stats":{"Line":3},"fn_name":null},{"line":575,"address":[2685858],"length":1,"stats":{"Line":3},"fn_name":null},{"line":580,"address":[2685922],"length":1,"stats":{"Line":3},"fn_name":null},{"line":583,"address":[2685930],"length":1,"stats":{"Line":3},"fn_name":null},{"line":587,"address":[2686120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":588,"address":[2686040],"length":1,"stats":{"Line":3},"fn_name":null},{"line":592,"address":[2686224],"length":1,"stats":{"Line":3},"fn_name":null},{"line":594,"address":[2686199],"length":1,"stats":{"Line":3},"fn_name":null},{"line":600,"address":[2686288],"length":1,"stats":{"Line":3},"fn_name":null},{"line":603,"address":[2686403],"length":1,"stats":{"Line":3},"fn_name":null},{"line":605,"address":[2686722],"length":1,"stats":{"Line":3},"fn_name":null},{"line":607,"address":[2682920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[2682941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[2681718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[2681739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[2691773,2690272],"length":1,"stats":{"Line":3},"fn_name":"next_result"},{"line":619,"address":[2690719,2690806,2690565,2690313,2691795],"length":1,"stats":{"Line":15},"fn_name":null},{"line":620,"address":[2690321],"length":1,"stats":{"Line":3},"fn_name":null},{"line":621,"address":[2690331],"length":1,"stats":{"Line":3},"fn_name":null},{"line":622,"address":[2690343],"length":1,"stats":{"Line":3},"fn_name":null},{"line":623,"address":[2690369],"length":1,"stats":{"Line":3},"fn_name":null},{"line":624,"address":[2690395],"length":1,"stats":{"Line":3},"fn_name":null},{"line":625,"address":[2690421],"length":1,"stats":{"Line":3},"fn_name":null},{"line":626,"address":[2690447],"length":1,"stats":{"Line":3},"fn_name":null},{"line":627,"address":[2690471],"length":1,"stats":{"Line":3},"fn_name":null},{"line":628,"address":[2690500],"length":1,"stats":{"Line":3},"fn_name":null},{"line":631,"address":[2690975],"length":1,"stats":{"Line":3},"fn_name":null},{"line":644,"address":[2691070],"length":1,"stats":{"Line":3},"fn_name":null},{"line":645,"address":[2691672],"length":1,"stats":{"Line":3},"fn_name":null},{"line":647,"address":[2691145,2691373,2691463,2691091],"length":1,"stats":{"Line":9},"fn_name":null},{"line":648,"address":[2691189,2691113],"length":1,"stats":{"Line":6},"fn_name":null},{"line":649,"address":[2691444],"length":1,"stats":{"Line":3},"fn_name":null},{"line":651,"address":[2691661],"length":1,"stats":{"Line":3},"fn_name":null},{"line":655,"address":[2692029],"length":1,"stats":{"Line":3},"fn_name":null},{"line":666,"address":[2692146],"length":1,"stats":{"Line":3},"fn_name":null},{"line":667,"address":[2692154],"length":1,"stats":{"Line":3},"fn_name":null},{"line":668,"address":[2692179],"length":1,"stats":{"Line":3},"fn_name":null},{"line":669,"address":[2692204],"length":1,"stats":{"Line":3},"fn_name":null},{"line":670,"address":[2692229],"length":1,"stats":{"Line":3},"fn_name":null},{"line":671,"address":[2692254],"length":1,"stats":{"Line":3},"fn_name":null},{"line":673,"address":[2692279],"length":1,"stats":{"Line":3},"fn_name":null},{"line":674,"address":[2692444,2692965,2692300],"length":1,"stats":{"Line":7},"fn_name":null},{"line":675,"address":[2692449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":676,"address":[2692484],"length":1,"stats":{"Line":3},"fn_name":null},{"line":678,"address":[2692544],"length":1,"stats":{"Line":3},"fn_name":null},{"line":679,"address":[2692872],"length":1,"stats":{"Line":3},"fn_name":null},{"line":681,"address":[2692737],"length":1,"stats":{"Line":3},"fn_name":null},{"line":682,"address":[2692861],"length":1,"stats":{"Line":3},"fn_name":null},{"line":685,"address":[2692359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[2692319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[2692337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[2690701],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":186,"coverable":223},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","lib.rs"],"content":"// some internal functions take a lot of args but thats ok\n#![allow(clippy::too_many_arguments)]\n\nmod ascii_string;\npub mod context;\npub mod endpoint_client;\npub mod endpoint_server;\npub mod gosling;\npub mod identity_client;\npub mod identity_server;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","tests","context.rs"],"content":"// standard\nuse std::io::{BufRead, BufReader, Write};\nuse std::net::TcpStream;\n\n// extern crates\nuse anyhow::bail;\nuse bson::doc;\nuse serial_test::serial;\nuse tor_interface::legacy_tor_client::*;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// internal crates\nuse gosling::context::*;\n\n#[test]\nfn test_mock_client_gosling_context() -\u003e anyhow::Result\u003c()\u003e {\n    let alice_tor_client = Box::new(MockTorClient::new());\n    let pat_tor_client = Box::new(MockTorClient::new());\n    gosling_context_test(alice_tor_client, pat_tor_client)\n}\n\n#[test]\n#[serial]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_legacy_client_gosling_context() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(\"tor\")?;\n\n    let mut alice_path = std::env::temp_dir();\n    alice_path.push(\"test_legacy_client_gosling_context_alice\");\n    let alice_tor_client = Box::new(LegacyTorClient::new(\u0026tor_path, \u0026alice_path)?);\n\n    let mut pat_path = std::env::temp_dir();\n    pat_path.push(\"test_legacy_client_gosling_context_pat\");\n    let pat_tor_client = Box::new(LegacyTorClient::new(\u0026tor_path, \u0026pat_path)?);\n\n    gosling_context_test(alice_tor_client, pat_tor_client)\n}\n\n#[cfg(test)]\nfn gosling_context_test(\n    alice_tor_client: Box\u003cdyn TorProvider\u003e,\n    pat_tor_client: Box\u003cdyn TorProvider\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // Bootstrap Alice\n    let alice_private_key = Ed25519PrivateKey::generate();\n    let alice_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n\n    println!(\n        \"Starting Alice gosling context ({})\",\n        alice_service_id.to_string()\n    );\n\n    let mut alice = Context::new(\n        alice_tor_client,\n        420,\n        420,\n        std::time::Duration::from_secs(60),\n        4096,\n        None,\n        alice_private_key,\n    )?;\n    alice.bootstrap()?;\n\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice.update()?.drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Alice BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    println!(\"Alice Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived { line } =\u003e {\n                    println!(\"--- ALICE --- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // Bootstrap Pat\n    let pat_private_key = Ed25519PrivateKey::generate();\n    let pat_service_id = V3OnionServiceId::from_private_key(\u0026pat_private_key);\n\n    println!(\n        \"Starting Pat gosling context ({})\",\n        pat_service_id.to_string()\n    );\n    let mut pat = Context::new(\n        pat_tor_client,\n        420,\n        420,\n        std::time::Duration::from_secs(60),\n        4096,\n        None,\n        pat_private_key,\n    )?;\n    pat.bootstrap()?;\n\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in pat.update()?.drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Pat BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    println!(\"Pat Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived { line } =\u003e {\n                    println!(\"--- PAT --- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // Start the Alice identity server\n    println!(\"Alice identity server starting\");\n    alice.identity_server_start()?;\n    let mut alice_identity_published: bool = false;\n\n    while !alice_identity_published {\n        for event in alice.update()?.drain(..) {\n            match event {\n                ContextEvent::IdentityServerPublished =\u003e {\n                    alice_identity_published = true;\n                    println!(\"Alice identity server published\");\n                }\n                ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n            }\n        }\n    }\n\n    // Pat begins client handshake\n    println!(\"Pat identity client handshake begin\");\n    let mut pat_identity_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    {\n        let mut pat_identity_handshake_tries_remaining = 3;\n        while pat_identity_handshake_tries_remaining \u003e 0\n            \u0026\u0026 pat_identity_handshake_handle == INVALID_HANDSHAKE_HANDLE\n        {\n            match pat.identity_client_begin_handshake(\n                alice_service_id.clone(),\n                \"test_endpoint\".to_string(),\n            ) {\n                Ok(handle) =\u003e {\n                    pat_identity_handshake_handle = handle;\n                }\n                Err(err) =\u003e {\n                    println!(\n                        \"Pat connecting to Alice's identity server failed with: {:?}\",\n                        err\n                    );\n                    pat_identity_handshake_tries_remaining -= 1;\n                }\n            }\n        }\n\n        if pat_identity_handshake_tries_remaining == 0 {\n            bail!(\"pat.identity_client_handshake() failed no more retries remain\");\n        }\n    }\n\n    // Alice waits for handshake start\n    let mut alice_identity_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    println!(\"Alice waits for identity handshake start\");\n    {\n        let mut alice_identity_server_endpoint_request_received: bool = false;\n        while !alice_identity_server_endpoint_request_received {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerHandshakeStarted { handle } =\u003e {\n                        alice_identity_handshake_handle = handle;\n                        println!(\"Pat has connected to Alice identity server\");\n                    }\n                    ContextEvent::IdentityServerEndpointRequestReceived {\n                        handle,\n                        client_service_id,\n                        requested_endpoint,\n                    } =\u003e {\n                        assert_eq!(alice_identity_handshake_handle, handle);\n                        assert_eq!(pat_service_id, client_service_id);\n                        assert_eq!(requested_endpoint, \"test_endpoint\");\n                        alice_identity_server_endpoint_request_received = true;\n                        println!(\"Alice receives initial identity handshake request\");\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n    }\n\n    // Alice sends challenge\n    println!(\"Alice sends identity server challenge\");\n    alice.identity_server_handle_endpoint_request_received(\n        alice_identity_handshake_handle,\n        true,\n        true,\n        doc! {},\n    )?;\n\n    // Pat responds to challenge\n    println!(\"Pat waits for server challenge\");\n    {\n        let mut pat_identity_client_challenge: Option\u003cbson::document::Document\u003e = None;\n        while pat_identity_client_challenge.is_none() {\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityClientChallengeReceived {\n                        handle,\n                        endpoint_challenge,\n                    } =\u003e {\n                        assert_eq!(handle, pat_identity_handshake_handle);\n                        pat_identity_client_challenge = Some(endpoint_challenge);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        println!(\"Pat responds to challenge\");\n        if let Some(challenge) = pat_identity_client_challenge {\n            assert_eq!(challenge, doc! {});\n            // send empty doc in response\n            pat.identity_client_handle_challenge_received(pat_identity_handshake_handle, doc! {})?;\n        } else {\n            bail!(\"missing pat_identity_client_challenge\");\n        }\n    }\n\n    // Alice evaluate challenge response\n    println!(\"Alice awaits challenge response\");\n    {\n        let mut alice_identity_server_challenge_response: Option\u003cbson::document::Document\u003e = None;\n        while alice_identity_server_challenge_response.is_none() {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerChallengeResponseReceived {\n                        handle,\n                        challenge_response,\n                    } =\u003e {\n                        assert_eq!(handle, alice_identity_handshake_handle);\n                        alice_identity_server_challenge_response = Some(challenge_response);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n        println!(\"Alice evaluates challenge response\");\n        if let Some(challenge_response) = alice_identity_server_challenge_response {\n            assert_eq!(challenge_response, doc! {});\n            println!(\"Alice accepts challenge response\");\n            alice.identity_server_handle_challenge_response_received(\n                alice_identity_handshake_handle,\n                true,\n            )?;\n        } else {\n            bail!(\"missing challenge response\");\n        }\n    }\n\n    // Alice and Pat awaits handshake results\n    println!(\"Identity handshake completing\");\n    let (\n        alice_endpoint_private_key,\n        alice_endpoint_service_id,\n        pat_auth_private_key,\n        pat_auth_public_key,\n    ) = {\n        let mut alice_endpoint_private_key: Option\u003cEd25519PrivateKey\u003e = None;\n        let mut alice_endpoint_service_id: Option\u003cV3OnionServiceId\u003e = None;\n        let mut pat_auth_private_key: Option\u003cX25519PrivateKey\u003e = None;\n        let mut pat_auth_public_key: Option\u003cX25519PublicKey\u003e = None;\n\n        let mut pat_identity_client_handshake_completed: bool = false;\n        let mut alice_identity_server_hanshake_completed: bool = false;\n        while !pat_identity_client_handshake_completed || !alice_identity_server_hanshake_completed\n        {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerHandshakeCompleted {\n                        handle,\n                        endpoint_private_key,\n                        endpoint_name,\n                        client_service_id,\n                        client_auth_public_key,\n                    } =\u003e {\n                        assert_eq!(handle, alice_identity_handshake_handle);\n                        alice_endpoint_private_key = Some(endpoint_private_key);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        assert_eq!(client_service_id, pat_service_id);\n                        pat_auth_public_key = Some(client_auth_public_key);\n                        alice_identity_server_hanshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityClientHandshakeCompleted {\n                        handle,\n                        identity_service_id,\n                        endpoint_service_id,\n                        endpoint_name,\n                        client_auth_private_key,\n                    } =\u003e {\n                        assert_eq!(handle, pat_identity_handshake_handle);\n                        assert_eq!(identity_service_id, alice_service_id);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        alice_endpoint_service_id = Some(endpoint_service_id);\n                        pat_auth_private_key = Some(client_auth_private_key);\n                        pat_identity_client_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        // verify the private key returned by alice matches service id returned by pat\n        assert_eq!(\n            V3OnionServiceId::from_private_key(alice_endpoint_private_key.as_ref().unwrap()),\n            *alice_endpoint_service_id.as_ref().unwrap()\n        );\n\n        (\n            alice_endpoint_private_key.unwrap(),\n            alice_endpoint_service_id.unwrap(),\n            pat_auth_private_key.unwrap(),\n            pat_auth_public_key.unwrap(),\n        )\n    };\n\n    // Alice starts endpoint server\n    println!(\"Alice endpoint server starting\");\n    alice.endpoint_server_start(\n        alice_endpoint_private_key,\n        \"test_endpoint\".to_string(),\n        pat_service_id.clone(),\n        pat_auth_public_key.clone(),\n    )?;\n    {\n        let mut alice_endpoint_server_published: bool = false;\n        while !alice_endpoint_server_published {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerPublished {\n                        endpoint_service_id,\n                        endpoint_name,\n                    } =\u003e {\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        println!(\"Alice endpoint server published\");\n                        alice_endpoint_server_published = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n    }\n\n    // Pat begins client handshake\n    println!(\"Pat endpoint client handshake begin\");\n    let mut pat_endpoint_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    {\n        let mut pat_endpoint_handshake_tries_remaining = 3;\n        while pat_endpoint_handshake_tries_remaining \u003e 0\n            \u0026\u0026 pat_endpoint_handshake_handle == INVALID_HANDSHAKE_HANDLE\n        {\n            match pat.endpoint_client_begin_handshake(\n                alice_endpoint_service_id.clone(),\n                pat_auth_private_key.clone(),\n                \"test_channel\".to_string(),\n            ) {\n                Ok(handle) =\u003e {\n                    pat_endpoint_handshake_handle = handle;\n                }\n                Err(err) =\u003e {\n                    println!(\n                        \"Pat connecting to Alice's identity server failed with:\\n{:?}\",\n                        err\n                    );\n                    pat_endpoint_handshake_tries_remaining -= 1;\n                }\n            }\n        }\n\n        if pat_endpoint_handshake_tries_remaining == 0 {\n            bail!(\"pat.endpoint_client_begin_handshake() failed no more retries remain\");\n        }\n    }\n\n    // Alice waits for handshake start\n    let mut alice_endpoint_server_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    println!(\"Alice waits for endpoint handshake to start\");\n    {\n        let mut alice_endpoint_server_request_recieved: bool = false;\n        while !alice_endpoint_server_request_recieved {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerHandshakeStarted { handle } =\u003e {\n                        alice_endpoint_server_handshake_handle = handle;\n                        println!(\"Pat has connected to Alice endpoint server\")\n                    }\n                    ContextEvent::EndpointServerChannelRequestReceived {\n                        handle,\n                        client_service_id,\n                        requested_channel,\n                    } =\u003e {\n                        assert_eq!(handle, alice_endpoint_server_handshake_handle);\n                        assert_eq!(client_service_id, pat_service_id);\n                        assert_eq!(requested_channel, \"test_channel\");\n                        alice_endpoint_server_request_recieved = true;\n                        println!(\"Pat requesting '{0}' endpoint channel\", requested_channel);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        // Alice sends handshake response\n        println!(\"Alice sends endpoint handshake response\");\n        alice.endpoint_server_handle_channel_request_received(\n            alice_endpoint_server_handshake_handle,\n            true,\n        )?;\n    }\n\n    // Alice and Pat await hndshake result\n    println!(\"Endpoint handshake completing\");\n    let (alice_server_stream, mut pat_client_stream) = {\n        let mut alice_server_stream: Option\u003cTcpStream\u003e = None;\n        let mut pat_client_stream: Option\u003cTcpStream\u003e = None;\n\n        let mut pat_endpoint_client_handshake_completed: bool = false;\n        let mut alice_endpoint_server_handshake_completed: bool = false;\n\n        while !pat_endpoint_client_handshake_completed || !alice_endpoint_server_handshake_completed\n        {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerHandshakeCompleted {\n                        handle,\n                        endpoint_service_id,\n                        client_service_id,\n                        channel_name,\n                        stream,\n                    } =\u003e {\n                        assert_eq!(handle, alice_endpoint_server_handshake_handle);\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(client_service_id, pat_service_id);\n                        assert_eq!(channel_name, \"test_channel\");\n                        alice_server_stream = Some(stream);\n                        alice_endpoint_server_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    _ =\u003e bail!(\"alice.upate() returned unexepcted event\"),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointClientHandshakeCompleted {\n                        handle,\n                        endpoint_service_id,\n                        channel_name,\n                        stream,\n                    } =\u003e {\n                        assert_eq!(handle, pat_endpoint_handshake_handle);\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(channel_name, \"test_channel\");\n                        pat_client_stream = Some(stream);\n                        pat_endpoint_client_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    _ =\u003e bail!(\"pat.upate() returned unexepcted event\"),\n                }\n            }\n        }\n        (alice_server_stream.unwrap(), pat_client_stream.unwrap())\n    };\n\n    println!(\"Endpoint handshake complete, TcpStreams returned\");\n\n    pat_client_stream.write(b\"Hello World!\\n\")?;\n    pat_client_stream.flush()?;\n\n    alice_server_stream.set_nonblocking(false)?;\n    let mut alice_reader = BufReader::new(alice_server_stream);\n\n    let mut response: String = Default::default();\n    alice_reader.read_line(\u0026mut response)?;\n\n    assert_eq!(response, \"Hello World!\\n\");\n\n    println!(\"TcpStream communication succesful\");\n\n    Ok(())\n}\n","traces":[{"line":42,"address":[1302784,1344125,1306225],"length":1,"stats":{"Line":1},"fn_name":"gosling_context_test"},{"line":47,"address":[1302853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1303257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1303438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1303330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1303593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1303646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1303709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1303720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1304044,1304333,1304287,1343952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[1304320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1304494,1304328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[1306585,1306658,1304569,1304504,1305212],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[1305116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1305327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1306261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1305491,1306234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[1306253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[1305521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[1306326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1304531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1306688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1306872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1306764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1307027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[1307080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1307143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1307154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1307767,1343856,1307721,1307478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[1307754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1307762,1307928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[1307938,1308011,1308654,1310088,1310015],"length":1,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[1308558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1309401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1309694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[1309667,1308933],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[1309686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1308963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1309756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1310118,1307965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1310226,1343835,1310137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1310213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1310221,1310387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[1311569,1310470,1311351,1311075,1310397,1311628],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[1310998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[1311246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1311254,1311322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[1311097,1311356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1311641,1310424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[1311660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1311672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1311683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1311705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1343310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[1311732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[1343283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1343379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1343395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[1343408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[1343665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[1343741,1343794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1311693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[1311742,1311816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[1311769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1311781,1311860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[1311879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1311887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1311970,1314927,1315030,1311897,1314687,1312601],"length":1,"stats":{"Line":4},"fn_name":null},{"line":188,"address":[1312501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[1313821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1313837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1314104,1313845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[1313875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1314144,1313969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1314348,1314209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[1314428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1314595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1314603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1313642,1314711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1313592,1312620,1313221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[1313179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1313301,1313384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1315043,1311924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[1315105,1343270,1315356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1315062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1315078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[1315198,1315389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1315408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1315529,1315442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[1340386,1342780,1340994,1343171,1343068,1315562],"length":1,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[1340914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[1342212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1342250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1342399,1342659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1342842,1342029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[1341614,1341979,1341013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[1341572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[1341777,1341694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1315535,1315592],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[1315611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[1315750,1315851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[1316082,1316231,1340250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[1340329,1315769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1316400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1316446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[1316567,1316480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[1340048,1316600,1337932,1337324,1339748,1340151],"length":1,"stats":{"Line":4},"fn_name":null},{"line":268,"address":[1337852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[1339152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[1339206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[1339627,1339367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[1339810,1338973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1337951,1338552,1338923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[1338510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1338632,1338715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[1316630,1316573],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[1316649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[1316788,1316889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[1317120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[1317405,1317174,1337188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[1317166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[1337267,1316807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[1317446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[1323755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1323773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[1323837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[1323869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[1317492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[1317512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[1317520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1317536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[1317544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[1317552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[1317597,1317560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[1322099,1322399,1318302,1317694,1317570,1322502],"length":1,"stats":{"Line":4},"fn_name":null},{"line":318,"address":[1318222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[1321047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[1321144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[1321476,1321305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[1321580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[1321755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[1321923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[1322009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[1320766,1322161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[1320360,1320756,1318321,1318969,1320638],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[1318892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1319170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[1319366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[1319669,1319535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[1319752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[1319919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[1320055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[1320265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[1320422,1318991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[1322828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[1322685,1317607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[1322704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[1322988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[1323083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[1323223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[1323359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[1323901,1323972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":375,"address":[1337048,1324197,1324478,1324304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[1323991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[1324105,1324037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[1324129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[1324190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[1324337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[1324345,1324511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":384,"address":[1324521,1326024,1326261,1326383,1324594,1325199],"length":1,"stats":{"Line":4},"fn_name":null},{"line":385,"address":[1325122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[1325464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[1325504,1325641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":391,"address":[1325724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[1325891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[1325937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[1326048,1325221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[1326393,1324548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[1326412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[1326424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[1326435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[1326457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[1336459,1336526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[1326484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[1336376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[1336391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[1336552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[1336568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[1336581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[1336850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[1336985,1336926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[1326445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[1326568,1326494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[1326521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[1326533,1326612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":437,"address":[1326631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[1326639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[1326722,1326649,1329565,1327353,1329908,1329805],"length":1,"stats":{"Line":4},"fn_name":null},{"line":440,"address":[1327253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[1328573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[1328589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[1328597,1328856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[1328673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[1328721,1328896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[1329098,1328961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[1329181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[1329348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[1329451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[1328394,1329589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[1327372,1327973,1328344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[1327931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[1328136,1328053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[1326676,1329921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[1330187,1329948,1336347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1329940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[1330029,1330220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":478,"address":[1334853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[1330239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[1330258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[1330277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[1330285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[1330293,1330333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":487,"address":[1334452,1331101,1334579,1330303,1330485,1334297],"length":1,"stats":{"Line":4},"fn_name":null},{"line":488,"address":[1331021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1333189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[1333335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[1333504,1333638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[1333721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[1333897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[1334064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[1334172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[1333094,1334370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[1332942,1333084,1332787,1331120,1331768],"length":1,"stats":{"Line":3},"fn_name":null},{"line":508,"address":[1331699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[1331885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[1332001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[1332170,1332304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[1332387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[1332554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[1332662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[1331790,1332860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[1334765,1334676,1330343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":529,"address":[1334889,1334960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[1335095,1336229,1334979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[1335080,1335237,1336211,1335144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[1335380,1336193,1335208,1302821,1335286],"length":1,"stats":{"Line":3},"fn_name":null},{"line":535,"address":[1335350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[1335429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[1335500,1335548,1335695,1336124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[1335610,1335743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[1335818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[1335864],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":222,"coverable":252},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","fuzz","fuzz_targets","fuzz_session.rs"],"content":"#![no_main]\n\n// std\nuse std::collections::{BTreeSet, VecDeque};\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// honk_rpc\nuse honk_rpc::honk_rpc::{ApiSet, Error, ErrorCode, RequestCookie, Response, Session};\n\n// extern\nuse bson::Bson;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\n#[derive(Arbitrary, Debug)]\nenum SessionMethod {\n    Update,\n    ClientCallSync,\n    ClientCallAsync {\n        // the number of update calls the ApiSet should wait before returning\n        wait_count: u8,\n    },\n    ClientCallInvalid{\n        namespace: Option\u003cString\u003e,\n        function: Option\u003cString\u003e,\n        version: Option\u003ci32\u003e,\n        // arguments: Option\u003cbson::document::Document\u003e,\n    },\n    ClientDrainResponses,\n}\n\n\n#[derive(Default)]\nstruct TestApiSet {\n    pending_async_calls: Vec\u003c(u8, RequestCookie)\u003e,\n    complete_async_calls: VecDeque\u003cRequestCookie\u003e,\n}\n\n// impl ApiSet\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"fuzzing\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e) -\u003e Result\u003cOption\u003cBson\u003e, ErrorCode\u003e {\n        match (name, version) {\n            (\"sync_call\", 0) =\u003e Ok(Some(bson::Bson::Null)),\n            (\"sync_call\", _) =\u003e Err(ErrorCode::RequestVersionInvalid),\n            (\"async_call\", 0) =\u003e {\n                if let Some(request_cookie) = request_cookie {\n                    if let Some(bson::Bson::Int32(val)) = args.get_mut(\"wait_count\") {\n                        let \u0026mut val = val;\n                        let wait_count = val.clamp(0, 255) as u8;\n                        self.pending_async_calls.push((wait_count, request_cookie));\n                    }\n                }\n                Ok(None)\n            },\n            (\"async_call\", _) =\u003e Err(ErrorCode::RequestVersionInvalid),\n            _ =\u003e Err(ErrorCode::RequestFunctionInvalid),\n        }\n    }\n\n    fn update(\u0026mut self) -\u003e () {\n        self.pending_async_calls.retain_mut(|record| -\u003e bool {\n            if record.0 == 0 {\n                self.complete_async_calls.push_back(record.1);\n                false\n            } else {\n                record.0 -= 1;\n                true\n            }\n        });\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cBson\u003e, ErrorCode)\u003e {\n        match self.complete_async_calls.pop_front() {\n            Some(cookie) =\u003e Some((cookie, Some(bson::Bson::Null), ErrorCode::Success)),\n            None =\u003e None\n        }\n    }\n}\n\n\nstruct Context {\n    session: Session\u003cTcpStream\u003e,\n    apiset: TestApiSet,\n    pending_successes: BTreeSet\u003cRequestCookie\u003e,\n    pending_failures: BTreeSet\u003cRequestCookie\u003e,\n}\n\nimpl Context {\n    fn new(session: Session\u003cTcpStream\u003e) -\u003e Context {\n        Context{session, apiset: Default::default(), pending_successes: Default::default(), pending_failures: Default::default()}\n    }\n}\n\nfuzz_target!(|methods: Vec\u003cSessionMethod\u003e| {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr).unwrap();\n    let socket_addr = listener.local_addr().unwrap();\n\n    let alice_stream = TcpStream::connect(socket_addr).unwrap();\n    alice_stream.set_nonblocking(true).unwrap();\n\n    let (pat_stream, _socket_addr) = listener.accept().unwrap();\n    pat_stream.set_nonblocking(true).unwrap();\n\n    let alice = Session::new(alice_stream);\n    let pat = Session::new(pat_stream);\n\n    let mut current = \u0026mut Context::new(alice);\n    let mut next = \u0026mut Context::new(pat);\n\n    // run the methods on our pair of HonkRpc Sessions\n    for method in methods {\n        match method {\n            SessionMethod::Update =\u003e match current.session.update(Some(\u0026mut [\u0026mut current.apiset])) {\n                Ok(()) =\u003e {},\n                Err(Error::MessageConversionFailed(ErrorCode::RequestFunctionInvalid)) =\u003e {},\n                Err(error) =\u003e panic!(\"{:?}\", error),\n            },\n            SessionMethod::ClientCallSync =\u003e {\n                let cookie = current.session.client_call(\"fuzzing\", \"sync_call\", 0, bson::doc!{}).unwrap();\n                assert!(current.pending_successes.insert(cookie));\n            }\n            SessionMethod::ClientCallAsync{wait_count} =\u003e {\n                let cookie = current.session.client_call(\"fuzzing\", \"async_call\", 0, bson::doc!{\"wait_count\" : Bson::Int32(wait_count as i32)}).unwrap();\n                assert!(current.pending_successes.insert(cookie));\n            }\n            SessionMethod::ClientCallInvalid{namespace,function,version} =\u003e {\n                // ensure invalid namespace\n                let namespace = match namespace {\n                    Some(namespace) =\u003e namespace,\n                    None =\u003e \"invalid\".to_string(),\n                };\n                let namespace = match namespace.as_str() {\n                    \"fuzzing\" =\u003e \"invalid\",\n                    namespace =\u003e namespace,\n                };\n\n                // ensure invalid function name\n                let function = match function {\n                    Some(function) =\u003e function,\n                    None =\u003e \"invalid\".to_string(),\n                };\n                let function = match function.as_str() {\n                    \"sync_call\" =\u003e \"invalid\",\n                    \"async_call\" =\u003e \"invalid\",\n                    function =\u003e function,\n                };\n\n                // ensure invalid function version\n                let version = match version {\n                    Some(0) =\u003e 1,\n                    Some(version) =\u003e version,\n                    None =\u003e 1,\n                };\n\n                let cookie = current.session.client_call(namespace, function, version, bson::doc!{}).unwrap();\n                assert!(current.pending_failures.insert(cookie));\n            }\n            SessionMethod::ClientDrainResponses =\u003e {\n                for response in current.session.client_drain_responses() {\n                    match response {\n                        Response::Pending{cookie} =\u003e assert!(current.pending_successes.contains(\u0026cookie) || current.pending_failures.contains(\u0026cookie)),\n                        Response::Success{cookie, result: _} =\u003e assert!(current.pending_successes.remove(\u0026cookie)),\n                        Response::Error{cookie, error_code} =\u003e {\n                            assert!(current.pending_failures.remove(\u0026cookie));\n                            assert!(error_code == ErrorCode::RequestNamespaceInvalid ||\n                                    error_code == ErrorCode::RequestFunctionInvalid ||\n                                    error_code == ErrorCode::RequestVersionInvalid);\n                        }\n                    }\n                }\n            },\n        }\n        std::mem::swap(\u0026mut current, \u0026mut next);\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","byte_counter.rs"],"content":"use std::io::Write;\n\n#[derive(Default)]\npub(crate) struct ByteCounter {\n    bytes: usize,\n}\n\nimpl ByteCounter {\n    pub fn bytes(\u0026self) -\u003e usize {\n        self.bytes\n    }\n}\n\nimpl Write for ByteCounter {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.bytes += buf.len();\n        Ok(buf.len())\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), std::io::Error\u003e {\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[11118640],"length":1,"stats":{"Line":5},"fn_name":null},{"line":10,"address":[559765],"length":1,"stats":{"Line":5},"fn_name":null},{"line":15,"address":[12489408],"length":1,"stats":{"Line":5},"fn_name":"write"},{"line":16,"address":[559815,559874],"length":1,"stats":{"Line":5},"fn_name":null},{"line":17,"address":[12489490],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[2804624],"length":1,"stats":{"Line":0},"fn_name":"flush"},{"line":21,"address":[2804629],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":7},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","honk_rpc.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::fmt::Debug;\nuse std::io::{Cursor, ErrorKind};\n#[cfg(test)]\nuse std::net::{SocketAddr, TcpListener, TcpStream};\nuse std::option::Option;\n\n// extern crates\nuse bson::doc;\nuse bson::document::ValueAccessError;\n\nuse crate::byte_counter::ByteCounter;\n\n#[derive(Debug, Eq, PartialEq)]\npub enum ErrorCode {\n    // Protocol Errors\n    BsonParseFailed,\n    MessageTooBig,\n    MessageParseFailed,\n    MessageVersionIncompatible,\n    SectionIdUnknown,\n    SectionParseFailed,\n    RequestCookieInvalid,\n    RequestNamespaceInvalid,\n    RequestFunctionInvalid,\n    RequestVersionInvalid,\n    ResponseCookieInvalid,\n    ResponseStateInvalid,\n\n    Success,\n    Runtime(i32),\n    Unknown(i32),\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to read data from read stream\")]\n    ReaderReadFailed(#[source] std::io::Error),\n\n    #[error(\"received invalid bson document size header value of {0}, must be at least 4\")]\n    BsonDocumentSizeTooSmall(i32),\n\n    #[error(\"received invalid bson document size header value of {0}, must be less than {1}\")]\n    BsonDocumentSizeTooLarge(i32, i32),\n\n    #[error(\"waited longer than {} seconds for read\", .0.as_secs_f32())]\n    MessageReadTimedOut(std::time::Duration),\n\n    #[error(\"failed to parse bson Message document\")]\n    BsonDocumentParseFailed(#[source] bson::de::Error),\n\n    #[error(\"failed to convert bson document to Message\")]\n    MessageConversionFailed(#[source] crate::honk_rpc::ErrorCode),\n\n    #[error(\"failed to serialize bson Message document\")]\n    MessageWriteFailed(#[source] bson::ser::Error),\n\n    #[error(\"failed to write message to write stream\")]\n    WriterWriteFailed(#[source] std::io::Error),\n\n    #[error(\"failed to flush message to write stream\")]\n    WriterFlushFailed(#[source] std::io::Error),\n\n    #[error(\"recieved error section without cookie\")]\n    UnknownErrorSectionReceived(#[source] crate::honk_rpc::ErrorCode),\n\n    #[error(\n        \"tried to set invalid max message size; must be \u003e=5 bytes and \u003c= i32::MAX (2147483647)\"\n    )]\n    InvalidMaxMesageSize(),\n\n    #[error(\"queued message section is too large to write; calculated size is {0} but must be less than {1}\")]\n    SectionTooLarge(usize, usize),\n}\n\nimpl From\u003ci32\u003e for ErrorCode {\n    fn from(value: i32) -\u003e ErrorCode {\n        match value {\n            -1i32 =\u003e ErrorCode::BsonParseFailed,\n            -2i32 =\u003e ErrorCode::MessageTooBig,\n            -3i32 =\u003e ErrorCode::MessageParseFailed,\n            -4i32 =\u003e ErrorCode::MessageVersionIncompatible,\n            -5i32 =\u003e ErrorCode::SectionIdUnknown,\n            -6i32 =\u003e ErrorCode::SectionParseFailed,\n            -7i32 =\u003e ErrorCode::RequestCookieInvalid,\n            -8i32 =\u003e ErrorCode::RequestNamespaceInvalid,\n            -9i32 =\u003e ErrorCode::RequestFunctionInvalid,\n            -10i32 =\u003e ErrorCode::RequestVersionInvalid,\n            -11i32 =\u003e ErrorCode::ResponseCookieInvalid,\n            -12i32 =\u003e ErrorCode::ResponseStateInvalid,\n            0i32 =\u003e ErrorCode::Success,\n            value =\u003e {\n                if value \u003e 0 {\n                    ErrorCode::Runtime(value)\n                } else {\n                    ErrorCode::Unknown(value)\n                }\n            }\n        }\n    }\n}\n\nimpl From\u003cErrorCode\u003e for i32 {\n    fn from(err: ErrorCode) -\u003e Self {\n        match err {\n            ErrorCode::BsonParseFailed =\u003e -1i32,\n            ErrorCode::MessageTooBig =\u003e -2i32,\n            ErrorCode::MessageParseFailed =\u003e -3i32,\n            ErrorCode::MessageVersionIncompatible =\u003e -4i32,\n            ErrorCode::SectionIdUnknown =\u003e -5i32,\n            ErrorCode::SectionParseFailed =\u003e -6i32,\n            ErrorCode::RequestCookieInvalid =\u003e -7i32,\n            ErrorCode::RequestNamespaceInvalid =\u003e -8i32,\n            ErrorCode::RequestFunctionInvalid =\u003e -9i32,\n            ErrorCode::RequestVersionInvalid =\u003e -10i32,\n            ErrorCode::ResponseCookieInvalid =\u003e -11i32,\n            ErrorCode::ResponseStateInvalid =\u003e -12i32,\n            ErrorCode::Success =\u003e 0i32,\n            ErrorCode::Runtime(val) =\u003e val,\n            ErrorCode::Unknown(val) =\u003e val,\n        }\n    }\n}\n\nimpl std::fmt::Display for ErrorCode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            ErrorCode::BsonParseFailed =\u003e write!(f, \"ProtocolError: failed to parse BSON object\"),\n            ErrorCode::MessageTooBig =\u003e write!(f, \"ProtocolError: received document too large\"),\n            ErrorCode::MessageParseFailed =\u003e {\n                write!(f, \"ProtocolError: received message has invalid schema\")\n            }\n            ErrorCode::MessageVersionIncompatible =\u003e write!(\n                f,\n                \"ProtocolError: received message has incompatible version\"\n            ),\n            ErrorCode::SectionIdUnknown =\u003e write!(\n                f,\n                \"ProtocolError: received message contains section of unknown type\"\n            ),\n            ErrorCode::SectionParseFailed =\u003e write!(\n                f,\n                \"ProtocolError: received message contains section with invalid schema\"\n            ),\n            ErrorCode::RequestCookieInvalid =\u003e {\n                write!(f, \"ProtocolError: request cookie already in use\")\n            }\n            ErrorCode::RequestNamespaceInvalid =\u003e write!(\n                f,\n                \"ProtocolError: request function does not exist in requested namespace\"\n            ),\n            ErrorCode::RequestFunctionInvalid =\u003e {\n                write!(f, \"ProtocolError: request function does not exist\")\n            }\n            ErrorCode::RequestVersionInvalid =\u003e {\n                write!(f, \"ProtocolError: request function version does not exist\")\n            }\n            ErrorCode::ResponseCookieInvalid =\u003e {\n                write!(f, \"ProtocolError: response cookie is not recognized\")\n            }\n            ErrorCode::ResponseStateInvalid =\u003e write!(f, \"ProtocolError: response state not valid\"),\n            ErrorCode::Success =\u003e write!(f, \"Success\"),\n            ErrorCode::Runtime(code) =\u003e write!(f, \"RuntimeError: runtime error {}\", code),\n            ErrorCode::Unknown(code) =\u003e write!(f, \"UnknownError: unknown error code {}\", code),\n        }\n    }\n}\n\nimpl std::error::Error for ErrorCode {}\n\nconst HONK_RPC_VERSION: i32 = 1i32;\n\nstruct Message {\n    honk_rpc: i32,\n    sections: Vec\u003cSection\u003e,\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for Message {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        // verify version\n        let honk_rpc = match value.get_i32(\"honk_rpc\") {\n            Ok(HONK_RPC_VERSION) =\u003e HONK_RPC_VERSION,\n            Ok(_bad_version) =\u003e return Err(ErrorCode::MessageVersionIncompatible),\n            Err(_err) =\u003e return Err(ErrorCode::MessageParseFailed),\n        };\n\n        if let Ok(sections) = value.get_array_mut(\"sections\") {\n            // messages must have at least one section\n            if sections.is_empty() {\n                return Err(ErrorCode::MessageParseFailed);\n            }\n\n            let mut message = Message {\n                honk_rpc,\n                sections: Default::default(),\n            };\n\n            for section in sections.iter_mut() {\n                if let bson::Bson::Document(section) = std::mem::take(section) {\n                    message.sections.push(Section::try_from(section)?);\n                } else {\n                    return Err(ErrorCode::SectionParseFailed);\n                }\n            }\n            Ok(message)\n        } else {\n            Err(ErrorCode::MessageParseFailed)\n        }\n    }\n}\n\nimpl From\u003cMessage\u003e for bson::document::Document {\n    fn from(value: Message) -\u003e bson::document::Document {\n        let mut value = value;\n        let mut message = bson::document::Document::new();\n        message.insert(\"honk_rpc\", value.honk_rpc);\n\n        let mut sections = bson::Array::new();\n        for section in value.sections.drain(0..) {\n            sections.push(bson::Bson::Document(bson::document::Document::from(\n                section,\n            )));\n        }\n        message.insert(\"sections\", sections);\n\n        message\n    }\n}\n\npub type RequestCookie = i64;\n\nconst ERROR_SECTION_ID: i32 = 0i32;\nconst REQUEST_SECTION_ID: i32 = 1i32;\nconst RESPONSE_SECTION_ID: i32 = 2i32;\n\nenum Section {\n    Error(ErrorSection),\n    Request(RequestSection),\n    Response(ResponseSection),\n}\n\nstruct ErrorSection {\n    cookie: Option\u003cRequestCookie\u003e,\n    code: ErrorCode,\n    message: Option\u003cString\u003e,\n    data: Option\u003cbson::Bson\u003e,\n}\n\nstruct RequestSection {\n    cookie: Option\u003cRequestCookie\u003e,\n    namespace: String,\n    function: String,\n    version: i32,\n    arguments: bson::document::Document,\n}\n\n#[repr(i32)]\n#[derive(Debug, PartialEq)]\nenum RequestState {\n    Pending = 0i32,\n    Complete = 1i32,\n}\n\nstruct ResponseSection {\n    cookie: RequestCookie,\n    state: RequestState,\n    result: Option\u003cbson::Bson\u003e,\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for Section {\n    type Error = ErrorCode;\n\n    fn try_from(\n        value: bson::document::Document,\n    ) -\u003e Result\u003cSelf, \u003cSelf as TryFrom\u003cbson::document::Document\u003e\u003e::Error\u003e {\n        match value.get_i32(\"id\") {\n            Ok(ERROR_SECTION_ID) =\u003e Ok(Section::Error(ErrorSection::try_from(value)?)),\n            Ok(REQUEST_SECTION_ID) =\u003e Ok(Section::Request(RequestSection::try_from(value)?)),\n            Ok(RESPONSE_SECTION_ID) =\u003e Ok(Section::Response(ResponseSection::try_from(value)?)),\n            Ok(_) =\u003e Err(ErrorCode::SectionIdUnknown),\n            Err(_) =\u003e Err(ErrorCode::SectionParseFailed),\n        }\n    }\n}\n\nimpl From\u003cSection\u003e for bson::document::Document {\n    fn from(value: Section) -\u003e bson::document::Document {\n        match value {\n            Section::Error(section) =\u003e bson::document::Document::from(section),\n            Section::Request(section) =\u003e bson::document::Document::from(section),\n            Section::Response(section) =\u003e bson::document::Document::from(section),\n        }\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for ErrorSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e Some(cookie),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let code = match value.get_i32(\"code\") {\n            Ok(code) =\u003e ErrorCode::from(code),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let message = match value.get_str(\"message\") {\n            Ok(message) =\u003e Some(message.to_string()),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let data = value.get_mut(\"data\").map(std::mem::take);\n\n        Ok(ErrorSection {\n            cookie,\n            code,\n            message,\n            data,\n        })\n    }\n}\n\nimpl From\u003cErrorSection\u003e for bson::document::Document {\n    fn from(value: ErrorSection) -\u003e bson::document::Document {\n        let mut error_section = bson::document::Document::new();\n        error_section.insert(\"id\", ERROR_SECTION_ID);\n\n        if let Some(cookie) = value.cookie {\n            error_section.insert(\"cookie\", cookie);\n        }\n\n        error_section.insert(\"code\", Into::\u003ci32\u003e::into(value.code));\n\n        if let Some(message) = value.message {\n            error_section.insert(\"message\", message);\n        }\n\n        if let Some(data) = value.data {\n            error_section.insert(\"data\", data);\n        }\n\n        error_section\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for RequestSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e Some(cookie),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let namespace = match value.get_str(\"namespace\") {\n            Ok(namespace) =\u003e namespace.to_string(),\n            Err(ValueAccessError::NotPresent) =\u003e String::default(),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let function = match value.get_str(\"function\") {\n            Ok(function) =\u003e {\n                if function.is_empty() {\n                    return Err(ErrorCode::RequestFunctionInvalid);\n                } else {\n                    function.to_string()\n                }\n            }\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let version = match value.get_i32(\"version\") {\n            Ok(version) =\u003e version,\n            Err(ValueAccessError::NotPresent) =\u003e 0i32,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let arguments = match value.get_document_mut(\"arguments\") {\n            Ok(arguments) =\u003e std::mem::take(arguments),\n            Err(ValueAccessError::NotPresent) =\u003e bson::document::Document::new(),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        Ok(RequestSection {\n            cookie,\n            namespace,\n            function,\n            version,\n            arguments,\n        })\n    }\n}\n\nimpl From\u003cRequestSection\u003e for bson::document::Document {\n    fn from(value: RequestSection) -\u003e bson::document::Document {\n        let mut request_section = bson::document::Document::new();\n        request_section.insert(\"id\", REQUEST_SECTION_ID);\n\n        if let Some(cookie) = value.cookie {\n            request_section.insert(\"cookie\", cookie);\n        }\n\n        if !value.namespace.is_empty() {\n            request_section.insert(\"namespace\", value.namespace);\n        }\n\n        request_section.insert(\"function\", value.function);\n\n        if value.version != 0i32 {\n            request_section.insert(\"version\", value.version);\n        }\n\n        request_section.insert(\"arguments\", value.arguments);\n\n        request_section\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for ResponseSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e cookie,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let state = match value.get_i32(\"state\") {\n            Ok(0i32) =\u003e RequestState::Pending,\n            Ok(1i32) =\u003e RequestState::Complete,\n            Ok(_) =\u003e return Err(ErrorCode::ResponseStateInvalid),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let result = value.get_mut(\"result\").map(std::mem::take);\n\n        // if complete the result must be present\n        if state == RequestState::Complete \u0026\u0026 result.is_none() {\n            return Err(ErrorCode::SectionParseFailed);\n        }\n\n        // if pending there should be no result\n        if state == RequestState::Pending \u0026\u0026 result.is_some() {\n            return Err(ErrorCode::SectionParseFailed);\n        }\n\n        Ok(ResponseSection {\n            cookie,\n            state,\n            result,\n        })\n    }\n}\n\nimpl From\u003cResponseSection\u003e for bson::document::Document {\n    fn from(value: ResponseSection) -\u003e bson::document::Document {\n        let mut response_section = bson::document::Document::new();\n        response_section.insert(\"id\", RESPONSE_SECTION_ID);\n\n        response_section.insert(\"cookie\", value.cookie);\n        response_section.insert(\"state\", value.state as i32);\n\n        if let Some(result) = value.result {\n            response_section.insert(\"result\", result);\n        }\n\n        response_section\n    }\n}\n\npub trait ApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str;\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e;\n    fn update(\u0026mut self) {}\n    // TODO: add support for more error data per spec (string, debug)?\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e {\n        None\n    }\n}\n\npub enum Response {\n    Pending {\n        cookie: RequestCookie,\n    },\n    Success {\n        cookie: RequestCookie,\n        result: bson::Bson,\n    },\n    Error {\n        cookie: RequestCookie,\n        error_code: ErrorCode,\n    },\n}\n\n// 4 kilobytes per specification\npub const DEFAULT_MAX_MESSAGE_SIZE: usize = 4 * 1024;\npub const DEFAULT_MAX_WAIT_TIME: std::time::Duration = std::time::Duration::from_secs(60);\n\n// Base Message Bson Format\n// document size             4 (sizeof i32 )\nconst HEADER_SIZE: usize = 4usize;\n// \"honk_rpc\" : i32          1 (0x10) + 8 (strlen \"honk_rpc\") + 1 (null) + 4 (sizeof i32)\nconst HONK_RPC_SIZE: usize = 14usize;\n// \"sections\" : {\"0\": Null}  1 (0x04) + 8 (strlen \"sections\") + 1 (null) + 4 (sizeof i32) + 1 (0x0a) + 1 (strlen \"0\") + 1 (null) + 1 (0x00)\nconst SECTIONS_SIZE: usize = 18usize;\n// footer                    1 (0x00)\nconst FOOTER_SIZE: usize = 1usize;\n\n// The honk-rpc message overhead before the content of a single section is added\nconst MIN_MESSAGE_SIZE: usize = HEADER_SIZE + HONK_RPC_SIZE + SECTIONS_SIZE + FOOTER_SIZE;\n\n// returns the number of bytes needed to encode a message with one section, not\n// counting the size of that section\npub fn get_message_overhead() -\u003e Result\u003cusize, Error\u003e {\n    // construct an example empty message; the size of a real message with\n    // one section can be calculated as the sizeof(message) + sizeof(section)\n    let message = doc! {\n        \"honk_rpc\" : HONK_RPC_VERSION,\n        \"sections\" : [\n            bson::Bson::Null\n        ]\n    };\n\n    let mut counter: ByteCounter = Default::default();\n    message\n        .to_writer(\u0026mut counter)\n        .map_err(Error::MessageWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\npub fn get_error_section_size(\n    cookie: Option\u003cRequestCookie\u003e,\n    message: Option\u003cString\u003e,\n    data: Option\u003cbson::Bson\u003e,\n) -\u003e Result\u003cusize, Error\u003e {\n    let mut error_section = doc! {\n        \"id\": ERROR_SECTION_ID,\n        \"code\": Into::\u003ci32\u003e::into(ErrorCode::Success),\n    };\n\n    if let Some(cookie) = cookie {\n        error_section.insert(\"cookie\", bson::Bson::Int64(cookie));\n    }\n\n    if let Some(message) = message {\n        error_section.insert(\"message\", bson::Bson::String(message));\n    }\n\n    if let Some(data) = data {\n        error_section.insert(\"data\", data);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    error_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::MessageWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\npub fn get_request_section_size(\n    cookie: Option\u003cRequestCookie\u003e,\n    namespace: Option\u003cString\u003e,\n    function: String,\n    version: Option\u003ci32\u003e,\n    arguments: Option\u003cbson::Document\u003e,\n) -\u003e Result\u003cusize, Error\u003e {\n    let mut request_section = doc! {\n        \"id\": REQUEST_SECTION_ID,\n        \"function\": bson::Bson::String(function),\n    };\n\n    if let Some(cookie) = cookie {\n        request_section.insert(\"cookie\", bson::Bson::Int64(cookie));\n    }\n\n    if let Some(namespace) = namespace {\n        request_section.insert(\"namespace\", bson::Bson::String(namespace));\n    }\n\n    if let Some(version) = version {\n        request_section.insert(\"version\", bson::Bson::Int32(version));\n    }\n\n    if let Some(arguments) = arguments {\n        request_section.insert(\"arguments\", arguments);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    request_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::MessageWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\npub fn get_response_section_size(result: Option\u003cbson::Bson\u003e) -\u003e Result\u003cusize, Error\u003e {\n    let mut response_section = doc! {\n        \"id\": RESPONSE_SECTION_ID,\n        \"cookie\": bson::Bson::Int64(0),\n        \"state\": bson::Bson::Int32(0),\n    };\n\n    if let Some(result) = result {\n        response_section.insert(\"result\", result);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    response_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::MessageWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\npub struct Session\u003cRW\u003e {\n    // read-write stream\n    stream: RW,\n    // we write outgoing data to an intermediate buffer to handle writer blocking\n    message_write_buffer: VecDeque\u003cu8\u003e,\n\n    // message read data\n\n    // remaining number of bytes to read for current message\n    // if None, no message read is in progress\n    remaining_byte_count: Option\u003cusize\u003e,\n    // data we've read but not yet a full Message object\n    message_read_buffer: Vec\u003cu8\u003e,\n    // received sections to be handled\n    pending_sections: VecDeque\u003cSection\u003e,\n    // remote client's inbound remote procedure calls to local server\n    inbound_requests: Vec\u003cRequestSection\u003e,\n    // remote server's responses to local client's remote procedure calls\n    inbound_responses: VecDeque\u003cResponse\u003e,\n\n    // message write data\n\n    // we serialize outgoing messages to this buffer first to verify size limitations\n    message_serialization_buffer: VecDeque\u003cu8\u003e,\n    // the next request cookie to use when making a remote prodedure call\n    next_cookie: RequestCookie,\n    // sections to be sent to the remote server\n    outbound_sections: Vec\u003cbson::Document\u003e,\n\n    // the maximum size of a message we've agreed to allow in the session\n    max_message_size: usize,\n    // the maximum amount of time the session is willing to wait to receive a message\n    // before terminating the session\n    max_wait_time: std::time::Duration,\n    // last time a new message read began\n    read_timestamp: std::time::Instant,\n}\n\n#[allow(dead_code)]\nimpl\u003cRW\u003e Session\u003cRW\u003e\nwhere\n    RW: std::io::Read + std::io::Write + Send,\n{\n    pub fn set_max_message_size(\u0026mut self, max_message_size: i32) -\u003e Result\u003c(), Error\u003e {\n        if max_message_size \u003c MIN_MESSAGE_SIZE as i32 {\n            // base size of a honk-rpc mssage\n            Err(Error::InvalidMaxMesageSize())\n        } else {\n            self.max_message_size = max_message_size as usize;\n            Ok(())\n        }\n    }\n\n    pub fn get_max_message_size(\u0026self) -\u003e usize {\n        self.max_message_size\n    }\n\n    pub fn set_max_wait_time(\u0026mut self, max_wait_time: std::time::Duration) {\n        self.max_wait_time = max_wait_time;\n    }\n\n    pub fn get_max_wait_time(\u0026self) -\u003e std::time::Duration {\n        self.max_wait_time\n    }\n\n    pub fn new(stream: RW) -\u003e Self {\n        let mut message_write_buffer: VecDeque\u003cu8\u003e = Default::default();\n        message_write_buffer.reserve(DEFAULT_MAX_MESSAGE_SIZE);\n\n        let mut message_serialization_buffer: VecDeque\u003cu8\u003e = Default::default();\n        message_serialization_buffer.reserve(DEFAULT_MAX_MESSAGE_SIZE);\n\n        Session {\n            stream,\n            message_write_buffer,\n            remaining_byte_count: None,\n            message_read_buffer: Default::default(),\n            pending_sections: Default::default(),\n            inbound_requests: Default::default(),\n            inbound_responses: Default::default(),\n            message_serialization_buffer,\n            next_cookie: Default::default(),\n            outbound_sections: Default::default(),\n            max_message_size: DEFAULT_MAX_MESSAGE_SIZE,\n            max_wait_time: DEFAULT_MAX_WAIT_TIME,\n            read_timestamp: std::time::Instant::now(),\n        }\n    }\n\n    pub fn into_stream(self) -\u003e RW {\n        self.stream\n    }\n\n    fn stream_read(\u0026mut self, buffer: \u0026mut [u8]) -\u003e Result\u003cusize, Error\u003e {\n        match self.stream.read(buffer) {\n            Err(err) =\u003e {\n                if err.kind() == ErrorKind::WouldBlock || err.kind() == ErrorKind::TimedOut {\n                    // abort if we've gone too long without a new message\n                    if std::time::Instant::now().duration_since(self.read_timestamp)\n                        \u003e self.max_wait_time\n                    {\n                        Err(Error::MessageReadTimedOut(self.max_wait_time))\n                    } else {\n                        Ok(0)\n                    }\n                } else {\n                    Err(Error::ReaderReadFailed(err))\n                }\n            }\n            Ok(0) =\u003e Err(Error::ReaderReadFailed(std::io::Error::from(\n                ErrorKind::UnexpectedEof,\n            ))),\n            Ok(count) =\u003e {\n                // update read_timestamp\n                self.read_timestamp = std::time::Instant::now();\n                Ok(count)\n            }\n        }\n    }\n\n    fn read_message_size(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        match self.remaining_byte_count {\n            // we've already read the size header\n            Some(_remaining) =\u003e Ok(()),\n            // still need to read the size header\n            None =\u003e {\n                // may have been partially read already so ensure it's the right size\n                assert!(self.message_read_buffer.len() \u003c std::mem::size_of::\u003ci32\u003e());\n                let bytes_needed = std::mem::size_of::\u003ci32\u003e() - self.message_read_buffer.len();\n                // ensure we have enough space for an entire int32\n                let mut buffer = [0u8; std::mem::size_of::\u003ci32\u003e()];\n                // but shrink view down to number of bytes remaining\n                let buffer = \u0026mut buffer[0..bytes_needed];\n                match self.stream_read(buffer) {\n                    Err(err) =\u003e Err(err),\n                    Ok(0) =\u003e Ok(()),\n                    Ok(count) =\u003e {\n                        #[cfg(test)]\n                        println!(\"\u003c\u003c\u003c read {} bytes for message header\", count);\n                        self.message_read_buffer\n                            .extend_from_slice(\u0026buffer[0..count]);\n\n                        // all bytes required for i32 message size have been read\n                        if self.message_read_buffer.len() == std::mem::size_of::\u003ci32\u003e() {\n                            let size = \u0026self.message_read_buffer.as_slice();\n                            let size: i32 = (size[0] as i32)\n                                | (size[1] as i32) \u003c\u003c 8\n                                | (size[2] as i32) \u003c\u003c 16\n                                | (size[3] as i32) \u003c\u003c 24;\n                            // size should be at least larger than the bytes required for size header\n                            if size \u003c= std::mem::size_of::\u003ci32\u003e() as i32 {\n                                return Err(Error::BsonDocumentSizeTooSmall(size));\n                            }\n                            // convert to usize type now that we know it's not negative\n                            if size as usize \u003e self.max_message_size {\n                                return Err(Error::BsonDocumentSizeTooLarge(\n                                    size,\n                                    self.max_message_size as i32,\n                                ));\n                            }\n\n                            // deduct size of i32 header and save\n                            let size = size as usize - std::mem::size_of::\u003ci32\u003e();\n\n                            self.remaining_byte_count = Some(size);\n                        }\n                        Ok(())\n                    }\n                }\n            }\n        }\n    }\n\n    fn read_message(\u0026mut self) -\u003e Result\u003cOption\u003cMessage\u003e, Error\u003e {\n        // update remaining bytes to read for message\n        self.read_message_size()?;\n        // read the message bytes\n        if let Some(remaining) = self.remaining_byte_count {\n            #[cfg(test)]\n            println!(\"--- message requires {} more bytes\", remaining);\n\n            let mut buffer = vec![0u8; remaining];\n            match self.stream_read(\u0026mut buffer) {\n                Err(err) =\u003e Err(err),\n                Ok(0) =\u003e Ok(None),\n                Ok(count) =\u003e {\n                    #[cfg(test)]\n                    println!(\"\u003c\u003c\u003c read {} bytes\", count);\n                    // append read bytes\n                    self.message_read_buffer\n                        .extend_from_slice(\u0026buffer[0..count]);\n                    if remaining == count {\n                        self.remaining_byte_count = None;\n\n                        let mut cursor = Cursor::new(std::mem::take(\u0026mut self.message_read_buffer));\n                        let bson = bson::document::Document::from_reader(\u0026mut cursor)\n                            .map_err(Error::BsonDocumentParseFailed)?;\n\n                        // take back our allocated vec and clear it\n                        self.message_read_buffer = cursor.into_inner();\n                        self.message_read_buffer.clear();\n\n                        #[cfg(test)]\n                        println!(\"\u003c\u003c\u003c read message: {}\", bson);\n\n                        Ok(Some(\n                            Message::try_from(bson).map_err(Error::MessageConversionFailed)?,\n                        ))\n                    } else {\n                        // update the remaining byte count\n                        self.remaining_byte_count = Some(remaining - count);\n                        Ok(None)\n                    }\n                }\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    // read and save of available sections\n    fn read_sections(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        loop {\n            match self.read_message() {\n                Ok(Some(mut message)) =\u003e {\n                    self.pending_sections.extend(message.sections.drain(..));\n                }\n                Ok(None) =\u003e return Ok(()),\n                Err(err) =\u003e {\n                    match err {\n                        // in the event of timeouts and IO errors we finish any remaining work\n                        Error::MessageReadTimedOut(_) | Error::ReaderReadFailed(_) =\u003e {\n                            // ensure no pending items to handle\n                            if self.pending_sections.is_empty() \u0026\u0026 self.inbound_responses.is_empty()\n                            {\n                                return Err(err);\n                            }\n                            return Ok(());\n                        }\n                        // all other errors we terminate\n                        _ =\u003e return Err(err),\n                    }\n                }\n            }\n        }\n    }\n\n    // route read sections to client and server buffers\n    fn process_sections(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        while let Some(section) = self.pending_sections.pop_front() {\n            match section {\n                Section::Error(error) =\u003e {\n                    if let Some(cookie) = error.cookie {\n                        // error in response to a request\n                        self.inbound_responses.push_back(Response::Error {\n                            cookie,\n                            error_code: error.code,\n                        });\n                    } else {\n                        return Err(Error::UnknownErrorSectionReceived(error.code));\n                    }\n                }\n                Section::Request(request) =\u003e {\n                    // request to route to our apisets\n                    self.inbound_requests.push(request);\n                }\n                Section::Response(response) =\u003e {\n                    // response to our client\n\n                    if let Some(result) = response.result {\n                        self.inbound_responses.push_back(Response::Success {\n                            cookie: response.cookie,\n                            result,\n                        });\n                    } else {\n                        self.inbound_responses.push_back(Response::Pending {\n                            cookie: response.cookie,\n                        });\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn push_outbound_section(\u0026mut self, section: Section) -\u003e Result\u003c(), Error\u003e {\n        let max_section_size = self.max_message_size - MIN_MESSAGE_SIZE;\n\n        let mut counter: ByteCounter = Default::default();\n        let section: bson::Document = section.into();\n        section\n            .to_writer(\u0026mut counter)\n            .map_err(Error::MessageWriteFailed)?;\n        let section_size = counter.bytes();\n\n        if section_size \u003c= max_section_size {\n            self.outbound_sections.push(section);\n            Ok(())\n        } else {\n            Err(Error::SectionTooLarge(section_size, max_section_size))\n        }\n    }\n\n    // package outbound sections into a message, and serialize message to the message_write_buffer\n    fn serialize_messages(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        // if no pending sections there is nothing to do\n        if self.outbound_sections.is_empty() {\n            return Ok(());\n        }\n\n        // build message and convert to bson to send\n        let message = Message {\n            honk_rpc: HONK_RPC_VERSION,\n            sections: Default::default(),\n        };\n        let mut message = bson::document::Document::from(message);\n        message.insert(\"sections\", std::mem::take(\u0026mut self.outbound_sections));\n        self.serialize_messages_impl(message)\n    }\n\n    fn serialize_messages_impl(\n        \u0026mut self,\n        mut message: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self.message_serialization_buffer.clear();\n        message\n            .to_writer(\u0026mut self.message_serialization_buffer)\n            .map_err(Error::MessageWriteFailed)?;\n\n        if self.message_serialization_buffer.len() \u003e self.max_message_size {\n            // if we can't split a message anymore then we have a problem\n            let sections = message.get_array_mut(\"sections\").unwrap();\n            assert!(sections.len() \u003e 1);\n\n            let right = doc! {\n                \"honk_rpc\" : HONK_RPC_VERSION,\n                \"sections\" : sections.split_off(sections.len() / 2),\n            };\n            let left = message;\n\n            self.serialize_messages_impl(left)?;\n            self.serialize_messages_impl(right)?;\n        } else {\n            #[cfg(test)]\n            println!(\"\u003e\u003e\u003e write message: {:?}\", message);\n            // copy the serialized message into the pending write buffer\n            self.message_write_buffer\n                .append(\u0026mut self.message_serialization_buffer);\n        }\n\n        Ok(())\n    }\n\n    fn write_pending_data(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let bytes_written = self.write_pending_data_impl()?;\n        self.stream.flush().map_err(Error::WriterWriteFailed)?;\n        // removes the written bytes\n        self.message_write_buffer.drain(0..bytes_written);\n        // and shuffles the data so it is contiguous\n        self.message_write_buffer.make_contiguous();\n\n        Ok(())\n    }\n\n    fn write_pending_data_impl(\u0026mut self) -\u003e Result\u003cusize, Error\u003e {\n        // write pending data\n        let (mut pending_data, empty): (\u0026[u8], \u0026[u8]) = self.message_write_buffer.as_slices();\n        assert!(empty.is_empty());\n        let pending_bytes: usize = pending_data.len();\n        let mut bytes_written: usize = 0usize;\n\n        while bytes_written != pending_bytes {\n            match self.stream.write(pending_data) {\n                Err(err) =\u003e {\n                    let kind = err.kind();\n                    if kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut {\n                        // no *additional* bytes written so return bytes written so far\n                        return Ok(bytes_written);\n                    } else {\n                        return Err(Error::WriterWriteFailed(err));\n                    }\n                }\n                Ok(count) =\u003e {\n                    bytes_written += count;\n                    #[cfg(test)]\n                    println!(\"\u003e\u003e\u003e sent {} of {} bytes\", bytes_written, pending_bytes);\n                    pending_data = \u0026pending_data[count..];\n                }\n            }\n        }\n\n        Ok(bytes_written)\n    }\n\n    pub fn update(\u0026mut self, apisets: Option\u003c\u0026mut [\u0026mut dyn ApiSet]\u003e) -\u003e Result\u003c(), Error\u003e {\n        // read sections from remote\n        self.read_sections()?;\n        // route sections to buffers\n        self.process_sections()?;\n\n        // handle incoming api calls\n        let apisets = apisets.unwrap_or(\u0026mut []);\n        self.handle_requests(apisets)?;\n\n        // serialize pending responses\n        self.serialize_messages()?;\n\n        // write pendng data to writer\n        self.write_pending_data()?;\n\n        Ok(())\n    }\n\n    // apisets : a slice of mutable ApiSet references sorted by their namespaces\n    fn handle_requests(\u0026mut self, apisets: \u0026mut [\u0026mut dyn ApiSet]) -\u003e Result\u003c(), Error\u003e {\n        // first handle all of our inbound requests\n        let mut inbound_requests = std::mem::take(\u0026mut self.inbound_requests);\n        for mut request in inbound_requests.drain(..) {\n            if let Ok(idx) =\n                apisets.binary_search_by(|probe| probe.namespace().cmp(\u0026request.namespace))\n            {\n                let apiset = match apisets.get_mut(idx) {\n                    Some(apiset) =\u003e apiset,\n                    None =\u003e unreachable!(),\n                };\n                match apiset.exec_function(\n                    \u0026request.function,\n                    request.version,\n                    std::mem::take(\u0026mut request.arguments),\n                    request.cookie,\n                ) {\n                    // func found, called, and returned immediately\n                    Ok(Some(result)) =\u003e {\n                        if let Some(cookie) = request.cookie {\n                            self.push_outbound_section(Section::Response(ResponseSection {\n                                cookie,\n                                state: RequestState::Complete,\n                                result: Some(result),\n                            }))?;\n                        }\n                    }\n                    // func found, called, and result is pending\n                    Ok(None) =\u003e {\n                        if let Some(cookie) = request.cookie {\n                            self.push_outbound_section(Section::Response(ResponseSection {\n                                cookie,\n                                state: RequestState::Pending,\n                                result: None,\n                            }))?;\n                        }\n                    }\n                    // some error\n                    Err(error_code) =\u003e {\n                        self.push_outbound_section(Section::Error(ErrorSection {\n                            cookie: request.cookie,\n                            code: error_code,\n                            message: None,\n                            data: None,\n                        }))?;\n                    }\n                }\n            } else {\n                // invalid namespace\n                self.push_outbound_section(Section::Error(ErrorSection {\n                    cookie: request.cookie,\n                    code: ErrorCode::RequestNamespaceInvalid,\n                    message: None,\n                    data: None,\n                }))?;\n            }\n        }\n\n        // next send out async responses from apisets\n        for apiset in apisets.iter_mut() {\n            // allow apiset to do any required repetitive work\n            apiset.update();\n            // put pending results in our message\n            while let Some((cookie, result, error_code)) = apiset.next_result() {\n                match (cookie, result, error_code) {\n                    (cookie, Some(result), ErrorCode::Success) =\u003e {\n                        self.push_outbound_section(Section::Response(ResponseSection {\n                            cookie,\n                            state: RequestState::Complete,\n                            result: Some(result),\n                        }))?;\n                    }\n                    (cookie, result, error_code) =\u003e {\n                        if let Some(result) = result {\n                            println!(\"Server::update(): ApiSet next_result() returned both result and an ErrorCode {{ result : '{}', error : {} }}\", result, error_code);\n                        }\n                        self.push_outbound_section(Section::Error(ErrorSection {\n                            cookie: Some(cookie),\n                            code: error_code,\n                            message: None,\n                            data: None,\n                        }))?;\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    // call a remote client's function\n    pub fn client_call(\n        \u0026mut self,\n        namespace: \u0026str,\n        function: \u0026str,\n        version: i32,\n        arguments: bson::document::Document,\n    ) -\u003e Result\u003cRequestCookie, Error\u003e {\n        // always make sure we have a new cookie\n        let cookie = self.next_cookie;\n        self.next_cookie += 1;\n\n        // add request to outgoing buffer\n        self.push_outbound_section(Section::Request(RequestSection {\n            cookie: Some(cookie),\n            namespace: namespace.to_string(),\n            function: function.to_string(),\n            version,\n            arguments,\n        }))?;\n\n        Ok(cookie)\n    }\n\n    // consume all the responses from the client\n    pub fn client_drain_responses(\u0026mut self) -\u003e std::collections::vec_deque::Drain\u003cResponse\u003e {\n        self.inbound_responses.drain(..)\n    }\n\n    // get the next response from the client\n    pub fn client_next_response(\u0026mut self) -\u003e Option\u003cResponse\u003e {\n        self.inbound_responses.pop_front()\n    }\n}\n\n#[test]\nfn test_honk_client_read_write() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    let mut alice = Session::new(stream1);\n    let mut pat = Session::new(stream2);\n\n    println!(\"--- pat reads message, but none has been sent\");\n\n    // no message sent yet\n    assert!(pat.read_message()?.is_none());\n\n    println!(\"--- alice sends no message, but no pending sections so no message sent\");\n\n    // send an empty message\n    alice.serialize_messages()?;\n    alice.write_pending_data()?;\n\n    println!(\"--- pat reads message, but none has been sent\");\n\n    // ensure no mesage as actually sent\n    match pat.read_message() {\n        Ok(Some(msg)) =\u003e panic!(\n            \"message should not have been sent: {}\",\n            bson::document::Document::from(msg)\n        ),\n        Ok(None) =\u003e {}\n        Err(err) =\u003e panic!(\"{:?}\", err),\n    }\n\n    println!(\"--- pat sends an error message\");\n\n    const CUSTOM_ERROR: \u0026str = \"Custom Error!\";\n\n    pat.push_outbound_section(Section::Error(ErrorSection {\n        cookie: Some(42069),\n        code: ErrorCode::Runtime(1),\n        message: Some(CUSTOM_ERROR.to_string()),\n        data: None,\n    }))?;\n\n    pat.serialize_messages()?;\n    pat.write_pending_data()?;\n\n    println!(\"--- alice reads and verifies message\");\n\n    // wait for alice to receive message\n    let mut alice_read_message: bool = false;\n    while !alice_read_message {\n        // println!(\"reading...\");\n        if let Some(mut msg) = alice.read_message()? {\n            assert_eq!(msg.sections.len(), 1);\n            match msg.sections.pop() {\n                Some(Section::Error(section)) =\u003e {\n                    match (section.cookie, section.code, section.message) {\n                        (Some(42069), ErrorCode::Runtime(1), Some(message)) =\u003e {\n                            assert_eq!(message, CUSTOM_ERROR);\n                            alice_read_message = true;\n                        }\n                        (cookie, code, message) =\u003e panic!(\n                            \"unexpected error section: cookie: {:?}, code: {:?}, message: {:?}\",\n                            cookie, code, message\n                        ),\n                    };\n                }\n                Some(_) =\u003e panic!(\"was expecting an Error section\"),\n                None =\u003e panic!(\"we should have a message\"),\n            }\n        }\n    }\n\n    println!(\"--- alice sends multi-section message\");\n\n    alice.push_outbound_section(Section::Error(ErrorSection {\n        cookie: Some(42069),\n        code: ErrorCode::Runtime(2),\n        message: Some(CUSTOM_ERROR.to_string()),\n        data: None,\n    }))?;\n    alice.push_outbound_section(Section::Request(RequestSection {\n        cookie: None,\n        namespace: \"std\".to_string(),\n        function: \"print\".to_string(),\n        version: 0,\n        arguments: doc! {\"message\": \"hello!\"},\n    }))?;\n    alice.push_outbound_section(Section::Response(ResponseSection {\n        cookie: 123456,\n        state: RequestState::Pending,\n        result: None,\n    }))?;\n\n    // send a multi-section mesage\n    alice.serialize_messages()?;\n    alice.write_pending_data()?;\n\n    println!(\"--- pat reads and verifies multi-section message\");\n\n    // read sections sent to pat\n    let mut pat_read_message: bool = false;\n    while !pat_read_message {\n        if let Some(msg) = pat.read_message()? {\n            assert_eq!(msg.sections.len(), 3);\n            for section in msg.sections.iter() {\n                match section {\n                    Section::Error(section) =\u003e {\n                        assert_eq!(section.cookie, Some(42069));\n                        assert_eq!(section.code, ErrorCode::Runtime(2));\n                        assert_eq!(section.message, Some(CUSTOM_ERROR.to_string()));\n                        assert_eq!(section.data, None);\n                    }\n                    Section::Request(section) =\u003e {\n                        assert_eq!(section.cookie, None);\n                        assert_eq!(section.namespace, \"std\");\n                        assert_eq!(section.function, \"print\");\n                        assert_eq!(section.version, 0i32);\n                    }\n                    Section::Response(section) =\u003e {\n                        assert_eq!(section.cookie, 123456);\n                        assert_eq!(section.state, RequestState::Pending);\n                        assert_eq!(section.result, None);\n                    }\n                }\n            }\n            pat_read_message = true;\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nstruct TestApiSet {\n    call_count: usize,\n}\n\n#[cfg(test)]\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"namespace\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        _args: bson::document::Document,\n        _request_section: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        match (name, version) {\n            (\"function\", 0) =\u003e {\n                println!(\"--- namespace::function_0() called\");\n                self.call_count += 1;\n            }\n            _ =\u003e (),\n        }\n        Ok(Some(bson::Bson::Null))\n    }\n}\n\n#[test]\nfn test_honk_timeout() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let alice_stream = TcpStream::connect(socket_addr)?;\n    alice_stream.set_nonblocking(true)?;\n    alice_stream.set_nodelay(true)?;\n    println!(\"--- alice peer_addr: {}\", alice_stream.peer_addr()?);\n    let (pat_stream, _socket_addr) = listener.accept()?;\n    pat_stream.set_nonblocking(true)?;\n    pat_stream.set_nodelay(true)?;\n\n    let mut alice = Session::new(alice_stream);\n    let mut alice_apiset = TestApiSet { call_count: 0usize };\n    let mut pat = Session::new(pat_stream);\n\n    let start = std::time::Instant::now();\n\n    println!(\n        \"--- {:?} alice set max_wait_time to 3 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    alice.update(None)?;\n    alice.set_max_wait_time(std::time::Duration::from_secs(3));\n    alice.update(None)?;\n\n    // a read will happen so time should reset\n    println!(\n        \"--- {:?} sleep 2 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(2));\n\n    println!(\n        \"--- {:?} pat calls namespace::function_0()\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.client_call(\"namespace\", \"function\", 0, doc! {})?;\n    while alice_apiset.call_count != 1 {\n        pat.update(None)?;\n        alice.update(Some(\u0026mut [\u0026mut alice_apiset]))?;\n    }\n\n    // a read will happen so time should reset\n    println!(\n        \"--- {:?} sleep 2 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(2));\n    pat.update(None)?;\n    alice.update(None)?;\n\n    println!(\n        \"--- {:?} pat calls namespace::function_0()\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.client_call(\"namespace\", \"function\", 0, doc! {})?;\n    while alice_apiset.call_count != 2 {\n        pat.update(None)?;\n        alice.update(Some(\u0026mut [\u0026mut alice_apiset]))?;\n    }\n\n    // on reads occur so alice should timeout\n    println!(\n        \"--- {:?} sleep 4 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(4));\n\n    println!(\n        \"--- {:?} pat+alice update\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.update(None)?;\n    match alice.update(None) {\n        Ok(()) =\u003e panic!(\"should have timed out\"),\n        Err(Error::MessageReadTimedOut(duration)) =\u003e {\n            println!(\"--- expected time out after {:?}\", duration)\n        }\n        Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n    }\n    Ok(())\n}\n","traces":[{"line":78,"address":[2784576],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":79,"address":[2784586],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[2784640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2784650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[2784660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2784670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2784680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2784690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[2784700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[2784710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[2784720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[2784730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2784740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2784750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[2784760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2784811,2784793,2784626],"length":1,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[2784799],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[2784781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2784816],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":106,"address":[2784824],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[2784856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[2784869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2784882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[2784892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2784902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2784912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2784922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[2784932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2784942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2784952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2784962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[2784972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[2784982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2784992],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[2785006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2785024],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":128,"address":[2785057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[2785087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[2785136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[2785185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2785240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2785295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2785350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[2785405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[2785460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[2785515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[2785570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2785625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2785680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[2785735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[2785795,2785870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[2786033,2785958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2786128,2787771,2787894],"length":1,"stats":{"Line":5},"fn_name":"try_from"},{"line":183,"address":[2786153],"length":1,"stats":{"Line":5},"fn_name":null},{"line":186,"address":[2786308,2786229,2786145],"length":1,"stats":{"Line":15},"fn_name":null},{"line":188,"address":[2786474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2786367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[2786433,2786640,2786537,2787111],"length":1,"stats":{"Line":15},"fn_name":null},{"line":194,"address":[2786576,2786649],"length":1,"stats":{"Line":10},"fn_name":null},{"line":195,"address":[2786679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[2786655],"length":1,"stats":{"Line":5},"fn_name":null},{"line":203,"address":[2786776,2787113,2786851,2787681],"length":1,"stats":{"Line":20},"fn_name":null},{"line":204,"address":[2787129,2787164],"length":1,"stats":{"Line":10},"fn_name":null},{"line":205,"address":[2787472,2787705,2787320],"length":1,"stats":{"Line":10},"fn_name":null},{"line":207,"address":[2787352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2787000],"length":1,"stats":{"Line":5},"fn_name":null},{"line":212,"address":[2786596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[2811433,2810592,2811464],"length":1,"stats":{"Line":5},"fn_name":"from"},{"line":219,"address":[2810609],"length":1,"stats":{"Line":5},"fn_name":null},{"line":220,"address":[2810634],"length":1,"stats":{"Line":5},"fn_name":null},{"line":221,"address":[2810770,2810691],"length":1,"stats":{"Line":10},"fn_name":null},{"line":223,"address":[2810789],"length":1,"stats":{"Line":5},"fn_name":null},{"line":224,"address":[2810808,2810901],"length":1,"stats":{"Line":10},"fn_name":null},{"line":225,"address":[2811287,2811110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[2811132],"length":1,"stats":{"Line":5},"fn_name":null},{"line":231,"address":[2811240],"length":1,"stats":{"Line":5},"fn_name":null},{"line":278,"address":[2789245,2789216,2787920],"length":1,"stats":{"Line":5},"fn_name":"try_from"},{"line":281,"address":[2788040,2787950],"length":1,"stats":{"Line":10},"fn_name":null},{"line":282,"address":[2788766,2788225,2788562],"length":1,"stats":{"Line":6},"fn_name":null},{"line":283,"address":[2788339,2788781],"length":1,"stats":{"Line":10},"fn_name":null},{"line":284,"address":[2788986,2788453],"length":1,"stats":{"Line":10},"fn_name":null},{"line":285,"address":[2788177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2788129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[2811488],"length":1,"stats":{"Line":5},"fn_name":"from"},{"line":293,"address":[2811510],"length":1,"stats":{"Line":5},"fn_name":null},{"line":294,"address":[2811547],"length":1,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[2811589],"length":1,"stats":{"Line":5},"fn_name":null},{"line":296,"address":[2811637],"length":1,"stats":{"Line":5},"fn_name":null},{"line":304,"address":[2790321,2789264,2790343],"length":1,"stats":{"Line":3},"fn_name":"try_from"},{"line":305,"address":[2789281],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[2789414,2789337,2789470],"length":1,"stats":{"Line":6},"fn_name":null},{"line":308,"address":[2789432],"length":1,"stats":{"Line":3},"fn_name":null},{"line":309,"address":[2789523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[2789542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2789490,2789590],"length":1,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[2789632,2789721],"length":1,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[2789670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[2789747,2789859],"length":1,"stats":{"Line":5},"fn_name":null},{"line":319,"address":[2789879,2789812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":320,"address":[2789959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[2789984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[2789927,2790075],"length":1,"stats":{"Line":6},"fn_name":null},{"line":326,"address":[2790166],"length":1,"stats":{"Line":3},"fn_name":null},{"line":327,"address":[2790102],"length":1,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[2790118],"length":1,"stats":{"Line":3},"fn_name":null},{"line":336,"address":[2812687,2811696,2812654],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":337,"address":[2811718],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[2811833,2811910],"length":1,"stats":{"Line":6},"fn_name":null},{"line":340,"address":[2811934],"length":1,"stats":{"Line":3},"fn_name":null},{"line":341,"address":[2811957,2812032],"length":1,"stats":{"Line":6},"fn_name":null},{"line":344,"address":[2812056,2811998],"length":1,"stats":{"Line":6},"fn_name":null},{"line":346,"address":[2812116],"length":1,"stats":{"Line":3},"fn_name":null},{"line":347,"address":[2812184,2812269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[2812293,2812233],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[2812490,2812388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[2812437],"length":1,"stats":{"Line":3},"fn_name":null},{"line":361,"address":[2790368,2791978,2792000],"length":1,"stats":{"Line":5},"fn_name":"try_from"},{"line":362,"address":[2790385],"length":1,"stats":{"Line":5},"fn_name":null},{"line":364,"address":[2790447,2790580,2790524],"length":1,"stats":{"Line":11},"fn_name":null},{"line":365,"address":[2790542],"length":1,"stats":{"Line":5},"fn_name":null},{"line":366,"address":[2790636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[2790655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[2790600,2790698,2790774],"length":1,"stats":{"Line":10},"fn_name":null},{"line":371,"address":[2790794,2790727],"length":1,"stats":{"Line":10},"fn_name":null},{"line":372,"address":[2790895,2790840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[2790852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[2790796,2790941],"length":1,"stats":{"Line":10},"fn_name":null},{"line":377,"address":[2790970],"length":1,"stats":{"Line":5},"fn_name":null},{"line":378,"address":[2791012,2791075],"length":1,"stats":{"Line":10},"fn_name":null},{"line":379,"address":[2791111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[2791099],"length":1,"stats":{"Line":5},"fn_name":null},{"line":384,"address":[2791028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[2791154,2791236,2791301],"length":1,"stats":{"Line":15},"fn_name":null},{"line":388,"address":[2791278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[2791357],"length":1,"stats":{"Line":5},"fn_name":null},{"line":390,"address":[2791375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[2791321,2791418,2791471],"length":1,"stats":{"Line":10},"fn_name":null},{"line":394,"address":[2791436,2791498],"length":1,"stats":{"Line":10},"fn_name":null},{"line":395,"address":[2791858,2791922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[2791882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[2791673],"length":1,"stats":{"Line":5},"fn_name":null},{"line":400,"address":[2791500],"length":1,"stats":{"Line":5},"fn_name":null},{"line":401,"address":[2791526],"length":1,"stats":{"Line":5},"fn_name":null},{"line":402,"address":[2791574],"length":1,"stats":{"Line":5},"fn_name":null},{"line":403,"address":[2791622],"length":1,"stats":{"Line":5},"fn_name":null},{"line":404,"address":[2791633],"length":1,"stats":{"Line":5},"fn_name":null},{"line":410,"address":[2812848,2813762,2813689],"length":1,"stats":{"Line":5},"fn_name":"from"},{"line":411,"address":[2812870],"length":1,"stats":{"Line":5},"fn_name":null},{"line":412,"address":[2812975,2813055],"length":1,"stats":{"Line":10},"fn_name":null},{"line":414,"address":[2813079],"length":1,"stats":{"Line":5},"fn_name":null},{"line":415,"address":[2813158,2813102],"length":1,"stats":{"Line":10},"fn_name":null},{"line":418,"address":[2813181,2813143],"length":1,"stats":{"Line":10},"fn_name":null},{"line":419,"address":[2813349,2813192],"length":1,"stats":{"Line":10},"fn_name":null},{"line":422,"address":[2813273,2813368],"length":1,"stats":{"Line":10},"fn_name":null},{"line":424,"address":[2813392],"length":1,"stats":{"Line":5},"fn_name":null},{"line":425,"address":[2813545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[2813410,2813610],"length":1,"stats":{"Line":10},"fn_name":null},{"line":430,"address":[2813634],"length":1,"stats":{"Line":5},"fn_name":null},{"line":437,"address":[2792016,2793017],"length":1,"stats":{"Line":5},"fn_name":"try_from"},{"line":438,"address":[2792033],"length":1,"stats":{"Line":5},"fn_name":null},{"line":439,"address":[2792092,2792169],"length":1,"stats":{"Line":10},"fn_name":null},{"line":440,"address":[2792187],"length":1,"stats":{"Line":5},"fn_name":null},{"line":441,"address":[2792246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[2792300,2792208],"length":1,"stats":{"Line":10},"fn_name":null},{"line":445,"address":[2792478],"length":1,"stats":{"Line":5},"fn_name":null},{"line":446,"address":[2792491],"length":1,"stats":{"Line":5},"fn_name":null},{"line":447,"address":[2792429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[2792375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[2792502],"length":1,"stats":{"Line":5},"fn_name":null},{"line":454,"address":[2792559,2792665,2792633],"length":1,"stats":{"Line":15},"fn_name":null},{"line":455,"address":[2792703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[2792885,2792639,2792756],"length":1,"stats":{"Line":15},"fn_name":null},{"line":460,"address":[2792926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[2792808],"length":1,"stats":{"Line":5},"fn_name":null},{"line":465,"address":[2792762],"length":1,"stats":{"Line":5},"fn_name":null},{"line":466,"address":[2792773],"length":1,"stats":{"Line":5},"fn_name":null},{"line":472,"address":[2814473,2814454,2813808],"length":1,"stats":{"Line":5},"fn_name":"from"},{"line":473,"address":[2813830],"length":1,"stats":{"Line":5},"fn_name":null},{"line":474,"address":[2813928,2814005],"length":1,"stats":{"Line":10},"fn_name":null},{"line":476,"address":[2814026],"length":1,"stats":{"Line":5},"fn_name":null},{"line":477,"address":[2814090],"length":1,"stats":{"Line":5},"fn_name":null},{"line":479,"address":[2814168],"length":1,"stats":{"Line":5},"fn_name":null},{"line":480,"address":[2814298,2814399],"length":1,"stats":{"Line":10},"fn_name":null},{"line":483,"address":[2814347],"length":1,"stats":{"Line":5},"fn_name":null},{"line":496,"address":[2344352,2344357],"length":1,"stats":{"Line":16},"fn_name":"update\u003cgosling::endpoint_server::EndpointServer\u003e"},{"line":498,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[2794084,2793040],"length":1,"stats":{"Line":3},"fn_name":"get_message_overhead"},{"line":539,"address":[2793287,2793057],"length":1,"stats":{"Line":6},"fn_name":null},{"line":542,"address":[2793243],"length":1,"stats":{"Line":3},"fn_name":null},{"line":546,"address":[2793721,2793663],"length":1,"stats":{"Line":6},"fn_name":null},{"line":547,"address":[2793994,2793729],"length":1,"stats":{"Line":3},"fn_name":null},{"line":549,"address":[2793882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[2794030,2793850],"length":1,"stats":{"Line":6},"fn_name":null},{"line":554,"address":[2795798,2795850,2794112],"length":1,"stats":{"Line":0},"fn_name":"get_error_section_size"},{"line":559,"address":[2794445,2794149,2794266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[2794394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[2794553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[2794725,2794574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[2794649,2794749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[2794780,2794914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[2794879,2794938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[2795085,2795029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[2795073,2795109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[2795382,2794139,2795117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[2795270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[2795238,2795421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[2795888,2797764,2797869],"length":1,"stats":{"Line":3},"fn_name":"get_request_section_size"},{"line":591,"address":[2795954,2796087,2796358],"length":1,"stats":{"Line":9},"fn_name":null},{"line":593,"address":[2796223],"length":1,"stats":{"Line":3},"fn_name":null},{"line":596,"address":[2796447],"length":1,"stats":{"Line":3},"fn_name":null},{"line":597,"address":[2796619,2796468],"length":1,"stats":{"Line":6},"fn_name":null},{"line":600,"address":[2796543,2796643],"length":1,"stats":{"Line":6},"fn_name":null},{"line":601,"address":[2796674,2796780],"length":1,"stats":{"Line":6},"fn_name":null},{"line":604,"address":[2796799,2796768],"length":1,"stats":{"Line":6},"fn_name":null},{"line":605,"address":[2796810,2796919],"length":1,"stats":{"Line":6},"fn_name":null},{"line":608,"address":[2796943,2796884],"length":1,"stats":{"Line":6},"fn_name":null},{"line":609,"address":[2797078,2797022],"length":1,"stats":{"Line":6},"fn_name":null},{"line":612,"address":[2797102,2797066],"length":1,"stats":{"Line":6},"fn_name":null},{"line":613,"address":[2797374,2797110,2795935],"length":1,"stats":{"Line":6},"fn_name":null},{"line":615,"address":[2797262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[2797231,2797412],"length":1,"stats":{"Line":6},"fn_name":null},{"line":620,"address":[2799184,2799165,2797904],"length":1,"stats":{"Line":3},"fn_name":"get_response_section_size"},{"line":621,"address":[2798027,2797926,2798214,2798335],"length":1,"stats":{"Line":12},"fn_name":null},{"line":623,"address":[2798158],"length":1,"stats":{"Line":3},"fn_name":null},{"line":624,"address":[2798280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":627,"address":[2798429],"length":1,"stats":{"Line":3},"fn_name":null},{"line":628,"address":[2798656,2798559],"length":1,"stats":{"Line":6},"fn_name":null},{"line":631,"address":[2798680,2798603],"length":1,"stats":{"Line":6},"fn_name":null},{"line":632,"address":[2798952,2798688],"length":1,"stats":{"Line":3},"fn_name":null},{"line":634,"address":[2798840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[2798809,2798987],"length":1,"stats":{"Line":6},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":862,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":908,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":960,"address":[2257036,2254992,2257009],"length":1,"stats":{"Line":5},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":965,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":966,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":969,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":972,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":974,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":981,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":999,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1008,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1026,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1041,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1042,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1048,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1050,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1054,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1056,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1058,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":1059,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1061,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1065,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1066,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1067,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1069,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1072,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1073,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1074,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1077,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1087,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1096,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1115,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":1118,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1130,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":1131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1144,"address":[2237968,2238939],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1153,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1158,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1159,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1164,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1173,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":365,"coverable":499},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","lib.rs"],"content":"mod byte_counter;\npub mod honk_rpc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","tests","honk_rpc.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// extern crates\nuse bson::doc;\nuse data_encoding::HEXLOWER;\nuse sha3::{Digest, Sha3_256};\n\n// internal crates\nuse honk_rpc::honk_rpc::*;\n\n#[derive(Default)]\nstruct TestApiSet {\n    delay_echo_results: VecDeque\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e,\n}\n\nconst RUNTIME_ERROR_INVALID_ARG: ErrorCode = ErrorCode::Runtime(1i32);\nconst RUNTIME_ERROR_NOT_IMPLEMENTED: ErrorCode = ErrorCode::Runtime(2i32);\n\nimpl TestApiSet {\n    // returns the same string arg sent\n    fn echo_0(\n        \u0026mut self,\n        mut args: bson::document::Document,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        if let Some(bson::Bson::String(val)) = args.get_mut(\"val\") {\n            println!(\"TestApiSet::echo_0(val): val = '{}'\", val);\n            Ok(Some(bson::Bson::String(std::mem::take(val))))\n        } else {\n            Err(RUNTIME_ERROR_INVALID_ARG)\n        }\n    }\n\n    // second version of echo that isn't implemented\n    fn echo_1(\u0026mut self, _args: bson::document::Document) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        Err(RUNTIME_ERROR_NOT_IMPLEMENTED)\n    }\n\n    // same as echo but takes awhile and appends ' - Delayed!' to source string before returning\n    fn delay_echo_0(\n        \u0026mut self,\n        request_cookie: Option\u003cRequestCookie\u003e,\n        mut args: bson::document::Document,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        if let Some(bson::Bson::String(val)) = args.get_mut(\"val\") {\n            println!(\"TestApiSet::delay_echo_0(val): val = '{}'\", val);\n            // only enqueue response if a request cookie is provided\n            if let Some(request_cookie) = request_cookie {\n                val.push_str(\" - Delayed!\");\n                self.delay_echo_results.push_back((\n                    request_cookie,\n                    Some(bson::Bson::String(std::mem::take(val))),\n                    ErrorCode::Success,\n                ));\n            }\n            // async func so don't return result immediately\n            Ok(None)\n        } else {\n            Err(RUNTIME_ERROR_INVALID_ARG)\n        }\n    }\n\n    fn sha256_0(\n        \u0026mut self,\n        mut args: bson::document::Document,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        if let Some(bson::Bson::Binary(val)) = args.get_mut(\"data\") {\n            let mut sha256 = Sha3_256::new();\n            sha256.update(\u0026val.bytes);\n\n            let hash = sha256.finalize();\n\n            Ok(Some(bson::Bson::String(HEXLOWER.encode(\u0026hash))))\n        } else {\n            Err(RUNTIME_ERROR_INVALID_ARG)\n        }\n    }\n}\n\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"test\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e {\n        match (name, version) {\n            (\"echo\", 0) =\u003e self.echo_0(args),\n            (\"echo\", 1) =\u003e self.echo_1(args),\n            (\"delay_echo\", 0) =\u003e self.delay_echo_0(request_cookie, args),\n            (\"sha256\", 0) =\u003e self.sha256_0(args),\n            (name, version) =\u003e {\n                println!(\"received {{ name: '{}', version: {} }}\", name, version);\n                Err(ErrorCode::RequestFunctionInvalid)\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Option\u003cbson::Bson\u003e, ErrorCode)\u003e {\n        self.delay_echo_results.pop_front()\n    }\n}\n\n#[test]\nfn test_honk_client_apiset() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    let mut alice = Session::new(stream1);\n    let mut pat = Session::new(stream2);\n\n    let mut test_api_set: TestApiSet = Default::default();\n    let alice_apisets: \u0026mut [\u0026mut dyn ApiSet] = \u0026mut [\u0026mut test_api_set];\n\n    //\n    // Pat calls remote test::echo_0 call\n    //\n\n    println!(\"--- pat calling test::echo(val: \\\"Hello Alice!\\\")\");\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 0, doc! {\"val\" : \"Hello Alice!\"})?;\n\n    println!(\"--- pat wits for response from alice\");\n    let mut pat_sync_call_handled: bool = false;\n    while !pat_sync_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    if let bson::Bson::String(result) = result {\n                        assert_eq!(result, \"Hello Alice!\");\n                        pat_sync_call_handled = true;\n                    }\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls remote test::echo_0 call (with wrong arg)\n    //\n    println!(\"--- pat calling test::echo(string: \\\"Hello Alice!\\\"), should fail because bad arg\");\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 0, doc! {\"string\" : \"Hello Alice!\"})?;\n\n    println!(\"--- pat waits for response from alice\");\n    let mut pat_bad_call_handled: bool = false;\n    while !pat_bad_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\"received unexpected result: {}, cookie: {}\", result, cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    assert_eq!(error_code, RUNTIME_ERROR_INVALID_ARG);\n                    println!(\"--- pat received invlaid arg response\");\n                    pat_bad_call_handled = true;\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls v2 remote test::echo_1 call (which is not implemented)\n    //\n    println!(\n        \"--- pat calling test::echo_1(val: \\\"Hello Again!\\\"), should fail because not implemented\"\n    );\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 1, doc! {\"val\" : \"Hello Again!\"})?;\n\n    println!(\"--- pat waits for response from alice\");\n    let mut pat_bad_call_handled: bool = false;\n    while !pat_bad_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\"received unexpected result: {}, cookie: {}\", result, cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    assert_eq!(error_code, RUNTIME_ERROR_NOT_IMPLEMENTED);\n                    println!(\"--- pat received not implemented response\");\n                    pat_bad_call_handled = true;\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls test::delay_echo_0 which goes through the async machinery\n    //\n    println!(\"--- pat calling test::delay_echo(val: \\\"Hello Delayed?\\\"), should succeed\");\n    let sent_cookie = pat.client_call(\"test\", \"delay_echo\", 0, doc! {\"val\" : \"Hello Delayed?\"})?;\n\n    println!(\"--- pat waits for ack from alice\");\n    let mut pat_async_call_acked: bool = false;\n    while !pat_async_call_acked {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    println!(\"--- pat received pending response\");\n                    pat_async_call_acked = true;\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\"received unexpected sucess: {}, cookie: {}\", result, cookie);\n                }\n            }\n        }\n    }\n\n    println!(\"--- pat waits for alice response\");\n    let mut pat_async_call_handled: bool = false;\n    while !pat_async_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    if let bson::Bson::String(result) = result {\n                        assert_eq!(result, \"Hello Delayed? - Delayed!\");\n                        println!(\"--- pat received success response\");\n                        pat_async_call_handled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    println!(\"--- pat calling test::sha256(data: [0x00..])\");\n    let mut args: bson::document::Document = Default::default();\n    let data = vec![0u8; DEFAULT_MAX_MESSAGE_SIZE / 2];\n    args.insert(\n        \"data\",\n        bson::Bson::Binary(bson::Binary {\n            subtype: bson::spec::BinarySubtype::Generic,\n            bytes: data,\n        }),\n    );\n\n    let cookie1 = pat.client_call(\"test\", \"sha256\", 0, args)?;\n\n    println!(\"--- pat calling test::sha256(data: [0xff..])\");\n    let mut args: bson::document::Document = Default::default();\n    let data = vec![0xFFu8; DEFAULT_MAX_MESSAGE_SIZE / 2];\n    args.insert(\n        \"data\",\n        bson::Bson::Binary(bson::Binary {\n            subtype: bson::spec::BinarySubtype::Generic,\n            bytes: data,\n        }),\n    );\n\n    let cookie2 = pat.client_call(\"test\", \"sha256\", 0, args)?;\n\n    println!(\"--- pat waits for alice responses\");\n    let mut pat_0x00_buffer_hashed: bool = false;\n    let mut pat_0xff_buffer_hashed: bool = false;\n\n    while !pat_0x00_buffer_hashed || !pat_0xff_buffer_hashed {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        for response in pat.client_drain_responses() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    println!(\"cookie: {}, result: {}\", cookie, result);\n                    if let bson::Bson::String(result) = result {\n                        if cookie == cookie1 {\n                            pat_0x00_buffer_hashed = true;\n                            assert_eq!(\n                                result,\n                                \"463c61ad03873aa9e82581205205acc3d3c8346c7037c43e4e241ee529f2dc27\"\n                            );\n                            println!(\"--- pat received 0x00 buffer hash\");\n                        } else if cookie == cookie2 {\n                            assert_eq!(\n                                result,\n                                \"9bd2dc706dd5251ae8fad858931585c71a1b4587aa7ecb30e15880e1b9dcda16\"\n                            );\n                            pat_0xff_buffer_hashed = true;\n                            println!(\"--- pat received 0xff buffer hash\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":23,"address":[499949,499408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[499446,499627,499520],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[499726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[499790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[499596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[499984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[500012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[500956,500064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[500298,500557,500117,500191],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[500397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[500467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[500492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[500764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[500562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[500753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[500521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[500267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[500992,501767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[501030,501211,501104],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[501243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[501260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[501297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[501319,501447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[501180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[501792],"length":1,"stats":{"Line":1},"fn_name":"namespace"},{"line":86,"address":[503112,501824,503083],"length":1,"stats":{"Line":1},"fn_name":"exec_function"},{"line":93,"address":[502676,502414,502096,501933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[502139,502051,502342,501970],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[502363,502248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[502057,502449,502369],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[502375,502701,502552],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[502558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[502911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[503008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[503136],"length":1,"stats":{"Line":1},"fn_name":"next_result"},{"line":106,"address":[503153],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":36},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","fuzz","fuzz_targets","fuzz_crypto.rs"],"content":"#![no_main]\n\n// tor_interface\nuse tor_interface::tor_crypto::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\n#[derive(Arbitrary, Debug)]\nstruct CryptoData\u003c'a\u003e {\n    ed25519_public_raw: [u8; 32],\n    onion_service_id: \u0026'a str,\n    x25519_public_raw: [u8; 32],\n    message_1: \u0026'a [u8],\n    message_2: \u0026'a [u8],\n    ed25519_private_raw_1: [u8; 64],\n    ed25519_private_raw_2: [u8; 64],\n    x25519_private_raw_1: [u8; 32],\n    x25519_private_raw_2: [u8; 32],\n}\n\nfuzz_target!(|data: CryptoData| {\n\n    //\n    // ed25519 tests\n    //\n\n    // ensure random bytes don't break ed25519public from_raw\n    let _ = Ed25519PublicKey::from_raw(\u0026data.ed25519_public_raw);\n\n    // ensure random string doesn't break v3onionserviceid from_string\n    let _ = V3OnionServiceId::from_string(data.onion_service_id);\n\n    // ensure random bytes don't break x25519public from_raw\n    let _ = X25519PublicKey::from_raw(\u0026data.x25519_public_raw);\n\n    // try to build key from raw binary blob, return early if invalid\n    if let Ok(ed25519_private_1) = Ed25519PrivateKey::from_raw(\u0026data.ed25519_private_raw_1) {\n        // ensure key round-trips through keyblob representation\n        assert_eq!(Ed25519PrivateKey::from_key_blob(ed25519_private_1.to_key_blob().as_ref()).unwrap(), ed25519_private_1);\n\n        // ensure key round-trips through raw bytes representation\n        match Ed25519PrivateKey::from_raw(\u0026ed25519_private_1.to_bytes()) {\n            Ok(ed25519_private) =\u003e assert_eq!(ed25519_private, ed25519_private_1),\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        }\n\n        // derive private keys public key\n        let ed25519_public_1 = Ed25519PublicKey::from_private_key(\u0026ed25519_private_1);\n\n        // compare onion service id derivation from public vs privat ekey\n        assert_eq!(V3OnionServiceId::from_private_key(\u0026ed25519_private_1), V3OnionServiceId::from_public_key(\u0026ed25519_public_1));\n        let onion_service_id_1 = V3OnionServiceId::from_public_key(\u0026ed25519_public_1);\n        // ensure service id round-trips through string representation\n        assert_eq!(V3OnionServiceId::from_string(\u0026onion_service_id_1.to_string()).unwrap(), onion_service_id_1);\n\n        // ensure public key round-trips through service id\n        assert_eq!(ed25519_public_1, Ed25519PublicKey::from_service_id(\u0026V3OnionServiceId::from_public_key(\u0026ed25519_public_1)).unwrap());\n\n        // ensure key round-trips through raw bytes representation\n        assert_eq!(ed25519_public_1, Ed25519PublicKey::from_raw(ed25519_public_1.as_bytes()).unwrap());\n\n        // sign and verify a message\n        let ed25519_signature_1 = ed25519_private_1.sign_message(data.message_1);\n        assert!(ed25519_signature_1.verify(data.message_1, \u0026ed25519_public_1));\n        // verify signature does not work for unrelated message\n        if data.message_1 != data.message_2 {\n            assert!(!ed25519_signature_1.verify(data.message_2, \u0026ed25519_public_1));\n        }\n\n        // ensure we can't verfify another key's signature\n        if data.ed25519_private_raw_1 != data.ed25519_private_raw_2 {\n            // try to build key from raw binary blob, return early if invalid\n            if let Ok(ed25519_private_2) = Ed25519PrivateKey::from_raw(\u0026data.ed25519_private_raw_2) {\n\n                // ensure key round-trips through keyblob representation\n                assert_eq!(Ed25519PrivateKey::from_key_blob(ed25519_private_2.to_key_blob().as_ref()).unwrap(), ed25519_private_2);\n\n                // ensure key round-trips through raw bytes representation\n                match Ed25519PrivateKey::from_raw(\u0026ed25519_private_2.to_bytes()) {\n                    Ok(ed25519_private) =\u003e assert_eq!(ed25519_private, ed25519_private_2),\n                    Err(err) =\u003e panic!(\"{:?}\", err),\n                }\n\n                // derive private key's public key\n                let ed25519_public_2 = Ed25519PublicKey::from_private_key(\u0026ed25519_private_2);\n\n                // compare onion service id derivation from public vs privat ekey\n                assert_eq!(V3OnionServiceId::from_private_key(\u0026ed25519_private_2), V3OnionServiceId::from_public_key(\u0026ed25519_public_2));\n                let onion_service_id_2 = V3OnionServiceId::from_public_key(\u0026ed25519_public_2);\n                // ensure service id round-trips through string representation\n                assert_eq!(V3OnionServiceId::from_string(\u0026onion_service_id_2.to_string()).unwrap(), onion_service_id_2);\n\n                // ensure public key round-trips through service id\n                assert_eq!(ed25519_public_2, Ed25519PublicKey::from_service_id(\u0026V3OnionServiceId::from_public_key(\u0026ed25519_public_2)).unwrap());\n\n                // ensure key round-trips through raw bytes representation\n                assert_eq!(ed25519_public_2, Ed25519PublicKey::from_raw(ed25519_public_2.as_bytes()).unwrap());\n\n\n                // sign and verify a message\n                let ed25519_signature_2 = ed25519_private_2.sign_message(data.message_2);\n                assert!(ed25519_signature_2.verify(data.message_2, \u0026ed25519_public_2));\n\n                // verify signature does not work for unrelated message\n                if data.message_1 != data.message_2 {\n                    assert!(!ed25519_signature_2.verify(data.message_1, \u0026ed25519_public_2));\n                }\n\n                // verify we cannot verify signatures using the wrong public keys\n                if ed25519_public_1 != ed25519_public_2 {\n                    assert!(!ed25519_signature_1.verify(data.message_1, \u0026ed25519_public_2));\n                    assert!(!ed25519_signature_2.verify(data.message_2, \u0026ed25519_public_1));\n                }\n            }\n        }\n    }\n\n    //\n    // x25519 tests\n    //\n\n    if let Ok(x25519_private_1) = X25519PrivateKey::from_raw(\u0026data.x25519_private_raw_1) {\n        // ensure round-trips through byte representation\n        assert_eq!(x25519_private_1, X25519PrivateKey::from_raw(\u0026x25519_private_1.to_bytes()).unwrap());\n        assert_eq!(data.x25519_private_raw_1, x25519_private_1.to_bytes());\n        // ensure round-trips through base64 representation\n        assert_eq!(x25519_private_1, X25519PrivateKey::from_base64(\u0026x25519_private_1.to_base64()).unwrap());\n\n        // ensure converts to e25519 without issue\n        let _ = Ed25519PrivateKey::from_private_x25519(\u0026x25519_private_1).unwrap();\n\n        let x25519_public_1 = X25519PublicKey::from_private_key(\u0026x25519_private_1);\n        // ensure round-trips through byte representation\n        assert_eq!(x25519_public_1, X25519PublicKey::from_raw(x25519_public_1.as_bytes()));\n        // ensure round-trips through base32 representation\n        assert_eq!(x25519_public_1, X25519PublicKey::from_base32(\u0026x25519_public_1.to_base32()).unwrap());\n\n        if let Ok(x25519_private_2) = X25519PrivateKey::from_raw(\u0026data.x25519_private_raw_2) {\n            // ensure round-trips through byte representation\n            assert_eq!(x25519_private_2, X25519PrivateKey::from_raw(\u0026x25519_private_2.to_bytes()).unwrap());\n            assert_eq!(data.x25519_private_raw_2, x25519_private_2.to_bytes());\n            // ensure round-trips through base64 representation\n            assert_eq!(x25519_private_2, X25519PrivateKey::from_base64(\u0026x25519_private_2.to_base64()).unwrap());\n\n            // ensure converts to e25519 without issue\n            let _ = Ed25519PrivateKey::from_private_x25519(\u0026x25519_private_2).unwrap();\n\n            let x25519_public_2 = X25519PublicKey::from_private_key(\u0026x25519_private_2);\n            // ensure round-trips through byte representation\n            assert_eq!(x25519_public_2, X25519PublicKey::from_raw(x25519_public_2.as_bytes()));\n            // ensure round-trips through base32 representation\n            assert_eq!(x25519_public_2, X25519PublicKey::from_base32(\u0026x25519_public_2.to_base32()).unwrap());\n        }\n    }\n\n\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_client.rs"],"content":"// standard\nuse std::boxed::Box;\nuse std::collections::BTreeMap;\nuse std::convert::From;\nuse std::default::Default;\nuse std::io::ErrorKind;\nuse std::net::{SocketAddr, TcpListener};\nuse std::ops::Drop;\nuse std::option::Option;\nuse std::path::Path;\nuse std::string::ToString;\nuse std::sync::{atomic, Arc};\nuse std::time::Duration;\n\n// extern crates\nuse socks::Socks5Stream;\n\n// internal crates\nuse crate::legacy_tor_control_stream::*;\nuse crate::legacy_tor_controller::*;\nuse crate::legacy_tor_process::*;\nuse crate::legacy_tor_version::*;\nuse crate::tor_crypto::*;\nuse crate::tor_provider;\nuse crate::tor_provider::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to create LegacyTorProcess object\")]\n    LegacyTorProcessCreationFailed(#[source] crate::legacy_tor_process::Error),\n\n    #[error(\"failed to create LegacyControlStream object\")]\n    LegacyControlStreamCreationFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"failed to create LegacyTorController object\")]\n    LegacyTorControllerCreationFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to authenticate with the tor process\")]\n    LegacyTorProcessAuthenticationFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to determine the tor process version\")]\n    GetInfoVersionFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"tor process version to old; found {0} but must be at least {1}\")]\n    LegacyTorProcessTooOld(String, String),\n\n    #[error(\"failed to register for STATUS_CLIENT and HS_DESC events\")]\n    SetEventsFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to delete unused onion service\")]\n    DelOnionFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed waiting for async events\")]\n    WaitAsyncEventsFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to begin bootstrap\")]\n    SetConfDisableNetwork0Failed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to add client auth for onion service\")]\n    OnionClientAuthAddFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to remove client auth from onion service\")]\n    OnionClientAuthRemoveFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to get socks listener\")]\n    GetInfoNetListenersSocksFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"no socks listeners available to connect through\")]\n    NoSocksListenersFound(),\n\n    #[error(\"invalid circuit token\")]\n    CircuitTokenInvalid(),\n\n    #[error(\"unable to connect to socks listener\")]\n    Socks5ConnectionFailed(#[source] std::io::Error),\n\n    #[error(\"unable to bind TCP listener\")]\n    TcpListenerBindFailed(#[source] std::io::Error),\n\n    #[error(\"unable to get TCP listener's local address\")]\n    TcpListenerLocalAddrFailed(#[source] std::io::Error),\n\n    #[error(\"failed to create onion service\")]\n    AddOnionFailed(#[source] crate::legacy_tor_controller::Error),\n}\n\nimpl From\u003cError\u003e for crate::tor_provider::Error {\n    fn from(error: Error) -\u003e Self {\n        crate::tor_provider::Error::Generic(error.to_string())\n    }\n}\n\n//\n// CircuitToken Implementation\n//\nstruct LegacyCircuitToken {\n    username: String,\n    password: String,\n}\n\nimpl LegacyCircuitToken {\n    fn new() -\u003e LegacyCircuitToken {\n        const CIRCUIT_TOKEN_USERNAME_LENGTH: usize = 32usize;\n        const CIRCUIT_TOKEN_PASSWORD_LENGTH: usize = 32usize;\n        let username = generate_password(CIRCUIT_TOKEN_USERNAME_LENGTH);\n        let password = generate_password(CIRCUIT_TOKEN_PASSWORD_LENGTH);\n\n        LegacyCircuitToken { username, password }\n    }\n}\n\nimpl Default for LegacyCircuitToken {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n//\n// LegacyOnionListener\n//\n\npub struct LegacyOnionListener {\n    listener: TcpListener,\n    is_active: Arc\u003catomic::AtomicBool\u003e,\n    onion_addr: OnionAddr,\n}\n\nimpl OnionListenerImpl for LegacyOnionListener {\n    fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.listener.set_nonblocking(nonblocking)\n    }\n\n    fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e {\n        match self.listener.accept() {\n            Ok((stream, _socket_addr)) =\u003e Ok(Some(OnionStream {\n                stream,\n                local_addr: Some(self.onion_addr.clone()),\n                peer_addr: None,\n            })),\n            Err(err) =\u003e {\n                if err.kind() == ErrorKind::WouldBlock {\n                    Ok(None)\n                } else {\n                    Err(err)\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for LegacyOnionListener {\n    fn drop(\u0026mut self) {\n        self.is_active.store(false, atomic::Ordering::Relaxed);\n    }\n}\n\npub struct LegacyTorClient {\n    daemon: LegacyTorProcess,\n    version: LegacyTorVersion,\n    controller: LegacyTorController,\n    socks_listener: Option\u003cSocketAddr\u003e,\n    // list of open onion services and their is_active flag\n    onion_services: Vec\u003c(V3OnionServiceId, Arc\u003catomic::AtomicBool\u003e)\u003e,\n    // our list of circuit tokens for the tor daemon\n    circuit_token_counter: usize,\n    circuit_tokens: BTreeMap\u003cCircuitToken, LegacyCircuitToken\u003e,\n}\n\nimpl LegacyTorClient {\n    pub fn new(tor_bin_path: \u0026Path, data_directory: \u0026Path) -\u003e Result\u003cLegacyTorClient, Error\u003e {\n        // launch tor\n        let daemon = LegacyTorProcess::new(tor_bin_path, data_directory)\n            .map_err(Error::LegacyTorProcessCreationFailed)?;\n        // open a control stream\n        let control_stream =\n            LegacyControlStream::new(daemon.get_control_addr(), Duration::from_millis(16))\n                .map_err(Error::LegacyControlStreamCreationFailed)?;\n\n        // create a controler\n        let mut controller = LegacyTorController::new(control_stream)\n            .map_err(Error::LegacyTorControllerCreationFailed)?;\n\n        // authenticate\n        controller\n            .authenticate(daemon.get_password())\n            .map_err(Error::LegacyTorProcessAuthenticationFailed)?;\n\n        // min required version for v3 client auth (see control-spec.txt)\n        let min_required_version = LegacyTorVersion {\n            major: 0u32,\n            minor: 4u32,\n            micro: 6u32,\n            patch_level: 1u32,\n            status_tag: None,\n        };\n\n        let version = controller\n            .getinfo_version()\n            .map_err(Error::GetInfoVersionFailed)?;\n\n        if version \u003c min_required_version {\n            return Err(Error::LegacyTorProcessTooOld(\n                version.to_string(),\n                min_required_version.to_string(),\n            ));\n        }\n\n        // register for STATUS_CLIENT async events\n        controller\n            .setevents(\u0026[\"STATUS_CLIENT\", \"HS_DESC\"])\n            .map_err(Error::SetEventsFailed)?;\n\n        Ok(LegacyTorClient {\n            daemon,\n            version,\n            controller,\n            socks_listener: None,\n            onion_services: Default::default(),\n            circuit_token_counter: 0usize,\n            circuit_tokens: Default::default(),\n        })\n    }\n\n    #[allow(dead_code)]\n    pub fn version(\u0026mut self) -\u003e LegacyTorVersion {\n        self.version.clone()\n    }\n}\n\nimpl TorProvider for LegacyTorClient {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, tor_provider::Error\u003e {\n        let mut i = 0;\n        while i \u003c self.onion_services.len() {\n            // remove onion services with no active listeners\n            if !self.onion_services[i].1.load(atomic::Ordering::Relaxed) {\n                let entry = self.onion_services.swap_remove(i);\n                let service_id = entry.0;\n\n                self.controller\n                    .del_onion(\u0026service_id)\n                    .map_err(Error::DelOnionFailed)?;\n            } else {\n                i += 1;\n            }\n        }\n\n        let mut events: Vec\u003cTorEvent\u003e = Default::default();\n        for async_event in self\n            .controller\n            .wait_async_events()\n            .map_err(Error::WaitAsyncEventsFailed)?\n            .iter()\n        {\n            match async_event {\n                AsyncEvent::StatusClient {\n                    severity,\n                    action,\n                    arguments,\n                } =\u003e {\n                    if severity == \"NOTICE\" \u0026\u0026 action == \"BOOTSTRAP\" {\n                        let mut progress: u32 = 0;\n                        let mut tag: String = Default::default();\n                        let mut summary: String = Default::default();\n                        for (key, val) in arguments.iter() {\n                            match key.as_str() {\n                                \"PROGRESS\" =\u003e progress = val.parse().unwrap_or(0u32),\n                                \"TAG\" =\u003e tag = val.to_string(),\n                                \"SUMMARY\" =\u003e summary = val.to_string(),\n                                _ =\u003e {} // ignore unexpected arguments\n                            }\n                        }\n                        events.push(TorEvent::BootstrapStatus {\n                            progress,\n                            tag,\n                            summary,\n                        });\n                        if progress == 100u32 {\n                            events.push(TorEvent::BootstrapComplete);\n                        }\n                    }\n                }\n                AsyncEvent::HsDesc { action, hs_address } =\u003e {\n                    if action == \"UPLOADED\" {\n                        events.push(TorEvent::OnionServicePublished {\n                            service_id: hs_address.clone(),\n                        });\n                    }\n                }\n                AsyncEvent::Unknown { lines } =\u003e {\n                    println!(\"Received Unknown Event:\");\n                    for line in lines.iter() {\n                        println!(\" {}\", line);\n                    }\n                }\n            }\n        }\n\n        for log_line in self.daemon.wait_log_lines().iter_mut() {\n            events.push(TorEvent::LogReceived {\n                line: std::mem::take(log_line),\n            });\n        }\n\n        Ok(events)\n    }\n\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Ok(self\n            .controller\n            .setconf(\u0026[(\"DisableNetwork\", \"0\")])\n            .map_err(Error::SetConfDisableNetwork0Failed)?)\n    }\n\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Ok(self\n            .controller\n            .onion_client_auth_add(service_id, client_auth, None, \u0026Default::default())\n            .map_err(Error::OnionClientAuthAddFailed)?)\n    }\n\n    fn remove_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Ok(self\n            .controller\n            .onion_client_auth_remove(service_id)\n            .map_err(Error::OnionClientAuthRemoveFailed)?)\n    }\n\n    // connect to an onion service and returns OnionStream\n    fn connect(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, tor_provider::Error\u003e {\n        if self.socks_listener.is_none() {\n            let mut listeners = self\n                .controller\n                .getinfo_net_listeners_socks()\n                .map_err(Error::GetInfoNetListenersSocksFailed)?;\n            if listeners.is_empty() {\n                return Err(Error::NoSocksListenersFound())?;\n            }\n            self.socks_listener = Some(listeners.swap_remove(0));\n        }\n\n        let socks_listener = match self.socks_listener {\n            Some(socks_listener) =\u003e socks_listener,\n            None =\u003e unreachable!(),\n        };\n\n        // our onion domain\n        let target = socks::TargetAddr::Domain(format!(\"{}.onion\", service_id), virt_port);\n        // readwrite stream\n        let stream = match \u0026circuit {\n            None =\u003e Socks5Stream::connect(socks_listener, target),\n            Some(circuit) =\u003e {\n                if let Some(circuit) = self.circuit_tokens.get(circuit) {\n                    Socks5Stream::connect_with_password(\n                        socks_listener,\n                        target,\n                        \u0026circuit.username,\n                        \u0026circuit.password,\n                    )\n                } else {\n                    return Err(Error::CircuitTokenInvalid())?;\n                }\n            }\n        }\n        .map_err(Error::Socks5ConnectionFailed)?;\n\n        Ok(OnionStream {\n            stream: stream.into_inner(),\n            local_addr: None,\n            peer_addr: Some(TargetAddr::OnionService(OnionAddr::V3(OnionAddrV3::new(\n                service_id.clone(),\n                virt_port,\n            )))),\n        })\n    }\n\n    // stand up an onion service and return an LegacyOnionListener\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, tor_provider::Error\u003e {\n        // try to bind to a local address, let OS pick our port\n        let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n        let listener = TcpListener::bind(socket_addr).map_err(Error::TcpListenerBindFailed)?;\n        let socket_addr = listener\n            .local_addr()\n            .map_err(Error::TcpListenerLocalAddrFailed)?;\n\n        let mut flags = AddOnionFlags {\n            discard_pk: true,\n            ..Default::default()\n        };\n        if authorized_clients.is_some() {\n            flags.v3_auth = true;\n        }\n\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(\n            V3OnionServiceId::from_private_key(private_key),\n            virt_port,\n        ));\n\n        // start onion service\n        let (_, service_id) = self\n            .controller\n            .add_onion(\n                Some(private_key),\n                \u0026flags,\n                None,\n                virt_port,\n                Some(socket_addr),\n                authorized_clients,\n            )\n            .map_err(Error::AddOnionFailed)?;\n\n        let is_active = Arc::new(atomic::AtomicBool::new(true));\n        self.onion_services\n            .push((service_id, Arc::clone(\u0026is_active)));\n\n        let onion_listener = Box::new(LegacyOnionListener {\n            listener,\n            is_active,\n            onion_addr,\n        });\n\n        Ok(OnionListener { onion_listener })\n    }\n\n    fn generate_token(\u0026mut self) -\u003e CircuitToken {\n        let new_token = self.circuit_token_counter;\n        self.circuit_token_counter += 1;\n        self.circuit_tokens\n            .insert(new_token, LegacyCircuitToken::new());\n        new_token\n    }\n\n    fn release_token(\u0026mut self, circuit_token: CircuitToken) {\n        self.circuit_tokens.remove(\u0026circuit_token);\n    }\n}\n","traces":[{"line":88,"address":[1575488,1575607],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":89,"address":[1575565,1575507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[1556400,1556581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1556429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1556444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1556608],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":114,"address":[1556616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1556640],"length":1,"stats":{"Line":2},"fn_name":"set_nonblocking"},{"line":130,"address":[1556661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[1556688,1557076],"length":1,"stats":{"Line":3},"fn_name":"accept"},{"line":134,"address":[1556718],"length":1,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[1556756,1556950],"length":1,"stats":{"Line":6},"fn_name":null},{"line":136,"address":[1556787],"length":1,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[1556900,1556794],"length":1,"stats":{"Line":6},"fn_name":null},{"line":138,"address":[1556940],"length":1,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[1556813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[1557143,1557216,1556842],"length":1,"stats":{"Line":4},"fn_name":null},{"line":142,"address":[1557223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[1557191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1368320],"length":1,"stats":{"Line":3},"fn_name":"drop"},{"line":153,"address":[1368329],"length":1,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[1560326,1560802,1557296],"length":1,"stats":{"Line":3},"fn_name":null},{"line":172,"address":[1557755,1557366],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[1557717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[1558184,1557827,1560787,1557702],"length":1,"stats":{"Line":6},"fn_name":null},{"line":177,"address":[1558120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1558066,1558254,1560739,1558516],"length":1,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[1558452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[1558913,1558634,1560705],"length":1,"stats":{"Line":3},"fn_name":null},{"line":185,"address":[1558429,1558591],"length":1,"stats":{"Line":6},"fn_name":null},{"line":186,"address":[1558849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[1560684,1558831,1559280,1558986],"length":1,"stats":{"Line":6},"fn_name":null},{"line":199,"address":[1559216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1559174,1559354],"length":1,"stats":{"Line":6},"fn_name":null},{"line":202,"address":[1560479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1559395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[1560400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[1559425,1559811,1560376,1557334,1559360],"length":1,"stats":{"Line":9},"fn_name":null},{"line":211,"address":[1559747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[1559944],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[1559509],"length":1,"stats":{"Line":3},"fn_name":null},{"line":215,"address":[1559613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[1559669],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[1559707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[1559717],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[1559884],"length":1,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[1560848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1560865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1560896,1564612,1562362],"length":1,"stats":{"Line":3},"fn_name":"update"},{"line":232,"address":[1560935],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[1560971],"length":1,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[1565068,1561071],"length":1,"stats":{"Line":6},"fn_name":null},{"line":236,"address":[1564633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1564673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[1564737,1565011,1562371,1564840,1560927],"length":1,"stats":{"Line":5},"fn_name":null},{"line":241,"address":[1564947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[1565060,1565073,1564764],"length":1,"stats":{"Line":6},"fn_name":null},{"line":247,"address":[1561016],"length":1,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[1561193,1561041,1561447],"length":1,"stats":{"Line":6},"fn_name":null},{"line":251,"address":[1561383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1561753],"length":1,"stats":{"Line":3},"fn_name":null},{"line":255,"address":[1562439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[1563761,1563044,1562489],"length":1,"stats":{"Line":9},"fn_name":null},{"line":261,"address":[1563102],"length":1,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[1563121],"length":1,"stats":{"Line":3},"fn_name":null},{"line":263,"address":[1563128],"length":1,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[1563200,1563289,1563642],"length":1,"stats":{"Line":9},"fn_name":null},{"line":265,"address":[1563683,1563778],"length":1,"stats":{"Line":6},"fn_name":null},{"line":266,"address":[1563794,1564320,1563865],"length":1,"stats":{"Line":9},"fn_name":null},{"line":267,"address":[1563941,1563889,1564147,1563837],"length":1,"stats":{"Line":12},"fn_name":null},{"line":268,"address":[1563905,1563955],"length":1,"stats":{"Line":6},"fn_name":null},{"line":272,"address":[1563536],"length":1,"stats":{"Line":3},"fn_name":null},{"line":273,"address":[1563449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[1563456],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[1563496],"length":1,"stats":{"Line":3},"fn_name":null},{"line":277,"address":[1563700],"length":1,"stats":{"Line":3},"fn_name":null},{"line":278,"address":[1563710,1563766],"length":1,"stats":{"Line":6},"fn_name":null},{"line":282,"address":[1562533],"length":1,"stats":{"Line":3},"fn_name":null},{"line":283,"address":[1564457,1562561],"length":1,"stats":{"Line":6},"fn_name":null},{"line":284,"address":[1564489],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[1564482],"length":1,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[1562381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[1562401,1562597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1562624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[1562956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[1561845],"length":1,"stats":{"Line":3},"fn_name":null},{"line":299,"address":[1562290],"length":1,"stats":{"Line":3},"fn_name":null},{"line":300,"address":[1562156],"length":1,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[1562183],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[1565104],"length":1,"stats":{"Line":3},"fn_name":"bootstrap"},{"line":308,"address":[1565121,1565264],"length":1,"stats":{"Line":3},"fn_name":null},{"line":311,"address":[1565236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[1565673,1565705,1565312],"length":1,"stats":{"Line":3},"fn_name":"add_client_auth"},{"line":319,"address":[1565533,1565486,1565639,1565339],"length":1,"stats":{"Line":9},"fn_name":null},{"line":321,"address":[1565525,1565380,1565686],"length":1,"stats":{"Line":6},"fn_name":null},{"line":322,"address":[1565611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[1565728],"length":1,"stats":{"Line":1},"fn_name":"remove_client_auth"},{"line":329,"address":[1565881,1565744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[1565854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[1568653,1565920,1568365],"length":1,"stats":{"Line":3},"fn_name":"connect"},{"line":342,"address":[1565994],"length":1,"stats":{"Line":3},"fn_name":null},{"line":343,"address":[1566284,1566079],"length":1,"stats":{"Line":3},"fn_name":null},{"line":346,"address":[1566253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[1566230,1566358],"length":1,"stats":{"Line":6},"fn_name":null},{"line":348,"address":[1568685,1568876,1566395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[1566516,1566364],"length":1,"stats":{"Line":6},"fn_name":null},{"line":353,"address":[1566040],"length":1,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[1566692],"length":1,"stats":{"Line":3},"fn_name":null},{"line":359,"address":[1566782],"length":1,"stats":{"Line":3},"fn_name":null},{"line":361,"address":[1568396,1567158,1567964,1567652,1566937],"length":1,"stats":{"Line":11},"fn_name":null},{"line":362,"address":[1566948,1567156],"length":1,"stats":{"Line":6},"fn_name":null},{"line":363,"address":[1567076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[1567193,1567092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[1567251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[1567315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[1567517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[1567335,1568447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[1567900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[1568243],"length":1,"stats":{"Line":3},"fn_name":null},{"line":379,"address":[1568038,1567813],"length":1,"stats":{"Line":6},"fn_name":null},{"line":380,"address":[1568045],"length":1,"stats":{"Line":3},"fn_name":null},{"line":381,"address":[1568121],"length":1,"stats":{"Line":3},"fn_name":null},{"line":382,"address":[1568055],"length":1,"stats":{"Line":3},"fn_name":null},{"line":389,"address":[1571130,1568880,1571091],"length":1,"stats":{"Line":3},"fn_name":"listener"},{"line":396,"address":[1568970],"length":1,"stats":{"Line":3},"fn_name":null},{"line":397,"address":[1569083,1569295],"length":1,"stats":{"Line":3},"fn_name":null},{"line":398,"address":[1569268,1569396,1571118,1569595],"length":1,"stats":{"Line":6},"fn_name":null},{"line":400,"address":[1569531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[1569744,1569818],"length":1,"stats":{"Line":6},"fn_name":null},{"line":407,"address":[1569810],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[1569828],"length":1,"stats":{"Line":3},"fn_name":null},{"line":411,"address":[1569791],"length":1,"stats":{"Line":3},"fn_name":null},{"line":416,"address":[1571100,1570404,1570016,1569946],"length":1,"stats":{"Line":6},"fn_name":null},{"line":419,"address":[1569950],"length":1,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[1569958],"length":1,"stats":{"Line":3},"fn_name":null},{"line":423,"address":[1569968],"length":1,"stats":{"Line":3},"fn_name":null},{"line":424,"address":[1570000],"length":1,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[1570321],"length":1,"stats":{"Line":3},"fn_name":null},{"line":428,"address":[1570438],"length":1,"stats":{"Line":3},"fn_name":null},{"line":429,"address":[1570527,1570705],"length":1,"stats":{"Line":6},"fn_name":null},{"line":430,"address":[1570538,1570633],"length":1,"stats":{"Line":6},"fn_name":null},{"line":432,"address":[1570969,1570755],"length":1,"stats":{"Line":6},"fn_name":null},{"line":433,"address":[1570724],"length":1,"stats":{"Line":3},"fn_name":null},{"line":434,"address":[1570739],"length":1,"stats":{"Line":3},"fn_name":null},{"line":438,"address":[1570977],"length":1,"stats":{"Line":3},"fn_name":null},{"line":441,"address":[1571168],"length":1,"stats":{"Line":0},"fn_name":"generate_token"},{"line":442,"address":[1571188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1571208,1571319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[1571279,1571248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[1571259,1571295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[1571360],"length":1,"stats":{"Line":0},"fn_name":"release_token"},{"line":450,"address":[1571380],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":110,"coverable":152},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_control_stream.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::default::Default;\nuse std::io::{ErrorKind, Read, Write};\nuse std::net::{SocketAddr, TcpStream};\nuse std::option::Option;\nuse std::string::ToString;\nuse std::time::Duration;\n\n// extern crates\nuse regex::Regex;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"control stream read timeout must not be zero\")]\n    ReadTimeoutZero(),\n\n    #[error(\"could not connect to control port\")]\n    CreationFailed(#[source] std::io::Error),\n\n    #[error(\"configure control port socket failed\")]\n    ConfigurationFailed(#[source] std::io::Error),\n\n    #[error(\"control port parsing regex creation failed\")]\n    ParsingRegexCreationFailed(#[source] regex::Error),\n\n    #[error(\"control port stream read failure\")]\n    ReadFailed(#[source] std::io::Error),\n\n    #[error(\"control port stream closed by remote\")]\n    ClosedByRemote(),\n\n    #[error(\"received control port response invalid utf8\")]\n    InvalidResponse(#[source] std::str::Utf8Error),\n\n    #[error(\"failed to parse control port reply: {0}\")]\n    ReplyParseFailed(String),\n\n    #[error(\"control port stream write failure\")]\n    WriteFailed(#[source] std::io::Error),\n}\n\npub(crate) struct LegacyControlStream {\n    stream: TcpStream,\n    closed_by_remote: bool,\n    pending_data: Vec\u003cu8\u003e,\n    pending_lines: VecDeque\u003cString\u003e,\n    pending_reply: Vec\u003cString\u003e,\n    reading_multiline_value: bool,\n    // regexes used to parse control port responses\n    single_line_data: Regex,\n    multi_line_data: Regex,\n    end_reply_line: Regex,\n}\n\ntype StatusCode = u32;\npub(crate) struct Reply {\n    pub status_code: StatusCode,\n    pub reply_lines: Vec\u003cString\u003e,\n}\n\nimpl LegacyControlStream {\n    pub fn new(addr: \u0026SocketAddr, read_timeout: Duration) -\u003e Result\u003cLegacyControlStream, Error\u003e {\n        if read_timeout.is_zero() {\n            return Err(Error::ReadTimeoutZero());\n        }\n\n        let stream = TcpStream::connect(addr).map_err(Error::CreationFailed)?;\n        stream\n            .set_read_timeout(Some(read_timeout))\n            .map_err(Error::ConfigurationFailed)?;\n\n        // pre-allocate a kilobyte for the read buffer\n        const READ_BUFFER_SIZE: usize = 1024;\n        let pending_data = Vec::with_capacity(READ_BUFFER_SIZE);\n\n        let single_line_data =\n            Regex::new(r\"^\\d\\d\\d-.*\").map_err(Error::ParsingRegexCreationFailed)?;\n        let multi_line_data =\n            Regex::new(r\"^\\d\\d\\d+.*\").map_err(Error::ParsingRegexCreationFailed)?;\n        let end_reply_line =\n            Regex::new(r\"^\\d\\d\\d .*\").map_err(Error::ParsingRegexCreationFailed)?;\n\n        Ok(LegacyControlStream {\n            stream,\n            closed_by_remote: false,\n            pending_data,\n            pending_lines: Default::default(),\n            pending_reply: Default::default(),\n            reading_multiline_value: false,\n            // regex\n            single_line_data,\n            multi_line_data,\n            end_reply_line,\n        })\n    }\n\n    #[cfg(test)]\n    pub(crate) fn closed_by_remote(\u0026mut self) -\u003e bool {\n        self.closed_by_remote\n    }\n\n    fn read_line(\u0026mut self) -\u003e Result\u003cOption\u003cString\u003e, Error\u003e {\n        // read pending bytes from stream until we have a line to return\n        while self.pending_lines.is_empty() {\n            let byte_count = self.pending_data.len();\n            match self.stream.read_to_end(\u0026mut self.pending_data) {\n                Err(err) =\u003e {\n                    if err.kind() == ErrorKind::WouldBlock || err.kind() == ErrorKind::TimedOut {\n                        if byte_count == self.pending_data.len() {\n                            return Ok(None);\n                        }\n                    } else {\n                        return Err(Error::ReadFailed(err));\n                    }\n                }\n                Ok(0usize) =\u003e {\n                    self.closed_by_remote = true;\n                    return Err(Error::ClosedByRemote());\n                }\n                Ok(_count) =\u003e (),\n            }\n\n            // split our read buffer into individual lines\n            let mut begin = 0;\n            for index in 1..self.pending_data.len() {\n                if self.pending_data[index - 1] == b'\\r' \u0026\u0026 self.pending_data[index] == b'\\n' {\n                    let end = index - 1;\n                    // view into byte vec of just the found line\n                    let line_view: \u0026[u8] = \u0026self.pending_data[begin..end];\n                    // convert to string\n                    let line_string =\n                        std::str::from_utf8(line_view).map_err(Error::InvalidResponse)?;\n\n                    // save in pending list\n                    self.pending_lines.push_back(line_string.to_string());\n                    // update begin (and skip over \\r\\n)\n                    begin = end + 2;\n                }\n            }\n            // leave any leftover bytes in the buffer for the next call\n            self.pending_data.drain(0..begin);\n        }\n\n        Ok(self.pending_lines.pop_front())\n    }\n\n    pub fn read_reply(\u0026mut self) -\u003e Result\u003cOption\u003cReply\u003e, Error\u003e {\n        loop {\n            let current_line = match self.read_line()? {\n                Some(line) =\u003e line,\n                None =\u003e return Ok(None),\n            };\n\n            // make sure the status code matches (if we are not in the\n            // middle of a multi-line read\n            if let Some(first_line) = self.pending_reply.first() {\n                if !self.reading_multiline_value {\n                    let first_status_code = \u0026first_line[0..3];\n                    let current_status_code = \u0026current_line[0..3];\n                    if first_status_code != current_status_code {\n                        return Err(Error::ReplyParseFailed(format!(\n                            \"mismatched status codes, {} != {}\",\n                            first_status_code, current_status_code\n                        )));\n                    }\n                }\n            }\n\n            // end of a response\n            if self.end_reply_line.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found multi-line end reply but not reading a multi-line reply\".to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n                break;\n            // single line data from getinfo and friends\n            } else if self.single_line_data.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found single-line reply but still reading a multi-line reply\".to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n            // begin of multiline data from getinfo and friends\n            } else if self.multi_line_data.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found multi-line start reply but still reading a multi-line reply\"\n                            .to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n                self.reading_multiline_value = true;\n            // multiline data to be squashed to a single entry\n            } else {\n                if !self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found a multi-line intermediate reply but not reading a multi-line reply\"\n                            .to_string(),\n                    ));\n                }\n                // don't bother writing the end of multiline token\n                if current_line == \".\" {\n                    self.reading_multiline_value = false;\n                } else {\n                    let multiline = match self.pending_reply.last_mut() {\n                        Some(multiline) =\u003e multiline,\n                        // if our logic here is right, then\n                        // self.reading_multiline_value == !self.pending_reply.is_empty()\n                        // should always be true regardless of the data received\n                        // from the control port\n                        None =\u003e unreachable!(),\n                    };\n                    multiline.push('\\n');\n                    multiline.push_str(\u0026current_line);\n                }\n            }\n        }\n\n        // take ownership of the reply lines\n        let mut reply_lines: Vec\u003cString\u003e = Default::default();\n        std::mem::swap(\u0026mut self.pending_reply, \u0026mut reply_lines);\n\n        // parse out the response code for easier matching\n        let status_code_string = match reply_lines.first() {\n            Some(line) =\u003e line[0..3].to_string(),\n            // the lines have already been parsed+validated in the above loop\n            None =\u003e unreachable!(),\n        };\n        let status_code: u32 = match status_code_string.parse() {\n            Ok(status_code) =\u003e status_code,\n            Err(_) =\u003e {\n                return Err(Error::ReplyParseFailed(format!(\n                    \"unable to parse '{}' as status code\",\n                    status_code_string\n                )))\n            }\n        };\n\n        // strip the redundant status code from start of lines\n        for line in reply_lines.iter_mut() {\n            if line.starts_with(\u0026status_code_string) {\n                *line = line[4..].to_string();\n            }\n        }\n\n        Ok(Some(Reply {\n            status_code,\n            reply_lines,\n        }))\n    }\n\n    pub fn write(\u0026mut self, cmd: \u0026str) -\u003e Result\u003c(), Error\u003e {\n        if let Err(err) = write!(self.stream, \"{}\\r\\n\", cmd) {\n            self.closed_by_remote = true;\n            return Err(Error::WriteFailed(err));\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":63,"address":[1620528,1618304,1620697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[1618343],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[1618466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1618529,1618616,1618378],"length":1,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[1618739,1618326,1620682,1618872,1618576],"length":1,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[1618552],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[1618840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1618811],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[1618909,1619146,1618981,1620637],"length":1,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[1619416,1620616,1619110,1619251],"length":1,"stats":{"Line":8},"fn_name":null},{"line":81,"address":[1619380,1619521,1619737],"length":1,"stats":{"Line":8},"fn_name":null},{"line":84,"address":[1620099],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[1619654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[1619673],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[1619713],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[1619842],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[1619907],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[1619971],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[1620035],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[1349328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[1349333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1620736,1622319],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[1620766],"length":1,"stats":{"Line":4},"fn_name":null},{"line":106,"address":[1620871],"length":1,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[1620939,1620895],"length":1,"stats":{"Line":5},"fn_name":null},{"line":108,"address":[1620949],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[1620972,1621298,1621211],"length":1,"stats":{"Line":8},"fn_name":null},{"line":110,"address":[1621455,1621275],"length":1,"stats":{"Line":8},"fn_name":null},{"line":111,"address":[1621489],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[1621346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1620996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[1621003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[1621067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1621085],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[1621552,1621097,1621675],"length":1,"stats":{"Line":12},"fn_name":null},{"line":127,"address":[1622260,1621696],"length":1,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[1621817,1622023],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[1621862],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[1622056,1621934,1622157],"length":1,"stats":{"Line":8},"fn_name":null},{"line":136,"address":[1622088],"length":1,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[1622252,1622265,1622134],"length":1,"stats":{"Line":8},"fn_name":null},{"line":142,"address":[1621598],"length":1,"stats":{"Line":4},"fn_name":null},{"line":145,"address":[1620798],"length":1,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[1622352,1626793],"length":1,"stats":{"Line":4},"fn_name":null},{"line":149,"address":[1625014,1622391],"length":1,"stats":{"Line":8},"fn_name":null},{"line":150,"address":[1622415],"length":1,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[1622753],"length":1,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[1622670],"length":1,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[1622926,1622825],"length":1,"stats":{"Line":8},"fn_name":null},{"line":158,"address":[1623022],"length":1,"stats":{"Line":4},"fn_name":null},{"line":159,"address":[1623095],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[1623197],"length":1,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[1623307],"length":1,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[1623579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[1623039,1623839],"length":1,"stats":{"Line":8},"fn_name":null},{"line":172,"address":[1623925],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[1626842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1625234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1625171],"length":1,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[1623967,1623874],"length":1,"stats":{"Line":8},"fn_name":null},{"line":181,"address":[1624053],"length":1,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[1625043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[1624974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1625001,1624911],"length":1,"stats":{"Line":8},"fn_name":null},{"line":188,"address":[1624002,1624770,1624095],"length":1,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[1624149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1624783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1624728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[1624665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1624763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1624130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1624234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1624167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[1624361,1624194,1624421],"length":1,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[1624414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1624375,1624442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[1624536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1624565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1624582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[1625272],"length":1,"stats":{"Line":4},"fn_name":null},{"line":225,"address":[1625321],"length":1,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[1625377],"length":1,"stats":{"Line":4},"fn_name":null},{"line":229,"address":[1625525],"length":1,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[1625650,1625733],"length":1,"stats":{"Line":8},"fn_name":null},{"line":234,"address":[1625802],"length":1,"stats":{"Line":4},"fn_name":null},{"line":236,"address":[1626584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[1625943,1626264,1625820],"length":1,"stats":{"Line":12},"fn_name":null},{"line":245,"address":[1626336,1626569,1626285],"length":1,"stats":{"Line":12},"fn_name":null},{"line":246,"address":[1626377],"length":1,"stats":{"Line":4},"fn_name":null},{"line":250,"address":[1626143],"length":1,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[1626103],"length":1,"stats":{"Line":4},"fn_name":null},{"line":256,"address":[1626992],"length":1,"stats":{"Line":4},"fn_name":null},{"line":257,"address":[1627103,1627031],"length":1,"stats":{"Line":8},"fn_name":null},{"line":258,"address":[1627215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[1627222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[1627301],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":81,"coverable":96},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_controller.rs"],"content":"// standard\nuse std::default::Default;\nuse std::net::SocketAddr;\nuse std::option::Option;\n#[cfg(test)]\nuse std::path::Path;\nuse std::str::FromStr;\nuse std::string::ToString;\n#[cfg(test)]\nuse std::time::{Duration, Instant};\n\n// extern crates\nuse regex::Regex;\n#[cfg(test)]\nuse serial_test::serial;\n\n// internal crates\nuse crate::legacy_tor_control_stream::*;\n#[cfg(test)]\nuse crate::legacy_tor_process::*;\nuse crate::legacy_tor_version::*;\nuse crate::tor_crypto::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"response regex creation failed\")]\n    ParsingRegexCreationFailed(#[source] regex::Error),\n\n    #[error(\"control stream read reply failed\")]\n    ReadReplyFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"unexpected synchronous reply recieved\")]\n    UnexpectedSynchonousReplyReceived(),\n\n    #[error(\"control stream write command failed\")]\n    WriteCommandFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"invalid command arguments: {0}\")]\n    InvalidCommandArguments(String),\n\n    #[error(\"command failed: {0} {}\", .1.join(\"\\n\"))]\n    CommandFailed(u32, Vec\u003cString\u003e),\n\n    #[error(\"failed to parse command reply: {0}\")]\n    CommandReplyParseFailed(String),\n\n    #[error(\"failed to parse received tor version\")]\n    TorVersionParseFailed(#[source] crate::legacy_tor_version::Error),\n}\n\n// Per-command data\n#[derive(Default)]\npub(crate) struct AddOnionFlags {\n    pub discard_pk: bool,\n    pub detach: bool,\n    pub v3_auth: bool,\n    pub non_anonymous: bool,\n    pub max_streams_close_circuit: bool,\n}\n\n#[derive(Default)]\npub(crate) struct OnionClientAuthAddFlags {\n    pub permanent: bool,\n}\n\npub(crate) enum AsyncEvent {\n    Unknown {\n        lines: Vec\u003cString\u003e,\n    },\n    StatusClient {\n        severity: String,\n        action: String,\n        arguments: Vec\u003c(String, String)\u003e,\n    },\n    HsDesc {\n        action: String,\n        hs_address: V3OnionServiceId,\n    },\n}\n\npub(crate) struct LegacyTorController {\n    // underlying control stream\n    control_stream: LegacyControlStream,\n    // list of async replies to be handled\n    async_replies: Vec\u003cReply\u003e,\n    // regex for parsing events\n    status_event_pattern: Regex,\n    status_event_argument_pattern: Regex,\n    hs_desc_pattern: Regex,\n}\n\nimpl LegacyTorController {\n    pub fn new(control_stream: LegacyControlStream) -\u003e Result\u003cLegacyTorController, Error\u003e {\n        let status_event_pattern =\n            Regex::new(r#\"^STATUS_CLIENT (?P\u003cseverity\u003eNOTICE|WARN|ERR) (?P\u003caction\u003e[A-Za-z]+)\"#)\n                .map_err(Error::ParsingRegexCreationFailed)?;\n        let status_event_argument_pattern =\n            Regex::new(r#\"(?P\u003ckey\u003e[A-Z]+)=(?P\u003cvalue\u003e[A-Za-z0-9_]+|\"[^\"]+\")\"#)\n                .map_err(Error::ParsingRegexCreationFailed)?;\n        let hs_desc_pattern = Regex::new(\n            r#\"HS_DESC (?P\u003caction\u003eREQUESTED|UPLOAD|RECEIVED|UPLOADED|IGNORE|FAILED|CREATED) (?P\u003chsaddress\u003e[a-z2-7]{56})\"#\n        ).map_err(Error::ParsingRegexCreationFailed)?;\n\n        Ok(LegacyTorController {\n            control_stream,\n            async_replies: Default::default(),\n            // regex\n            status_event_pattern,\n            status_event_argument_pattern,\n            hs_desc_pattern,\n        })\n    }\n\n    // return curently available events, does not block waiting\n    // for an event\n    fn wait_async_replies(\u0026mut self) -\u003e Result\u003cVec\u003cReply\u003e, Error\u003e {\n        let mut replies: Vec\u003cReply\u003e = Default::default();\n        // take any previously received async replies\n        std::mem::swap(\u0026mut self.async_replies, \u0026mut replies);\n\n        // and keep consuming until none are available\n        loop {\n            if let Some(reply) = self\n                .control_stream\n                .read_reply()\n                .map_err(Error::ReadReplyFailed)?\n            {\n                replies.push(reply);\n            } else {\n                // no more replies immediately available so return\n                return Ok(replies);\n            }\n        }\n    }\n\n    fn reply_to_event(\u0026self, reply: \u0026mut Reply) -\u003e Result\u003cAsyncEvent, Error\u003e {\n        if reply.status_code != 650u32 {\n            return Err(Error::UnexpectedSynchonousReplyReceived());\n        }\n\n        // not sure this is what we want but yolo\n        let reply_text = reply.reply_lines.join(\" \");\n        if let Some(caps) = self.status_event_pattern.captures(\u0026reply_text) {\n            let severity = match caps.name(\"severity\") {\n                Some(severity) =\u003e severity.as_str(),\n                None =\u003e unreachable!(),\n            };\n            let action = match caps.name(\"action\") {\n                Some(action) =\u003e action.as_str(),\n                None =\u003e unreachable!(),\n            };\n\n            let mut arguments: Vec\u003c(String, String)\u003e = Default::default();\n            for caps in self\n                .status_event_argument_pattern\n                .captures_iter(\u0026reply_text)\n            {\n                let key = match caps.name(\"key\") {\n                    Some(key) =\u003e key.as_str(),\n                    None =\u003e unreachable!(),\n                };\n                let value = {\n                    let value = match caps.name(\"value\") {\n                        Some(value) =\u003e value.as_str(),\n                        None =\u003e unreachable!(),\n                    };\n                    if value.starts_with('\\\"') \u0026\u0026 value.ends_with('\\\"') {\n                        \u0026value[1..value.len() - 1]\n                    } else {\n                        value\n                    }\n                };\n                arguments.push((key.to_string(), value.to_string()));\n            }\n\n            return Ok(AsyncEvent::StatusClient {\n                severity: severity.to_string(),\n                action: action.to_string(),\n                arguments,\n            });\n        }\n\n        if let Some(caps) = self.hs_desc_pattern.captures(\u0026reply_text) {\n            let action = match caps.name(\"action\") {\n                Some(action) =\u003e action.as_str(),\n                None =\u003e unreachable!(),\n            };\n            let hs_address = match caps.name(\"hsaddress\") {\n                Some(hs_address) =\u003e hs_address.as_str(),\n                None =\u003e unreachable!(),\n            };\n\n            if let Ok(hs_address) = V3OnionServiceId::from_string(hs_address) {\n                return Ok(AsyncEvent::HsDesc {\n                    action: action.to_string(),\n                    hs_address,\n                });\n            }\n        }\n\n        // no luck parsing reply, just return full text\n        let mut reply_lines: Vec\u003cString\u003e = Default::default();\n        std::mem::swap(\u0026mut reply_lines, \u0026mut reply.reply_lines);\n\n        Ok(AsyncEvent::Unknown { lines: reply_lines })\n    }\n\n    pub fn wait_async_events(\u0026mut self) -\u003e Result\u003cVec\u003cAsyncEvent\u003e, Error\u003e {\n        let mut async_replies = self.wait_async_replies()?;\n        let mut async_events: Vec\u003cAsyncEvent\u003e = Default::default();\n\n        for reply in async_replies.iter_mut() {\n            async_events.push(self.reply_to_event(reply)?);\n        }\n\n        Ok(async_events)\n    }\n\n    // wait for a sync reply, save off async replies for later\n    fn wait_sync_reply(\u0026mut self) -\u003e Result\u003cReply, Error\u003e {\n        loop {\n            if let Some(reply) = self\n                .control_stream\n                .read_reply()\n                .map_err(Error::ReadReplyFailed)?\n            {\n                match reply.status_code {\n                    650u32 =\u003e self.async_replies.push(reply),\n                    _ =\u003e return Ok(reply),\n                }\n            }\n        }\n    }\n\n    fn write_command(\u0026mut self, text: \u0026str) -\u003e Result\u003cReply, Error\u003e {\n        self.control_stream\n            .write(text)\n            .map_err(Error::WriteCommandFailed)?;\n        self.wait_sync_reply()\n    }\n\n    //\n    // Tor Commands\n    //\n    // The section where we can find the specification in control-spec.txt\n    // for the underlying command is listed in parentheses\n    //\n    // Each of these command wrapper methods block until completion\n    //\n\n    // SETCONF (3.1)\n    fn setconf_cmd(\u0026mut self, key_values: \u0026[(\u0026str, \u0026str)]) -\u003e Result\u003cReply, Error\u003e {\n        if key_values.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"SETCONF key-value pairs list must not be empty\".to_string(),\n            ));\n        }\n        let mut command_buffer = vec![\"SETCONF\".to_string()];\n\n        for (key, value) in key_values.iter() {\n            command_buffer.push(format!(\"{}={}\", key, value));\n        }\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // GETCONF (3.3)\n    #[cfg(test)]\n    fn getconf_cmd(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if keywords.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"GETCONF keywords list must not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"GETCONF {}\", keywords.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // SETEVENTS (3.4)\n    fn setevents_cmd(\u0026mut self, event_codes: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if event_codes.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"SETEVENTS event codes list mut not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"SETEVENTS {}\", event_codes.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // AUTHENTICATE (3.5)\n    fn authenticate_cmd(\u0026mut self, password: \u0026str) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"AUTHENTICATE \\\"{}\\\"\", password);\n\n        self.write_command(\u0026command)\n    }\n\n    // GETINFO (3.9)\n    fn getinfo_cmd(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if keywords.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"GETINFO keywords list must not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"GETINFO {}\", keywords.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // ADD_ONION (3.27)\n    fn add_onion_cmd(\n        \u0026mut self,\n        key: Option\u003c\u0026Ed25519PrivateKey\u003e,\n        flags: \u0026AddOnionFlags,\n        max_streams: Option\u003cu16\u003e,\n        virt_port: u16,\n        target: Option\u003cSocketAddr\u003e,\n        client_auth: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let mut command_buffer = vec![\"ADD_ONION\".to_string()];\n\n        // set our key or request a new one\n        if let Some(key) = key {\n            command_buffer.push(key.to_key_blob());\n        } else {\n            command_buffer.push(\"NEW:ED25519-V3\".to_string());\n        }\n\n        // set our flags\n        let mut flag_buffer: Vec\u003c\u0026str\u003e = Default::default();\n        if flags.discard_pk {\n            flag_buffer.push(\"DiscardPK\");\n        }\n        if flags.detach {\n            flag_buffer.push(\"Detach\");\n        }\n        if flags.v3_auth {\n            flag_buffer.push(\"V3Auth\");\n        }\n        if flags.non_anonymous {\n            flag_buffer.push(\"NonAnonymous\");\n        }\n        if flags.max_streams_close_circuit {\n            flag_buffer.push(\"MaxStreamsCloseCircuit\");\n        }\n\n        if !flag_buffer.is_empty() {\n            command_buffer.push(format!(\"Flags={}\", flag_buffer.join(\",\")));\n        }\n\n        // set max concurrent streams\n        if let Some(max_streams) = max_streams {\n            command_buffer.push(format!(\"MaxStreams={}\", max_streams));\n        }\n\n        // set our onion service target\n        if let Some(target) = target {\n            command_buffer.push(format!(\"Port={},{}\", virt_port, target));\n        } else {\n            command_buffer.push(format!(\"Port={}\", virt_port));\n        }\n        // setup client auth\n        if let Some(client_auth) = client_auth {\n            for key in client_auth.iter() {\n                command_buffer.push(format!(\"ClientAuthV3={}\", key.to_base32()));\n            }\n        }\n\n        // finally send the command\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // DEL_ONION (3.38)\n    fn del_onion_cmd(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"DEL_ONION {}\", service_id);\n\n        self.write_command(\u0026command)\n    }\n\n    // ONION_CLIENT_AUTH_ADD (3.30)\n    fn onion_client_auth_add_cmd(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        private_key: \u0026X25519PrivateKey,\n        client_name: Option\u003cString\u003e,\n        flags: \u0026OnionClientAuthAddFlags,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let mut command_buffer = vec![\"ONION_CLIENT_AUTH_ADD\".to_string()];\n\n        // set the onion service id\n        command_buffer.push(service_id.to_string());\n\n        // set our client's private key\n        command_buffer.push(format!(\"x25519:{}\", private_key.to_base64()));\n\n        if let Some(client_name) = client_name {\n            command_buffer.push(format!(\"ClientName={}\", client_name));\n        }\n\n        if flags.permanent {\n            command_buffer.push(\"Flags=Permanent\".to_string());\n        }\n\n        // finally send command\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // ONION_CLIENT_AUTH_REMOVE (3.31)\n    fn onion_client_auth_remove_cmd(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"ONION_CLIENT_AUTH_REMOVE {}\", service_id);\n\n        self.write_command(\u0026command)\n    }\n\n    //\n    // Public high-level typesafe command method wrappers\n    //\n\n    pub fn setconf(\u0026mut self, key_values: \u0026[(\u0026str, \u0026str)]) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.setconf_cmd(key_values)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    #[cfg(test)]\n    pub fn getconf(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cVec\u003c(String, String)\u003e, Error\u003e {\n        let reply = self.getconf_cmd(keywords)?;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                let mut key_values: Vec\u003c(String, String)\u003e = Default::default();\n                for line in reply.reply_lines {\n                    match line.find('=') {\n                        Some(index) =\u003e key_values\n                            .push((line[0..index].to_string(), line[index + 1..].to_string())),\n                        None =\u003e key_values.push((line, String::new())),\n                    }\n                }\n                Ok(key_values)\n            }\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn setevents(\u0026mut self, events: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.setevents_cmd(events)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn authenticate(\u0026mut self, password: \u0026str) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.authenticate_cmd(password)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn getinfo(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cVec\u003c(String, String)\u003e, Error\u003e {\n        let reply = self.getinfo_cmd(keywords)?;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                let mut key_values: Vec\u003c(String, String)\u003e = Default::default();\n                for line in reply.reply_lines {\n                    match line.find('=') {\n                        Some(index) =\u003e key_values\n                            .push((line[0..index].to_string(), line[index + 1..].to_string())),\n                        None =\u003e {\n                            if line != \"OK\" {\n                                key_values.push((line, String::new()))\n                            }\n                        }\n                    }\n                }\n                Ok(key_values)\n            }\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn add_onion(\n        \u0026mut self,\n        key: Option\u003c\u0026Ed25519PrivateKey\u003e,\n        flags: \u0026AddOnionFlags,\n        max_streams: Option\u003cu16\u003e,\n        virt_port: u16,\n        target: Option\u003cSocketAddr\u003e,\n        client_auth: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003c(Option\u003cEd25519PrivateKey\u003e, V3OnionServiceId), Error\u003e {\n        let reply = self.add_onion_cmd(key, flags, max_streams, virt_port, target, client_auth)?;\n\n        let mut private_key: Option\u003cEd25519PrivateKey\u003e = None;\n        let mut service_id: Option\u003cV3OnionServiceId\u003e = None;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                for line in reply.reply_lines {\n                    if let Some(mut index) = line.find(\"ServiceID=\") {\n                        if service_id.is_some() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"received duplicate ServiceID entries\".to_string(),\n                            ));\n                        }\n                        index += \"ServiceId=\".len();\n                        let service_id_string = \u0026line[index..];\n                        service_id = match V3OnionServiceId::from_string(service_id_string) {\n                            Ok(service_id) =\u003e Some(service_id),\n                            Err(_) =\u003e {\n                                return Err(Error::CommandReplyParseFailed(format!(\n                                    \"could not parse '{}' as V3OnionServiceId\",\n                                    service_id_string\n                                )))\n                            }\n                        }\n                    } else if let Some(mut index) = line.find(\"PrivateKey=\") {\n                        if private_key.is_some() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"received duplicate PrivateKey entries\".to_string(),\n                            ));\n                        }\n                        index += \"PrivateKey=\".len();\n                        let key_blob_string = \u0026line[index..];\n                        private_key = match Ed25519PrivateKey::from_key_blob_legacy(key_blob_string) {\n                            Ok(private_key) =\u003e Some(private_key),\n                            Err(_) =\u003e {\n                                return Err(Error::CommandReplyParseFailed(format!(\n                                    \"could not parse {} as Ed25519PrivateKey\",\n                                    key_blob_string\n                                )))\n                            }\n                        };\n                    } else if line.contains(\"ClientAuthV3=\") {\n                        if client_auth.unwrap_or_default().is_empty() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"recieved unexpected ClientAuthV3 keys\".to_string(),\n                            ));\n                        }\n                    } else if !line.contains(\"OK\") {\n                        return Err(Error::CommandReplyParseFailed(format!(\n                            \"received unexpected reply line '{}'\",\n                            line\n                        )));\n                    }\n                }\n            }\n            code =\u003e return Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n\n        if flags.discard_pk {\n            if private_key.is_some() {\n                return Err(Error::CommandReplyParseFailed(\n                    \"PrivateKey response should have been discard\".to_string(),\n                ));\n            }\n        } else if private_key.is_none() {\n            return Err(Error::CommandReplyParseFailed(\n                \"did not receive a PrivateKey\".to_string(),\n            ));\n        }\n\n        match service_id {\n            Some(service_id) =\u003e Ok((private_key, service_id)),\n            None =\u003e Err(Error::CommandReplyParseFailed(\n                \"did not receive a ServiceID\".to_string(),\n            )),\n        }\n    }\n\n    pub fn del_onion(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.del_onion_cmd(service_id)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    // more specific encapulsation of specific command invocations\n\n    pub fn getinfo_net_listeners_socks(\u0026mut self) -\u003e Result\u003cVec\u003cSocketAddr\u003e, Error\u003e {\n        let response = self.getinfo(\u0026[\"net/listeners/socks\"])?;\n        for (key, value) in response.iter() {\n            if key.as_str() == \"net/listeners/socks\" {\n                if value.is_empty() {\n                    return Ok(Default::default());\n                }\n                // get our list of double-quoted strings\n                let listeners: Vec\u003c\u0026str\u003e = value.split(' ').collect();\n                let mut result: Vec\u003cSocketAddr\u003e = Default::default();\n                for socket_addr in listeners.iter() {\n                    if !socket_addr.starts_with('\\\"') || !socket_addr.ends_with('\\\"') {\n                        return Err(Error::CommandReplyParseFailed(format!(\n                            \"could not parse '{}' as socket address\",\n                            socket_addr\n                        )));\n                    }\n\n                    // remove leading/trailing double quote\n                    let stripped = \u0026socket_addr[1..socket_addr.len() - 1];\n                    result.push(match SocketAddr::from_str(stripped) {\n                        Ok(result) =\u003e result,\n                        Err(_) =\u003e {\n                            return Err(Error::CommandReplyParseFailed(format!(\n                                \"could not parse '{}' as socket address\",\n                                socket_addr\n                            )))\n                        }\n                    });\n                }\n                return Ok(result);\n            }\n        }\n        Err(Error::CommandReplyParseFailed(\n            \"reply did not find a 'net/listeners/socks' key/value\".to_string(),\n        ))\n    }\n\n    pub fn getinfo_version(\u0026mut self) -\u003e Result\u003cLegacyTorVersion, Error\u003e {\n        let response = self.getinfo(\u0026[\"version\"])?;\n        for (key, value) in response.iter() {\n            if key.as_str() == \"version\" {\n                return LegacyTorVersion::from_str(value).map_err(Error::TorVersionParseFailed);\n            }\n        }\n        Err(Error::CommandReplyParseFailed(\n            \"did not find a 'version' key/value\".to_string(),\n        ))\n    }\n\n    pub fn onion_client_auth_add(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        private_key: \u0026X25519PrivateKey,\n        client_name: Option\u003cString\u003e,\n        flags: \u0026OnionClientAuthAddFlags,\n    ) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.onion_client_auth_add_cmd(service_id, private_key, client_name, flags)?;\n\n        match reply.status_code {\n            250u32..=252u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn onion_client_auth_remove(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.onion_client_auth_remove_cmd(service_id)?;\n\n        match reply.status_code {\n            250u32..=251u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n}\n\n#[test]\n#[serial]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_tor_controller() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_tor_controller\");\n    let tor_process = LegacyTorProcess::new(\u0026tor_path, \u0026data_path)?;\n\n    // create a scope to ensure tor_controller is dropped\n    {\n        let control_stream =\n            LegacyControlStream::new(tor_process.get_control_addr(), Duration::from_millis(16))?;\n\n        // create a tor controller and send authentication command\n        let mut tor_controller = LegacyTorController::new(control_stream)?;\n        tor_controller.authenticate_cmd(tor_process.get_password())?;\n        assert!(\n            tor_controller\n                .authenticate_cmd(\"invalid password\")?\n                .status_code\n                == 515u32\n        );\n\n        // tor controller should have shutdown the connection after failed authentication\n        assert!(\n            tor_controller\n                .authenticate_cmd(tor_process.get_password())\n                .is_err(),\n            \"expected failure due to closed connection\"\n        );\n        assert!(tor_controller.control_stream.closed_by_remote());\n    }\n    // now create a second controller\n    {\n        let control_stream =\n            LegacyControlStream::new(tor_process.get_control_addr(), Duration::from_millis(16))?;\n\n        // create a tor controller and send authentication command\n        // all async events are just printed to stdout\n        let mut tor_controller = LegacyTorController::new(control_stream)?;\n        tor_controller.authenticate(tor_process.get_password())?;\n\n        // ensure everything is matching our default_torrc settings\n        let vals = tor_controller.getconf(\u0026[\"SocksPort\", \"AvoidDiskWrites\", \"DisableNetwork\"])?;\n        for (key, value) in vals.iter() {\n            let expected = match key.as_str() {\n                \"SocksPort\" =\u003e \"auto OnionTrafficOnly\",\n                \"AvoidDiskWrites\" =\u003e \"1\",\n                \"DisableNetwork\" =\u003e \"1\",\n                _ =\u003e panic!(\"unexpected returned key: {}\", key),\n            };\n            assert!(value == expected);\n        }\n\n        let vals = tor_controller.getinfo(\u0026[\"version\", \"config-file\", \"config-text\"])?;\n        let mut expected_torrc_path = data_path.clone();\n        expected_torrc_path.push(\"torrc\");\n        let mut expected_control_port_path = data_path.clone();\n        expected_control_port_path.push(\"control_port\");\n        for (key, value) in vals.iter() {\n            match key.as_str() {\n                \"version\" =\u003e assert!(Regex::new(r\"\\d+\\.\\d+\\.\\d+\\.\\d+\")?.is_match(\u0026value)),\n                \"config-file\" =\u003e assert!(Path::new(\u0026value) == expected_torrc_path),\n                \"config-text\" =\u003e assert!(\n                    value.to_string()\n                        == format!(\n                            \"\\nControlPort auto\\nControlPortWriteToFile {}\\nDataDirectory {}\",\n                            expected_control_port_path.display(),\n                            data_path.display()\n                        )\n                ),\n                _ =\u003e panic!(\"unexpected returned key: {}\", key),\n            }\n        }\n\n        tor_controller.setevents(\u0026[\"STATUS_CLIENT\"])?;\n        // begin bootstrap\n        tor_controller.setconf(\u0026[(\"DisableNetwork\", \"0\")])?;\n\n        // add an onoin service\n        let (private_key, service_id) =\n            match tor_controller.add_onion(None, \u0026Default::default(), None, 22, None, None)? {\n                (Some(private_key), service_id) =\u003e (private_key, service_id),\n                _ =\u003e panic!(\"add_onion did not return expected values\"),\n            };\n        println!(\"private_key: {}\", private_key.to_key_blob());\n        println!(\"service_id: {}\", service_id.to_string());\n\n        assert!(\n            tor_controller\n                .del_onion(\u0026V3OnionServiceId::from_string(\n                    \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd\"\n                )?)\n                .is_err(),\n            \"deleting unknown onion should have failed\"\n        );\n\n        // delete our new onion\n        tor_controller.del_onion(\u0026service_id)?;\n\n        println!(\"listeners: \");\n        for sock_addr in tor_controller.getinfo_net_listeners_socks()?.iter() {\n            println!(\" {}\", sock_addr);\n        }\n\n        // print our event names available to tor\n        for (key, value) in tor_controller.getinfo(\u0026[\"events/names\"])?.iter() {\n            println!(\"{} : {}\", key, value);\n        }\n\n        let stop_time = Instant::now() + std::time::Duration::from_secs(5);\n        while stop_time \u003e Instant::now() {\n            for async_event in tor_controller.wait_async_events()?.iter() {\n                match async_event {\n                    AsyncEvent::Unknown { lines } =\u003e {\n                        println!(\"Unknown: {}\", lines.join(\"\\n\"));\n                    }\n                    AsyncEvent::StatusClient {\n                        severity,\n                        action,\n                        arguments,\n                    } =\u003e {\n                        println!(\"STATUS_CLIENT severity={}, action={}\", severity, action);\n                        for (key, value) in arguments.iter() {\n                            println!(\" {}='{}'\", key, value);\n                        }\n                    }\n                    AsyncEvent::HsDesc { action, hs_address } =\u003e {\n                        println!(\n                            \"HS_DESC action={}, hsaddress={}\",\n                            action,\n                            hs_address.to_string()\n                        );\n                    }\n                }\n            }\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":93,"address":[1724922,1724839,1723360],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[1723398,1723664,1724920,1723470],"length":1,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[1723625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1724905,1723734,1723589,1723961],"length":1,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[1723913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1724537],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[1724182],"length":1,"stats":{"Line":4},"fn_name":null},{"line":106,"address":[1724212],"length":1,"stats":{"Line":4},"fn_name":null},{"line":108,"address":[1724357],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[1724409],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[1724473],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[1724960,1725618,1725589],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[1724989],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[1725093,1725034],"length":1,"stats":{"Line":8},"fn_name":null},{"line":123,"address":[1725373,1725108,1725553],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[1725334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1725428,1725536],"length":1,"stats":{"Line":8},"fn_name":null},{"line":131,"address":[1725456],"length":1,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[1725632,1727359,1729714],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[1725687],"length":1,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[1725823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1725712],"length":1,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[1725958,1725778],"length":1,"stats":{"Line":8},"fn_name":null},{"line":144,"address":[1726172,1726071],"length":1,"stats":{"Line":8},"fn_name":null},{"line":145,"address":[1726231],"length":1,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[1726350],"length":1,"stats":{"Line":4},"fn_name":null},{"line":149,"address":[1726447],"length":1,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[1726564],"length":1,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[1726591,1726712],"length":1,"stats":{"Line":8},"fn_name":null},{"line":156,"address":[1726613],"length":1,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[1727412,1726964],"length":1,"stats":{"Line":8},"fn_name":null},{"line":159,"address":[1727474],"length":1,"stats":{"Line":4},"fn_name":null},{"line":163,"address":[1727591],"length":1,"stats":{"Line":4},"fn_name":null},{"line":164,"address":[1727688],"length":1,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[1728140,1727802,1727867],"length":1,"stats":{"Line":12},"fn_name":null},{"line":168,"address":[1727925,1727976],"length":1,"stats":{"Line":8},"fn_name":null},{"line":170,"address":[1727851],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[1727961,1728145],"length":1,"stats":{"Line":8},"fn_name":null},{"line":176,"address":[1727148],"length":1,"stats":{"Line":4},"fn_name":null},{"line":177,"address":[1727026],"length":1,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[1727057],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[1727116],"length":1,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[1728341],"length":1,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[1728643,1728529],"length":1,"stats":{"Line":6},"fn_name":null},{"line":185,"address":[1728705],"length":1,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[1728804],"length":1,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[1728901],"length":1,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[1728984],"length":1,"stats":{"Line":3},"fn_name":null},{"line":194,"address":[1729184],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[1729103],"length":1,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[1729446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1729492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[1729563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1729728,1730645],"length":1,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[1729758,1729886],"length":1,"stats":{"Line":4},"fn_name":null},{"line":210,"address":[1729867],"length":1,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[1730313,1729981,1730058],"length":1,"stats":{"Line":12},"fn_name":null},{"line":213,"address":[1730357,1730337],"length":1,"stats":{"Line":8},"fn_name":null},{"line":216,"address":[1730205],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[1730672],"length":1,"stats":{"Line":4},"fn_name":null},{"line":221,"address":[1730701,1731224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":222,"address":[1730713,1730964],"length":1,"stats":{"Line":4},"fn_name":null},{"line":225,"address":[1730936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1731050],"length":1,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[1731103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1731131],"length":1,"stats":{"Line":4},"fn_name":null},{"line":235,"address":[1731248],"length":1,"stats":{"Line":4},"fn_name":null},{"line":236,"address":[1731403,1731270],"length":1,"stats":{"Line":5},"fn_name":null},{"line":238,"address":[1731375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[1731368],"length":1,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[1732666,1732418,1731440],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[1731533],"length":1,"stats":{"Line":4},"fn_name":null},{"line":254,"address":[1731629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1731596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1731894,1732679,1731711,1731553],"length":1,"stats":{"Line":4},"fn_name":null},{"line":260,"address":[1732111,1731865,1731969],"length":1,"stats":{"Line":12},"fn_name":null},{"line":261,"address":[1732540],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[1732235,1732082],"length":1,"stats":{"Line":8},"fn_name":null},{"line":265,"address":[1732362,1732275],"length":1,"stats":{"Line":8},"fn_name":null},{"line":270,"address":[1368074,1367440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1367512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[1367665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1367638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1367729,1367532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[1367964,1368040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[1732688,1733326],"length":1,"stats":{"Line":4},"fn_name":null},{"line":283,"address":[1732760],"length":1,"stats":{"Line":4},"fn_name":null},{"line":284,"address":[1732917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[1732890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1732780,1732981],"length":1,"stats":{"Line":4},"fn_name":null},{"line":290,"address":[1733216,1733292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":294,"address":[1733360,1733661],"length":1,"stats":{"Line":4},"fn_name":null},{"line":295,"address":[1733459],"length":1,"stats":{"Line":4},"fn_name":null},{"line":297,"address":[1733630,1733556],"length":1,"stats":{"Line":8},"fn_name":null},{"line":301,"address":[1733696,1734334],"length":1,"stats":{"Line":4},"fn_name":null},{"line":302,"address":[1733768],"length":1,"stats":{"Line":4},"fn_name":null},{"line":303,"address":[1733925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[1733898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[1733989,1733788],"length":1,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[1734300,1734224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":313,"address":[1737411,1735746,1734368],"length":1,"stats":{"Line":4},"fn_name":null},{"line":322,"address":[1734539,1737424,1734765],"length":1,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[1734786,1734726],"length":1,"stats":{"Line":7},"fn_name":null},{"line":326,"address":[1734892,1734802],"length":1,"stats":{"Line":6},"fn_name":null},{"line":328,"address":[1734821,1734940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[1734921],"length":1,"stats":{"Line":4},"fn_name":null},{"line":333,"address":[1734977],"length":1,"stats":{"Line":4},"fn_name":null},{"line":334,"address":[1734998,1735073],"length":1,"stats":{"Line":6},"fn_name":null},{"line":336,"address":[1734990],"length":1,"stats":{"Line":4},"fn_name":null},{"line":337,"address":[1735091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[1735083],"length":1,"stats":{"Line":4},"fn_name":null},{"line":340,"address":[1735140],"length":1,"stats":{"Line":3},"fn_name":null},{"line":342,"address":[1735132],"length":1,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[1735189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[1735181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":346,"address":[1735248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[1735222,1735288],"length":1,"stats":{"Line":8},"fn_name":null},{"line":350,"address":[1735481,1735294,1735368],"length":1,"stats":{"Line":6},"fn_name":null},{"line":354,"address":[1735755,1735329],"length":1,"stats":{"Line":4},"fn_name":null},{"line":355,"address":[1735906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[1735860,1736024],"length":1,"stats":{"Line":7},"fn_name":null},{"line":360,"address":[1736331],"length":1,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[1736508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[1736618,1736454],"length":1,"stats":{"Line":7},"fn_name":null},{"line":366,"address":[1736650,1736713],"length":1,"stats":{"Line":6},"fn_name":null},{"line":367,"address":[1736846,1736940],"length":1,"stats":{"Line":3},"fn_name":null},{"line":372,"address":[1737209,1736671],"length":1,"stats":{"Line":8},"fn_name":null},{"line":374,"address":[1737336,1737249],"length":1,"stats":{"Line":8},"fn_name":null},{"line":378,"address":[1737440,1737736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[1737535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":381,"address":[1737705,1737630],"length":1,"stats":{"Line":4},"fn_name":null},{"line":385,"address":[1737760,1738941,1739300],"length":1,"stats":{"Line":3},"fn_name":null},{"line":392,"address":[1737837,1737952,1739285],"length":1,"stats":{"Line":6},"fn_name":null},{"line":395,"address":[1738152,1738215],"length":1,"stats":{"Line":6},"fn_name":null},{"line":398,"address":[1738247,1738341],"length":1,"stats":{"Line":3},"fn_name":null},{"line":400,"address":[1738600],"length":1,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[1738814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[1738746],"length":1,"stats":{"Line":3},"fn_name":null},{"line":405,"address":[1738979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[1738950,1739045],"length":1,"stats":{"Line":6},"fn_name":null},{"line":411,"address":[1739166,1739085],"length":1,"stats":{"Line":6},"fn_name":null},{"line":415,"address":[1739640,1739344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[1739439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[1739609,1739534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[1739664],"length":1,"stats":{"Line":4},"fn_name":null},{"line":429,"address":[1739885,1739705],"length":1,"stats":{"Line":4},"fn_name":null},{"line":431,"address":[1739873],"length":1,"stats":{"Line":4},"fn_name":null},{"line":432,"address":[1739952],"length":1,"stats":{"Line":4},"fn_name":null},{"line":433,"address":[1739968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[1377187,1376834,1375440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[1375481,1375696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[1375684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[1375768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[1377141,1376065,1375971],"length":1,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[1376469,1376290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[1376590,1377121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[1376611,1376861],"length":1,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[1376532,1376682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[1376315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[1375783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[1740160],"length":1,"stats":{"Line":4},"fn_name":null},{"line":458,"address":[1740381,1740201],"length":1,"stats":{"Line":4},"fn_name":null},{"line":460,"address":[1740369],"length":1,"stats":{"Line":4},"fn_name":null},{"line":461,"address":[1740448],"length":1,"stats":{"Line":4},"fn_name":null},{"line":462,"address":[1740464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[1740656],"length":1,"stats":{"Line":4},"fn_name":null},{"line":467,"address":[1740877,1740697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":469,"address":[1740865],"length":1,"stats":{"Line":4},"fn_name":null},{"line":470,"address":[1740944],"length":1,"stats":{"Line":4},"fn_name":null},{"line":471,"address":[1740960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[1742630,1741152,1742989],"length":1,"stats":{"Line":4},"fn_name":null},{"line":476,"address":[1741193,1741418],"length":1,"stats":{"Line":4},"fn_name":null},{"line":478,"address":[1741403],"length":1,"stats":{"Line":4},"fn_name":null},{"line":480,"address":[1741483],"length":1,"stats":{"Line":4},"fn_name":null},{"line":481,"address":[1741809,1742943,1741704],"length":1,"stats":{"Line":12},"fn_name":null},{"line":482,"address":[1742225,1742046],"length":1,"stats":{"Line":8},"fn_name":null},{"line":483,"address":[1742903,1742314],"length":1,"stats":{"Line":8},"fn_name":null},{"line":484,"address":[1742335,1742657],"length":1,"stats":{"Line":8},"fn_name":null},{"line":486,"address":[1742410,1742288],"length":1,"stats":{"Line":8},"fn_name":null},{"line":487,"address":[1742435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[1742071],"length":1,"stats":{"Line":4},"fn_name":null},{"line":494,"address":[1741510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[1743040,1746115,1748078],"length":1,"stats":{"Line":4},"fn_name":null},{"line":507,"address":[1743178,1743524],"length":1,"stats":{"Line":4},"fn_name":null},{"line":509,"address":[1743478],"length":1,"stats":{"Line":4},"fn_name":null},{"line":510,"address":[1743498],"length":1,"stats":{"Line":4},"fn_name":null},{"line":512,"address":[1743506],"length":1,"stats":{"Line":4},"fn_name":null},{"line":514,"address":[1743584,1743884,1748035],"length":1,"stats":{"Line":8},"fn_name":null},{"line":515,"address":[1744113,1745005],"length":1,"stats":{"Line":8},"fn_name":null},{"line":516,"address":[1745103,1745170],"length":1,"stats":{"Line":8},"fn_name":null},{"line":517,"address":[1746132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[1745203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[1745176,1745241,1745342],"length":1,"stats":{"Line":8},"fn_name":null},{"line":522,"address":[1745280,1745390],"length":1,"stats":{"Line":8},"fn_name":null},{"line":523,"address":[1745406,1745599],"length":1,"stats":{"Line":8},"fn_name":null},{"line":524,"address":[1745463],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[1745850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[1746074,1745785,1745663,1746034,1745137,1746249],"length":1,"stats":{"Line":12},"fn_name":null},{"line":533,"address":[1746414,1746347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[1747319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[1746447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[1746420,1746485,1746586],"length":1,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[1746524,1746635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[1746651,1746945,1746887,1746787],"length":1,"stats":{"Line":3},"fn_name":null},{"line":541,"address":[1746693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[1747068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[1746381,1747436],"length":1,"stats":{"Line":8},"fn_name":null},{"line":550,"address":[1747871,1747514],"length":1,"stats":{"Line":6},"fn_name":null},{"line":551,"address":[1747934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[1747899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[1747548,1747481],"length":1,"stats":{"Line":8},"fn_name":null},{"line":556,"address":[1747672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[1743662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[1744147],"length":1,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[1744178,1744407],"length":1,"stats":{"Line":6},"fn_name":null},{"line":568,"address":[1744844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[1744416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[1744214,1744152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":573,"address":[1744282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[1744247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[1744220],"length":1,"stats":{"Line":4},"fn_name":null},{"line":579,"address":[1744476],"length":1,"stats":{"Line":4},"fn_name":null},{"line":580,"address":[1744635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[1744446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[1748112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":587,"address":[1748144,1748324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":589,"address":[1748312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[1748389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":591,"address":[1748404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[1748592,1751006,1751067],"length":1,"stats":{"Line":4},"fn_name":null},{"line":598,"address":[1748623,1748802],"length":1,"stats":{"Line":4},"fn_name":null},{"line":599,"address":[1748922,1748767,1749123],"length":1,"stats":{"Line":12},"fn_name":null},{"line":600,"address":[1749167,1749321],"length":1,"stats":{"Line":8},"fn_name":null},{"line":601,"address":[1749394],"length":1,"stats":{"Line":4},"fn_name":null},{"line":602,"address":[1751023,1749452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[1749490,1749429],"length":1,"stats":{"Line":8},"fn_name":null},{"line":606,"address":[1749541],"length":1,"stats":{"Line":4},"fn_name":null},{"line":607,"address":[1749604,1749962,1749704],"length":1,"stats":{"Line":12},"fn_name":null},{"line":608,"address":[1750117,1749978,1750036],"length":1,"stats":{"Line":12},"fn_name":null},{"line":609,"address":[1750212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[1750162,1750387],"length":1,"stats":{"Line":8},"fn_name":null},{"line":617,"address":[1750547,1750624,1750757],"length":1,"stats":{"Line":12},"fn_name":null},{"line":618,"address":[1750592],"length":1,"stats":{"Line":4},"fn_name":null},{"line":620,"address":[1750771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[1749862],"length":1,"stats":{"Line":4},"fn_name":null},{"line":630,"address":[1749198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[1749096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[1751088,1751906],"length":1,"stats":{"Line":3},"fn_name":null},{"line":636,"address":[1751278,1751113],"length":1,"stats":{"Line":3},"fn_name":null},{"line":637,"address":[1751560,1751389,1751249],"length":1,"stats":{"Line":9},"fn_name":null},{"line":638,"address":[1751601,1751753],"length":1,"stats":{"Line":6},"fn_name":null},{"line":639,"address":[1751817],"length":1,"stats":{"Line":3},"fn_name":null},{"line":642,"address":[1751623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[1751533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[1751936],"length":1,"stats":{"Line":3},"fn_name":null},{"line":654,"address":[1751984,1752173],"length":1,"stats":{"Line":3},"fn_name":null},{"line":657,"address":[1752382,1752156],"length":1,"stats":{"Line":6},"fn_name":null},{"line":658,"address":[1752238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[1752464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":664,"address":[1752496,1752685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":667,"address":[1752668,1752894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":668,"address":[1752750],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":208,"coverable":262},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_process.rs"],"content":"// standard\nuse std::default::Default;\nuse std::fs;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader, Read, Write};\nuse std::net::SocketAddr;\nuse std::ops::Drop;\nuse std::path::Path;\nuse std::process;\nuse std::process::{Child, ChildStdout, Command, Stdio};\nuse std::str::FromStr;\nuse std::string::ToString;\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\n\n// extern crates\nuse data_encoding::HEXUPPER;\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse sha1::{Digest, Sha1};\n\n// internal crates\nuse crate::tor_crypto::generate_password;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to read control port file\")]\n    ControlPortFileReadFailed(#[source] std::io::Error),\n\n    #[error(\"provided control port file '{0}' larger than expected ({1} bytes)\")]\n    ControlPortFileTooLarge(String, u64),\n\n    #[error(\"failed to parse '{0}' as control port file\")]\n    ControlPortFileContentsInvalid(String),\n\n    #[error(\"provided tor bin path '{0}' must be an absolute path\")]\n    TorBinPathNotAbsolute(String),\n\n    #[error(\"provided data directory '{0}' must be an absolute path\")]\n    TorDataDirectoryPathNotAbsolute(String),\n\n    #[error(\"failed to create data directory\")]\n    DataDirectoryCreationFailed(#[source] std::io::Error),\n\n    #[error(\"file exists in provided data directory path '{0}'\")]\n    DataDirectoryPathExistsAsFile(String),\n\n    #[error(\"failed to create default_torrc file\")]\n    DefaultTorrcFileCreationFailed(#[source] std::io::Error),\n\n    #[error(\"failed to write default_torrc file\")]\n    DefaultTorrcFileWriteFailed(#[source] std::io::Error),\n\n    #[error(\"failed to create torrc file\")]\n    TorrcFileCreationFailed(#[source] std::io::Error),\n\n    #[error(\"failed to remove control_port file\")]\n    ControlPortFileDeleteFailed(#[source] std::io::Error),\n\n    #[error(\"failed to start legacy tor process\")]\n    LegacyTorProcessStartFailed(#[source] std::io::Error),\n\n    #[error(\"failed to read control addr from control_file '{0}'\")]\n    ControlPortFileMissing(String),\n\n    #[error(\"unable to take legacy tor process stdout\")]\n    LegacyTorProcessStdoutTakeFailed(),\n\n    #[error(\"failed to spawn tor process stdout read thread\")]\n    StdoutReadThreadSpawnFailed(#[source] std::io::Error),\n}\n\nfn read_control_port_file(control_port_file: \u0026Path) -\u003e Result\u003cSocketAddr, Error\u003e {\n    // open file\n    let mut file = File::open(control_port_file).map_err(Error::ControlPortFileReadFailed)?;\n\n    // bail if the file is larger than expected\n    let metadata = file.metadata().map_err(Error::ControlPortFileReadFailed)?;\n    if metadata.len() \u003e= 1024 {\n        return Err(Error::ControlPortFileTooLarge(\n            format!(\"{}\", control_port_file.display()),\n            metadata.len(),\n        ));\n    }\n\n    // read contents to string\n    let mut contents = String::new();\n    file.read_to_string(\u0026mut contents)\n        .map_err(Error::ControlPortFileReadFailed)?;\n\n    if contents.starts_with(\"PORT=\") {\n        let addr_string = \u0026contents.trim_end()[\"PORT=\".len()..];\n        if let Ok(addr) = SocketAddr::from_str(addr_string) {\n            return Ok(addr);\n        }\n    }\n    Err(Error::ControlPortFileContentsInvalid(format!(\n        \"{}\",\n        control_port_file.display()\n    )))\n}\n\n// Encapsulates the tor daemon process\npub(crate) struct LegacyTorProcess {\n    control_addr: SocketAddr,\n    process: Child,\n    password: String,\n    // stdout data\n    stdout_lines: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n}\n\nimpl LegacyTorProcess {\n    const S2K_RFC2440_SPECIFIER_LEN: usize = 9;\n\n    fn hash_tor_password_with_salt(\n        salt: \u0026[u8; Self::S2K_RFC2440_SPECIFIER_LEN],\n        password: \u0026str,\n    ) -\u003e String {\n        assert_eq!(salt[Self::S2K_RFC2440_SPECIFIER_LEN - 1], 0x60);\n\n        // tor-specific rfc 2440 constants\n        const EXPBIAS: u8 = 6u8;\n        const C: u8 = 0x60; // salt[S2K_RFC2440_SPECIFIER_LEN - 1]\n        const COUNT: usize = (16usize + ((C \u0026 15u8) as usize)) \u003c\u003c ((C \u003e\u003e 4) + EXPBIAS);\n\n        // squash together our hash input\n        let mut input: Vec\u003cu8\u003e = Default::default();\n        // append salt (sans the 'C' constant')\n        input.extend_from_slice(\u0026salt[0..Self::S2K_RFC2440_SPECIFIER_LEN - 1]);\n        // append password bytes\n        input.extend_from_slice(password.as_bytes());\n\n        let input = input.as_slice();\n        let input_len = input.len();\n\n        let mut sha1 = Sha1::new();\n        let mut count = COUNT;\n        while count \u003e 0 {\n            if count \u003e input_len {\n                sha1.update(input);\n                count -= input_len;\n            } else {\n                sha1.update(\u0026input[0..count]);\n                break;\n            }\n        }\n\n        let key = sha1.finalize();\n\n        let mut hash = \"16:\".to_string();\n        HEXUPPER.encode_append(salt, \u0026mut hash);\n        HEXUPPER.encode_append(\u0026key, \u0026mut hash);\n\n        hash\n    }\n\n    fn hash_tor_password(password: \u0026str) -\u003e String {\n        let mut salt = [0x00u8; Self::S2K_RFC2440_SPECIFIER_LEN];\n        OsRng.fill_bytes(\u0026mut salt);\n        salt[Self::S2K_RFC2440_SPECIFIER_LEN - 1] = 0x60u8;\n\n        Self::hash_tor_password_with_salt(\u0026salt, password)\n    }\n\n    pub fn get_control_addr(\u0026self) -\u003e \u0026SocketAddr {\n        \u0026self.control_addr\n    }\n\n    pub fn get_password(\u0026self) -\u003e \u0026String {\n        \u0026self.password\n    }\n\n    pub fn new(tor_bin_path: \u0026Path, data_directory: \u0026Path) -\u003e Result\u003cLegacyTorProcess, Error\u003e {\n        if tor_bin_path.is_relative() {\n            return Err(Error::TorBinPathNotAbsolute(format!(\n                \"{}\",\n                tor_bin_path.display()\n            )));\n        }\n        if data_directory.is_relative() {\n            return Err(Error::TorDataDirectoryPathNotAbsolute(format!(\n                \"{}\",\n                data_directory.display()\n            )));\n        }\n\n        // create data directory if it doesn't exist\n        if !data_directory.exists() {\n            fs::create_dir_all(data_directory).map_err(Error::DataDirectoryCreationFailed)?;\n        } else if data_directory.is_file() {\n            return Err(Error::DataDirectoryPathExistsAsFile(format!(\n                \"{}\",\n                data_directory.display()\n            )));\n        }\n\n        // construct paths to torrc files\n        let default_torrc = data_directory.join(\"default_torrc\");\n        let torrc = data_directory.join(\"torrc\");\n        let control_port_file = data_directory.join(\"control_port\");\n\n        // TODO: should we nuke the existing torrc between runs? Do we want\n        // users setting custom nonsense in there?\n        // construct default torrc\n        //  - daemon determines socks port and only allows clients to connect to onion services\n        //  - minimize writes to disk\n        //  - start with network disabled by default\n        if !default_torrc.exists() {\n            const DEFAULT_TORRC_CONTENT: \u0026str = \"SocksPort auto OnionTrafficOnly\\n\\\n            AvoidDiskWrites 1\\n\\\n            DisableNetwork 1\\n\\n\";\n\n            let mut default_torrc_file =\n                File::create(\u0026default_torrc).map_err(Error::DefaultTorrcFileCreationFailed)?;\n            default_torrc_file\n                .write_all(DEFAULT_TORRC_CONTENT.as_bytes())\n                .map_err(Error::DefaultTorrcFileWriteFailed)?;\n        }\n\n        // create empty torrc for user\n        if !torrc.exists() {\n            let _ = File::create(\u0026torrc).map_err(Error::TorrcFileCreationFailed)?;\n        }\n\n        // remove any existing control_port_file\n        if control_port_file.exists() {\n            fs::remove_file(\u0026control_port_file).map_err(Error::ControlPortFileDeleteFailed)?;\n        }\n\n        const CONTROL_PORT_PASSWORD_LENGTH: usize = 32usize;\n        let password = generate_password(CONTROL_PORT_PASSWORD_LENGTH);\n        let password_hash = Self::hash_tor_password(\u0026password);\n\n        let mut process = Command::new(tor_bin_path.as_os_str())\n            .stdout(Stdio::piped())\n            .stdin(Stdio::null())\n            .stderr(Stdio::null())\n            // point to our above written torrc file\n            .arg(\"--defaults-torrc\")\n            .arg(default_torrc)\n            // location of torrc\n            .arg(\"--torrc-file\")\n            .arg(torrc)\n            // root data directory\n            .arg(\"DataDirectory\")\n            .arg(data_directory)\n            // daemon will assign us a port, and we will\n            // read it from the control port file\n            .arg(\"ControlPort\")\n            .arg(\"auto\")\n            // control port file destination\n            .arg(\"ControlPortWriteToFile\")\n            .arg(control_port_file.clone())\n            // use password authentication to prevent other apps\n            // from modifying our daemon's settings\n            .arg(\"HashedControlPassword\")\n            .arg(password_hash)\n            // tor process will shut down after this process shuts down\n            // to avoid orphaned tor daemon\n            .arg(\"__OwningControllerProcess\")\n            .arg(process::id().to_string())\n            .spawn()\n            .map_err(Error::LegacyTorProcessStartFailed)?;\n\n        let mut control_addr = None;\n        let start = Instant::now();\n\n        // try and read the control port from the control port file\n        // or abort after 5 seconds\n        // TODO: make this timeout configurable?\n        while control_addr.is_none() \u0026\u0026 start.elapsed() \u003c Duration::from_secs(5) {\n            if control_port_file.exists() {\n                control_addr = Some(read_control_port_file(control_port_file.as_path())?);\n                fs::remove_file(\u0026control_port_file).map_err(Error::ControlPortFileDeleteFailed)?;\n            }\n        }\n\n        let control_addr = match control_addr {\n            Some(control_addr) =\u003e control_addr,\n            None =\u003e {\n                return Err(Error::ControlPortFileMissing(format!(\n                    \"{}\",\n                    control_port_file.display()\n                )))\n            }\n        };\n\n        let stdout_lines: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e = Default::default();\n\n        {\n            let stdout_lines = Arc::downgrade(\u0026stdout_lines);\n            let stdout = BufReader::new(match process.stdout.take() {\n                Some(stdout) =\u003e stdout,\n                None =\u003e return Err(Error::LegacyTorProcessStdoutTakeFailed()),\n            });\n\n            std::thread::Builder::new()\n                .name(\"tor_stdout_reader\".to_string())\n                .spawn(move || {\n                    LegacyTorProcess::read_stdout_task(\u0026stdout_lines, stdout);\n                })\n                .map_err(Error::StdoutReadThreadSpawnFailed)?;\n        }\n\n        Ok(LegacyTorProcess {\n            control_addr,\n            process,\n            password,\n            stdout_lines,\n        })\n    }\n\n    fn read_stdout_task(\n        stdout_lines: \u0026std::sync::Weak\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n        mut stdout: BufReader\u003cChildStdout\u003e,\n    ) {\n        while let Some(stdout_lines) = stdout_lines.upgrade() {\n            let mut line = String::default();\n            // read line\n            if stdout.read_line(\u0026mut line).is_ok() {\n                // remove trailing '\\n'\n                line.pop();\n                // then acquire the lock on the line buffer\n                let mut stdout_lines = match stdout_lines.lock() {\n                    Ok(stdout_lines) =\u003e stdout_lines,\n                    Err(_) =\u003e unreachable!(),\n                };\n                stdout_lines.push(line);\n            }\n        }\n    }\n\n    pub fn wait_log_lines(\u0026mut self) -\u003e Vec\u003cString\u003e {\n        let mut lines = match self.stdout_lines.lock() {\n            Ok(lines) =\u003e lines,\n            Err(_) =\u003e unreachable!(),\n        };\n        std::mem::take(\u0026mut lines)\n    }\n}\n\nimpl Drop for LegacyTorProcess {\n    fn drop(\u0026mut self) {\n        let _ = self.process.kill();\n    }\n}\n\n#[test]\nfn test_password_hash() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let salt1: [u8; LegacyTorProcess::S2K_RFC2440_SPECIFIER_LEN] = [\n        0xbeu8, 0x2au8, 0x25u8, 0x1du8, 0xe6u8, 0x2cu8, 0xb2u8, 0x7au8, 0x60u8,\n    ];\n    let hash1 = LegacyTorProcess::hash_tor_password_with_salt(\u0026salt1, \"abcdefghijklmnopqrstuvwxyz\");\n    assert_eq!(\n        hash1,\n        \"16:BE2A251DE62CB27A60AC9178A937990E8ED0AB662FA82A5C7DE3EBB23A\"\n    );\n\n    let salt2: [u8; LegacyTorProcess::S2K_RFC2440_SPECIFIER_LEN] = [\n        0x36u8, 0x73u8, 0x0eu8, 0xefu8, 0xd1u8, 0x8cu8, 0x60u8, 0xd6u8, 0x60u8,\n    ];\n    let hash2 = LegacyTorProcess::hash_tor_password_with_salt(\u0026salt2, \"password\");\n    assert_eq!(\n        hash2,\n        \"16:36730EEFD18C60D66052E7EA535438761C0928D316EEA56A190C99B50A\"\n    );\n\n    // ensure same password is hashed to different things\n    assert_ne!(\n        LegacyTorProcess::hash_tor_password(\"password\"),\n        LegacyTorProcess::hash_tor_password(\"password\")\n    );\n\n    Ok(())\n}\n","traces":[{"line":73,"address":[1592272,1594062,1594493],"length":1,"stats":{"Line":4},"fn_name":"read_control_port_file"},{"line":75,"address":[1592479,1592327],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[1594488,1592613,1592820,1592441],"length":1,"stats":{"Line":8},"fn_name":null},{"line":79,"address":[1592889,1592797],"length":1,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[1594373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1594087,1594186,1592928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1594304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1592905],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[1594041,1593033,1593209,1592954],"length":1,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[1593177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1593146,1593254],"length":1,"stats":{"Line":8},"fn_name":null},{"line":92,"address":[1593344],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[1593517],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[1593638],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[1593826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1593727,1593313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[1594512,1595832,1595925],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[1594577],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[1594726],"length":1,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[1594748,1594870],"length":1,"stats":{"Line":8},"fn_name":null},{"line":131,"address":[1594935],"length":1,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[1594954],"length":1,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[1595025],"length":1,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[1595033],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[1595052],"length":1,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[1595888,1595064],"length":1,"stats":{"Line":8},"fn_name":null},{"line":139,"address":[1595226],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[1595328],"length":1,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[1595846,1595893],"length":1,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[1595360,1595246],"length":1,"stats":{"Line":8},"fn_name":null},{"line":148,"address":[1595079],"length":1,"stats":{"Line":4},"fn_name":null},{"line":150,"address":[1595384],"length":1,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[1595419],"length":1,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[1595659,1595585],"length":1,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[1595767],"length":1,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[1595952],"length":1,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[1595986],"length":1,"stats":{"Line":4},"fn_name":null},{"line":159,"address":[1596003],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[1596039],"length":1,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[1596044],"length":1,"stats":{"Line":4},"fn_name":null},{"line":165,"address":[1596064],"length":1,"stats":{"Line":4},"fn_name":null},{"line":166,"address":[1596072],"length":1,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[1596080],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[1598446,1603257,1596096],"length":1,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[1596205],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[1596396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1596312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1596278],"length":1,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[1596744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[1596660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1596626],"length":1,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[1597211,1596974],"length":1,"stats":{"Line":4},"fn_name":null},{"line":190,"address":[1597075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1597412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1597328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[1597105],"length":1,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[1597683,1597175],"length":1,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[1597691],"length":1,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[1597769,1597849],"length":1,"stats":{"Line":8},"fn_name":null},{"line":213,"address":[1597937,1597876,1598084,1598455],"length":1,"stats":{"Line":8},"fn_name":null},{"line":215,"address":[1598196,1598379],"length":1,"stats":{"Line":4},"fn_name":null},{"line":216,"address":[1598189],"length":1,"stats":{"Line":4},"fn_name":null},{"line":217,"address":[1598347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[1598473,1597911],"length":1,"stats":{"Line":8},"fn_name":null},{"line":222,"address":[1598561,1598500],"length":1,"stats":{"Line":8},"fn_name":null},{"line":226,"address":[1598535,1598780],"length":1,"stats":{"Line":8},"fn_name":null},{"line":227,"address":[1598830,1603152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1598820],"length":1,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[1599027,1599118],"length":1,"stats":{"Line":8},"fn_name":null},{"line":234,"address":[1599229,1599394,1600180,1600047,1599933,1599562,1599676,1599456,1599324,1600424,1599149],"length":1,"stats":{"Line":40},"fn_name":null},{"line":235,"address":[1599248],"length":1,"stats":{"Line":4},"fn_name":null},{"line":236,"address":[1599351],"length":1,"stats":{"Line":4},"fn_name":null},{"line":237,"address":[1599413],"length":1,"stats":{"Line":4},"fn_name":null},{"line":240,"address":[1599522],"length":1,"stats":{"Line":4},"fn_name":null},{"line":243,"address":[1599636],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[1599918],"length":1,"stats":{"Line":4},"fn_name":null},{"line":257,"address":[1600007],"length":1,"stats":{"Line":4},"fn_name":null},{"line":261,"address":[1600113],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[1599269,1600365,1603111],"length":1,"stats":{"Line":4},"fn_name":null},{"line":265,"address":[1600497],"length":1,"stats":{"Line":4},"fn_name":null},{"line":266,"address":[1600507],"length":1,"stats":{"Line":4},"fn_name":null},{"line":271,"address":[1600637,1600563],"length":1,"stats":{"Line":8},"fn_name":null},{"line":272,"address":[1602612,1600804],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[1602644,1602854,1603076],"length":1,"stats":{"Line":4},"fn_name":null},{"line":274,"address":[1602822,1596173,1602920],"length":1,"stats":{"Line":12},"fn_name":null},{"line":278,"address":[1600602],"length":1,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[1600849],"length":1,"stats":{"Line":4},"fn_name":null},{"line":281,"address":[1601036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1600910,1600832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1601276,1600881],"length":1,"stats":{"Line":8},"fn_name":null},{"line":291,"address":[1601357,1601284],"length":1,"stats":{"Line":8},"fn_name":null},{"line":292,"address":[1601573,1601438,1601373],"length":1,"stats":{"Line":12},"fn_name":null},{"line":293,"address":[1601559],"length":1,"stats":{"Line":4},"fn_name":null},{"line":294,"address":[1601478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1602482,1601635,1601756,1602134,1601887],"length":1,"stats":{"Line":12},"fn_name":null},{"line":298,"address":[1602536,1601799,1601683],"length":1,"stats":{"Line":8},"fn_name":null},{"line":299,"address":[1601807],"length":1,"stats":{"Line":8},"fn_name":null},{"line":300,"address":[1774777],"length":1,"stats":{"Line":4},"fn_name":null},{"line":302,"address":[1602075],"length":1,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[1602259],"length":1,"stats":{"Line":4},"fn_name":null},{"line":307,"address":[1602187],"length":1,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[1602219],"length":1,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[1602251],"length":1,"stats":{"Line":4},"fn_name":null},{"line":313,"address":[1604047,1603296,1604151],"length":1,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[1603321,1603396,1603449],"length":1,"stats":{"Line":12},"fn_name":null},{"line":318,"address":[1603442],"length":1,"stats":{"Line":4},"fn_name":null},{"line":320,"address":[1603514,1603581],"length":1,"stats":{"Line":8},"fn_name":null},{"line":322,"address":[1603705],"length":1,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[1603712],"length":1,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[1603762],"length":1,"stats":{"Line":4},"fn_name":null},{"line":328,"address":[1603932,1603851],"length":1,"stats":{"Line":8},"fn_name":null},{"line":333,"address":[1604428,1604176],"length":1,"stats":{"Line":3},"fn_name":null},{"line":334,"address":[1604208],"length":1,"stats":{"Line":3},"fn_name":null},{"line":335,"address":[1604240],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[1604396,1604317],"length":1,"stats":{"Line":6},"fn_name":null},{"line":343,"address":[1368368],"length":1,"stats":{"Line":4},"fn_name":"drop"},{"line":344,"address":[1368377],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":99,"coverable":117},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_version.rs"],"content":"// standard\nuse std::cmp::Ordering;\nuse std::option::Option;\nuse std::str::FromStr;\nuse std::string::ToString;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"{}\", .0)]\n    ParseError(String),\n}\n\n// see version-spec.txt\n#[derive(Clone)]\npub struct LegacyTorVersion {\n    pub major: u32,\n    pub minor: u32,\n    pub micro: u32,\n    pub patch_level: u32,\n    pub status_tag: Option\u003cString\u003e,\n}\n\nimpl LegacyTorVersion {\n    fn status_tag_pattern_is_match(status_tag: \u0026str) -\u003e bool {\n        if status_tag.is_empty() {\n            return false;\n        }\n\n        for c in status_tag.chars() {\n            if c.is_whitespace() {\n                return false;\n            }\n        }\n        true\n    }\n\n    fn new(\n        major: u32,\n        minor: u32,\n        micro: u32,\n        patch_level: Option\u003cu32\u003e,\n        status_tag: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cLegacyTorVersion, Error\u003e {\n        let status_tag = if let Some(status_tag) = status_tag {\n            if Self::status_tag_pattern_is_match(status_tag) {\n                Some(status_tag.to_string())\n            } else {\n                return Err(Error::ParseError(\n                    \"tor version status tag may not be empty or contain white-space\".to_string(),\n                ));\n            }\n        } else {\n            None\n        };\n\n        Ok(LegacyTorVersion {\n            major,\n            minor,\n            micro,\n            patch_level: patch_level.unwrap_or(0u32),\n            status_tag,\n        })\n    }\n}\n\nimpl FromStr for LegacyTorVersion {\n    type Err = Error;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cLegacyTorVersion, Self::Err\u003e {\n        // MAJOR.MINOR.MICRO[.PATCHLEVEL][-STATUS_TAG][ (EXTRA_INFO)]*\n        let mut tokens = s.split(' ');\n        let (major, minor, micro, patch_level, status_tag) =\n            if let Some(version_status_tag) = tokens.next() {\n                let mut tokens = version_status_tag.split('-');\n                let (major, minor, micro, patch_level) = if let Some(version) = tokens.next() {\n                    let mut tokens = version.split('.');\n                    let major: u32 = if let Some(major) = tokens.next() {\n                        match major.parse() {\n                            Ok(major) =\u003e major,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MAJOR portion of tor version\",\n                                    major\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MAJOR portion of tor version\".to_string(),\n                        ));\n                    };\n                    let minor: u32 = if let Some(minor) = tokens.next() {\n                        match minor.parse() {\n                            Ok(minor) =\u003e minor,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MINOR portion of tor version\",\n                                    minor\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MINOR portion of tor version\".to_string(),\n                        ));\n                    };\n                    let micro: u32 = if let Some(micro) = tokens.next() {\n                        match micro.parse() {\n                            Ok(micro) =\u003e micro,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MICRO portion of tor version\",\n                                    micro\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MICRO portion of tor version\".to_string(),\n                        ));\n                    };\n                    let patch_level: u32 = if let Some(patch_level) = tokens.next() {\n                        match patch_level.parse() {\n                            Ok(patch_level) =\u003e patch_level,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as PATCHLEVEL portion of tor version\",\n                                    patch_level\n                                )))\n                            }\n                        }\n                    } else {\n                        0u32\n                    };\n                    (major, minor, micro, patch_level)\n                } else {\n                    // if there were '-' the previous next() would have returned the enire string\n                    unreachable!();\n                };\n                let status_tag = tokens.next().map(|status_tag| status_tag.to_string());\n\n                (major, minor, micro, patch_level, status_tag)\n            } else {\n                // if there were no ' ' character the previou snext() would have returned the enire string\n                unreachable!();\n            };\n        for extra_info in tokens {\n            if !extra_info.starts_with('(') || !extra_info.ends_with(')') {\n                return Err(Error::ParseError(format!(\n                    \"failed to parse '{}' as [ (EXTRA_INFO)]\",\n                    extra_info\n                )));\n            }\n        }\n        LegacyTorVersion::new(\n            major,\n            minor,\n            micro,\n            Some(patch_level),\n            status_tag.as_deref(),\n        )\n    }\n}\n\nimpl ToString for LegacyTorVersion {\n    fn to_string(\u0026self) -\u003e String {\n        match \u0026self.status_tag {\n            Some(status_tag) =\u003e format!(\n                \"{}.{}.{}.{}-{}\",\n                self.major, self.minor, self.micro, self.patch_level, status_tag\n            ),\n            None =\u003e format!(\n                \"{}.{}.{}.{}\",\n                self.major, self.minor, self.micro, self.patch_level\n            ),\n        }\n    }\n}\n\nimpl PartialEq for LegacyTorVersion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.major == other.major\n            \u0026\u0026 self.minor == other.minor\n            \u0026\u0026 self.micro == other.micro\n            \u0026\u0026 self.patch_level == other.patch_level\n            \u0026\u0026 self.status_tag == other.status_tag\n    }\n}\n\nimpl PartialOrd for LegacyTorVersion {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        if let Some(order) = self.major.partial_cmp(\u0026other.major) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.minor.partial_cmp(\u0026other.minor) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.micro.partial_cmp(\u0026other.micro) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.patch_level.partial_cmp(\u0026other.patch_level) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        // version-spect.txt *does* say that we should compare tags lexicgraphically\n        // if all of the version numbers are the same when comparing, but we are\n        // going to diverge here and say we can only compare tags for equality.\n        //\n        // In practice we will be comparing tor daemon tags against tagless (stable)\n        // versions so this shouldn't be an issue\n\n        if self.status_tag == other.status_tag {\n            return Some(Ordering::Equal);\n        }\n\n        None\n    }\n}\n\n#[test]\nfn test_version() -\u003e anyhow::Result\u003c()\u003e {\n    assert!(LegacyTorVersion::from_str(\"1.2.3\")? == LegacyTorVersion::new(1, 2, 3, None, None)?);\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4\")? == LegacyTorVersion::new(1, 2, 3, Some(4), None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3-test\")?\n            == LegacyTorVersion::new(1, 2, 3, None, Some(\"test\"))?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-test\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"test\"))?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3 (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, None, None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4 (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-tag (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"tag\"))?\n    );\n\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-tag (extra_info) (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"tag\"))?\n    );\n\n    assert!(LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"spaced tag\")).is_err());\n    assert!(LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"\" /* empty tag */)).is_err());\n    assert!(LegacyTorVersion::from_str(\"\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2-foo\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo bar\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo bar (extra_info)\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo (extra_info) badtext\").is_err());\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(1, 0, 0, Some(0), None)?\n    );\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(0, 1, 0, Some(0), None)?\n    );\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(0, 0, 1, Some(0), None)?\n    );\n\n    // ensure status tags make comparison between equal versions (apart from\n    // tags) unknowable\n    let zero_version = LegacyTorVersion::new(0, 0, 0, Some(0), None)?;\n    let zero_version_tag = LegacyTorVersion::new(0, 0, 0, Some(0), Some(\"tag\"))?;\n\n    assert!(!(zero_version \u003c zero_version_tag));\n    assert!(!(zero_version \u003c= zero_version_tag));\n    assert!(!(zero_version \u003e zero_version_tag));\n    assert!(!(zero_version \u003e= zero_version_tag));\n\n    Ok(())\n}\n","traces":[{"line":24,"address":[1664048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1664071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1664118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1664125,1664089,1664171],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[1664179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1664204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1664164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1664842,1664224],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[1664418,1664326,1664602],"length":1,"stats":{"Line":9},"fn_name":null},{"line":45,"address":[1664388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1664562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1664453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1664423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1664403],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[1664743],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[1664625],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[1664704],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[1664864,1668556],"length":1,"stats":{"Line":4},"fn_name":"from_str"},{"line":71,"address":[1664903],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[1667625],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[1665013],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[1665032,1665124,1667440],"length":1,"stats":{"Line":12},"fn_name":null},{"line":76,"address":[1665156],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[1665175,1665267],"length":1,"stats":{"Line":8},"fn_name":null},{"line":78,"address":[1665299],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[1665507],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[1665659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1665405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1665372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1665845,1665528],"length":1,"stats":{"Line":8},"fn_name":null},{"line":93,"address":[1665877],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[1666085],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[1666237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[1665983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1665950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1666106,1666423],"length":1,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[1666455],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[1666663],"length":1,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[1666812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1666561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1666528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[1667107,1667133,1666681,1666998],"length":1,"stats":{"Line":13},"fn_name":null},{"line":123,"address":[1667030],"length":1,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[1667112],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[1667201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1667096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1667405],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[1667512],"length":1,"stats":{"Line":6},"fn_name":null},{"line":142,"address":[1667565],"length":1,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[1667896,1667729,1668057],"length":1,"stats":{"Line":9},"fn_name":null},{"line":148,"address":[1668089,1668292,1668211],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[1668352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1668010],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[1668028],"length":1,"stats":{"Line":4},"fn_name":null},{"line":166,"address":[1668592],"length":1,"stats":{"Line":0},"fn_name":"to_string"},{"line":167,"address":[1668623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1669357,1669063,1669190,1669135,1669245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[1668784,1668662,1668839,1668729,1668891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1669536],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":182,"address":[1669559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1669583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[1669600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1669617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1669634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1669664],"length":1,"stats":{"Line":4},"fn_name":"partial_cmp"},{"line":192,"address":[1669688],"length":1,"stats":{"Line":4},"fn_name":null},{"line":193,"address":[1669735],"length":1,"stats":{"Line":4},"fn_name":null},{"line":194,"address":[1669808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1669825,1669767],"length":1,"stats":{"Line":8},"fn_name":null},{"line":199,"address":[1669833],"length":1,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[1669906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1669916,1669865],"length":1,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[1669924],"length":1,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[1669997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1669956,1670010],"length":1,"stats":{"Line":8},"fn_name":null},{"line":211,"address":[1670018],"length":1,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[1670062],"length":1,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[1670050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[1670085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1670075],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":68,"coverable":80},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","lib.rs"],"content":"pub mod legacy_tor_client;\nmod legacy_tor_control_stream;\nmod legacy_tor_controller;\nmod legacy_tor_process;\nmod legacy_tor_version;\npub mod mock_tor_client;\npub mod tor_crypto;\npub mod tor_provider;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","mock_tor_client.rs"],"content":"// standard\nuse std::collections::BTreeMap;\nuse std::io::ErrorKind;\nuse std::net::{SocketAddr, TcpListener, TcpStream};\nuse std::sync::{atomic, Arc, Mutex};\n\n// internal crates\nuse crate::tor_crypto::*;\nuse crate::tor_provider;\nuse crate::tor_provider::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"client not bootstrapped\")]\n    ClientNotBootstrapped(),\n\n    #[error(\"client already bootstrapped\")]\n    ClientAlreadyBootstrapped(),\n\n    #[error(\"onion service not found: {}\", .0)]\n    OnionServiceNotFound(OnionAddr),\n\n    #[error(\"onion service not published: {}\", .0)]\n    OnionServiceNotPublished(OnionAddr),\n\n    #[error(\"onion service requires onion auth\")]\n    OnionServiceRequiresOnionAuth(),\n\n    #[error(\"provided onion auth key invalid\")]\n    OnionServiceAuthInvalid(),\n\n    #[error(\"unable to bind TCP listener\")]\n    TcpListenerBindFailed(#[source] std::io::Error),\n\n    #[error(\"unable to get TCP listener's local adress\")]\n    TcpListenerLocalAddrFailed(#[source] std::io::Error),\n}\n\nimpl From\u003cError\u003e for crate::tor_provider::Error {\n    fn from(error: Error) -\u003e Self {\n        crate::tor_provider::Error::Generic(error.to_string())\n    }\n}\n\npub struct MockOnionListener {\n    listener: std::net::TcpListener,\n    is_active: Arc\u003catomic::AtomicBool\u003e,\n    onion_addr: OnionAddr,\n}\n\nimpl OnionListenerImpl for MockOnionListener {\n    fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.listener.set_nonblocking(nonblocking)\n    }\n    fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e {\n        match self.listener.accept() {\n            Ok((stream, _socket_addr)) =\u003e Ok(Some(OnionStream {\n                stream,\n                local_addr: Some(self.onion_addr.clone()),\n                peer_addr: None,\n            })),\n            Err(err) =\u003e {\n                if err.kind() == ErrorKind::WouldBlock {\n                    Ok(None)\n                } else {\n                    Err(err)\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for MockOnionListener {\n    fn drop(\u0026mut self) {\n        self.is_active.store(false, atomic::Ordering::Relaxed);\n    }\n}\n\nstruct MockTorNetwork {\n    onion_services: Option\u003cBTreeMap\u003cOnionAddr, (Vec\u003cX25519PublicKey\u003e, SocketAddr)\u003e\u003e,\n}\n\nimpl MockTorNetwork {\n    const fn new() -\u003e MockTorNetwork {\n        MockTorNetwork {\n            onion_services: None,\n        }\n    }\n\n    fn connect_to_onion(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        client_auth: Option\u003c\u0026X25519PublicKey\u003e,\n    ) -\u003e Result\u003cOnionStream, Error\u003e {\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id.clone(), virt_port));\n\n        match \u0026mut self.onion_services {\n            Some(onion_services) =\u003e {\n                if let Some((client_auth_keys, socket_addr)) = onion_services.get(\u0026onion_addr) {\n                    match (client_auth_keys.len(), client_auth) {\n                        (0, None) =\u003e (),\n                        (_, None) =\u003e return Err(Error::OnionServiceRequiresOnionAuth()),\n                        (0, Some(_)) =\u003e return Err(Error::OnionServiceAuthInvalid()),\n                        (_, Some(client_auth)) =\u003e {\n                            if !client_auth_keys.contains(client_auth) {\n                                return Err(Error::OnionServiceAuthInvalid());\n                            }\n                        }\n                    }\n\n                    if let Ok(stream) = TcpStream::connect(socket_addr) {\n                        Ok(OnionStream {\n                            stream,\n                            local_addr: None,\n                            peer_addr: Some(TargetAddr::OnionService(onion_addr)),\n                        })\n                    } else {\n                        Err(Error::OnionServiceNotFound(onion_addr))\n                    }\n                } else {\n                    Err(Error::OnionServiceNotPublished(onion_addr))\n                }\n            },\n            None =\u003e Err(Error::OnionServiceNotPublished(onion_addr))\n        }\n    }\n\n    fn start_onion(\n        \u0026mut self,\n        service_id: V3OnionServiceId,\n        virt_port: u16,\n        client_auth_keys: Vec\u003cX25519PublicKey\u003e,\n        address: SocketAddr,\n    ) {\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id, virt_port));\n        match \u0026mut self.onion_services {\n            Some(onion_services) =\u003e {\n                onion_services.insert(onion_addr, (client_auth_keys, address));\n            },\n            None =\u003e {\n                let mut onion_services = BTreeMap::new();\n                onion_services.insert(onion_addr, (client_auth_keys, address));\n                self.onion_services = Some(onion_services);\n            }\n        }\n    }\n\n    fn stop_onion(\u0026mut self, onion_addr: \u0026OnionAddr) {\n        if let Some(onion_services) = \u0026mut self.onion_services {\n            onion_services.remove(onion_addr);\n        }\n    }\n}\n\nstatic MOCK_TOR_NETWORK: Mutex\u003cMockTorNetwork\u003e = Mutex::new(MockTorNetwork::new());\n\npub struct MockTorClient {\n    events: Vec\u003cTorEvent\u003e,\n    bootstrapped: bool,\n    client_auth_keys: BTreeMap\u003cV3OnionServiceId, X25519PublicKey\u003e,\n    onion_services: Vec\u003c(OnionAddr, Arc\u003catomic::AtomicBool\u003e)\u003e,\n}\n\nimpl MockTorClient {\n    pub fn new() -\u003e MockTorClient {\n        let mut events: Vec\u003cTorEvent\u003e = Default::default();\n        let line = \"[notice] MockTorClient running\".to_string();\n        events.push(TorEvent::LogReceived { line });\n\n        MockTorClient {\n            events,\n            bootstrapped: false,\n            client_auth_keys: Default::default(),\n            onion_services: Default::default(),\n        }\n    }\n}\n\nimpl Default for MockTorClient {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl TorProvider for MockTorClient {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, tor_provider::Error\u003e {\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                let mut i = 0;\n                while i \u003c self.onion_services.len() {\n                    // remove onion services with no active listeners\n                    if !self.onion_services[i].1.load(atomic::Ordering::Relaxed) {\n                        let entry = self.onion_services.swap_remove(i);\n                        let onion_addr = entry.0;\n                        mock_tor_network.stop_onion(\u0026onion_addr);\n                    } else {\n                        i += 1;\n                    }\n                }\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n\n        Ok(std::mem::take(\u0026mut self.events))\n    }\n\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        if self.bootstrapped {\n            Err(Error::ClientAlreadyBootstrapped())?\n        } else {\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 0u32,\n                tag: \"start\".to_string(),\n                summary: \"bootstrapping started\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 50u32,\n                tag: \"middle\".to_string(),\n                summary: \"bootstrapping continues\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 100u32,\n                tag: \"finished\".to_string(),\n                summary: \"bootstrapping completed\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapComplete);\n            self.bootstrapped = true;\n            Ok(())\n        }\n    }\n\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        let client_auth_public = X25519PublicKey::from_private_key(client_auth);\n        if let Some(key) = self.client_auth_keys.get_mut(service_id) {\n            *key = client_auth_public;\n        } else {\n            self.client_auth_keys\n                .insert(service_id.clone(), client_auth_public);\n        }\n        Ok(())\n    }\n\n    fn remove_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        self.client_auth_keys.remove(service_id);\n        Ok(())\n    }\n\n    fn connect(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        _circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, tor_provider::Error\u003e {\n        let client_auth = self.client_auth_keys.get(service_id);\n\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                Ok(mock_tor_network.connect_to_onion(service_id, virt_port, client_auth)?)\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n    }\n\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, tor_provider::Error\u003e {\n        // convert inputs to relevant types\n        let service_id = V3OnionServiceId::from_private_key(private_key);\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id.clone(), virt_port));\n        let authorized_clients: Vec\u003cX25519PublicKey\u003e = match authorized_clients {\n            Some(keys) =\u003e keys.into(),\n            None =\u003e Default::default(),\n        };\n\n        // try to bind to a local address, let OS pick our port\n        let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n        let listener = TcpListener::bind(socket_addr).map_err(Error::TcpListenerBindFailed)?;\n        let socket_addr = listener\n            .local_addr()\n            .map_err(Error::TcpListenerLocalAddrFailed)?;\n\n        // register the onion service with the mock tor network\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e mock_tor_network.start_onion(\n                service_id.clone(),\n                virt_port,\n                authorized_clients,\n                socket_addr,\n            ),\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n\n        // init flag for signaling when listener goes out of scope so we can tear down onion service\n        let is_active = Arc::new(atomic::AtomicBool::new(true));\n        self.onion_services\n            .push((onion_addr.clone(), Arc::clone(\u0026is_active)));\n\n        // onion service published event\n        self.events\n            .push(TorEvent::OnionServicePublished { service_id });\n\n        let onion_listener = Box::new(MockOnionListener {\n            listener,\n            is_active,\n            onion_addr,\n        });\n\n        Ok(OnionListener { onion_listener })\n    }\n\n    fn generate_token(\u0026mut self) -\u003e CircuitToken {\n        0usize\n    }\n\n    fn release_token(\u0026mut self, _token: CircuitToken) {}\n}\n\nimpl Drop for MockTorClient {\n    fn drop(\u0026mut self) {\n        // remove all our onion services\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                for entry in self.onion_services.iter() {\n                    let onion_addr = \u0026entry.0;\n                    mock_tor_network.stop_onion(onion_addr);\n                }\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n    }\n}\n","traces":[{"line":40,"address":[1575751,1575632],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":41,"address":[1575651,1575709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1582016],"length":1,"stats":{"Line":1},"fn_name":"set_nonblocking"},{"line":53,"address":[1582037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1582064,1582452],"length":1,"stats":{"Line":2},"fn_name":"accept"},{"line":56,"address":[1582094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[1582132,1582326],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[1582163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[1582276,1582170],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[1582316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[1582189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1582519,1582592,1582218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[1582599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1582567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1368416],"length":1,"stats":{"Line":2},"fn_name":"drop"},{"line":75,"address":[1368425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[1582672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1582720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1582799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[1582878],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[1582988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[1583942,1583063,1583252,1583000],"length":1,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[1583257,1583109,1583415],"length":1,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[1583371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1583431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1583480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1583501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1583537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1583322,1583581,1583796],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[1583710],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1583607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[1583617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[1583798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[1583155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1582884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1584795,1584767,1583968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[1584093,1584009],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[1584118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[1584161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[1584173,1584776],"length":1,"stats":{"Line":4},"fn_name":null},{"line":142,"address":[1584124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[1584479,1584304],"length":1,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[1584503],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[1584832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[1584856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[1584881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[1584912,1585362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[1584928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[1584958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[1585023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[1585103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[1585166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[1585408],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":182,"address":[1585416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1585440,1586115,1586237],"length":1,"stats":{"Line":2},"fn_name":"update"},{"line":188,"address":[1585470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1585496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1585516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[1585537,1585525,1585615],"length":1,"stats":{"Line":6},"fn_name":null},{"line":193,"address":[1585821,1585641,1586134],"length":1,"stats":{"Line":6},"fn_name":null},{"line":194,"address":[1585888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[1585946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1586010,1586086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[1586139,1585916,1586129],"length":1,"stats":{"Line":4},"fn_name":null},{"line":205,"address":[1585728],"length":1,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[1586272,1587082],"length":1,"stats":{"Line":2},"fn_name":"bootstrap"},{"line":209,"address":[1587183,1586301],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[1586359,1587185,1587109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[1586488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[1586307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[1586332],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[1586688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[1586588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[1586613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[1586888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[1586788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[1586813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[1587021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[1587052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1587056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[1587248],"length":1,"stats":{"Line":2},"fn_name":"add_client_auth"},{"line":238,"address":[1587312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1587422,1587333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[1587387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[1587459,1587434],"length":1,"stats":{"Line":4},"fn_name":null},{"line":243,"address":[1587442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[1587493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1587520],"length":1,"stats":{"Line":1},"fn_name":"remove_client_auth"},{"line":252,"address":[1587543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[1587567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[1587600,1588354,1588431],"length":1,"stats":{"Line":2},"fn_name":"connect"},{"line":262,"address":[1587690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[1587713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[1587739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[1587842,1587757,1588160],"length":1,"stats":{"Line":5},"fn_name":null},{"line":272,"address":[1590719,1588464,1590896],"length":1,"stats":{"Line":2},"fn_name":"listener"},{"line":279,"address":[1588540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[1588578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[1588655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[1588705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[1588681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[1588760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[1588900,1589103,1590894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[1589068,1589444,1589237],"length":1,"stats":{"Line":4},"fn_name":null},{"line":291,"address":[1589380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[1589349,1589473],"length":1,"stats":{"Line":4},"fn_name":null},{"line":295,"address":[1589660,1589484],"length":1,"stats":{"Line":4},"fn_name":null},{"line":296,"address":[1589603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[1589620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":305,"address":[1589837,1589803],"length":1,"stats":{"Line":4},"fn_name":null},{"line":306,"address":[1589908,1590107],"length":1,"stats":{"Line":4},"fn_name":null},{"line":307,"address":[1590001,1589933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":310,"address":[1590267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":311,"address":[1590131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[1590592,1590381],"length":1,"stats":{"Line":4},"fn_name":null},{"line":314,"address":[1590286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[1590301],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[1590317],"length":1,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[1590600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[1590928],"length":1,"stats":{"Line":0},"fn_name":"generate_token"},{"line":326,"address":[1590954,1590944],"length":1,"stats":{"Line":0},"fn_name":"release_token"},{"line":330,"address":[1368464,1368914,1368991],"length":1,"stats":{"Line":2},"fn_name":"drop"},{"line":332,"address":[1368484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[1368515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[1368533,1368614,1368774],"length":1,"stats":{"Line":6},"fn_name":null},{"line":335,"address":[1368795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[1368803,1368902],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":113,"coverable":127},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","tor_crypto.rs"],"content":"// standard\nuse std::convert::TryInto;\nuse std::iter;\nuse std::str;\n\n// extern crates\nuse curve25519_dalek::Scalar;\nuse data_encoding::{BASE32, BASE32_NOPAD, BASE64};\nuse data_encoding_macro::new_encoding;\nuse rand::distributions::Alphanumeric;\nuse rand::rngs::OsRng;\nuse rand::Rng;\nuse sha3::{Digest, Sha3_256};\nuse static_assertions::const_assert_eq;\nuse tor_llcrypto::pk::keymanip::*;\nuse tor_llcrypto::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"{0}\")]\n    ParseError(String),\n    #[error(\"{0}\")]\n    ConversionError(String),\n    #[error(\"invalid key\")]\n    KeyInvalid,\n}\n\n/// The number of bytes in an ed25519 secret key\n/// cbindgen:ignore\npub const ED25519_PRIVATE_KEY_SIZE: usize = 64;\n/// The number of bytes in an ed25519 public key\n/// cbindgen:ignore\npub const ED25519_PUBLIC_KEY_SIZE: usize = 32;\n/// The number of bytes in an ed25519 signature\n/// cbindgen:ignore\npub const ED25519_SIGNATURE_SIZE: usize = 64;\n/// The number of bytes needed to store onion service id as an ASCII c-string (not including null-terminator)\npub const V3_ONION_SERVICE_ID_STRING_LENGTH: usize = 56;\n/// The number of bytes needed to store onion service id as an ASCII c-string (including null-terminator)\npub const V3_ONION_SERVICE_ID_STRING_SIZE: usize = 57;\nconst_assert_eq!(V3_ONION_SERVICE_ID_STRING_SIZE, V3_ONION_SERVICE_ID_STRING_LENGTH + 1);\n/// The number of bytes needed to store base64 encoded ed25519 private key as an ASCII c-string (not including null-terminator)\npub const ED25519_PRIVATE_KEYBLOB_BASE64_LENGTH: usize = 88;\n/// key klob header string\nconst ED25519_PRIVATE_KEY_KEYBLOB_HEADER: \u0026str = \"ED25519-V3:\";\n/// The number of bytes needed to store the keyblob header\npub const ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH: usize = 11;\nconst_assert_eq!(ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH, ED25519_PRIVATE_KEY_KEYBLOB_HEADER.len());\n/// The number of bytes needed to store ed25519 private keyblob as an ASCII c-string (not including a null terminator)\npub const ED25519_PRIVATE_KEY_KEYBLOB_LENGTH: usize = 99;\nconst_assert_eq!(ED25519_PRIVATE_KEY_KEYBLOB_LENGTH, ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH + ED25519_PRIVATE_KEYBLOB_BASE64_LENGTH);\n/// The number of bytes needed to store ed25519 private keyblob as an ASCII c-string (including a null terminator)\npub const ED25519_PRIVATE_KEY_KEYBLOB_SIZE: usize = 100;\nconst_assert_eq!(ED25519_PRIVATE_KEY_KEYBLOB_SIZE, ED25519_PRIVATE_KEY_KEYBLOB_LENGTH + 1);\n// number of bytes in an onion service id after base32 decode\nconst V3_ONION_SERVICE_ID_RAW_SIZE: usize = 35;\n// byte index of the start of the public key checksum\nconst V3_ONION_SERVICE_ID_CHECKSUM_OFFSET: usize = 32;\n// byte index of the v3 onion service version\nconst V3_ONION_SERVICE_ID_VERSION_OFFSET: usize = 34;\n/// The number of bytes in a v3 service id's truncated checksum\nconst TRUNCATED_CHECKSUM_SIZE: usize = 2;\n/// The number of bytes in an x25519 private key\n/// cbindgen:ignore\npub const X25519_PRIVATE_KEY_SIZE: usize = 32;\n/// The number of bytes in an x25519 publickey\n/// cbindgen:ignore\npub const X25519_PUBLIC_KEY_SIZE: usize = 32;\n/// The number of bytes needed to store base64 encoded x25519 private key as an ASCII c-string (not including null-terminator)\npub const X25519_PRIVATE_KEY_BASE64_LENGTH: usize = 44;\n/// The number of bytes needed to store base64 encoded x25519 private key as an ASCII c-string (including a null terminator)\npub const X25519_PRIVATE_KEY_BASE64_SIZE: usize = 45;\nconst_assert_eq!(X25519_PRIVATE_KEY_BASE64_SIZE, X25519_PRIVATE_KEY_BASE64_LENGTH + 1);\n/// The number of bytes needed to store base32 encoded x25519 public key as an ASCII c-string (not including null-terminator)\npub const X25519_PUBLIC_KEY_BASE32_LENGTH: usize = 52;\n/// The number of bytes needed to store base32 encoded x25519 public key as an ASCII c-string (including a null terminator)\npub const X25519_PUBLIC_KEY_BASE32_SIZE: usize = 53;\nconst_assert_eq!(X25519_PUBLIC_KEY_BASE32_SIZE, X25519_PUBLIC_KEY_BASE32_LENGTH + 1);\n\nconst ONION_BASE32: data_encoding::Encoding = new_encoding! {\n    symbols: \"abcdefghijklmnopqrstuvwxyz234567\",\n    padding: '=',\n};\n\n// Free functions\n\n// securely generate password using OsRng\npub(crate) fn generate_password(length: usize) -\u003e String {\n    let password: String = iter::repeat(())\n        .map(|()| OsRng.sample(Alphanumeric))\n        .map(char::from)\n        .take(length)\n        .collect();\n\n    password\n}\n\n// Struct deinitions\n\npub struct Ed25519PrivateKey {\n    expanded_keypair: pk::ed25519::ExpandedKeypair,\n}\n\n#[derive(Clone)]\npub struct Ed25519PublicKey {\n    public_key: pk::ed25519::PublicKey,\n}\n\n#[derive(Clone)]\npub struct Ed25519Signature {\n    signature: pk::ed25519::Signature,\n}\n\n#[derive(Clone)]\npub struct X25519PrivateKey {\n    secret_key: pk::curve25519::StaticSecret,\n}\n\n#[derive(Clone, PartialEq, Eq, Hash)]\npub struct X25519PublicKey {\n    public_key: pk::curve25519::PublicKey,\n}\n\n#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct V3OnionServiceId {\n    data: [u8; V3_ONION_SERVICE_ID_STRING_LENGTH],\n}\n\n#[derive(Clone, Copy)]\npub enum SignBit {\n    Zero,\n    One,\n}\n\nimpl From\u003cSignBit\u003e for u8 {\n    fn from(signbit: SignBit) -\u003e Self {\n        match signbit {\n            SignBit::Zero =\u003e 0u8,\n            SignBit::One =\u003e 1u8,\n        }\n    }\n}\n\nimpl From\u003cSignBit\u003e for bool {\n    fn from(signbit: SignBit) -\u003e Self {\n        match signbit {\n            SignBit::Zero =\u003e false,\n            SignBit::One =\u003e true,\n        }\n    }\n}\n\nimpl From\u003cbool\u003e for SignBit {\n    fn from(signbit: bool) -\u003e Self {\n        if signbit {\n            SignBit::One\n        } else {\n            SignBit::Zero\n        }\n    }\n}\n\n// which validation method to use when constructing an ed25519 expanded key from\n// a byte array\nenum FromRawValidationMethod {\n    // expanded ed25519 keys coming from legacy c-tor daemon; the scalar portion\n    // is clamped, but not reduced\n    LegacyCTor,\n    // expanded ed25519 keys coming from ed25519-dalek crate; the scalar portion\n    // has been clamped AND reduced\n    Ed25519Dalek,\n}\n\n// Ed25519 Private Key\n\nimpl Ed25519PrivateKey {\n    pub fn generate() -\u003e Ed25519PrivateKey {\n        let csprng = \u0026mut OsRng;\n        let keypair = pk::ed25519::Keypair::generate(csprng);\n\n        Ed25519PrivateKey {\n            expanded_keypair: pk::ed25519::ExpandedKeypair::from(\u0026keypair),\n        }\n    }\n\n    fn from_raw_impl(raw: \u0026[u8; ED25519_PRIVATE_KEY_SIZE], method: FromRawValidationMethod) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        // see: https://gitlab.torproject.org/tpo/core/arti/-/issues/1343\n        match method {\n            FromRawValidationMethod::LegacyCTor =\u003e {\n                // Verify the scalar portion of the expanded key has been clamped\n                // see: https://gitlab.torproject.org/tpo/core/arti/-/issues/1021\n                if !(raw[0] == raw[0] \u0026 248 \u0026\u0026 raw[31] == (raw[31] \u0026 63) | 64) {\n                    return Err(Error::KeyInvalid);\n                }\n            },\n            FromRawValidationMethod::Ed25519Dalek =\u003e {\n                // Verify the scalar is non-zero and it has been reduced\n                let scalar: [u8; 32] = raw[..32].try_into().unwrap();\n                if scalar.iter().all(|\u0026x| x == 0x00u8) {\n                    return Err(Error::KeyInvalid);\n                }\n                let reduced_scalar = Scalar::from_bytes_mod_order(scalar).to_bytes();\n                if scalar != reduced_scalar {\n                    return Err(Error::KeyInvalid);\n                }\n            }\n        }\n\n        if let Some(expanded_keypair) = pk::ed25519::ExpandedKeypair::from_secret_key_bytes(*raw) {\n            Ok(Ed25519PrivateKey{expanded_keypair})\n        } else {\n            Err(Error::KeyInvalid)\n        }\n    }\n\n    pub fn from_raw(raw: \u0026[u8; ED25519_PRIVATE_KEY_SIZE]) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_raw_impl(raw, FromRawValidationMethod::Ed25519Dalek)\n    }\n\n    fn from_key_blob_impl(key_blob: \u0026str, method: FromRawValidationMethod) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        if key_blob.len() != ED25519_PRIVATE_KEY_KEYBLOB_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received string with length '{}'\",\n                ED25519_PRIVATE_KEY_KEYBLOB_LENGTH,\n                key_blob.len()\n            )));\n        }\n\n        if !key_blob.starts_with(ED25519_PRIVATE_KEY_KEYBLOB_HEADER) {\n            return Err(Error::ParseError(format!(\n                \"expects string that begins with '{}'; received '{}'\",\n                \u0026ED25519_PRIVATE_KEY_KEYBLOB_HEADER, \u0026key_blob\n            )));\n        }\n\n        let base64_key: \u0026str = \u0026key_blob[ED25519_PRIVATE_KEY_KEYBLOB_HEADER.len()..];\n        let private_key_data = match BASE64.decode(base64_key.as_bytes()) {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"could not parse '{}' as base64\",\n                    base64_key\n                )))\n            }\n        };\n        let private_key_data_len = private_key_data.len();\n        let private_key_data_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = match private_key_data.try_into()\n        {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded private key length '{}'; actual '{}'\",\n                    ED25519_PRIVATE_KEY_SIZE, private_key_data_len\n                )))\n            }\n        };\n\n        Ed25519PrivateKey::from_raw_impl(\u0026private_key_data_raw, method)\n    }\n\n    pub (crate) fn from_key_blob_legacy(key_blob: \u0026str) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_key_blob_impl(key_blob, FromRawValidationMethod::LegacyCTor)\n    }\n\n    pub fn from_key_blob(key_blob: \u0026str) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_key_blob_impl(key_blob, FromRawValidationMethod::Ed25519Dalek)\n    }\n\n    pub fn from_private_x25519(\n        x25519_private: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(Ed25519PrivateKey, SignBit), Error\u003e {\n        if let Some((result, signbit)) =\n            convert_curve25519_to_ed25519_private(\u0026x25519_private.secret_key)\n        {\n            Ok((\n                Ed25519PrivateKey {\n                    expanded_keypair: result,\n                },\n                match signbit {\n                    0u8 =\u003e SignBit::Zero,\n                    1u8 =\u003e SignBit::One,\n                    invalid_signbit =\u003e {\n                        return Err(Error::ConversionError(format!(\n                            \"convert_curve25519_to_ed25519_private() returned invalid signbit: {}\",\n                            invalid_signbit\n                        )))\n                    }\n                },\n            ))\n        } else {\n            Err(Error::ConversionError(\n                \"could not convert x25519 private key to ed25519 private key\".to_string(),\n            ))\n        }\n    }\n\n    pub fn to_key_blob(\u0026self) -\u003e String {\n        let mut key_blob = ED25519_PRIVATE_KEY_KEYBLOB_HEADER.to_string();\n        key_blob.push_str(\u0026BASE64.encode(\u0026self.expanded_keypair.to_secret_key_bytes()));\n\n        key_blob\n    }\n\n    pub fn sign_message_ex(\n        \u0026self,\n        _public_key: \u0026Ed25519PublicKey,\n        message: \u0026[u8],\n    ) -\u003e Ed25519Signature {\n        let signature = self\n            .expanded_keypair\n            .sign(message);\n        Ed25519Signature { signature }\n    }\n\n    pub fn sign_message(\u0026self, message: \u0026[u8]) -\u003e Ed25519Signature {\n        let public_key = Ed25519PublicKey::from_private_key(self);\n        self.sign_message_ex(\u0026public_key, message)\n    }\n\n    pub fn to_bytes(\u0026self) -\u003e [u8; ED25519_PRIVATE_KEY_SIZE] {\n        self.expanded_keypair.to_secret_key_bytes()\n    }\n}\n\nimpl PartialEq for Ed25519PrivateKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.to_bytes().eq(\u0026other.to_bytes())\n    }\n}\n\nimpl Clone for Ed25519PrivateKey {\n    fn clone(\u0026self) -\u003e Ed25519PrivateKey {\n        match Ed25519PrivateKey::from_raw(\u0026self.to_bytes()) {\n            Ok(ed25519_private_key) =\u003e ed25519_private_key,\n            Err(_) =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl std::fmt::Debug for Ed25519PrivateKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"--- ed25519 private key ---\")\n    }\n}\n\n// Ed25519 Public Key\n\nimpl Ed25519PublicKey {\n    pub fn from_raw(raw: \u0026[u8; ED25519_PUBLIC_KEY_SIZE]) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        Ok(Ed25519PublicKey {\n            public_key: match pk::ed25519::PublicKey::from_bytes(raw) {\n                Ok(public_key) =\u003e public_key,\n                Err(_) =\u003e {\n                    return Err(Error::ConversionError(\n                        \"failed to create ed25519 public key from bytes\".to_string(),\n                    ))\n                }\n            },\n        })\n    }\n\n    pub fn from_service_id(service_id: \u0026V3OnionServiceId) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        // decode base32 encoded service id\n        let mut decoded_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n        let decoded_byte_count =\n            match ONION_BASE32.decode_mut(service_id.as_bytes(), \u0026mut decoded_service_id) {\n                Ok(decoded_byte_count) =\u003e decoded_byte_count,\n                Err(_) =\u003e {\n                    return Err(Error::ConversionError(format!(\n                        \"failed to decode '{}' as V3OnionServiceId\",\n                        service_id\n                    )))\n                }\n            };\n        if decoded_byte_count != V3_ONION_SERVICE_ID_RAW_SIZE {\n            return Err(Error::ConversionError(format!(\n                \"decoded byte count is '{}', expected '{}'\",\n                decoded_byte_count, V3_ONION_SERVICE_ID_RAW_SIZE\n            )));\n        }\n\n        Ed25519PublicKey::from_raw(\n            decoded_service_id[0..ED25519_PUBLIC_KEY_SIZE]\n                .try_into()\n                .unwrap(),\n        )\n    }\n\n    pub fn from_private_key(private_key: \u0026Ed25519PrivateKey) -\u003e Ed25519PublicKey {\n        Ed25519PublicKey {\n            public_key: *private_key.expanded_keypair.public()\n        }\n    }\n\n    fn from_public_x25519(\n        public_x25519: \u0026X25519PublicKey,\n        signbit: SignBit,\n    ) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        match convert_curve25519_to_ed25519_public(\u0026public_x25519.public_key, signbit.into()) {\n            Some(public_key) =\u003e Ok(Ed25519PublicKey { public_key }),\n            None =\u003e Err(Error::ConversionError(\n                \"failed to create ed25519 public key from x25519 public key and signbit\"\n                    .to_string(),\n            )),\n        }\n    }\n\n    pub fn to_base32(\u0026self) -\u003e String {\n        BASE32.encode(self.as_bytes())\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; ED25519_PUBLIC_KEY_SIZE] {\n        self.public_key.as_bytes()\n    }\n}\n\nimpl PartialEq for Ed25519PublicKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.public_key.eq(\u0026other.public_key)\n    }\n}\n\nimpl std::fmt::Debug for Ed25519PublicKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.public_key.fmt(f)\n    }\n}\n\n// Ed25519 Signature\n\nimpl Ed25519Signature {\n    pub fn from_raw(raw: \u0026[u8; ED25519_SIGNATURE_SIZE]) -\u003e Result\u003cEd25519Signature, Error\u003e {\n        Ok(Ed25519Signature {\n            signature: pk::ed25519::Signature::from_bytes(raw)\n        })\n    }\n\n    pub fn verify(\u0026self, message: \u0026[u8], public_key: \u0026Ed25519PublicKey) -\u003e bool {\n        if let Ok(()) = public_key.public_key.verify_strict(message, \u0026self.signature) {\n            return true;\n        }\n        false\n    }\n\n    // derives an ed25519 public key from the provided x25519 public key and signbit, then\n    // verifies this signature using said ed25519 public key\n    pub fn verify_x25519(\n        \u0026self,\n        message: \u0026[u8],\n        public_key: \u0026X25519PublicKey,\n        signbit: SignBit,\n    ) -\u003e bool {\n        if let Ok(public_key) = Ed25519PublicKey::from_public_x25519(public_key, signbit) {\n            return self.verify(message, \u0026public_key);\n        }\n        false\n    }\n\n    pub fn to_bytes(\u0026self) -\u003e [u8; ED25519_SIGNATURE_SIZE] {\n        self.signature.to_bytes()\n    }\n}\n\nimpl PartialEq for Ed25519Signature {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.signature.eq(\u0026other.signature)\n    }\n}\n\nimpl std::fmt::Debug for Ed25519Signature {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.signature.fmt(f)\n    }\n}\n\n// X25519 Private Key\n\nimpl X25519PrivateKey {\n    pub fn generate() -\u003e X25519PrivateKey {\n        let csprng = \u0026mut OsRng;\n        X25519PrivateKey {\n            secret_key: pk::curve25519::StaticSecret::random_from_rng(csprng),\n        }\n    }\n\n    pub fn from_raw(raw: \u0026[u8; X25519_PRIVATE_KEY_SIZE]) -\u003e Result\u003cX25519PrivateKey, Error\u003e {\n        // see: https://docs.rs/x25519-dalek/2.0.0-pre.1/src/x25519_dalek/x25519.rs.html#197\n        if raw[0] == raw[0] \u0026 240 \u0026\u0026 raw[31] == (raw[31] \u0026 127) | 64 {\n            Ok(X25519PrivateKey {\n                secret_key: pk::curve25519::StaticSecret::from(*raw),\n            })\n        } else {\n            Err(Error::KeyInvalid)\n        }\n    }\n\n    // a base64 encoded keyblob\n    pub fn from_base64(base64: \u0026str) -\u003e Result\u003cX25519PrivateKey, Error\u003e {\n        if base64.len() != X25519_PRIVATE_KEY_BASE64_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received string with length '{}'\",\n                X25519_PRIVATE_KEY_BASE64_LENGTH,\n                base64.len()\n            )));\n        }\n\n        let private_key_data = match BASE64.decode(base64.as_bytes()) {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"could not parse '{}' as base64\",\n                    base64\n                )))\n            }\n        };\n        let private_key_data_len = private_key_data.len();\n        let private_key_data_raw: [u8; X25519_PRIVATE_KEY_SIZE] = match private_key_data.try_into()\n        {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded private key length '{}'; actual '{}'\",\n                    X25519_PRIVATE_KEY_SIZE, private_key_data_len\n                )))\n            }\n        };\n\n        X25519PrivateKey::from_raw(\u0026private_key_data_raw)\n    }\n\n    // security note: only ever sign messages the private key owner controls the contents of!\n    // this function first derives an ed25519 private key from the provided x25519 private key\n    // and signs the message, returning the signature and signbit needed to calculate the\n    // ed25519 public key from our x25519 private key's associated x25519 public key\n    pub fn sign_message(\u0026self, message: \u0026[u8]) -\u003e Result\u003c(Ed25519Signature, SignBit), Error\u003e {\n        let (ed25519_private, signbit) = Ed25519PrivateKey::from_private_x25519(self)?;\n        Ok((ed25519_private.sign_message(message), signbit))\n    }\n\n    pub fn to_base64(\u0026self) -\u003e String {\n        BASE64.encode(\u0026self.secret_key.to_bytes())\n    }\n\n    pub fn to_bytes(\u0026self) -\u003e [u8; X25519_PRIVATE_KEY_SIZE] {\n        self.secret_key.to_bytes()\n    }\n}\n\nimpl PartialEq for X25519PrivateKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.secret_key.to_bytes() == other.secret_key.to_bytes()\n    }\n}\n\nimpl std::fmt::Debug for X25519PrivateKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"--- x25519 private key ---\")\n    }\n}\n\n// X25519 Public Key\nimpl X25519PublicKey {\n    pub fn from_private_key(private_key: \u0026X25519PrivateKey) -\u003e X25519PublicKey {\n        X25519PublicKey {\n            public_key: pk::curve25519::PublicKey::from(\u0026private_key.secret_key),\n        }\n    }\n\n    pub fn from_raw(raw: \u0026[u8; X25519_PUBLIC_KEY_SIZE]) -\u003e X25519PublicKey {\n        X25519PublicKey {\n            public_key: pk::curve25519::PublicKey::from(*raw),\n        }\n    }\n\n    pub fn from_base32(base32: \u0026str) -\u003e Result\u003cX25519PublicKey, Error\u003e {\n        if base32.len() != X25519_PUBLIC_KEY_BASE32_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received '{}' with length '{}'\",\n                X25519_PUBLIC_KEY_BASE32_LENGTH,\n                base32,\n                base32.len()\n            )));\n        }\n\n        let public_key_data = match BASE32_NOPAD.decode(base32.as_bytes()) {\n            Ok(public_key_data) =\u003e public_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"failed to decode '{}' as X25519PublicKey\",\n                    base32\n                )))\n            }\n        };\n        let public_key_data_len = public_key_data.len();\n        let public_key_data_raw: [u8; X25519_PUBLIC_KEY_SIZE] = match public_key_data.try_into() {\n            Ok(public_key_data) =\u003e public_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded public key length '{}'; actual '{}'\",\n                    X25519_PUBLIC_KEY_SIZE, public_key_data_len\n                )))\n            }\n        };\n\n        Ok(X25519PublicKey::from_raw(\u0026public_key_data_raw))\n    }\n\n    pub fn to_base32(\u0026self) -\u003e String {\n        BASE32_NOPAD.encode(self.public_key.as_bytes())\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; X25519_PUBLIC_KEY_SIZE] {\n        self.public_key.as_bytes()\n    }\n}\n\nimpl std::fmt::Debug for X25519PublicKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.to_base32())\n    }\n}\n\n// Onion Service Id\n\nimpl V3OnionServiceId {\n    // see https://github.com/torproject/torspec/blob/main/rend-spec-v3.txt#L2143\n    fn calc_truncated_checksum(\n        public_key: \u0026[u8; ED25519_PUBLIC_KEY_SIZE],\n    ) -\u003e [u8; TRUNCATED_CHECKSUM_SIZE] {\n        let mut hasher = Sha3_256::new();\n\n        // calculate checksum\n        hasher.update(b\".onion checksum\");\n        hasher.update(public_key);\n        hasher.update([0x03u8]);\n        let hash_bytes = hasher.finalize();\n\n        [hash_bytes[0], hash_bytes[1]]\n    }\n\n    pub fn from_string(service_id: \u0026str) -\u003e Result\u003cV3OnionServiceId, Error\u003e {\n        if !V3OnionServiceId::is_valid(service_id) {\n            return Err(Error::ParseError(format!(\n                \"'{}' is not a valid v3 onion service id\",\n                service_id\n            )));\n        }\n        Ok(V3OnionServiceId {\n            data: service_id.as_bytes().try_into().unwrap(),\n        })\n    }\n\n    pub fn from_public_key(public_key: \u0026Ed25519PublicKey) -\u003e V3OnionServiceId {\n        let mut raw_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n\n        raw_service_id[..ED25519_PUBLIC_KEY_SIZE].copy_from_slice(\u0026public_key.as_bytes()[..]);\n        let truncated_checksum = Self::calc_truncated_checksum(public_key.as_bytes());\n        raw_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET] = truncated_checksum[0];\n        raw_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET + 1] = truncated_checksum[1];\n        raw_service_id[V3_ONION_SERVICE_ID_VERSION_OFFSET] = 0x03u8;\n\n        let mut service_id = [0u8; V3_ONION_SERVICE_ID_STRING_LENGTH];\n        // panics on wrong buffer size, but given our constant buffer sizes should be fine\n        ONION_BASE32.encode_mut(\u0026raw_service_id, \u0026mut service_id);\n\n        V3OnionServiceId { data: service_id }\n    }\n\n    pub fn from_private_key(private_key: \u0026Ed25519PrivateKey) -\u003e V3OnionServiceId {\n        Self::from_public_key(\u0026Ed25519PublicKey::from_private_key(private_key))\n    }\n\n    pub fn is_valid(service_id: \u0026str) -\u003e bool {\n        if service_id.len() != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            return false;\n        }\n\n        let mut decoded_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n        match ONION_BASE32.decode_mut(service_id.as_bytes(), \u0026mut decoded_service_id) {\n            Ok(decoded_byte_count) =\u003e {\n                // ensure right size\n                if decoded_byte_count != V3_ONION_SERVICE_ID_RAW_SIZE {\n                    return false;\n                }\n                // ensure correct version\n                if decoded_service_id[V3_ONION_SERVICE_ID_VERSION_OFFSET] != 0x03 {\n                    return false;\n                }\n                // copy public key into own buffer\n                let mut public_key = [0u8; ED25519_PUBLIC_KEY_SIZE];\n                public_key[..].copy_from_slice(\u0026decoded_service_id[..ED25519_PUBLIC_KEY_SIZE]);\n                // ensure checksum is correct\n                let truncated_checksum = Self::calc_truncated_checksum(\u0026public_key);\n                if truncated_checksum[0] != decoded_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET]\n                    || truncated_checksum[1]\n                        != decoded_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET + 1]\n                {\n                    return false;\n                }\n                true\n            }\n            Err(_) =\u003e false,\n        }\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; V3_ONION_SERVICE_ID_STRING_LENGTH] {\n        \u0026self.data\n    }\n}\n\nimpl std::fmt::Display for V3OnionServiceId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        unsafe { write!(f, \"{}\", str::from_utf8_unchecked(\u0026self.data)) }\n    }\n}\n\nimpl std::fmt::Debug for V3OnionServiceId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        unsafe { write!(f, \"{}\", str::from_utf8_unchecked(\u0026self.data)) }\n    }\n}\n","traces":[{"line":88,"address":[1697456],"length":1,"stats":{"Line":4},"fn_name":"generate_password"},{"line":89,"address":[1697480],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[1641609,1641600],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":136,"address":[1697536],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":137,"address":[1697545],"length":1,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[1697560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[1697567],"length":1,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[1697584],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":146,"address":[1697593],"length":1,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[1697608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[1697615],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[1697632],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":155,"address":[1697644,1697653],"length":1,"stats":{"Line":5},"fn_name":null},{"line":156,"address":[1697655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[1697648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[1697836,1697680],"length":1,"stats":{"Line":5},"fn_name":null},{"line":178,"address":[1697701],"length":1,"stats":{"Line":5},"fn_name":null},{"line":179,"address":[1697709],"length":1,"stats":{"Line":5},"fn_name":null},{"line":182,"address":[1697733],"length":1,"stats":{"Line":5},"fn_name":null},{"line":186,"address":[1697872],"length":1,"stats":{"Line":5},"fn_name":null},{"line":188,"address":[1697910],"length":1,"stats":{"Line":5},"fn_name":null},{"line":192,"address":[1697938,1698251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[1698192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[1697963],"length":1,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[1641632,1641642],"length":1,"stats":{"Line":12},"fn_name":"{closure#0}"},{"line":200,"address":[1698456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1698353],"length":1,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[1698423],"length":1,"stats":{"Line":4},"fn_name":null},{"line":204,"address":[1698533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1698605,1698272,1698708],"length":1,"stats":{"Line":15},"fn_name":null},{"line":210,"address":[1698643],"length":1,"stats":{"Line":5},"fn_name":null},{"line":212,"address":[1698715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[1698848],"length":1,"stats":{"Line":4},"fn_name":null},{"line":217,"address":[1698864],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[1698896,1701068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1698953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[1699215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1699112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1698988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[1699569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[1699505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1699789],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[1700034,1699890],"length":1,"stats":{"Line":4},"fn_name":null},{"line":238,"address":[1700096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[1701119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1700306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[1700343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[1700432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[1700857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1700668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[1701344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[1701366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1701408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[1701430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[1702343,1702160,1701472],"length":1,"stats":{"Line":4},"fn_name":null},{"line":272,"address":[1702288,1701524],"length":1,"stats":{"Line":4},"fn_name":null},{"line":275,"address":[1701789],"length":1,"stats":{"Line":4},"fn_name":null},{"line":276,"address":[1701623],"length":1,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[1701629],"length":1,"stats":{"Line":4},"fn_name":null},{"line":280,"address":[1701771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[1701781],"length":1,"stats":{"Line":3},"fn_name":null},{"line":282,"address":[1701687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1701924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1702174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[1701653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1702384,1702755],"length":1,"stats":{"Line":5},"fn_name":null},{"line":298,"address":[1702414],"length":1,"stats":{"Line":5},"fn_name":null},{"line":299,"address":[1702441],"length":1,"stats":{"Line":5},"fn_name":null},{"line":301,"address":[1702721],"length":1,"stats":{"Line":5},"fn_name":null},{"line":304,"address":[1702784],"length":1,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[1702850],"length":1,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[1702896],"length":1,"stats":{"Line":4},"fn_name":null},{"line":316,"address":[1702952],"length":1,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[1702983],"length":1,"stats":{"Line":4},"fn_name":null},{"line":320,"address":[1703008],"length":1,"stats":{"Line":4},"fn_name":null},{"line":321,"address":[1703025],"length":1,"stats":{"Line":4},"fn_name":null},{"line":326,"address":[1703056],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":327,"address":[1703089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[1703371,1703152,1703342],"length":1,"stats":{"Line":3},"fn_name":"clone"},{"line":333,"address":[1703177],"length":1,"stats":{"Line":3},"fn_name":null},{"line":334,"address":[1703223],"length":1,"stats":{"Line":3},"fn_name":null},{"line":341,"address":[1703392],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":342,"address":[1703410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[1703845,1703472],"length":1,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[1703550],"length":1,"stats":{"Line":4},"fn_name":null},{"line":351,"address":[1703496],"length":1,"stats":{"Line":4},"fn_name":null},{"line":352,"address":[1703520],"length":1,"stats":{"Line":4},"fn_name":null},{"line":354,"address":[1703711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[1703623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[1704994,1703872],"length":1,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[1703894],"length":1,"stats":{"Line":4},"fn_name":null},{"line":365,"address":[1703915,1704015],"length":1,"stats":{"Line":8},"fn_name":null},{"line":367,"address":[1704080],"length":1,"stats":{"Line":4},"fn_name":null},{"line":369,"address":[1704775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[1704112],"length":1,"stats":{"Line":4},"fn_name":null},{"line":376,"address":[1704540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[1704201],"length":1,"stats":{"Line":4},"fn_name":null},{"line":389,"address":[1705040],"length":1,"stats":{"Line":5},"fn_name":null},{"line":391,"address":[1705078],"length":1,"stats":{"Line":5},"fn_name":null},{"line":395,"address":[1705136],"length":1,"stats":{"Line":4},"fn_name":null},{"line":399,"address":[1705179],"length":1,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[1705378],"length":1,"stats":{"Line":4},"fn_name":null},{"line":401,"address":[1705261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1705232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[1705488,1705642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[1705600,1705518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[1705664],"length":1,"stats":{"Line":5},"fn_name":null},{"line":413,"address":[1705669],"length":1,"stats":{"Line":5},"fn_name":null},{"line":418,"address":[1705680],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":419,"address":[1705694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[1705712],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":425,"address":[1705726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1705744],"length":1,"stats":{"Line":4},"fn_name":null},{"line":433,"address":[1705779],"length":1,"stats":{"Line":4},"fn_name":null},{"line":434,"address":[1705768],"length":1,"stats":{"Line":4},"fn_name":null},{"line":438,"address":[1705856],"length":1,"stats":{"Line":4},"fn_name":null},{"line":439,"address":[1705897],"length":1,"stats":{"Line":4},"fn_name":null},{"line":440,"address":[1705916],"length":1,"stats":{"Line":5},"fn_name":null},{"line":442,"address":[1705945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[1705968,1706233],"length":1,"stats":{"Line":4},"fn_name":null},{"line":453,"address":[1706050],"length":1,"stats":{"Line":4},"fn_name":null},{"line":454,"address":[1706124,1706199],"length":1,"stats":{"Line":8},"fn_name":null},{"line":456,"address":[1706150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[1706256],"length":1,"stats":{"Line":3},"fn_name":null},{"line":460,"address":[1706273],"length":1,"stats":{"Line":3},"fn_name":null},{"line":465,"address":[1706304],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":466,"address":[1706318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1706336],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":472,"address":[1706350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[1706368],"length":1,"stats":{"Line":4},"fn_name":null},{"line":480,"address":[1706382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":482,"address":[1706392],"length":1,"stats":{"Line":4},"fn_name":null},{"line":486,"address":[1706464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[1706494,1706573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1706642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[1706604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[1706510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[1708283,1706736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[1706769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[1707061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[1706958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[1707328,1706804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":508,"address":[1707390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[1708334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[1707600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[1707637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[1707722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[1708079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[1707884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[1709025,1708560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[1708799,1708611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[1708772,1708927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[1709056,1709193],"length":1,"stats":{"Line":4},"fn_name":null},{"line":541,"address":[1709146,1709074],"length":1,"stats":{"Line":8},"fn_name":null},{"line":544,"address":[1709216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[1709233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[1709248],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":551,"address":[1709272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[1709328],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":557,"address":[1709346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[1709408],"length":1,"stats":{"Line":5},"fn_name":null},{"line":565,"address":[1709426],"length":1,"stats":{"Line":5},"fn_name":null},{"line":569,"address":[1709488],"length":1,"stats":{"Line":4},"fn_name":null},{"line":571,"address":[1709506],"length":1,"stats":{"Line":4},"fn_name":null},{"line":575,"address":[1709600,1711326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[1709639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[1710014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[1709901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[1709674,1710300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":586,"address":[1710362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":588,"address":[1711377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[1710572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[1710609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[1710694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[1711119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[1710854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[1711600,1711750],"length":1,"stats":{"Line":4},"fn_name":null},{"line":609,"address":[1711630,1711708],"length":1,"stats":{"Line":8},"fn_name":null},{"line":612,"address":[1711776],"length":1,"stats":{"Line":3},"fn_name":null},{"line":613,"address":[1711781],"length":1,"stats":{"Line":3},"fn_name":null},{"line":618,"address":[1711792,1712064],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":619,"address":[1711826,1711968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[1712096],"length":1,"stats":{"Line":6},"fn_name":null},{"line":630,"address":[1712116],"length":1,"stats":{"Line":6},"fn_name":null},{"line":633,"address":[1712127],"length":1,"stats":{"Line":6},"fn_name":null},{"line":634,"address":[1712150],"length":1,"stats":{"Line":6},"fn_name":null},{"line":635,"address":[1712161],"length":1,"stats":{"Line":6},"fn_name":null},{"line":636,"address":[1712188],"length":1,"stats":{"Line":6},"fn_name":null},{"line":638,"address":[1712348,1712278,1712428],"length":1,"stats":{"Line":12},"fn_name":null},{"line":641,"address":[1712464],"length":1,"stats":{"Line":6},"fn_name":null},{"line":642,"address":[1712491],"length":1,"stats":{"Line":6},"fn_name":null},{"line":643,"address":[1712575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[1712898],"length":1,"stats":{"Line":6},"fn_name":null},{"line":649,"address":[1712730],"length":1,"stats":{"Line":6},"fn_name":null},{"line":653,"address":[1712976,1713527],"length":1,"stats":{"Line":5},"fn_name":null},{"line":654,"address":[1713006],"length":1,"stats":{"Line":5},"fn_name":null},{"line":656,"address":[1713023],"length":1,"stats":{"Line":5},"fn_name":null},{"line":657,"address":[1713133],"length":1,"stats":{"Line":5},"fn_name":null},{"line":658,"address":[1713168],"length":1,"stats":{"Line":5},"fn_name":null},{"line":659,"address":[1713389,1713176],"length":1,"stats":{"Line":5},"fn_name":null},{"line":660,"address":[1713267],"length":1,"stats":{"Line":5},"fn_name":null},{"line":662,"address":[1713272],"length":1,"stats":{"Line":5},"fn_name":null},{"line":664,"address":[1713410,1713311],"length":1,"stats":{"Line":5},"fn_name":null},{"line":669,"address":[1713552],"length":1,"stats":{"Line":4},"fn_name":null},{"line":670,"address":[1713576],"length":1,"stats":{"Line":4},"fn_name":null},{"line":673,"address":[1713616,1714378],"length":1,"stats":{"Line":6},"fn_name":null},{"line":674,"address":[1713649],"length":1,"stats":{"Line":6},"fn_name":null},{"line":675,"address":[1713755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[1713670],"length":1,"stats":{"Line":6},"fn_name":null},{"line":679,"address":[1713819,1713697],"length":1,"stats":{"Line":12},"fn_name":null},{"line":680,"address":[1713882],"length":1,"stats":{"Line":6},"fn_name":null},{"line":682,"address":[1713898],"length":1,"stats":{"Line":6},"fn_name":null},{"line":683,"address":[1713918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[1713928,1713916],"length":1,"stats":{"Line":12},"fn_name":null},{"line":687,"address":[1713993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[1713938],"length":1,"stats":{"Line":6},"fn_name":null},{"line":691,"address":[1714023,1713957],"length":1,"stats":{"Line":12},"fn_name":null},{"line":693,"address":[1714122],"length":1,"stats":{"Line":6},"fn_name":null},{"line":694,"address":[1714163],"length":1,"stats":{"Line":6},"fn_name":null},{"line":695,"address":[1714199,1714187,1714290],"length":1,"stats":{"Line":18},"fn_name":null},{"line":696,"address":[1714303,1714210],"length":1,"stats":{"Line":6},"fn_name":null},{"line":698,"address":[1714189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[1714326],"length":1,"stats":{"Line":6},"fn_name":null},{"line":702,"address":[1713906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[1714400],"length":1,"stats":{"Line":4},"fn_name":null},{"line":712,"address":[1714416],"length":1,"stats":{"Line":5},"fn_name":"fmt"},{"line":713,"address":[1714502,1714442],"length":1,"stats":{"Line":10},"fn_name":null},{"line":718,"address":[1714576],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":719,"address":[1714602,1714662],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":180,"coverable":229},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","tor_provider.rs"],"content":"// standard\nuse std::boxed::Box;\nuse std::io::{Read, Write};\nuse std::net::TcpStream;\nuse std::ops::{Deref, DerefMut};\n\n// internal crates\nuse crate::tor_crypto::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct OnionAddrV3 {\n    service_id: V3OnionServiceId,\n    virt_port: u16,\n}\n\nimpl OnionAddrV3 {\n    pub fn new(service_id: V3OnionServiceId, virt_port: u16) -\u003e OnionAddrV3 {\n        OnionAddrV3 {\n            service_id,\n            virt_port,\n        }\n    }\n\n    pub fn service_id(\u0026self) -\u003e \u0026V3OnionServiceId {\n        \u0026self.service_id\n    }\n}\n\nimpl std::fmt::Display for OnionAddrV3 {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}:{}\", self.service_id, self.virt_port)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub enum OnionAddr {\n    V3(OnionAddrV3),\n}\n\nimpl std::fmt::Display for OnionAddr {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            OnionAddr::V3(onion_addr) =\u003e onion_addr.fmt(f),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub enum TargetAddr {\n    Ip(std::net::SocketAddr),\n    Domain(String, u16),\n    OnionService(OnionAddr),\n}\n\n#[derive(Debug)]\npub enum TorEvent {\n    BootstrapStatus {\n        progress: u32,\n        tag: String,\n        summary: String,\n    },\n    BootstrapComplete,\n    LogReceived {\n        line: String,\n    },\n    OnionServicePublished {\n        service_id: V3OnionServiceId,\n    },\n}\n\npub type CircuitToken = usize;\n\n//\n// OnionStream Implementation\n//\n\npub struct OnionStream {\n    pub(crate) stream: TcpStream,\n    pub(crate) local_addr: Option\u003cOnionAddr\u003e,\n    pub(crate) peer_addr: Option\u003cTargetAddr\u003e,\n}\n\nimpl Deref for OnionStream {\n    type Target = TcpStream;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.stream\n    }\n}\n\nimpl DerefMut for OnionStream {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.stream\n    }\n}\n\nimpl From\u003cOnionStream\u003e for TcpStream {\n    fn from(onion_stream: OnionStream) -\u003e Self {\n        onion_stream.stream\n    }\n}\n\nimpl Read for OnionStream {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.stream.read(buf)\n    }\n}\n\nimpl Write for OnionStream {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.stream.write(buf)\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.stream.flush()\n    }\n}\n\nimpl OnionStream {\n    pub fn peer_addr(\u0026self) -\u003e Option\u003cTargetAddr\u003e {\n        self.peer_addr.clone()\n    }\n\n    pub fn local_addr(\u0026self) -\u003e Option\u003cOnionAddr\u003e {\n        None\n    }\n\n    pub fn try_clone(\u0026self) -\u003e Result\u003cSelf, std::io::Error\u003e {\n        Ok(Self {\n            stream: self.stream.try_clone()?,\n            local_addr: self.local_addr.clone(),\n            peer_addr: self.peer_addr.clone(),\n        })\n    }\n}\n\npub trait OnionListenerImpl: Send {\n    fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e;\n    fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e;\n}\n\npub struct OnionListener {\n    pub(crate) onion_listener: Box\u003cdyn OnionListenerImpl\u003e,\n}\n\nimpl OnionListener {\n    pub fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.onion_listener.set_nonblocking(nonblocking)\n    }\n\n    pub fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e {\n        self.onion_listener.accept()\n    }\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"{0}\")]\n    Generic(String),\n}\n\npub trait TorProvider: Send {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, Error\u003e;\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), Error\u003e;\n    fn remove_client_auth(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e;\n    fn connect(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, Error\u003e;\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, Error\u003e;\n    fn generate_token(\u0026mut self) -\u003e CircuitToken;\n    fn release_token(\u0026mut self, token: CircuitToken);\n}\n","traces":[{"line":17,"address":[1575776],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[3059632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[3059648],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":31,"address":[3059709,3059768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[3059856],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":43,"address":[3059869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[3059904],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":86,"address":[3059912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1576128],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"},{"line":92,"address":[1576136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1556368],"length":1,"stats":{"Line":2},"fn_name":"from"},{"line":98,"address":[3040161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[3059936],"length":1,"stats":{"Line":1},"fn_name":"read"},{"line":104,"address":[3059963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[3059984],"length":1,"stats":{"Line":1},"fn_name":"write"},{"line":110,"address":[3060011],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[3060032],"length":1,"stats":{"Line":1},"fn_name":"flush"},{"line":114,"address":[3060037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1576256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1576273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1576304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1576312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1576320,1576650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1576556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1576455,1576349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1576427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1576537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1576672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[1576696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[1576720],"length":1,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[1576740],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":13,"coverable":31},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","tests","tor_crypto.rs"],"content":"// internal crates\nuse tor_interface::tor_crypto::*;\n\n#[test]\nfn test_ed25519() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let private_key_blob = \"ED25519-V3:rP3u8mZaKohap0lKsB8Z8qXbXqK456JKKGONDBhV+gPBVKa2mHVQqnRTVuFXe3inU3YW6qvc7glYEwe9rK0LhQ==\";\n    let private_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = [\n        0xacu8, 0xfdu8, 0xeeu8, 0xf2u8, 0x66u8, 0x5au8, 0x2au8, 0x88u8, 0x5au8, 0xa7u8, 0x49u8,\n        0x4au8, 0xb0u8, 0x1fu8, 0x19u8, 0xf2u8, 0xa5u8, 0xdbu8, 0x5eu8, 0xa2u8, 0xb8u8, 0xe7u8,\n        0xa2u8, 0x4au8, 0x28u8, 0x63u8, 0x8du8, 0x0cu8, 0x18u8, 0x55u8, 0xfau8, 0x03u8, 0xc1u8,\n        0x54u8, 0xa6u8, 0xb6u8, 0x98u8, 0x75u8, 0x50u8, 0xaau8, 0x74u8, 0x53u8, 0x56u8, 0xe1u8,\n        0x57u8, 0x7bu8, 0x78u8, 0xa7u8, 0x53u8, 0x76u8, 0x16u8, 0xeau8, 0xabu8, 0xdcu8, 0xeeu8,\n        0x09u8, 0x58u8, 0x13u8, 0x07u8, 0xbdu8, 0xacu8, 0xadu8, 0x0bu8, 0x85u8,\n    ];\n    let public_raw: [u8; ED25519_PUBLIC_KEY_SIZE] = [\n        0xf2u8, 0xfdu8, 0xa2u8, 0xdbu8, 0xf3u8, 0x80u8, 0xa6u8, 0xbau8, 0x74u8, 0xa4u8, 0x90u8,\n        0xe1u8, 0x45u8, 0x55u8, 0xeeu8, 0xb9u8, 0x32u8, 0xa0u8, 0x5cu8, 0x39u8, 0x5au8, 0xe2u8,\n        0x02u8, 0x83u8, 0x55u8, 0x27u8, 0x89u8, 0x6au8, 0x1fu8, 0x2fu8, 0x3du8, 0xc5u8,\n    ];\n    let public_base32 = \"6L62FW7TQCTLU5FESDQUKVPOXEZKAXBZLLRAFA2VE6EWUHZPHXCQ====\";\n    let service_id_string = \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd\";\n    assert!(V3OnionServiceId::is_valid(\u0026service_id_string));\n\n    let mut message = [0x00u8; 256];\n    let null_message = [0x00u8; 256];\n    for (i, ptr) in message.iter_mut().enumerate() {\n        *ptr = i as u8;\n    }\n    let signature_raw: [u8; ED25519_SIGNATURE_SIZE] = [\n        0xa6u8, 0xd6u8, 0xc6u8, 0x1au8, 0x03u8, 0xbcu8, 0x43u8, 0x6fu8, 0x38u8, 0x53u8, 0x94u8,\n        0xcdu8, 0xdcu8, 0x86u8, 0x0au8, 0x88u8, 0x64u8, 0x43u8, 0x1du8, 0x18u8, 0x84u8, 0x30u8,\n        0x2fu8, 0xcdu8, 0xa6u8, 0x79u8, 0xcau8, 0x87u8, 0xd0u8, 0x29u8, 0xe7u8, 0x2bu8, 0x32u8,\n        0x9bu8, 0xa2u8, 0xa4u8, 0x3cu8, 0x74u8, 0x6au8, 0x08u8, 0x67u8, 0x0eu8, 0x63u8, 0x60u8,\n        0xcbu8, 0x46u8, 0x22u8, 0x55u8, 0x43u8, 0x5bu8, 0x84u8, 0x68u8, 0x0fu8, 0x47u8, 0xceu8,\n        0x6cu8, 0xd2u8, 0xb8u8, 0xebu8, 0xfeu8, 0xf6u8, 0x9eu8, 0x97u8, 0x0au8,\n    ];\n\n    // test the golden path first\n    let service_id = V3OnionServiceId::from_string(\u0026service_id_string)?;\n\n    let private_key = Ed25519PrivateKey::from_raw(\u0026private_raw)?;\n    assert_eq!(\n        private_key,\n        Ed25519PrivateKey::from_key_blob(\u0026private_key_blob)?\n    );\n    assert_eq!(private_key_blob, private_key.to_key_blob());\n\n    let public_key = Ed25519PublicKey::from_raw(\u0026public_raw)?;\n    assert_eq!(public_key, Ed25519PublicKey::from_service_id(\u0026service_id)?);\n    assert_eq!(public_key, Ed25519PublicKey::from_private_key(\u0026private_key));\n    assert_eq!(service_id, V3OnionServiceId::from_public_key(\u0026public_key));\n    assert_eq!(public_base32, public_key.to_base32());\n\n    let signature = private_key.sign_message(\u0026message);\n    assert_eq!(signature, Ed25519Signature::from_raw(\u0026signature_raw)?);\n    assert!(signature.verify(\u0026message, \u0026public_key));\n    assert!(!signature.verify(\u0026null_message, \u0026public_key));\n\n    // some invalid service ids\n    assert!(!V3OnionServiceId::is_valid(\"\"));\n    assert!(!V3OnionServiceId::is_valid(\n        \"\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n    ));\n    assert!(!V3OnionServiceId::is_valid(\n        \"6L62FW7TQCTLU5FESDQUKVPOXEZKAXBZLLRAFA2VE6EWUHZPHXCZSJYD\"\n    ));\n\n    // generate a new key, get the public key and sign/verify a message\n    let private_key = Ed25519PrivateKey::generate();\n    let public_key = Ed25519PublicKey::from_private_key(\u0026private_key);\n    let signature = private_key.sign_message(\u0026message);\n    assert!(signature.verify(\u0026message, \u0026public_key));\n\n    // test invalid private key blob returns an error\n    // https://gitlab.torproject.org/tpo/core/arti/-/issues/1021\n    let private_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = [\n        0x2eu8, 0x26u8, 0x0au8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x0au8, 0x77u8, 0x77u8,\n        0x77u8, 0x77u8, 0x5du8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8,\n        0x82u8, 0xb4u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8,\n        0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0xffu8,\n        0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8,\n        0xffu8, 0xffu8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x82u8, 0x88u8,\n    ];\n    match Ed25519PrivateKey::from_raw(\u0026private_raw) {\n        Ok(_) =\u003e panic!(\"invalid key accepted\"),\n        Err(tor_interface::tor_crypto::Error::KeyInvalid) =\u003e (),\n        Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_x25519() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // private/public key pair\n    const SECRET_BASE64: \u0026str = \"0GeSReJXdNcgvWRQdnDXhJGdu5UiwP2fefgT93/oqn0=\";\n    const SECRET_RAW: [u8; X25519_PRIVATE_KEY_SIZE] = [\n        0xd0u8, 0x67u8, 0x92u8, 0x45u8, 0xe2u8, 0x57u8, 0x74u8, 0xd7u8, 0x20u8, 0xbdu8, 0x64u8,\n        0x50u8, 0x76u8, 0x70u8, 0xd7u8, 0x84u8, 0x91u8, 0x9du8, 0xbbu8, 0x95u8, 0x22u8, 0xc0u8,\n        0xfdu8, 0x9fu8, 0x79u8, 0xf8u8, 0x13u8, 0xf7u8, 0x7fu8, 0xe8u8, 0xaau8, 0x7du8,\n    ];\n    const PUBLIC_BASE32: \u0026str = \"AEXCBCEDJ5KU34YGGMZ7PVHVDEA7D7YB7VQAPJTMTZGRJLN3JASA\";\n    const PUBLIC_RAW: [u8; X25519_PUBLIC_KEY_SIZE] = [\n        0x01u8, 0x2eu8, 0x20u8, 0x88u8, 0x83u8, 0x4fu8, 0x55u8, 0x4du8, 0xf3u8, 0x06u8, 0x33u8,\n        0x33u8, 0xf7u8, 0xd4u8, 0xf5u8, 0x19u8, 0x01u8, 0xf1u8, 0xffu8, 0x01u8, 0xfdu8, 0x60u8,\n        0x07u8, 0xa6u8, 0x6cu8, 0x9eu8, 0x4du8, 0x14u8, 0xadu8, 0xbbu8, 0x48u8, 0x24u8,\n    ];\n\n    // ensure we can convert from raw as expected\n    assert_eq!(\n        \u0026X25519PrivateKey::from_raw(\u0026SECRET_RAW)?.to_base64(),\n        SECRET_BASE64\n    );\n    assert_eq!(\n        \u0026X25519PublicKey::from_raw(\u0026PUBLIC_RAW).to_base32(),\n        PUBLIC_BASE32\n    );\n\n    // ensure we can round-trip as expected\n    assert_eq!(\n        \u0026X25519PrivateKey::from_base64(\u0026SECRET_BASE64)?.to_base64(),\n        SECRET_BASE64\n    );\n    assert_eq!(\n        \u0026X25519PublicKey::from_base32(\u0026PUBLIC_BASE32)?.to_base32(),\n        PUBLIC_BASE32\n    );\n\n    // ensure we generate the expected public key from private key\n    let private_key = X25519PrivateKey::from_base64(\u0026SECRET_BASE64)?;\n    let public_key = X25519PublicKey::from_private_key(\u0026private_key);\n    assert_eq!(public_key.to_base32(), PUBLIC_BASE32);\n\n    let message = b\"All around me are familiar faces\";\n\n    let (signature, signbit) = private_key.sign_message(message)?;\n    assert!(signature.verify_x25519(message, \u0026public_key, signbit));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","tests","tor_provider.rs"],"content":"// stanndard\nuse std::io::{Read, Write};\n\n// extern crates\nuse serial_test::serial;\n\n// internal crates\nuse tor_interface::legacy_tor_client::*;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\npub(crate) fn bootstrap_test(mut tor: Box\u003cdyn TorProvider\u003e) -\u003e anyhow::Result\u003c()\u003e {\n    tor.bootstrap()?;\n\n    let mut received_log = false;\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in tor.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    received_log = true;\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n    assert!(\n        received_log,\n        \"should have received a log line from tor provider\"\n    );\n\n    Ok(())\n}\n\npub(crate) fn onion_service_test(mut tor: Box\u003cdyn TorProvider\u003e) -\u003e anyhow::Result\u003c()\u003e {\n    tor.bootstrap()?;\n\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in tor.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // vanilla V3 onion service\n    {\n        // create an onion service for this test\n        let private_key = Ed25519PrivateKey::generate();\n\n        println!(\"Starting and listening to onion service\");\n        const VIRT_PORT: u16 = 42069u16;\n        let listener = tor.listener(\u0026private_key, VIRT_PORT, None)?;\n\n        let mut onion_published = false;\n        while !onion_published {\n            for event in tor.update()?.iter() {\n                match event {\n                    TorEvent::LogReceived { line } =\u003e {\n                        println!(\"--- {}\", line);\n                    }\n                    TorEvent::OnionServicePublished { service_id } =\u003e {\n                        let expected_service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n                        if expected_service_id == *service_id {\n                            println!(\"Onion Service {} published\", service_id.to_string());\n                            onion_published = true;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        const MESSAGE: \u0026str = \"Hello World!\";\n\n        {\n            let service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n\n            println!(\"Connecting to onion service\");\n            let mut client = tor.connect(\u0026service_id, VIRT_PORT, None)?;\n            println!(\"Client writing message: '{}'\", MESSAGE);\n            client.write_all(MESSAGE.as_bytes())?;\n            client.flush()?;\n            println!(\"End of client scope\");\n        }\n\n        if let Some(mut server) = listener.accept()? {\n            println!(\"Server reading message\");\n            let mut buffer = Vec::new();\n            server.read_to_end(\u0026mut buffer)?;\n            let msg = String::from_utf8(buffer)?;\n\n            assert!(MESSAGE == msg);\n            println!(\"Message received: '{}'\", msg);\n        } else {\n            panic!(\"no listener\");\n        }\n    }\n\n    // authenticated onion service\n    {\n        // create an onion service for this test\n        let private_key = Ed25519PrivateKey::generate();\n\n        let private_auth_key = X25519PrivateKey::generate();\n        let public_auth_key = X25519PublicKey::from_private_key(\u0026private_auth_key);\n\n        println!(\"Starting and listening to authenticated onion service\");\n        const VIRT_PORT: u16 = 42069u16;\n        let listener = tor.listener(\u0026private_key, VIRT_PORT, Some(\u0026[public_auth_key]))?;\n\n        let mut onion_published = false;\n        while !onion_published {\n            for event in tor.update()?.iter() {\n                match event {\n                    TorEvent::LogReceived { line } =\u003e {\n                        println!(\"--- {}\", line);\n                    }\n                    TorEvent::OnionServicePublished { service_id } =\u003e {\n                        let expected_service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n                        if expected_service_id == *service_id {\n                            println!(\n                                \"Authenticated Onion Service {} published\",\n                                service_id.to_string()\n                            );\n                            onion_published = true;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        const MESSAGE: \u0026str = \"Hello World!\";\n\n        {\n            let service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n\n            println!(\"Connecting to onion service (should fail)\");\n            assert!(\n                tor.connect(\u0026service_id, VIRT_PORT, None).is_err(),\n                \"should not able to connect to an authenticated onion service without auth key\"\n            );\n\n            println!(\"Add auth key for onion service\");\n            tor.add_client_auth(\u0026service_id, \u0026private_auth_key)?;\n\n            println!(\"Connecting to onion service with authentication\");\n            let mut client = tor.connect(\u0026service_id, VIRT_PORT, None)?;\n\n            println!(\"Client writing message: '{}'\", MESSAGE);\n            client.write_all(MESSAGE.as_bytes())?;\n            client.flush()?;\n            println!(\"End of client scope\");\n\n            println!(\"Remove auth key for onion service\");\n            tor.remove_client_auth(\u0026service_id)?;\n        }\n\n        if let Some(mut server) = listener.accept()? {\n            println!(\"Server reading message\");\n            let mut buffer = Vec::new();\n            server.read_to_end(\u0026mut buffer)?;\n            let msg = String::from_utf8(buffer)?;\n\n            assert!(MESSAGE == msg);\n            println!(\"Message received: '{}'\", msg);\n        } else {\n            panic!(\"no listener\");\n        }\n    }\n    Ok(())\n}\n\n#[test]\nfn test_mock_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n    bootstrap_test(Box::new(MockTorClient::new()))\n}\n\n#[test]\nfn test_mock_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    onion_service_test(Box::new(MockTorClient::new()))\n}\n\n#[test]\n#[serial]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_legacy_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_bootstrap\");\n\n    bootstrap_test(Box::new(LegacyTorClient::new(\u0026tor_path, \u0026data_path)?))\n}\n\n#[test]\n#[serial]\n#[cfg(not(feature = \"offline-test\"))]\nfn test_legacy_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_onion_service\");\n\n    onion_service_test(Box::new(LegacyTorClient::new(\u0026tor_path, \u0026data_path)?))\n}\n","traces":[{"line":13,"address":[1115688,1114176,1115847],"length":1,"stats":{"Line":1},"fn_name":"bootstrap_test"},{"line":14,"address":[1115834,1114287,1114183,1114347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[1114329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1114337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[1114345,1114412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1114489,1114422,1115705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1114926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1115452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1115592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1115565,1115103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[1115584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1115138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1115150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1115607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[1115728,1115782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1114454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1115755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1117514,1115872,1127793],"length":1,"stats":{"Line":1},"fn_name":"onion_service_test"},{"line":50,"address":[1115910,1127780,1116030,1116082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1116072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1116147,1116080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[1116227,1117531,1116157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[1116673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1116742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1117412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1117385,1116868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[1117404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1116906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1117433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1116189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1117557,1117628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[1117836,1127762,1117647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1117826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1117901,1117834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[1118033,1117911,1119099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[1118479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1118525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1118688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1118626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1118645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1119086,1118785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[1118823,1118923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1119078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1117943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1119129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1127719,1119175,1119637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1119762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1127701,1119865,1120003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1127663,1119976,1120143,1120052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[1120184,1120116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1120222,1127562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1120566,1120667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[1120686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1120705,1120906,1120789,1127319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[1120947,1127291,1121102,1120843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[1121073,1121234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[1121369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1127448,1120593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1121676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1121695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1121758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1121826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1121872,1122109,1127251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[1122099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1122107,1122174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[1123372,1122184,1122306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[1122752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1122798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1122961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1122899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1122918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1123359,1123058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[1123196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1123096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1123351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1122216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1123402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[1123551,1123604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[1123590,1123448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[1123682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1123861,1127211,1123728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1123926,1123834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[1127190,1124401,1123945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1124517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[1124743,1127175,1124620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1124786,1124871,1127160,1124719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[1124909,1124844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[1124928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1125091,1124974,1115894,1127125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1125153,1126967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1125494,1125595],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[1125614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1125717,1126708,1125834,1125633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[1126683,1126024,1125872,1125771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[1125998,1126150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[1126270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1126856,1125521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1126637],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":89,"coverable":98}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>