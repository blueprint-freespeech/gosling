<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","build.rs"],"content":"extern crate cbindgen;\nextern crate regex;\nextern crate serde;\nextern crate serde_json;\n\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::PathBuf;\n\nuse regex::Regex;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ConfigFlag {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    enabled: bool,\n}\n\n#[derive(Serialize)]\nstruct Constant {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    value: usize,\n}\n\n#[derive(Serialize)]\nstruct Alias {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    typename: String,\n}\n\n#[derive(Serialize)]\nstruct Param {\n    name: String,\n    typename: String,\n}\n\n#[derive(Serialize)]\nstruct Function {\n    comments: Vec\u003cString\u003e,\n    name: String,\n    return_param: String,\n    input_params: Vec\u003cParam\u003e,\n}\n\n#[derive(Serialize)]\nstruct Data {\n    config_flags: Vec\u003cConfigFlag\u003e,\n    constants: Vec\u003cConstant\u003e,\n    aliases: Vec\u003cAlias\u003e,\n    callbacks: Vec\u003cFunction\u003e,\n    functions: Vec\u003cFunction\u003e,\n}\n\nfn preprocess_header(source: \u0026str) -\u003e String {\n    #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n    let platform_pattern = Regex::new(r\"(?m)#if \\(defined\\(GOSLING_PLATFORM_LINUX\\) \\|\\| defined\\(GOSLING_PLATFORM_MACOS\\)\\)([^#].*\\n)+#endif\").unwrap();\n\n    #[cfg(not(target_os = \"windows\"))]\n    let platform_pattern =\n        Regex::new(r\"(?m)#if defined\\(GOSLING_PLATFORM_WINDOWS\\)([^#].*\\n)+#endif\").unwrap();\n\n    let source = platform_pattern.replace_all(source, \"\").to_string();\n\n    #[cfg(not(feature = \"mock-tor-provider\"))]\n    let source = {\n        let feature_pattern =\n            Regex::new(r\"(?m)#if defined\\(GOSLING_HAVE_MOCK_TOR_PROVIDER\\)([^#].*\\n)+#endif\")\n                .unwrap();\n        feature_pattern.replace_all(source.as_str(), \"\").to_string()\n    };\n    #[cfg(not(feature = \"legacy-tor-provider\"))]\n    let source = {\n        let feature_pattern =\n            Regex::new(r\"(?m)#if defined\\(GOSLING_HAVE_LEGACY_TOR_PROVIDER\\)([^#].*\\n)+#endif\")\n                .unwrap();\n        feature_pattern.replace_all(source.as_str(), \"\").to_string()\n    };\n\n    source\n}\n\nfn parse_param(params_raw: \u0026str) -\u003e Vec\u003cParam\u003e {\n    // function param\n    let param_pattern = Regex::new(r\"(?m)(?P\u003ctype\u003e(\\w+ \\**)+)(?P\u003cname\u003e\\w+)\").unwrap();\n    // pattern for our gosling structs\n    let struct_gosling_pattern = Regex::new(r\"(?m)struct (?P\u003cname\u003egosling_[\\w]+) \").unwrap();\n\n    let mut params: Vec\u003cParam\u003e = Default::default();\n    for param in param_pattern.captures_iter(params_raw) {\n        let t = \u0026param[\"type\"];\n        let t = match struct_gosling_pattern.captures(t) {\n            Some(cap) =\u003e struct_gosling_pattern.replace(t, \u0026cap[\"name\"]).to_string(),\n            None =\u003e t.to_string(),\n        };\n        let t = t.replace(\" *\", \"*\");\n        let n = \u0026param[\"name\"];\n\n        params.push(Param {\n            name: n.to_string(),\n            typename: t.trim().to_string(),\n        });\n    }\n    params\n}\n\nfn parse_header(source: \u0026str) -\u003e Data {\n    // all of the lines we cre about have this general form of muliple // style comments,\n    // followed by a single source line we care about\n    let commented_source_pattern =\n        Regex::new(r\"(?m)(?\u003ccomments\u003e(?:\\/\\/.*\\n)+)(?\u003csource\u003e.+)\").unwrap();\n    let comment_pattern = Regex::new(r\"(?m)^\\/\\/[ ]?\").unwrap();\n\n    // constant pattern\n    let constant_pattern = Regex::new(r\"^#define (?P\u003cname\u003e[A-Z0-9_]+) (?P\u003cvalue\u003e[0-9]+)$\").unwrap();\n    // primitive types\n    let typedef_pattern =\n        Regex::new(r\"^typedef (?P\u003ctype\u003e[\\w \\*]+) (?P\u003cname\u003egosling_[\\w]+);$\").unwrap();\n    // callback types\n    let callback_pattern = Regex::new(\n        r\"^typedef (?P\u003creturn\u003e[\\w \\*]+) \\(\\*(?P\u003cname\u003egosling_[\\w]+_t)\\)\\((?P\u003cparams\u003e[\\w ,\\*]*)\\);$\",\n    )\n    .unwrap();\n    // function declaration\n    let function_pattern = Regex::new(\n        r\"^(?P\u003creturn\u003e[\\w \\*]+( | \\*))(?P\u003cname\u003egosling_[\\w]+)\\((?P\u003cparams\u003e[\\w ,\\*]*)\\);$\",\n    )\n    .unwrap();\n\n    let mut config_flags: Vec\u003cConfigFlag\u003e = Default::default();\n    let mut constants: Vec\u003cConstant\u003e = Default::default();\n    let mut aliases: Vec\u003cAlias\u003e = Default::default();\n    let mut callbacks: Vec\u003cFunction\u003e = Default::default();\n    let mut functions: Vec\u003cFunction\u003e = Default::default();\n\n    config_flags.push(ConfigFlag {\n        comments: vec![\"Defined if cgosling is built with mock tor-provider support\".to_string()],\n        name: \"GOSLING_HAVE_MOCK_TOR_PROVIDER\".to_string(),\n        enabled: cfg!(feature = \"mock-tor-provider\"),\n    });\n    config_flags.push(ConfigFlag {\n        comments: vec![\"Defined if cgosling is built with legacy tor-provider support\".to_string()],\n        name: \"GOSLING_HAVE_LEGACY_TOR_PROVIDER\".to_string(),\n        enabled: cfg!(feature = \"legacy-tor-provider\"),\n    });\n\n    for commmented_source in commented_source_pattern.captures_iter(source) {\n        let comments = \u0026commmented_source[\"comments\"];\n        let comments = comment_pattern.replace_all(comments, \"\");\n        let comments = comments.trim();\n        let comments = comments.split('\\n').map(|s| s.to_string()).collect();\n\n        let source = \u0026commmented_source[\"source\"];\n\n        // try parse constant\n        if let Some(constant) = constant_pattern.captures(source) {\n            let name = constant[\"name\"].to_lowercase();\n            let value = constant[\"value\"].parse::\u003cusize\u003e().unwrap();\n            constants.push(Constant {\n                name,\n                value,\n                comments,\n            });\n        // try parse alias\n        } else if let Some(alias) = typedef_pattern.captures(source) {\n            let t = \u0026alias[\"type\"];\n            let n = \u0026alias[\"name\"];\n\n            if t == format!(\"struct {}\", n) {\n                aliases.push(Alias {\n                    name: n.to_string(),\n                    typename: \"uintptr_t\".to_string(),\n                    comments,\n                });\n            } else {\n                aliases.push(Alias {\n                    name: n.to_string(),\n                    typename: t.trim().to_string(),\n                    comments,\n                });\n            }\n        // try parse callback declaration\n        } else if let Some(callback) = callback_pattern.captures(source) {\n            let r = \u0026callback[\"return\"];\n            let n = \u0026callback[\"name\"];\n            let p = \u0026callback[\"params\"];\n\n            // move the pointer char next to the type\n            let r = r.trim().replace(\" *\", \"*\");\n\n            let params = parse_param(p);\n            callbacks.push(Function {\n                name: n.to_string(),\n                return_param: r,\n                input_params: params,\n                comments,\n            });\n        // try parse function declaration\n        } else if let Some(function) = function_pattern.captures(source) {\n            let r = \u0026function[\"return\"];\n            let n = \u0026function[\"name\"];\n            let p = \u0026function[\"params\"];\n\n            // move the pointer char next to the type\n            let r = r.trim().replace(\" *\", \"*\");\n\n            let params = parse_param(p);\n            functions.push(Function {\n                name: n.to_string(),\n                return_param: r,\n                input_params: params,\n                comments,\n            });\n        }\n    }\n\n    Data {\n        config_flags,\n        constants,\n        aliases,\n        callbacks,\n        functions,\n    }\n}\n\nfn main() {\n    if cfg!(not(feature = \"impl-lib\")) {\n        // set by cargo\n        let crate_dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n        // set by cargo\n        let profile = match std::env::var(\"PROFILE\") {\n            Ok(target) =\u003e target,\n            Err(_) =\u003e panic!(\"PROFILE not set\"),\n        };\n        // set by cmake\n        let target_dir = match std::env::var(\"CARGO_TARGET_DIR\") {\n            Ok(target) =\u003e PathBuf::from(target).join(profile),\n            Err(_) =\u003e panic!(\"CARGO_TARGET_DIR not set\"),\n        };\n\n        let header_file_path = target_dir.join(\"cgosling.h\");\n        println!(\"cargo:rerun-if-changed={}\", header_file_path.display());\n\n        // generate libgosling.h C header\n        match cbindgen::generate(\u0026crate_dir) {\n            Ok(bindings) =\u003e bindings.write_to_file(header_file_path.clone().into_os_string()),\n            Err(cbindgen::Error::ParseSyntaxError { .. }) =\u003e return, // ignore in favor of cargo's syntax check\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        };\n\n        // pre-process and re-write header\n        let source = std::fs::read_to_string(header_file_path.clone()).unwrap();\n        let source = preprocess_header(\u0026source);\n        std::fs::write(header_file_path, source.clone()).unwrap();\n\n        // convert generated header to json IDL\n        let idl = parse_header(source.as_str());\n\n        // and write json IDL to disk\n        let json_file_path = target_dir.join(\"cgosling.json\");\n        println!(\"cargo:rerun-if-changed={}\", json_file_path.display());\n        let mut json_file = match File::create(json_file_path) {\n            Ok(file) =\u003e file,\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        };\n        writeln!(json_file, \"{}\", serde_json::to_string_pretty(\u0026idl).unwrap()).unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","fuzz","fuzz_targets","fuzz_cgosling.rs"],"content":"#![no_main]\n\nuse std::ffi::{c_char, c_int};\nuse std::ptr;\n\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nuse cgosling::callbacks::*;\nuse cgosling::context::*;\nuse cgosling::crypto::*;\nuse cgosling::error::*;\nuse cgosling::ffi::*;\nuse cgosling::tor_provider::*;\nuse cgosling::utils::*;\n\n#[derive(Arbitrary, Debug)]\nenum Handle {\n    Null,\n    Valid(usize),\n    Invalid(usize),\n}\n\n#[derive(Arbitrary, Debug)]\nenum PHandle {\n    Null,\n    Valid,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Callback {\n    Null,\n    Valid,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Buffer\u003cT\u003e {\n    Null,\n    Valid(Vec\u003cT\u003e),\n}\n\n#[derive(Arbitrary, Debug)]\nenum Primitive\u003cT\u003e {\n    Valid(T),\n    Invalid(T),\n}\n\n#[derive(Arbitrary, Debug)]\nenum Function {\n    ErrorGetMessage{\n        error: Handle,\n    },\n    ErrorClone{\n        error_copy: PHandle,\n        orig_error: Handle,\n        out_error: PHandle,\n    },\n    ErrorFree{\n        error: Handle,\n    },\n    Ed25519PrivateKeyFree{\n        private_key: Handle,\n    },\n    X25519PrivateKeyFree{\n        private_key: Handle,\n    },\n    X25519PublicKeyFree{\n        public_key: Handle,\n    },\n    V3OnionServiceIdFree{\n        service_id: Handle,\n    },\n    IpAddressFree{\n        ip_address: Handle,\n    },\n    TargetAddressFree{\n        target_address: Handle,\n    },\n    ContextFree{\n        context: Handle,\n    },\n    TorProviderFree{\n        tor_provider: Handle,\n    },\n    LibraryInit{\n        out_library: PHandle,\n        out_error: PHandle,\n    },\n    LibraryFree{\n        library: Handle,\n    },\n    // Ed25519 Priavate Key Functions\n    Ed25519PrivateKeyGenerate{\n        out_private_key: PHandle,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyClone{\n        out_private_key: PHandle,\n        private_key: Handle,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyFromKeyblob{\n        out_private_key: PHandle,\n        key_blob: Buffer\u003cc_char\u003e,\n        key_blob_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    Ed25519PrivateKeyToKeyblob{\n        private_key: Handle,\n        out_key_blob: Buffer\u003cc_char\u003e,\n        key_blob_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // X25519 Private Key Functions\n    X25519PrivateKeyClone{\n        out_private_key: PHandle,\n        private_key: Handle,\n        out_error: PHandle,\n    },\n    X25519PrivateKeyFromBase64{\n        out_private_key: PHandle,\n        base64: Buffer\u003cc_char\u003e,\n        base64_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    X25519PrivateKeyToBase64{\n        private_key: Handle,\n        out_base64: Buffer\u003cc_char\u003e,\n        base64_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // X25519 Public Key Functions\n    X25519PublicKeyClone{\n        out_public_key: PHandle,\n        public_key: Handle,\n        out_error: PHandle,\n    },\n    X25519PublicKeyFromBase32{\n        out_public_key: PHandle,\n        base32: Buffer\u003cc_char\u003e,\n        base32_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    X25519PublicKeyToBase32{\n        public_key: Handle,\n        out_base32: Buffer\u003cc_char\u003e,\n        base32_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // V3 Onion Service Id Functions\n    V3OnionServiceIdClone{\n        out_service_id: PHandle,\n        service_id: Handle,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdFromString{\n        out_service_id: PHandle,\n        service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdFromEd25519PrivateKey{\n        out_service_id: PHandle,\n        ed25519_private_key: Handle,\n        out_error: PHandle,\n    },\n    V3OnionServiceIdToString{\n        service_id: Handle,\n        out_service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_size: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    StringIsValidV3OnionServiceId{\n        service_id_string: Buffer\u003cc_char\u003e,\n        service_id_string_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // TorProvider Functions\n    TorProviderConfigNewMockClientConfig{\n        out_tor_provider_config: PHandle,\n        out_error: PHandle,\n    },\n    TorProviderFromTorProviderConfig{\n        out_tor_provider: PHandle,\n        tor_provider_config: Handle,\n        out_error: PHandle,\n    },\n    // Context Functions\n    ContextInit{\n        out_context: PHandle,\n        tor_provider: Handle,\n        identity_port: u16,\n        endpoint_port: u16,\n        identity_private_key: Handle,\n        out_error: PHandle,\n    },\n    ContextBootstrapTor{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStartIdentityServer{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStopIdentityServer{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextStartEndpointServer{\n        context: Handle,\n        endpoint_private_key: Handle,\n        endpoint_name: Buffer\u003cc_char\u003e,\n        endpoint_name_length: Primitive\u003cusize\u003e,\n        client_identity: Handle,\n        client_auth_public_key: Handle,\n        out_error: PHandle,\n    },\n    ContextStopEndpointServer{\n        context: Handle,\n        endpoint_private_key: Handle,\n        out_error: PHandle,\n    },\n    ContextBeginIdentityHandshake{\n        context: Handle,\n        identity_service_id: Handle,\n        endpoint_name: Buffer\u003cc_char\u003e,\n        endpoint_name_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextAbortIdentityClientHandshake{\n        context: Handle,\n        handshake_handle: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextBeginEndpointHandshake{\n        context: Handle,\n        endpoint_service_id: Handle,\n        client_auth_private_key: Handle,\n        channel_name: Buffer\u003cc_char\u003e,\n        channel_name_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    ContextAbortEndpointClientHandshake{\n        context: Handle,\n        handshake_handle: Primitive\u003cusize\u003e,\n        out_error: PHandle\n    },\n    ContextPollEvents{\n        context: Handle,\n        out_error: PHandle,\n    },\n    // Callback Setters\n    ContextSetTorBootstrapStatusReceivedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetTorBootstrapCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetTorLogReceivedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientChallengeResponseSizeCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientBuildChallengeResponseCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityClientHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerPublishedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeStartedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerClientAllowedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerEndpointSupportedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerChallengeSizeCallack{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerBuildChallengeCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerVerifyChallengeResponseCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeRejectedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetIdentityServerHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointClientHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointClientHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerPublishedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeStartedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerChannelSupportedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeCompletedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeRejectedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    ContextSetEndpointServerHandshakeFailedCallback{\n        context: Handle,\n        callback: Callback,\n        out_error: PHandle,\n    },\n    // Context Utility Functions\n    ContextGenerateCircuitToken{\n        context: Handle,\n        out_error: PHandle,\n    },\n    ContextReleaseCircuitToken{\n        context: Handle,\n        circuit_token: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n    // IpAddress Functions\n    IpAddressClone{\n        out_ip_address: PHandle,\n        ip_address: Handle,\n        out_error: PHandle,\n    },\n    IpAddressFromIpv4{\n        out_ip_address: PHandle,\n        a: u8,\n        b: u8,\n        c: u8,\n        d: u8,\n        out_error: PHandle,\n    },\n    IpAddressFromIpv6{\n        out_ip_address: PHandle,\n        a: u16,\n        b: u16,\n        c: u16,\n        d: u16,\n        e: u16,\n        f: u16,\n        g: u16,\n        h: u16,\n        out_error: PHandle,\n    },\n    // TargetAddress Functions\n    TargetAddressClone{\n        out_target_address: PHandle,\n        target_address: Handle,\n        out_error: PHandle,\n    },\n    TargetAddressFromIpAddress{\n        out_target_address: PHandle,\n        ip_address: Handle,\n        port: u16,\n        out_error: PHandle,\n    },\n    TargetAddressFromDomain{\n        out_target_address: PHandle,\n        domain: Buffer\u003cc_char\u003e,\n        domain_length: Primitive\u003cusize\u003e,\n        port: u16,\n        out_error: PHandle,\n    },\n    TargetAddressFromV3OnionServiceId{\n        out_target_address: PHandle,\n        service_id: Handle,\n        port: u16,\n        out_error: PHandle,\n    },\n    TargetAddressFromString{\n        out_target_address: PHandle,\n        target_address: Buffer\u003cc_char\u003e,\n        target_address_length: Primitive\u003cusize\u003e,\n        out_error: PHandle,\n    },\n}\n\nfn handle_as_pointer\u003cT\u003e(value: Handle, handles: \u0026Vec\u003c*mut T\u003e) -\u003e *mut T {\n    let result: *mut T = match value {\n        Handle::Null =\u003e ptr::null_mut(),\n        Handle::Valid(value) =\u003e if !handles.is_empty() {\n            let index = value % handles.len();\n            handles[index]\n        } else {\n            ptr::null_mut()\n        },\n        Handle::Invalid(value) =\u003e if !handles.contains(\u0026(value as *mut T)) {\n            value as *mut T\n        } else {\n            ptr::null_mut()\n        }\n    };\n    result\n}\n\nfn handle_to_pointer\u003cT\u003e(value: Handle, handles: \u0026mut Vec\u003c*mut T\u003e) -\u003e *mut T {\n    let result: *mut T = match value {\n        Handle::Null =\u003e ptr::null_mut(),\n        Handle::Valid(value) =\u003e if !handles.is_empty() {\n            let index = value % handles.len();\n            handles.remove(index) as *mut T\n        } else {\n            ptr::null_mut()\n        },\n        Handle::Invalid(value) =\u003e if !handles.contains(\u0026(value as *mut T)) {\n            value as *mut T\n        } else {\n            ptr::null_mut()\n        },\n    };\n    result\n}\n\nfn phandle_to_out_pointer\u003cT\u003e(value: PHandle, out_pointer: *mut *mut T) -\u003e *mut *mut T {\n    match value {\n        PHandle::Null =\u003e ptr::null_mut(),\n        PHandle::Valid =\u003e out_pointer,\n    }\n}\n\nfn primitive_to_value\u003cT: Default + std::cmp::PartialEq\u003e(value: Primitive\u003cT\u003e, values: \u0026mut Vec\u003cT\u003e) -\u003e T where usize: From\u003cT\u003e{\n    match value {\n        Primitive::Valid(value) =\u003e if !values.is_empty() {\n            let index: usize = value.into();\n            let index = index % values.len();\n            values.remove(index)\n        } else {\n            Default::default()\n        },\n        Primitive::Invalid(value) =\u003e if !values.contains(\u0026value) {\n            value\n        } else {\n            Default::default()\n        }\n    }\n}\n\nfn buffer_to_size\u003cT\u003e(buffer: \u0026Buffer\u003cT\u003e, buffer_size: \u0026Primitive\u003cusize\u003e) -\u003e usize {\n    let size: usize = match (buffer, buffer_size) {\n        (Buffer::Null, Primitive::Valid(_)) =\u003e 0usize,\n        (Buffer::Null, Primitive::Invalid(value)) =\u003e *value,\n        (Buffer::Valid(buffer), Primitive::Valid(_)) =\u003e buffer.len(),\n        (Buffer::Valid(buffer), Primitive::Invalid(value)) =\u003e std::cmp::min(*value, buffer.len()),\n    };\n    size\n}\n\nfn buffer_as_pointer\u003cT\u003e(buffer: \u0026Buffer\u003cT\u003e) -\u003e *const T {\n    let pointer: *const T = match buffer {\n        Buffer::Null =\u003e ptr::null(),\n        Buffer::Valid(value) =\u003e value.as_ptr(),\n    };\n    pointer\n}\n\nfn buffer_as_mut_pointer\u003cT\u003e(buffer: \u0026mut Buffer\u003cT\u003e) -\u003e *mut T {\n    let pointer: *mut T = match buffer {\n        Buffer::Null =\u003e ptr::null_mut(),\n        Buffer::Valid(value) =\u003e value.as_mut_ptr(),\n    };\n    pointer\n}\n\nmacro_rules! impl_set_callback {\n    ($context:ident, $callback:ident, $out_error:ident, $contexts:ident, $errors:ident,$setter:ident, $func:ident) =\u003e {\n        let context = handle_as_pointer($context, \u0026$contexts);\n        let mut error: *mut GoslingError = ptr::null_mut();\n        let out_error = phandle_to_out_pointer($out_error, \u0026mut error);\n        match $callback {\n            Callback::Null =\u003e $setter(context, None, out_error),\n            Callback::Valid =\u003e $setter(context, Some($func), out_error),\n        }\n        if !error.is_null() {\n            $errors.push(error);\n        }\n    }\n}\n\n// no-op (or minimal op) callbacks for setters\n\nextern \"C\" fn bootstrap_status_received(_context: *mut GoslingContext, _progress: u32, _tag: *const c_char, _tag_length: usize, _summary: *const c_char, _summary_length: usize) {\n\n}\n\nextern \"C\" fn bootstrap_complete(_context: *mut GoslingContext) -\u003e () {\n\n}\n\nextern \"C\" fn tor_log_received(_context: *mut GoslingContext, _line: *const c_char, _line_length: usize) {\n\n}\n\nextern \"C\" fn identity_client_handshake_challenge_response_size(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_buffer: *const u8, _challenge_buffer_size: usize) -\u003e usize {\n    return 0;\n}\n\nextern \"C\" fn identity_client_handshake_build_challenge_response(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_buffer: *const u8, _challenge_buffer_size: usize, _out_challenge_response_buffer: *mut u8, _challenge_response_buffer_size: usize) {\n\n}\n\nextern \"C\" fn identity_client_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _identity_service_id: *const GoslingV3OnionServiceId, _endpoint_service_id: *const GoslingV3OnionServiceId, _endpoint_name: *const c_char, _endpoint_name_length: usize, _client_auth_private_key: *const GoslingX25519PrivateKey) {\n\n}\n\nextern \"C\" fn identity_client_handshake_failed(_context: *mut GoslingContext, _handshake_handle: usize, _error: *const GoslingError) {\n\n}\n\nextern \"C\" fn identity_server_published(_context: *mut GoslingContext) {\n\n}\n\nextern \"C\" fn identity_server_handshake_started(_context: *mut GoslingContext, _handshake_handle: usize) {\n\n}\n\nextern \"C\" fn identity_server_handshake_client_allowed(_context: *mut GoslingContext, _handshake_handle: usize, _client_service_id: *const GoslingV3OnionServiceId) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_endpoint_supported(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_name: *const c_char, _endpoint_name_length: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_handshake_challenge_size(_context: *mut GoslingContext, _handshake_handle: usize) -\u003e usize {\n    0usize\n}\n\nextern \"C\" fn identity_server_handshake_build_challenge(_context: *mut GoslingContext, _handshake_handle: usize, _out_challenge_buffer: *mut u8, _challenge_buffer_size: usize) {\n\n}\n\nextern \"C\" fn identity_server_handshake_verify_challenge_response(_context: *mut GoslingContext, _handshake_handle: usize, _challenge_response_buffer: *const u8, _challenge_response_buffer_size: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn identity_server_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_private_key: *const GoslingEd25519PrivateKey, _endpoint_name: *const c_char, _endpoint_name_length: usize, _client_service_id: *const GoslingV3OnionServiceId, _client_auth_public_key: *const GoslingX25519PublicKey) {\n\n}\n\nextern \"C\" fn identity_server_handshake_rejected(_context: *mut GoslingContext, _handshake_handle: usize, _client_allowed: bool, _client_requested_endpoint_valid: bool, _client_proof_signature_valid: bool, _client_auth_signature_valid: bool, _challenge_response_valid: bool) {\n\n}\n\nextern \"C\" fn identity_server_handshake_failed(_cntext: *mut GoslingContext, _handshake_handle: usize, _error: *const GoslingError) {\n\n}\n\nextern \"C\" fn endpoint_client_handhsake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize, _stream: c_int) {\n\n}\n\nextern \"C\" fn endpoint_client_handshake_failed(_context: *mut GoslingContext,\n    _handshake_handle: usize, _error: *const GoslingError) {\n\n}\n\nextern \"C\" fn endpoint_server_published(_context: *mut GoslingContext, _endpoint_service_id: *const GoslingV3OnionServiceId, _endpoint_name: *const c_char, _endpoint_name_length: usize) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_started(_context: *mut GoslingContext, _handshake_handle: usize) {\n\n}\n\nextern \"C\" fn endpoint_server_channel_supported(_context: *mut GoslingContext,\n_handshake_handle: usize, _client_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize) -\u003e bool {\n    true\n}\n\nextern \"C\" fn endpoint_server_handshake_completed(_context: *mut GoslingContext, _handshake_handle: usize, _endpoint_service_id: *const GoslingV3OnionServiceId, _client_service_id: *const GoslingV3OnionServiceId, _channel_name: *const c_char, _channel_name_length: usize, _stream: c_int) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_rejected(_context: *mut GoslingContext, _handshake_handle: usize, _client_allowed: bool, _client_requested_channel_valid: bool, _client_proof_signature_valid: bool) {\n\n}\n\nextern \"C\" fn endpoint_server_handshake_failed(_context: *mut GoslingContext,\n    _handshake_handle: usize, _error: *const GoslingError) {\n\n}\n\n#[derive(Arbitrary, Debug)]\nstruct Data {\n    functions: Vec\u003cFunction\u003e,\n}\n\nfuzz_target!(|data: Data| {\n    let mut libraries: Vec\u003c*mut GoslingLibrary\u003e = Default::default();\n    let mut errors: Vec\u003c*mut GoslingError\u003e = Default::default();\n    let mut contexts: Vec\u003c*mut GoslingContext\u003e = Default::default();\n    let mut ed25519_private_keys: Vec\u003c*mut GoslingEd25519PrivateKey\u003e = Default::default();\n    let mut v3_onion_service_ids: Vec\u003c*mut GoslingV3OnionServiceId\u003e = Default::default();\n    let mut x25519_private_keys: Vec\u003c*mut GoslingX25519PrivateKey\u003e = Default::default();\n    let mut x25519_public_keys : Vec\u003c*mut GoslingX25519PublicKey\u003e = Default::default();\n    let mut tor_provider_configs: Vec\u003c*mut GoslingTorProviderConfig\u003e = Default::default();\n    let mut tor_providers: Vec\u003c*mut GoslingTorProvider\u003e = Default::default();\n    let mut identity_handshakes: Vec\u003cusize\u003e = Default::default();\n    let mut endpoint_handshakes: Vec\u003cusize\u003e = Default::default();\n    let mut ip_addresses: Vec\u003c*mut GoslingIpAddress\u003e = Default::default();\n    let mut target_addresses: Vec\u003c*mut GoslingTargetAddress\u003e = Default::default();\n    let mut circuit_tokens: Vec\u003cGoslingCircuitToken\u003e = Default::default();\n\n    for function in data.functions {\n        match function {\n            Function::ErrorGetMessage{error} =\u003e {\n                let error = handle_as_pointer(error, \u0026errors);\n                gosling_error_get_message(error);\n            },\n            Function::ErrorClone{error_copy, orig_error, out_error} =\u003e {\n                let mut dest: *mut GoslingError = ptr::null_mut();\n                let error_copy = phandle_to_out_pointer(error_copy, \u0026mut dest);\n                let orig_error = handle_as_pointer(orig_error, \u0026errors);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_error_clone(error_copy, orig_error, out_error) };\n                if !dest.is_null() {\n                    errors.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ErrorFree{error} =\u003e {\n                let error = handle_to_pointer(error, \u0026mut errors);\n                gosling_error_free(error);\n            },\n            Function::Ed25519PrivateKeyFree{private_key} =\u003e {\n                let private_key = handle_to_pointer(private_key, \u0026mut ed25519_private_keys);\n                gosling_ed25519_private_key_free(private_key);\n            },\n            Function::X25519PrivateKeyFree{private_key} =\u003e {\n                let private_key = handle_to_pointer(private_key, \u0026mut x25519_private_keys);\n                gosling_x25519_private_key_free(private_key);\n            },\n            Function::X25519PublicKeyFree{public_key} =\u003e {\n                let public_key = handle_to_pointer(public_key, \u0026mut x25519_public_keys);\n                gosling_x25519_public_key_free(public_key);\n            },\n            Function::V3OnionServiceIdFree{service_id} =\u003e {\n               let service_id = handle_to_pointer(service_id, \u0026mut v3_onion_service_ids);\n               gosling_v3_onion_service_id_free(service_id);\n            },\n            Function::ContextFree{context} =\u003e {\n                let context = handle_to_pointer(context, \u0026mut contexts);\n                gosling_context_free(context);\n            },\n            Function::TorProviderFree{tor_provider} =\u003e {\n                let tor_provider = handle_to_pointer(tor_provider, \u0026mut tor_providers);\n                gosling_tor_provider_free(tor_provider);\n            },\n            Function::LibraryInit{out_library, out_error} =\u003e {\n                let mut library: *mut GoslingLibrary = ptr::null_mut();\n                let out_library = phandle_to_out_pointer(out_library, \u0026mut library);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_library_init(out_library, out_error) };\n                if !library.is_null() {\n                    libraries.push(library);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::LibraryFree{library} =\u003e {\n                let library = handle_to_pointer(library, \u0026mut libraries);\n                gosling_library_free(library);\n            },\n            Function::Ed25519PrivateKeyGenerate{out_private_key, out_error} =\u003e {\n                let mut private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_generate(out_private_key, out_error) };\n                if !private_key.is_null() {\n                    ed25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyClone{out_private_key, private_key, out_error} =\u003e {\n                let mut dest: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut dest);\n                let private_key = handle_as_pointer(private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_clone(out_private_key, private_key, out_error) };\n                if !dest.is_null() {\n                    ed25519_private_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyFromKeyblob{out_private_key, key_blob, key_blob_length, out_error} =\u003e {\n                let mut private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let key_blob_length = buffer_to_size(\u0026key_blob, \u0026key_blob_length);\n                let key_blob = buffer_as_pointer(\u0026key_blob);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_ed25519_private_key_from_keyblob(out_private_key, key_blob, key_blob_length, out_error) };\n                if !private_key.is_null() {\n                    ed25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::Ed25519PrivateKeyToKeyblob{private_key, mut out_key_blob, key_blob_size, out_error} =\u003e {\n                let private_key = handle_as_pointer(private_key, \u0026ed25519_private_keys);\n                let key_blob_size = buffer_to_size(\u0026out_key_blob, \u0026key_blob_size);\n                let out_key_blob = buffer_as_mut_pointer(\u0026mut out_key_blob);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_ed25519_private_key_to_keyblob(private_key, out_key_blob, key_blob_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyClone{out_private_key, private_key, out_error} =\u003e {\n                let mut dest: *mut GoslingX25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut dest);\n                let private_key = handle_as_pointer(private_key, \u0026x25519_private_keys);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_private_key_clone(out_private_key, private_key, out_error) };\n                if !dest.is_null() {\n                    x25519_private_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyFromBase64{out_private_key, base64, base64_length, out_error} =\u003e {\n                let mut private_key: *mut GoslingX25519PrivateKey = ptr::null_mut();\n                let out_private_key = phandle_to_out_pointer(out_private_key, \u0026mut private_key);\n                let base64_length = buffer_to_size(\u0026base64, \u0026base64_length);\n                let base64 = buffer_as_pointer(\u0026base64);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_private_key_from_base64(out_private_key, base64, base64_length, out_error) };\n                if !private_key.is_null() {\n                    x25519_private_keys.push(private_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PrivateKeyToBase64{private_key, mut out_base64, base64_size, out_error} =\u003e {\n                let private_key = handle_as_pointer(private_key, \u0026x25519_private_keys);\n                let base64_size = buffer_to_size(\u0026out_base64, \u0026base64_size);\n                let out_base64 = buffer_as_mut_pointer(\u0026mut out_base64);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_x25519_private_key_to_base64(private_key, out_base64, base64_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyClone{out_public_key, public_key, out_error} =\u003e {\n                let mut dest: *mut GoslingX25519PublicKey = ptr::null_mut();\n                let out_public_key = phandle_to_out_pointer(out_public_key, \u0026mut dest);\n                let public_key = handle_as_pointer(public_key, \u0026x25519_public_keys);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_public_key_clone(out_public_key, public_key, out_error) };\n                if !dest.is_null() {\n                    x25519_public_keys.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyFromBase32{out_public_key, base32, base32_length, out_error} =\u003e {\n                let mut public_key: *mut GoslingX25519PublicKey = ptr::null_mut();\n                let out_public_key = phandle_to_out_pointer(out_public_key, \u0026mut public_key);\n                let base32_length = buffer_to_size(\u0026base32, \u0026base32_length);\n                let base32 = buffer_as_pointer(\u0026base32);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_x25519_public_key_from_base32(out_public_key, base32, base32_length, out_error) };\n                if !out_public_key.is_null() {\n                    x25519_public_keys.push(public_key);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::X25519PublicKeyToBase32{public_key, mut out_base32, base32_size, out_error} =\u003e {\n                let public_key = handle_as_pointer(public_key, \u0026x25519_public_keys);\n                let base32_size = buffer_to_size(\u0026out_base32, \u0026base32_size);\n                let out_base32 = buffer_as_mut_pointer(\u0026mut out_base32);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_x25519_public_key_to_base32(public_key, out_base32, base32_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdClone{out_service_id, service_id, out_error} =\u003e {\n                let mut dest: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut dest);\n                let service_id = handle_as_pointer(service_id, \u0026v3_onion_service_ids);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_clone(out_service_id, service_id, out_error) };\n                if !dest.is_null() {\n                    v3_onion_service_ids.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdFromString{out_service_id, service_id_string, service_id_string_length, out_error} =\u003e {\n                let mut service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut service_id);\n                let service_id_string_length = buffer_to_size(\u0026service_id_string, \u0026service_id_string_length);\n                let service_id_string = buffer_as_pointer(\u0026service_id_string);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_from_string(out_service_id, service_id_string, service_id_string_length, out_error) };\n                if !out_service_id.is_null() {\n                    v3_onion_service_ids.push(service_id);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdFromEd25519PrivateKey{out_service_id, ed25519_private_key, out_error} =\u003e {\n                let mut service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n                let out_service_id = phandle_to_out_pointer(out_service_id, \u0026mut service_id);\n                let ed25519_private_key = handle_as_pointer(ed25519_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_v3_onion_service_id_from_ed25519_private_key(out_service_id, ed25519_private_key, out_error) };\n                if !out_service_id.is_null() {\n                    v3_onion_service_ids.push(service_id);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::V3OnionServiceIdToString{service_id, mut out_service_id_string, service_id_string_size, out_error} =\u003e {\n                let service_id = handle_as_pointer(service_id, \u0026v3_onion_service_ids);\n                let service_id_string_size = buffer_to_size(\u0026out_service_id_string, \u0026service_id_string_size);\n                let out_service_id_string = buffer_as_mut_pointer(\u0026mut out_service_id_string);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                gosling_v3_onion_service_id_to_string(service_id, out_service_id_string, service_id_string_size, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::StringIsValidV3OnionServiceId{service_id_string, service_id_string_length, out_error} =\u003e {\n                let service_id_string_length = buffer_to_size(\u0026service_id_string, \u0026service_id_string_length);\n                let service_id_string = buffer_as_pointer(\u0026service_id_string);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_string_is_valid_v3_onion_service_id(service_id_string, service_id_string_length, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            }\n            Function::TorProviderConfigNewMockClientConfig{out_tor_provider_config, out_error} =\u003e {\n                let mut tor_provider_config: *mut GoslingTorProviderConfig = ptr::null_mut();\n                let out_tor_provider_config = phandle_to_out_pointer(out_tor_provider_config, \u0026mut tor_provider_config);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_tor_provider_config_new_mock_client_config(out_tor_provider_config, out_error) };\n                if !tor_provider_config.is_null() {\n                    tor_provider_configs.push(tor_provider_config);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::TorProviderFromTorProviderConfig{out_tor_provider, tor_provider_config, out_error} =\u003e {\n                let mut tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n                let out_tor_provider = phandle_to_out_pointer(out_tor_provider, \u0026mut tor_provider);\n                let tor_provider_config = handle_as_pointer(tor_provider_config, \u0026tor_provider_configs);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_tor_provider_from_tor_provider_config(out_tor_provider, tor_provider_config, out_error) };\n                if !tor_provider.is_null() {\n                    tor_providers.push(tor_provider);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextInit{out_context, tor_provider, identity_port, endpoint_port, identity_private_key, out_error} =\u003e {\n                let mut context: *mut GoslingContext = ptr::null_mut();\n                let out_context = phandle_to_out_pointer(out_context, \u0026mut context);\n                let tor_provider = handle_as_pointer(tor_provider, \u0026tor_providers);\n                let identity_private_key = handle_as_pointer(identity_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_context_init(out_context, tor_provider, identity_port, endpoint_port, identity_private_key, out_error) };\n                if !context.is_null() {\n                    contexts.push(context);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBootstrapTor{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_bootstrap_tor(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStartIdentityServer{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_start_identity_server(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStopIdentityServer{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_stop_identity_server(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextStartEndpointServer{context, endpoint_private_key, endpoint_name, endpoint_name_length, client_identity, client_auth_public_key, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_private_key = handle_as_pointer(endpoint_private_key, \u0026ed25519_private_keys);\n                let endpoint_name_length = buffer_to_size(\u0026endpoint_name, \u0026endpoint_name_length);\n                let endpoint_name = buffer_as_pointer(\u0026endpoint_name);\n                let client_identity = handle_as_pointer(client_identity, \u0026v3_onion_service_ids);\n                let client_auth_public_key = handle_as_pointer(client_auth_public_key, \u0026x25519_public_keys);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_start_endpoint_server(context, endpoint_private_key, endpoint_name, endpoint_name_length, client_identity, client_auth_public_key, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            }\n            Function::ContextStopEndpointServer{context, endpoint_private_key, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_private_key = handle_as_pointer(endpoint_private_key, \u0026ed25519_private_keys);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_stop_endpoint_server(context, endpoint_private_key, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBeginIdentityHandshake{context, identity_service_id, endpoint_name, endpoint_name_length, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let identity_service_id = handle_as_pointer(identity_service_id, \u0026v3_onion_service_ids);\n                let endpoint_name_length = buffer_to_size(\u0026endpoint_name, \u0026endpoint_name_length);\n                let endpoint_name = buffer_as_pointer(\u0026endpoint_name);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                let handshake_handle = gosling_context_begin_identity_handshake(context, identity_service_id, endpoint_name, endpoint_name_length, out_error);\n                if handshake_handle != !0usize {\n                    identity_handshakes.push(handshake_handle);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextAbortIdentityClientHandshake{context, handshake_handle, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let handshake_handle = match handshake_handle {\n                    Primitive::Valid(value) =\u003e if !identity_handshakes.is_empty() {\n                        let index = value % identity_handshakes.len();\n                        identity_handshakes[index]\n                    } else {\n                        !0usize\n                    },\n                    Primitive::Invalid(value) =\u003e if !identity_handshakes.contains(\u0026value) {\n                        value\n                    } else {\n                        !0usize\n                    }\n                };\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_abort_identity_client_handshake(context, handshake_handle, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextBeginEndpointHandshake{context, endpoint_service_id, client_auth_private_key, channel_name, channel_name_length, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let endpoint_service_id = handle_as_pointer(endpoint_service_id, \u0026v3_onion_service_ids);\n                let client_auth_private_key = handle_as_pointer(client_auth_private_key, \u0026x25519_private_keys);\n                let channel_name_length = buffer_to_size(\u0026channel_name, \u0026channel_name_length);\n                let channel_name = buffer_as_pointer(\u0026channel_name);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                let handshake_handle = gosling_context_begin_endpoint_handshake(context, endpoint_service_id, client_auth_private_key, channel_name, channel_name_length, out_error);\n                if handshake_handle != !0usize {\n                    endpoint_handshakes.push(handshake_handle);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextAbortEndpointClientHandshake{context, handshake_handle, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let handshake_handle = match handshake_handle {\n                    Primitive::Valid(value) =\u003e if !endpoint_handshakes.is_empty() {\n                        let index = value % endpoint_handshakes.len();\n                        endpoint_handshakes[index]\n                    } else {\n                        !0usize\n                    },\n                    Primitive::Invalid(value) =\u003e if !endpoint_handshakes.contains(\u0026value) {\n                        value\n                    } else {\n                        !0usize\n                    }\n                };\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_abort_endpoint_client_handshake(context, handshake_handle, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextPollEvents{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                gosling_context_poll_events(context, out_error);\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::ContextSetTorBootstrapStatusReceivedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_bootstrap_status_received_callback, bootstrap_status_received);\n            },\n            Function::ContextSetTorBootstrapCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_bootstrap_completed_callback, bootstrap_complete);\n            },\n            Function::ContextSetTorLogReceivedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_tor_log_received_callback, tor_log_received);\n            },\n            Function::ContextSetIdentityClientChallengeResponseSizeCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_challenge_response_size_callback, identity_client_handshake_challenge_response_size);\n            },\n            Function::ContextSetIdentityClientBuildChallengeResponseCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_build_challenge_response_callback, identity_client_handshake_build_challenge_response);\n            },\n            Function::ContextSetIdentityClientHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_handshake_completed_callback, identity_client_handshake_completed);\n            },\n            Function::ContextSetIdentityClientHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_client_handshake_failed_callback, identity_client_handshake_failed);\n            },\n            Function::ContextSetIdentityServerPublishedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_published_callback, identity_server_published);\n            },\n            Function::ContextSetIdentityServerHandshakeStartedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_started_callback, identity_server_handshake_started);\n            },\n            Function::ContextSetIdentityServerClientAllowedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_client_allowed_callback, identity_server_handshake_client_allowed);\n            },\n            Function::ContextSetIdentityServerEndpointSupportedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_endpoint_supported_callback, identity_server_endpoint_supported);\n            },\n            Function::ContextSetIdentityServerChallengeSizeCallack{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_challenge_size_callback, identity_server_handshake_challenge_size);\n            },\n            Function::ContextSetIdentityServerBuildChallengeCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_build_challenge_callback, identity_server_handshake_build_challenge);\n            },\n            Function::ContextSetIdentityServerVerifyChallengeResponseCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_verify_challenge_response_callback, identity_server_handshake_verify_challenge_response);\n            },\n            Function::ContextSetIdentityServerHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_completed_callback, identity_server_handshake_completed);\n            },\n            Function::ContextSetIdentityServerHandshakeRejectedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_rejected_callback, identity_server_handshake_rejected);\n            },\n            Function::ContextSetIdentityServerHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_identity_server_handshake_failed_callback, identity_server_handshake_failed);\n            },\n            Function::ContextSetEndpointClientHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_client_handshake_completed_callback, endpoint_client_handhsake_completed);\n            },\n            Function::ContextSetEndpointClientHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_client_handshake_failed_callback, endpoint_client_handshake_failed);\n            },\n            Function::ContextSetEndpointServerPublishedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_published_callback, endpoint_server_published);\n            },\n            Function::ContextSetEndpointServerHandshakeStartedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_started_callback, endpoint_server_handshake_started);\n            },\n            Function::ContextSetEndpointServerChannelSupportedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_channel_supported_callback, endpoint_server_channel_supported);\n            },\n            Function::ContextSetEndpointServerHandshakeCompletedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_completed_callback, endpoint_server_handshake_completed);\n            },\n            Function::ContextSetEndpointServerHandshakeRejectedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_rejected_callback, endpoint_server_handshake_rejected);\n            },\n            Function::ContextSetEndpointServerHandshakeFailedCallback{context, callback, out_error} =\u003e {\n                impl_set_callback!(context, callback, out_error, contexts, errors, gosling_context_set_endpoint_server_handshake_failed_callback, endpoint_server_handshake_failed);\n            },\n            Function::ContextGenerateCircuitToken{context, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                let circuit_token = unsafe { gosling_context_generate_circuit_token(context, out_error) };\n                if !error.is_null() {\n                    errors.push(error);\n                } else {\n                    circuit_tokens.push(circuit_token);\n                }\n            },\n            Function::ContextReleaseCircuitToken{context, circuit_token, out_error} =\u003e {\n                let context = handle_as_pointer(context, \u0026contexts);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                let circuit_token = primitive_to_value(circuit_token, \u0026mut circuit_tokens);\n                unsafe { gosling_context_release_circuit_token(context, circuit_token, out_error) };\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::IpAddressFree{ip_address} =\u003e {\n                let ip_address = handle_to_pointer(ip_address, \u0026mut ip_addresses);\n                gosling_ip_address_free(ip_address);\n            },\n            Function::IpAddressClone{out_ip_address, ip_address, out_error} =\u003e {\n                let mut dest: *mut GoslingIpAddress = ptr::null_mut();\n                let out_ip_address = phandle_to_out_pointer(out_ip_address, \u0026mut dest);\n                let ip_address = handle_as_pointer(ip_address, \u0026ip_addresses);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_ip_address_clone(out_ip_address, ip_address, out_error) };\n                if !dest.is_null() {\n                    ip_addresses.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::IpAddressFromIpv4{out_ip_address, a, b, c, d, out_error} =\u003e {\n                let mut dest: *mut GoslingIpAddress = ptr::null_mut();\n                let out_ip_address = phandle_to_out_pointer(out_ip_address, \u0026mut dest);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_ip_address_from_ipv4(out_ip_address, a, b, c, d, out_error) };\n                if !dest.is_null() {\n                    ip_addresses.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::IpAddressFromIpv6{out_ip_address, a, b, c, d, e, f, g, h, out_error} =\u003e {\n                let mut dest: *mut GoslingIpAddress = ptr::null_mut();\n                let out_ip_address = phandle_to_out_pointer(out_ip_address, \u0026mut dest);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_ip_address_from_ipv6(out_ip_address, a, b, c, d, e, f, g, h, out_error) };\n                if !dest.is_null() {\n                    ip_addresses.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::TargetAddressFree{target_address} =\u003e {\n                let target_address = handle_to_pointer(target_address, \u0026mut target_addresses);\n                gosling_target_address_free(target_address);\n            },\n            Function::TargetAddressClone{out_target_address, target_address, out_error} =\u003e {\n                let mut dest: *mut GoslingTargetAddress = ptr::null_mut();\n                let out_target_address = phandle_to_out_pointer(out_target_address, \u0026mut dest);\n                let target_address = handle_as_pointer(target_address, \u0026target_addresses);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n                unsafe { gosling_target_address_clone(out_target_address, target_address, out_error) };\n                if !dest.is_null() {\n                    target_addresses.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::TargetAddressFromIpAddress{out_target_address, ip_address, port, out_error} =\u003e {\n                let mut dest: *mut GoslingTargetAddress = ptr::null_mut();\n                let out_target_address = phandle_to_out_pointer(out_target_address, \u0026mut dest);\n                let ip_address = handle_as_pointer(ip_address, \u0026ip_addresses);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_target_address_from_ip_address(out_target_address, ip_address, port, out_error) };\n                if !dest.is_null() {\n                    target_addresses.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::TargetAddressFromDomain{out_target_address, domain, domain_length, port, out_error} =\u003e {\n                let mut dest: *mut GoslingTargetAddress = ptr::null_mut();\n                let out_target_address = phandle_to_out_pointer(out_target_address, \u0026mut dest);\n                let domain_length = buffer_to_size(\u0026domain, \u0026domain_length);\n                let domain = buffer_as_pointer(\u0026domain);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_target_address_from_domain(out_target_address, domain, domain_length, port, out_error) };\n                if !dest.is_null() {\n                    target_addresses.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::TargetAddressFromV3OnionServiceId{out_target_address, service_id, port, out_error} =\u003e {\n                let mut dest: *mut GoslingTargetAddress = ptr::null_mut();\n                let out_target_address = phandle_to_out_pointer(out_target_address, \u0026mut dest);\n                let service_id = handle_as_pointer(service_id, \u0026v3_onion_service_ids);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_target_address_from_v3_onion_service_id(out_target_address, service_id, port, out_error) };\n                if !dest.is_null() {\n                    target_addresses.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n            Function::TargetAddressFromString{out_target_address, target_address, target_address_length, out_error} =\u003e {\n                let mut dest: *mut GoslingTargetAddress = ptr::null_mut();\n                let out_target_address = phandle_to_out_pointer(out_target_address, \u0026mut dest);\n                let target_address_length = buffer_to_size(\u0026target_address, \u0026target_address_length);\n                let target_address = buffer_as_pointer(\u0026target_address);\n                let mut error: *mut GoslingError = ptr::null_mut();\n                let out_error = phandle_to_out_pointer(out_error, \u0026mut error);\n\n                unsafe { gosling_target_address_from_string(out_target_address, target_address, target_address_length, out_error) };\n                if !dest.is_null() {\n                    target_addresses.push(dest);\n                }\n                if !error.is_null() {\n                    errors.push(error);\n                }\n            },\n        }\n    }\n});\n","traces":[{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","callbacks.rs"],"content":"// standard\nuse std::os::raw::c_char;\n\n// extern crates\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\n\n// internal crates\nuse crate::context::*;\nuse crate::crypto::*;\nuse crate::error::*;\nuse crate::macros::*;\n\n#[derive(Default, Clone)]\npub(crate) struct EventCallbacks {\n    // tor events\n    pub tor_bootstrap_status_received_callback: GoslingTorBootstrapStatusReceivedCallback,\n    pub tor_bootstrap_completed_callback: GoslingTorBootstrapCompletedCallback,\n    pub tor_log_received_callback: GoslingTorLogReceivedCallback,\n\n    // identity client events\n    pub identity_client_challenge_response_size_callback:\n        GoslingIdentityClientHandshakeChallengeResponseSizeCallback,\n    pub identity_client_build_challenge_response_callback:\n        GoslingIdentityClientHandshakeBuildChallengeResponseCallback,\n    pub identity_client_handshake_completed_callback:\n        GoslingIdentityClientHandshakeCompletedCallback,\n    pub identity_client_handshake_failed_callback: GoslingIdentityClientHandshakeFailedCallback,\n\n    // identity server events\n    pub identity_server_published_callback: GoslingIdentityServerPublishedCallback,\n    pub identity_server_handshake_started_callback: GoslingIdentityServerHandshakeStartedCallback,\n    pub identity_server_client_allowed_callback:\n        GoslingIdentityServerHandshakeClientAllowedCallback,\n    pub identity_server_endpoint_supported_callback: GoslingIdentityServerEndpointSupportedCallback,\n    pub identity_server_challenge_size_callback:\n        GoslingIdentityServerHandshakeChallengeSizeCallback,\n    pub identity_server_build_challenge_callback:\n        GoslingIdentityServerHandshakeBuildChallengeCallback,\n    pub identity_server_verify_challenge_response_callback:\n        GoslingIdentityServerHandshakeVerifyChallengeResponseCallback,\n    pub identity_server_handshake_completed_callback:\n        GoslingIdentityServerHandshakeCompletedCallback,\n    pub identity_server_handshake_rejected_callback: GoslingIdentityServerHandshakeRejectedCallback,\n    pub identity_server_handshake_failed_callback: GoslingIdentityServerHandshakeFailedCallback,\n\n    // endpoint client events\n    pub endpoint_client_handshake_completed_callback:\n        GoslingEndpointClientHandshakeCompletedCallback,\n    pub endpoint_client_handshake_failed_callback: GoslingEndpointClientHandshakeFailedCallback,\n\n    // endpoint server events\n    pub endpoint_server_published_callback: GoslingEndpointServerPublishedCallback,\n    pub endpoint_server_handshake_started_callback: GoslingEndpointServerHandshakeStartedCallback,\n    pub endpoint_server_channel_supported_callback: GoslingEndpointServerChannelSupportedCallback,\n    pub endpoint_server_handshake_completed_callback:\n        GoslingEndpointServerHandshakeCompletedCallback,\n    pub endpoint_server_handshake_rejected_callback: GoslingEndpointServerHandshakeRejectedCallback,\n    pub endpoint_server_handshake_failed_callback: GoslingEndpointServerHandshakeFailedCallback,\n}\n\n/// The function pointer type for the tor bootstrap status received callback. This\n/// callback is called when context's tor daemon's bootstrap status has progressed.\n///\n/// @param context: the context associated with this event\n/// @param progress: an unsigned integer from 0 to 100 indicating the current completion\n///  perentage of the context's bootstrap process\n/// @param tag: the null-terminated short name of the current bootstrap stage\n/// @param tag_length: the number of chrs in tag not including any null-terminator\n/// @param summary: the null-terminated description of the current bootstra stage\n/// @param summmary_length: the number of chars in summary not including the null-terminator\npub type GoslingTorBootstrapStatusReceivedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        progress: u32,\n        tag: *const c_char,\n        tag_length: usize,\n        summary: *const c_char,\n        summary_length: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the tor boootstrap completed callback. This callback\n/// is called when the context's tor daemon's bootstrap process has completed.\n///\n/// @param context: the context associated with this event\npub type GoslingTorBootstrapCompletedCallback =\n    Option\u003cextern \"C\" fn(context: *mut GoslingContext) -\u003e ()\u003e;\n\n/// The function pointer type for the tor log received callback. This callback is called\n/// whenever the context's tor daemon prints new log lines.\n///\n/// @param context: the context associated with this event\n/// @param line: the null-terminated received log line\n/// @param line_length: the number of chars in line not including the null-terminator\npub type GoslingTorLogReceivedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, line: *const c_char, line_length: usize) -\u003e (),\n\u003e;\n\n/// The function pointer type for the client handshake challenge response size\n/// callback. This callback is called when a client needs to know how much memory\n/// to allocate for a challenge response.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: pointer to the client handshake handle this callback\n///  invocation is associated with; null if no client handshake init callback was\n///  provided\n/// @param challenge_buffer: the source buffer containing a BSON document received\n///  from the  identity server to serve as an endpoint request challenge\n/// @param challenge_buffer_size: the number of bytes in challenge_buffer\n/// @return the number of bytes required to store the challenge response object\npub type GoslingIdentityClientHandshakeChallengeResponseSizeCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n    ) -\u003e usize,\n\u003e;\n\n/// The function pointer type for the identity client handshake build challlenge\n/// response callback. This callback is called when a client is ready to build a\n/// challenge response object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param endpoint_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @param challenge_buffer: the source buffer containing a BSON document received\n///  from the  identity server to serve as an endpoint request challenge\n/// @param challenge_buffer_size: the number of bytes in challenge_buffer\n/// @param out_challenge_response_buffer: the destination buffer for the callback\n///  to write a BSON document representing the endpoint request challenge response\n///  object\n/// @param out_challenge_response_buffer_size: the number of bytes allocated in\n///  out_challenge_response_buffer\npub type GoslingIdentityClientHandshakeBuildChallengeResponseCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n        out_challenge_response_buffer: *mut u8,\n        out_challenge_response_buffer_size: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity client handshake completed callback. This\n/// callback is called whenever the client successfully completes a handshake with an\n/// identity server and is granted access to an endpoint server.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param identity_service_id: the onion service id of the identity server the client\n///  has successfully completed a hadshake with\n/// @param endpoint_service_id: the onion service id of the endpoint server the client\n///  now has access to\n/// @param endpoint_name: the null-terminated name of the provided endpoint server\n/// @param endpoint_name_length: the number of chars in endpoint_name string not including\n///  the null-terminator\n/// @param client_auth_private_key: the client's x25519 private required to connect to\n///  the provided endpoint server\npub type GoslingIdentityClientHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        identity_service_id: *const GoslingV3OnionServiceId,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_auth_private_key: *const GoslingX25519PrivateKey,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity client handshake handshake failed\n/// callback. This callback is called when a client's identity handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingIdentityClientHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity server published callback. This callback\n/// is called whenever the onion service of the identity server associated with the given\n/// context is published and should be reachable by clients.\n///\n/// @param context: the context associated with this event\npub type GoslingIdentityServerPublishedCallback =\n    Option\u003cextern \"C\" fn(context: *mut GoslingContext) -\u003e ()\u003e;\n\n/// The function pointer type of the identity server handshake started callback. This callback\n/// is called whenever the identity server is initially connected to.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\npub type GoslingIdentityServerHandshakeStartedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e (),\n\u003e;\n\n/// The function pointer type of the identity server handshake client allowed callback.\n/// The result of this callback partially determines if an incoming client handshake\n/// request is possible to complete. For instance an implementation of this function\n//  may reference an allow/block list to determime if identity handshakes can be\n/// completed.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_service_id: the v3 onion service id of the connected client\n/// @return true if the server wants to allow the requesting client to connect client may complete the handshake, false otherwise\npub type GoslingIdentityServerHandshakeClientAllowedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_service_id: *const GoslingV3OnionServiceId,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type of the identity server endpoint supported callback. This\n/// callback is called when the server needs to determine if the client's requested\n/// endpoint is supported. The result of this callback partially determines if an\n/// incoming client handshake request is possible to complete.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param endpoint_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @return true if the server can handle requests for the requested endpoint,\n///  false otherwise\npub type GoslingIdentityServerEndpointSupportedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the server handshake challenge size callback.\n/// This callback is called when a server needs to know how much memory to allocate\n/// for a challenge.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @return the number of bytes required to store the challenge object\npub type GoslingIdentityServerHandshakeChallengeSizeCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e usize,\n\u003e;\n\n/// The function pointer type for the server handshake build challenge callback.\n/// This callback is called when a server needs to build a challenge object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param out_challenge_buffer: the destination buffer for the callback\n///  to write a BSON document representing the endpoint request challenge object\n/// @param out_challenge_buffer_size: the number of bytes allocated in\n///  out_challenge_buffer\npub type GoslingIdentityServerHandshakeBuildChallengeCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        out_challenge_buffer: *mut u8,\n        out_challenge_buffer_size: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function poointer type for the server handshake verify challenge response\n/// callback. This callback is called when a server needs to verify a challenge\n/// response object.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param challenge_response_buffer: a buffer containing the BSON document representing\n///  the endpoint request challenge response object\n/// @param challenge_response_buffer_size: the number of bytes in\n///  challenge_response_buffer\n/// @return the result of the challenge response verification\npub type GoslingIdentityServerHandshakeVerifyChallengeResponseCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        challenge_response_buffer: *const u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the identity server handshake completed callback. This\n/// callback is called whenever the identity server has successfully completed a\n/// handshake with and granted to a connecting identity client.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_private_key: the ed25519 private key of the endpoint server to host\n///  for the client\n/// @param endoint_name: the null-terminated name of the new endpoint server\n/// @param endpoint_name_length: the length of the endpoint_name string not including\n///  the null-terminator\n/// @param client_service_id: the onion service id of the client we have granted\n///  access to\n/// @param client_auth_public_key: the x25519 public key to use to encrypt the endpoint\n///  server's service descriptor as provided by the connecting client\npub type GoslingIdentityServerHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_private_key: *const GoslingEd25519PrivateKey,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        client_auth_public_key: *const GoslingX25519PublicKey,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type of the identity server handshake rejected callback. This\n/// callback is called whenever the identity server has rejected an identity client's\n/// handshake.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_allowed: true if requesting client is allowed, false otherwies\n/// @param client_requested_endpoint_valid: true if requesting client requested a\n///  valid endpoint, false otherwise\n/// @param client_proof_signature_valid: true if the requesting client properly\n///  signed the identity proof, false otherwise\n/// @param client_auth_signature_valid: true if the requesting client properly signed\n///  the authorization proof, false othewise\n/// @param challenge_response_valid: true if the requesting client's challenge\n///  response was accepted by the server, false otherwise\npub type GoslingIdentityServerHandshakeRejectedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_allowed: bool,\n        client_requested_endpoint_valid: bool,\n        client_proof_signature_valid: bool,\n        client_auth_signature_valid: bool,\n        challenge_response_valid: bool,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the identity server handshake handshake failed\n/// callback. This callback is called when a server's identity handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingIdentityServerHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint client handshake completed callback.\n/// This callback is called when the client successfully connects to an endpoint server.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_service_id: the onion service id of the endpoint server the client\n///  has connected to\n/// @param channel_name: the null-terminated name of the channel name requested by the\n///  the client\n/// @param channel_name_length: the number of chars in channel_name not including the\n///  null-terminator\n/// @param stream: os-specific tcp socket handle associated with the connection to the\n///  endpoint server\npub type GoslingEndpointClientHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: GoslingTcpSocket,\n    ),\n\u003e;\n\n/// The function pointer type for the endpoint client handshake handshake failed\n/// callback. This callback is called when a client's endpoint handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingEndpointClientHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingError,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint server published callback. This callbcak\n/// is called whenever the onion service of the indicated endpoint server associted with\n/// the given context is published and should be reachable by clients.\n///\n/// @param context: the context associated with this event\n/// @param endpoint_service_id: the onion service id of the published endpoint server\n/// @param endpoint_name: the null-terminated name of the endpoint server published\n/// @param endpoint_name_length: the number of chars in endpoint_name string not including the\n///  null-terminator\npub type GoslingEndpointServerPublishedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        enpdoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type of the endpoint server handshake started callback. This\n/// callback is called whenever the endpoint server is initially connected to.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\npub type GoslingEndpointServerHandshakeStartedCallback = Option\u003c\n    extern \"C\" fn(context: *mut GoslingContext, handshake_handle: GoslingHandshakeHandle) -\u003e (),\n\u003e;\n\n/// The function pointer type of the endpoint server channel supported callback. This\n/// callback is called when the server needs to determine if the client's requested\n/// channel is supported. The result of this callback partially determines if an\n/// incoming endpoint client handshake request is possible to complete.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_service_id: the onion service id of the connected endpoint client\n/// @param channel_name: a null-terminated ASCII string containing the name of the\n///  endpoint being requested\n/// @param channel_name_length: the number of chars in endpoint_name, not\n///  including the null-terminator\n/// @return true if the server can handle requests for the requested channel,\n///  false otherwise\npub type GoslingEndpointServerChannelSupportedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n    ) -\u003e bool,\n\u003e;\n\n/// The function pointer type for the endpoint server handshake completed callback.\n/// This callback is called when an endpoint server completes a handshake with an\n/// endpoint client.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param endpoint_service_id: the onion service id of the endpoint server the\n///  endpoint client has connected to\n/// @param client_service_id: the onion service id of the connected endpoint client\n/// @param channel_name: the null-terminated name of the channel requested by the client\n/// @param channel_name_length: the number of chars in channel_name not including the\n///  null-terminator\n/// @param stream: os-specific tcp socket handle associated with the connection to the\n///  endpoint client\npub type GoslingEndpointServerHandshakeCompletedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: GoslingTcpSocket,\n    ),\n\u003e;\n\n/// The function pointer type of the endpoint server handshake rejected callback. This\n/// callback is called whenever the endpoint server has rejected an endpoint client's\n/// handshake.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param client_allowed: true if requesting client is allowed, false otherwies\n/// @param client_requested_channel_valid: true if requesting client requested a\n///  valid endpoint, false otherwise\n/// @param client_proof_signature_valid: true if the requesting client properly\n///  signed the endpoint proof, false otherwise\npub type GoslingEndpointServerHandshakeRejectedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        client_allowed: bool,\n        client_requested_channel_valid: bool,\n        client_proof_signature_valid: bool,\n    ) -\u003e (),\n\u003e;\n\n/// The function pointer type for the endpoint server handshake handshake failed\n/// callback. This callback is called when a server's endpoint handshake fails.\n///\n/// @param context: the context associated with this event\n/// @param handshake_handle: the handshake handle this callback is associated with\n/// @param error: error associated with this failure\npub type GoslingEndpointServerHandshakeFailedCallback = Option\u003c\n    extern \"C\" fn(\n        context: *mut GoslingContext,\n        handshake_handle: GoslingHandshakeHandle,\n        error: *const GoslingError,\n    ) -\u003e (),\n\u003e;\n\nmacro_rules! impl_callback_setter {\n    ($callback_type:tt, $context:expr, $callback:expr, $error:expr) =\u003e {\n        paste::paste! {\n            translate_failures((), $error, || -\u003e anyhow::Result\u003c()\u003e {\n                let mut context_tuple_registry = get_context_tuple_registry();\n                let context = match context_tuple_registry.get_mut($context as usize) {\n                    Some(context) =\u003e context,\n                    None =\u003e {\n                        bail_invalid_handle!(context);\n                    }\n                };\n                context.1.[\u003c$callback_type\u003e] = $callback;\n                Ok(())\n            })\n        }\n    };\n}\n\n/// Set the tor bootstrap status received callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_bootstrap_status_received_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorBootstrapStatusReceivedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        tor_bootstrap_status_received_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the tor bootstrap completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_bootstrap_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorBootstrapCompletedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(tor_bootstrap_completed_callback, context, callback, error);\n}\n\n/// Sets the tor log received callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_tor_log_received_callback(\n    context: *mut GoslingContext,\n    callback: GoslingTorLogReceivedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(tor_log_received_callback, context, callback, error);\n}\n\n/// Sets the identity challenge challenge response size callback for the specified\n/// context\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_challenge_response_size_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeChallengeResponseSizeCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_client_challenge_response_size_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity client build challenge response callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_build_challenge_response_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeBuildChallengeResponseCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_client_build_challenge_response_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity client handshake completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeCompletedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_client_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity client handshake failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_client_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityClientHandshakeFailedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_client_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server published callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_published_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerPublishedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(identity_server_published_callback, context, callback, error);\n}\n\n/// Set the identity server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_started_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeStartedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_started_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server client allowed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_client_allowed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeClientAllowedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_client_allowed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server endpoint supported callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_endpoint_supported_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerEndpointSupportedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_endpoint_supported_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server challenge size callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_challenge_size_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeChallengeSizeCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_challenge_size_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server build challenge callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_build_challenge_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeBuildChallengeCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_build_challenge_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Sets the identity server verify challenge response callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_verify_challenge_response_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeVerifyChallengeResponseCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_verify_challenge_response_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeCompletedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request rejeced callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_rejected_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeRejectedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_rejected_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the identity server request failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_identity_server_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingIdentityServerHandshakeFailedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        identity_server_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint client handshake completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_client_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointClientHandshakeCompletedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        endpoint_client_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint client handshake failed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_client_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointClientHandshakeFailedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        endpoint_client_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server published callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_published_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerPublishedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(endpoint_server_published_callback, context, callback, error);\n}\n\n/// Set the endpoint server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_started_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeStartedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_started_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server handshake started callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_channel_supported_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerChannelSupportedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        endpoint_server_channel_supported_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_completed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeCompletedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_completed_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_rejected_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeRejectedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_rejected_callback,\n        context,\n        callback,\n        error\n    );\n}\n\n/// Set the endpoint server channel request completed callback for the specified context.\n///\n/// @param context: the context to register the callback to\n/// @param callback: the callback to register\n/// @param  error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_set_endpoint_server_handshake_failed_callback(\n    context: *mut GoslingContext,\n    callback: GoslingEndpointServerHandshakeFailedCallback,\n    error: *mut *mut GoslingError,\n) {\n    impl_callback_setter!(\n        endpoint_server_handshake_failed_callback,\n        context,\n        callback,\n        error\n    );\n}\n","traces":[{"line":519,"address":[1655296,1654656,1654528,1654912,1655552,1655680,1656064,1655744,1655488,1655104,1654784,1655168,1655424,1655808,1656000,1654848,1655040,1655232,1654976,1654592,1654720,1655616,1655872,1655360,1655936],"length":1,"stats":{"Line":38}},{"line":520,"address":[1992769,1995585,1990305,1990657,1994529,1996289,1995937,1996993,1998049,1991361,1998401,1994177,1998753,1993121,1991713,1996641,1994881,1992065,1993473,1995233,1993825,1991009,1992417,1997697,1997345],"length":1,"stats":{"Line":19}},{"line":521,"address":[1993143,1993903,1994255,1991031,1994551,1997775,1993199,1998071,1997367,1992847,1995607,1994903,1996311,1998831,1991735,1991791,1992143,1992495,1995311,1995663,1990327,1993847,1994959,1992791,1997015,1998423,1994199,1996367,1991087,1990679,1996719,1997423,1994607,1998127,1991439,1991383,1998479,1992439,1990735,1996663,1995255,1997071,1998775,1992087,1993495,1990383,1995959,1996015,1997719,1993551],"length":1,"stats":{"Line":38}},{"line":522,"address":[1990836,1994708,1996116,1996468,1997876,1992244,1996820,1990484,1994356,1997172,1991188,1998580,1995412,1991540,1992596,1993652,1997524,1991892,1992948,1995060,1995764,1998228,1998932,1993300,1994004],"length":1,"stats":{"Line":19}},{"line":527,"address":[1990857,1996841,1997193,1995081,1991913,1992617,1990505,1995433,1997545,1992969,1994377,1991209,1996137,1998953,1998249,1991561,1992265,1994729,1995785,1997897,1998601,1994025,1993321,1996489,1993673],"length":1,"stats":{"Line":19}},{"line":528,"address":[1991568,1998256,1995440,1991216,1992976,1994384,1996144,1997552,1994032,1998608,1992624,1994736,1998960,1992272,1995088,1996496,1993328,1996848,1997904,1991920,1995792,1990512,1993680,1997200,1990864],"length":1,"stats":{"Line":19}},{"line":541,"address":[1654496],"length":1,"stats":{"Line":0}},{"line":546,"address":[1990497],"length":1,"stats":{"Line":0}},{"line":561,"address":[1654560],"length":1,"stats":{"Line":1}},{"line":566,"address":[1990849,1990727],"length":1,"stats":{"Line":2}},{"line":576,"address":[1654624],"length":1,"stats":{"Line":0}},{"line":581,"address":[1991201,1991079],"length":1,"stats":{"Line":0}},{"line":592,"address":[1654688],"length":1,"stats":{"Line":1}},{"line":597,"address":[1991553],"length":1,"stats":{"Line":1}},{"line":612,"address":[1654752],"length":1,"stats":{"Line":1}},{"line":617,"address":[1991905],"length":1,"stats":{"Line":1}},{"line":632,"address":[1654816],"length":1,"stats":{"Line":1}},{"line":637,"address":[1992135],"length":1,"stats":{"Line":1}},{"line":652,"address":[1654880],"length":1,"stats":{"Line":1}},{"line":657,"address":[1992487],"length":1,"stats":{"Line":1}},{"line":672,"address":[1654944],"length":1,"stats":{"Line":1}},{"line":677,"address":[1992839,1992961],"length":1,"stats":{"Line":2}},{"line":687,"address":[1655008],"length":1,"stats":{"Line":0}},{"line":692,"address":[1993313],"length":1,"stats":{"Line":0}},{"line":707,"address":[1655072],"length":1,"stats":{"Line":1}},{"line":712,"address":[1993665],"length":1,"stats":{"Line":1}},{"line":727,"address":[1655136],"length":1,"stats":{"Line":1}},{"line":732,"address":[1994017],"length":1,"stats":{"Line":1}},{"line":747,"address":[1655200],"length":1,"stats":{"Line":1}},{"line":752,"address":[1994247],"length":1,"stats":{"Line":1}},{"line":767,"address":[1655264],"length":1,"stats":{"Line":1}},{"line":772,"address":[1994721],"length":1,"stats":{"Line":1}},{"line":787,"address":[1655328],"length":1,"stats":{"Line":1}},{"line":792,"address":[1995073],"length":1,"stats":{"Line":1}},{"line":807,"address":[1655392],"length":1,"stats":{"Line":1}},{"line":812,"address":[1995425],"length":1,"stats":{"Line":1}},{"line":827,"address":[1655456],"length":1,"stats":{"Line":0}},{"line":832,"address":[1995655],"length":1,"stats":{"Line":0}},{"line":847,"address":[1655520],"length":1,"stats":{"Line":1}},{"line":852,"address":[1996129],"length":1,"stats":{"Line":1}},{"line":867,"address":[1655584],"length":1,"stats":{"Line":1}},{"line":872,"address":[1996481],"length":1,"stats":{"Line":1}},{"line":887,"address":[1655648],"length":1,"stats":{"Line":1}},{"line":892,"address":[1996833],"length":1,"stats":{"Line":1}},{"line":907,"address":[1655712],"length":1,"stats":{"Line":1}},{"line":912,"address":[1997185,1997063],"length":1,"stats":{"Line":2}},{"line":922,"address":[1655776],"length":1,"stats":{"Line":0}},{"line":927,"address":[1997537],"length":1,"stats":{"Line":0}},{"line":942,"address":[1655840],"length":1,"stats":{"Line":1}},{"line":947,"address":[1997889],"length":1,"stats":{"Line":1}},{"line":962,"address":[1655904],"length":1,"stats":{"Line":1}},{"line":967,"address":[1998241],"length":1,"stats":{"Line":1}},{"line":982,"address":[1655968],"length":1,"stats":{"Line":0}},{"line":987,"address":[1998471],"length":1,"stats":{"Line":0}},{"line":1002,"address":[1656032],"length":1,"stats":{"Line":1}},{"line":1007,"address":[1998945],"length":1,"stats":{"Line":1}}],"covered":44,"coverable":56},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","context.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::ffi::CString;\nuse std::io::Cursor;\nuse std::os::raw::c_char;\n#[cfg(unix)]\nuse std::os::unix::io::{IntoRawFd, RawFd};\n#[cfg(windows)]\nuse std::os::windows::io::{IntoRawSocket, RawSocket};\nuse std::time::Duration;\n\n// extern crates\nuse anyhow::anyhow;\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\nuse gosling::context::*;\nuse tor_interface::tor_crypto::*;\n\n// internal\nuse crate::callbacks::*;\nuse crate::crypto::*;\nuse crate::error::Error;\nuse crate::error::*;\nuse crate::ffi::*;\nuse crate::macros::*;\nuse crate::tor_provider::*;\n\n// empty bson document layout:\n// {\n//     // document length 5 == 0x00000005\n//     0x05, 0x00, 0x00, 0x00,\n//     // document null-terminator\n//     0x00\n// };\nconst SMALLEST_BSON_DOC_SIZE: usize = 5;\n\n/// A handle for an in-progress identity handhskae\npub type GoslingHandshakeHandle = usize;\n#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n/// A native TCP socket handle\npub type GoslingTcpSocket = RawFd;\n#[cfg(any(target_os = \"windows\"))]\n/// A native TCP socket handle\npub type GoslingTcpSocket = RawSocket;\n/// A context object associated with a single peer identity\npub struct GoslingContext;\n/// cbindgen:ignore\ntype ContextTuple = (Context, EventCallbacks, Option\u003cVecDeque\u003cContextEvent\u003e\u003e);\ndefine_registry! {ContextTuple}\n\n/// Frees a gosling_context object\n///\n/// @param in_context: the context object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_free(in_context: *mut GoslingContext) {\n    impl_registry_free!(in_context, ContextTuple);\n}\n\n/// Initialize a gosling context.\n///\n/// @param out_context: returned initialied gosling context\n/// @param in_tor_provider: the tor client implementation to use; this function consumes the tor_provider\n///  and it may not be re-used in subsequent gosling_* calls, and it does not need to be freed\n/// @param identity_port: the tor virtual port the identity server listens on\n/// @param endpoint_port: the tor virtual port endpoint servers listen on\n/// @param identity_private_key: the e25519 private key used to start th identity server's onion service\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_context_init(\n    // out context\n    out_context: *mut *mut GoslingContext,\n    in_tor_provider: *mut GoslingTorProvider,\n    identity_port: u16,\n    endpoint_port: u16,\n    identity_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_context);\n        ensure_not_null!(in_tor_provider);\n        ensure_not_equal!(identity_port, 0);\n        ensure_not_equal!(endpoint_port, 0);\n        ensure_not_null!(identity_private_key);\n\n        // get our tor provider\n        let tor_provider = match get_tor_provider_registry().remove(in_tor_provider as usize) {\n            Some(tor_provider) =\u003e tor_provider,\n            None =\u003e bail_invalid_handle!(tor_provider),\n        };\n\n        // get our identity key\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let identity_private_key =\n            match ed25519_private_key_registry.get(identity_private_key as usize) {\n                Some(identity_private_key) =\u003e identity_private_key,\n                None =\u003e bail_invalid_handle!(identity_private_key),\n            };\n\n        // construct context\n        let context = Context::new(\n            tor_provider,\n            identity_port,\n            endpoint_port,\n            Duration::from_secs(60),\n            4096,\n            Some(Duration::from_secs(60)),\n            identity_private_key.clone(),\n        )?;\n\n        let handle = get_context_tuple_registry().insert((context, Default::default(), None));\n        *out_context = handle as *mut GoslingContext;\n\n        Ok(())\n    });\n}\n\n/// Connect a gosling_context to the tor network\n///\n/// @param context: the gosling context object to connect to the tor network\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_bootstrap_tor(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail_invalid_handle!(context),\n        };\n        Ok(context.0.bootstrap()?)\n    });\n}\n\n/// Start the identity server so that clients may request endpoints\n///\n/// @param context: the gosling context whose identity server to start\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_start_identity_server(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail_invalid_handle!(context),\n        };\n        Ok(context.0.identity_server_start()?)\n    });\n}\n\n/// Stop the identity server so clients can no longer request endpoints\n///\n/// @param context: the gosling context whose identity server to stop\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_stop_identity_server(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail_invalid_handle!(context),\n        };\n        Ok(context.0.identity_server_stop()?)\n    });\n}\n\n/// Start an endpoint server so the confirmed contact may connect\n///\n/// @param context: the gosling context with the given endpoint to start\n/// @param endpoint_private_key: the ed25519 private key needed to start the endpoint\n///  onion service\n/// @param endpoint_name: the ascii-encoded name of the endpoint server\n/// @param endpoint_name_length: the number of chars in endpoint name not including any null-terminator\n/// @param client_identity: the v3 onion service id of the gosling client associated with this endpoint\n/// @param client_auth_public_key: the x25519 public key used to encrypt the onion service descriptor\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_start_endpoint_server(\n    context: *mut GoslingContext,\n    endpoint_private_key: *const GoslingEd25519PrivateKey,\n    endpoint_name: *const c_char,\n    endpoint_name_length: usize,\n    client_identity: *const GoslingV3OnionServiceId,\n    client_auth_public_key: *const GoslingX25519PublicKey,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n        ensure_not_null!(endpoint_private_key);\n        ensure_not_null!(endpoint_name);\n        ensure_not_equal!(endpoint_name_length, 0);\n        ensure_not_null!(client_identity);\n        ensure_not_null!(client_auth_public_key);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail_invalid_handle!(context),\n        };\n\n        let endpoint_name =\n            unsafe { std::slice::from_raw_parts(endpoint_name as *const u8, endpoint_name_length) };\n        let endpoint_name = std::str::from_utf8(endpoint_name)?.to_string();\n        if !endpoint_name.is_ascii() {\n            bail!(\"endpoint_name must be an ascii string\");\n        }\n\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let endpoint_private_key =\n            match ed25519_private_key_registry.get(endpoint_private_key as usize) {\n                Some(ed25519_private_key) =\u003e ed25519_private_key,\n                None =\u003e bail_invalid_handle!(endpoint_private_key),\n            };\n\n        let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n        let client_identity = match v3_onion_service_id_registry.get(client_identity as usize) {\n            Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n            None =\u003e bail_invalid_handle!(client_identity),\n        };\n\n        let x25519_public_key_registry = get_x25519_public_key_registry();\n        let client_auth_public_key =\n            match x25519_public_key_registry.get(client_auth_public_key as usize) {\n                Some(x25519_public_key) =\u003e x25519_public_key,\n                None =\u003e bail_invalid_handle!(client_auth_public_key),\n            };\n\n        Ok(context.0.endpoint_server_start(\n            endpoint_private_key.clone(),\n            endpoint_name,\n            client_identity.clone(),\n            client_auth_public_key.clone(),\n        )?)\n    });\n}\n\n/// Stops an endpoint server\n///\n/// @param context: the gosling context associated with the endpoint server\n/// @param endpoint_private_key: the ed25519 private key associated with the endpoint server to stop\n/// @param error: filled on erro\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_stop_endpoint_server(\n    context: *mut GoslingContext,\n    endpoint_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n        ensure_not_null!(endpoint_private_key);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail_invalid_handle!(context),\n        };\n\n        let ed25519_private_key_registry = get_ed25519_private_key_registry();\n        let endpoint_private_key =\n            match ed25519_private_key_registry.get(endpoint_private_key as usize) {\n                Some(ed25519_private_key) =\u003e ed25519_private_key,\n                None =\u003e bail_invalid_handle!(endpoint_private_key),\n            };\n\n        let endpoint_identity = V3OnionServiceId::from_private_key(endpoint_private_key);\n        Ok(context.0.endpoint_server_stop(endpoint_identity)?)\n    });\n}\n\n/// Connect to and begin a handshake to request an endpoint from the given identity server\n///\n/// @param context: the context to request an endpoint server for\n/// @param identity_service_id: the service id of the identity server we want to request an endpoint server\n///  from\n/// @param endpoint_name: the name of the endpoint server to request\n/// @param endpoint_name_length: the number of chars in endpoin_name not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_begin_identity_handshake(\n    context: *mut GoslingContext,\n    identity_service_id: *const GoslingV3OnionServiceId,\n    endpoint_name: *const c_char,\n    endpoint_name_length: usize,\n    error: *mut *mut GoslingError,\n) -\u003e GoslingHandshakeHandle {\n    translate_failures(\n        !0usize,\n        error,\n        || -\u003e anyhow::Result\u003cGoslingHandshakeHandle\u003e {\n            ensure_not_null!(context);\n            ensure_not_null!(identity_service_id);\n            ensure_not_null!(endpoint_name);\n            ensure_not_equal!(endpoint_name_length, 0);\n\n            let mut context_tuple_registry = get_context_tuple_registry();\n            let context = match context_tuple_registry.get_mut(context as usize) {\n                Some(context) =\u003e context,\n                None =\u003e bail_invalid_handle!(context),\n            };\n\n            let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n            let identity_service_id =\n                match v3_onion_service_id_registry.get(identity_service_id as usize) {\n                    Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n                    None =\u003e bail_invalid_handle!(identity_service_id),\n                };\n\n            let endpoint_name = unsafe {\n                std::slice::from_raw_parts(endpoint_name as *const u8, endpoint_name_length)\n            };\n            let endpoint_name = std::str::from_utf8(endpoint_name)?.to_string();\n            if !endpoint_name.is_ascii() {\n                bail!(\"endpoint_name must be an ascii string\")\n            }\n\n            Ok(context\n                .0\n                .identity_client_begin_handshake(identity_service_id.clone(), endpoint_name)?)\n        },\n    )\n}\n\n/// Abort an in-progress identity client handshake\n///\n/// @param context: the context associated with the identity client handshake handle\n/// @param handshake_handle: the handle associated with the identity client handshake\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_abort_identity_client_handshake(\n    context: *mut GoslingContext,\n    handshake_handle: GoslingHandshakeHandle,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail_invalid_handle!(context),\n        };\n\n        Ok(context\n            .0\n            .identity_client_abort_handshake(handshake_handle)?)\n    })\n}\n\n/// Connect to and begin a handshake to request a channel from the given endpoint server\n///\n/// @param context: the context which will be opening the channel\n/// @param endpoint_service_id: the endpoint server to open a channel to\n/// @param client_auth_private_key: the x25519 clienth authorization key needed to decrypt the endpoint server's\n///  onion service descriptor\n/// @param channel_name: the ascii-encoded name of the channel to open\n/// @param channel_name_length: the number of chars in channel name not including any null-terminator\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_begin_endpoint_handshake(\n    context: *mut GoslingContext,\n    endpoint_service_id: *const GoslingV3OnionServiceId,\n    client_auth_private_key: *const GoslingX25519PrivateKey,\n    channel_name: *const c_char,\n    channel_name_length: usize,\n    error: *mut *mut GoslingError,\n) -\u003e GoslingHandshakeHandle {\n    translate_failures(\n        !0usize,\n        error,\n        || -\u003e anyhow::Result\u003cGoslingHandshakeHandle\u003e {\n            ensure_not_null!(context);\n            ensure_not_null!(endpoint_service_id);\n            ensure_not_null!(client_auth_private_key);\n            ensure_not_null!(channel_name);\n            ensure_not_equal!(channel_name_length, 0);\n\n            let mut context_tuple_registry = get_context_tuple_registry();\n            let context = match context_tuple_registry.get_mut(context as usize) {\n                Some(context) =\u003e context,\n                None =\u003e bail_invalid_handle!(context),\n            };\n\n            let v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n            let endpoint_service_id =\n                match v3_onion_service_id_registry.get(endpoint_service_id as usize) {\n                    Some(v3_onion_service_id) =\u003e v3_onion_service_id,\n                    None =\u003e bail_invalid_handle!(endpoint_service_id),\n                };\n\n            let x25519_private_key_registry = get_x25519_private_key_registry();\n            let client_auth_private_key =\n                match x25519_private_key_registry.get(client_auth_private_key as usize) {\n                    Some(x25519_private_key) =\u003e x25519_private_key,\n                    None =\u003e bail_invalid_handle!(client_auth_private_key),\n                };\n\n            let channel_name = unsafe {\n                std::slice::from_raw_parts(channel_name as *const u8, channel_name_length)\n            };\n            let channel_name = std::str::from_utf8(channel_name)?.to_string();\n            if !channel_name.is_ascii() {\n                bail!(\"channel_name must be an ascii string\");\n            }\n\n            Ok(context.0.endpoint_client_begin_handshake(\n                endpoint_service_id.clone(),\n                client_auth_private_key.clone(),\n                channel_name,\n            )?)\n        },\n    )\n}\n\n/// Abort an in-progress endpoint client handshake\n///\n/// @param context: the context associated with the endpoint client handshake handle\n/// @param handshake_handle: the handle associated with the identity client handshake\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_abort_endpoint_client_handshake(\n    context: *mut GoslingContext,\n    handshake_handle: GoslingHandshakeHandle,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail_invalid_handle!(context),\n        };\n\n        Ok(context\n            .0\n            .endpoint_client_abort_handshake(handshake_handle)?)\n    })\n}\n\nfn handle_context_event(\n    event: ContextEvent,\n    context: *mut GoslingContext,\n    callbacks: \u0026EventCallbacks,\n) -\u003e anyhow::Result\u003c()\u003e {\n    match event {\n        //\n        // Tor Events\n        //\n        ContextEvent::TorBootstrapStatusReceived {\n            progress,\n            tag,\n            summary,\n        } =\u003e {\n            if let Some(callback) = callbacks.tor_bootstrap_status_received_callback {\n                let tag0 = CString::new(tag.as_str()).expect(\n                    \"bootstrap status tag string should not have an intermediate null byte\",\n                );\n                let summary0 = CString::new(summary.as_str()).expect(\n                    \"bootstrap status summary string should not have an intermediate null byte\",\n                );\n                callback(\n                    context,\n                    progress,\n                    tag0.as_ptr(),\n                    tag.len(),\n                    summary0.as_ptr(),\n                    summary.len(),\n                );\n            }\n        }\n        ContextEvent::TorBootstrapCompleted =\u003e {\n            if let Some(callback) = callbacks.tor_bootstrap_completed_callback {\n                callback(context);\n            }\n        }\n        ContextEvent::TorLogReceived { line } =\u003e {\n            if let Some(callback) = callbacks.tor_log_received_callback {\n                let line0 = CString::new(line.as_str())\n                    .expect(\"tor log line string should not have an intermediate null byte\");\n                callback(context, line0.as_ptr(), line.len());\n            }\n        }\n        //\n        // Identity Client Events\n        //\n        ContextEvent::IdentityClientChallengeReceived {\n            handle,\n            endpoint_challenge,\n        } =\u003e {\n            // construct challenge response\n            let challenge_response = if let (\n                Some(challenge_response_size_callback),\n                Some(build_challenge_response_callback),\n            ) = (\n                callbacks.identity_client_challenge_response_size_callback,\n                callbacks.identity_client_build_challenge_response_callback,\n            ) {\n                let mut endpoint_challenge_buffer: Vec\u003cu8\u003e = Default::default();\n                endpoint_challenge.to_writer(\u0026mut endpoint_challenge_buffer).expect(\"endpoint_challenge should be a valid bson::document::Document and therefore serializable to Vec\u003cu8\u003e\");\n\n                // get the size of challenge response bson blob\n                let challenge_response_size = challenge_response_size_callback(\n                    context,\n                    handle,\n                    endpoint_challenge_buffer.as_ptr(),\n                    endpoint_challenge_buffer.len(),\n                );\n\n                if challenge_response_size \u003c SMALLEST_BSON_DOC_SIZE {\n                    bail!(\"identity_client_challenge_response_size_callback returned an impossibly small size '{}', smallest possible is {}\", challenge_response_size, SMALLEST_BSON_DOC_SIZE);\n                }\n\n                // get the challenge response bson blob\n                let mut challenge_response_buffer: Vec\u003cu8\u003e = vec![0u8; challenge_response_size];\n                build_challenge_response_callback(\n                    context,\n                    handle,\n                    endpoint_challenge_buffer.as_ptr(),\n                    endpoint_challenge_buffer.len(),\n                    challenge_response_buffer.as_mut_ptr(),\n                    challenge_response_buffer.len(),\n                );\n\n                // convert bson blob to bson object\n                match bson::document::Document::from_reader(Cursor::new(challenge_response_buffer))\n                {\n                    Ok(challenge_response) =\u003e challenge_response,\n                    Err(_) =\u003e bail!(\"failed to parse binary provided by identity_client_build_challenge_response_callback as BSON document\")\n                }\n            } else {\n                bail!(\"missing required identity_client_challenge_response_size() and identity_client_build_challenge_response() callbacks\");\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .identity_client_handle_challenge_received(handle, challenge_response)?,\n                None =\u003e bail_invalid_handle!(context),\n            };\n        }\n        ContextEvent::IdentityClientHandshakeCompleted {\n            handle,\n            identity_service_id,\n            endpoint_service_id,\n            endpoint_name,\n            client_auth_private_key,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_client_handshake_completed_callback {\n                let (identity_service_id, endpoint_service_id) = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    let identity_service_id =\n                        v3_onion_service_id_registry.insert(identity_service_id);\n                    let endpoint_service_id =\n                        v3_onion_service_id_registry.insert(endpoint_service_id);\n                    (identity_service_id, endpoint_service_id)\n                };\n\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                let client_auth_private_key =\n                    get_x25519_private_key_registry().insert(client_auth_private_key);\n\n                callback(\n                    context,\n                    handle,\n                    identity_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                    client_auth_private_key as *const GoslingX25519PrivateKey,\n                );\n\n                // cleanup\n                {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.remove(identity_service_id);\n                    v3_onion_service_id_registry.remove(endpoint_service_id);\n                }\n                get_x25519_private_key_registry().remove(client_auth_private_key);\n            } else {\n                bail!(\"missing required identity_client_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::IdentityClientHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.identity_client_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Identity Server Events\n        //\n        ContextEvent::IdentityServerPublished =\u003e {\n            if let Some(callback) = callbacks.identity_server_published_callback {\n                callback(context);\n            }\n        }\n        ContextEvent::IdentityServerHandshakeStarted { handle } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_started_callback {\n                callback(context, handle);\n            }\n        }\n        ContextEvent::IdentityServerEndpointRequestReceived {\n            handle,\n            client_service_id,\n            requested_endpoint,\n        } =\u003e {\n            let client_allowed = match callbacks.identity_server_client_allowed_callback {\n                Some(callback) =\u003e {\n                    let client_service_id =\n                        get_v3_onion_service_id_registry().insert(client_service_id);\n                    callback(\n                        context,\n                        handle,\n                        client_service_id as *const GoslingV3OnionServiceId,\n                    )\n                }\n                None =\u003e bail!(\"missing required identity_server_client_allowed() callback\"),\n            };\n\n            let endpoint_supported = match callbacks.identity_server_endpoint_supported_callback {\n                Some(callback) =\u003e {\n                    let requested_endpoint0 = CString::new(requested_endpoint.as_str()).expect(\n                        \"requested_endpoint should be a valid ASCII string and not have an intermediate null byte\",\n                    );\n                    callback(\n                        context,\n                        handle,\n                        requested_endpoint0.as_ptr(),\n                        requested_endpoint.len(),\n                    )\n                }\n                None =\u003e bail!(\"missing required identity_server_endpoint_supported() callback\"),\n            };\n            let endpoint_challenge = if let (\n                Some(challenge_size_callback),\n                Some(build_challenge_callback),\n            ) = (\n                callbacks.identity_server_challenge_size_callback,\n                callbacks.identity_server_build_challenge_callback,\n            ) {\n                // get the challenge size in bytes\n                let challenge_size = challenge_size_callback(context, handle);\n\n                if challenge_size \u003c SMALLEST_BSON_DOC_SIZE {\n                    bail!(\"identity_server_challenge_size_callback returned an impossibly small size '{}', smallest possible is {}\", challenge_size, SMALLEST_BSON_DOC_SIZE);\n                }\n\n                // construct challenge object into buffer\n                let mut challenge_buffer = vec![0u8; challenge_size];\n                build_challenge_callback(\n                    context,\n                    handle,\n                    challenge_buffer.as_mut_ptr(),\n                    challenge_size,\n                );\n\n                // convert bson blob to bson object\n                match bson::document::Document::from_reader(Cursor::new(challenge_buffer)) {\n                    Ok(challenge) =\u003e challenge,\n                    Err(_) =\u003e bail!(\"failed to parse binary provided by identity_server_build_challenge_callback as BSON document\")\n                }\n            } else {\n                bail!(\"missing required identity_server_challenge_size() and identity_server_build_challenge() callbacks\");\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context.0.identity_server_handle_endpoint_request_received(\n                    handle,\n                    client_allowed,\n                    endpoint_supported,\n                    endpoint_challenge,\n                )?,\n                None =\u003e bail_invalid_handle!(context),\n            };\n        }\n        ContextEvent::IdentityServerChallengeResponseReceived {\n            handle,\n            challenge_response,\n        } =\u003e {\n            let challenge_response_valid = match callbacks\n                .identity_server_verify_challenge_response_callback\n            {\n                Some(callback) =\u003e {\n                    // get response as bytes\n                    let mut challenge_response_buffer: Vec\u003cu8\u003e = Default::default();\n                    challenge_response\n                            .to_writer(\u0026mut challenge_response_buffer).expect(\"challenge_response should be a valid bson::document::Document and therefore serializable to Vec\u003cu8\u003e\");\n\n                    callback(\n                        context,\n                        handle,\n                        challenge_response_buffer.as_ptr(),\n                        challenge_response_buffer.len(),\n                    )\n                }\n                None =\u003e {\n                    bail!(\"missing required identity_server_verify_challenge_response() callback()\")\n                }\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .identity_server_handle_challenge_response_received(\n                        handle,\n                        challenge_response_valid,\n                    )?,\n                None =\u003e bail_invalid_handle!(context),\n            };\n        }\n        ContextEvent::IdentityServerHandshakeCompleted {\n            handle,\n            endpoint_private_key,\n            endpoint_name,\n            client_service_id,\n            client_auth_public_key,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_completed_callback {\n                let endpoint_private_key = {\n                    let mut ed25519_private_key_registry = get_ed25519_private_key_registry();\n                    ed25519_private_key_registry.insert(endpoint_private_key)\n                };\n\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                let client_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(client_service_id)\n                };\n\n                let client_auth_public_key = {\n                    let mut x25519_public_key_registry = get_x25519_public_key_registry();\n                    x25519_public_key_registry.insert(client_auth_public_key)\n                };\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_private_key as *const GoslingEd25519PrivateKey,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                    client_service_id as *const GoslingV3OnionServiceId,\n                    client_auth_public_key as *const GoslingX25519PublicKey,\n                );\n\n                // cleanup\n                get_ed25519_private_key_registry().remove(endpoint_private_key);\n                get_v3_onion_service_id_registry().remove(client_service_id);\n                get_x25519_public_key_registry().remove(client_auth_public_key);\n            } else {\n                bail!(\"missing required identity_server_handshake_completed_callback()\");\n            }\n        }\n        ContextEvent::IdentityServerHandshakeRejected {\n            handle,\n            client_allowed,\n            client_requested_endpoint_valid,\n            client_proof_signature_valid,\n            client_auth_signature_valid,\n            challenge_response_valid,\n        } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_rejected_callback {\n                callback(\n                    context,\n                    handle,\n                    client_allowed,\n                    client_requested_endpoint_valid,\n                    client_proof_signature_valid,\n                    client_auth_signature_valid,\n                    challenge_response_valid,\n                );\n            }\n        }\n        ContextEvent::IdentityServerHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.identity_server_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Endpoint Client Events\n        //\n        ContextEvent::EndpointClientHandshakeCompleted {\n            endpoint_service_id,\n            handle,\n            channel_name,\n            stream,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_client_handshake_completed_callback {\n                let endpoint_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(endpoint_service_id)\n                };\n                let channel_name0 = CString::new(channel_name.as_str())\n                    .expect(\"channel_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n                let stream = stream.into_raw_fd();\n                #[cfg(target_os = \"windows\")]\n                let stream = stream.into_raw_socket();\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    channel_name0.as_ptr(),\n                    channel_name.len(),\n                    stream,\n                );\n\n                // cleanup\n                get_v3_onion_service_id_registry().remove(endpoint_service_id);\n            } else {\n                bail!(\"missing required endpoint_client_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::EndpointClientHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.endpoint_client_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingError);\n                get_error_registry().remove(key);\n            }\n        }\n        //\n        // Endpoint Server Events\n        //\n        ContextEvent::EndpointServerPublished {\n            endpoint_service_id,\n            endpoint_name,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_published_callback {\n                let endpoint_service_id = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.insert(endpoint_service_id)\n                };\n                let endpoint_name0 = CString::new(endpoint_name.as_str())\n                    .expect(\"endpoint_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                callback(\n                    context,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    endpoint_name0.as_ptr(),\n                    endpoint_name.len(),\n                );\n\n                // cleanup\n                get_v3_onion_service_id_registry().remove(endpoint_service_id);\n            }\n        }\n        ContextEvent::EndpointServerHandshakeStarted { handle } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_started_callback {\n                callback(context, handle);\n            }\n        }\n        ContextEvent::EndpointServerChannelRequestReceived {\n            handle,\n            client_service_id,\n            requested_channel,\n        } =\u003e {\n            let channel_supported: bool = match callbacks.endpoint_server_channel_supported_callback\n            {\n                Some(callback) =\u003e {\n                    let client_service_id = {\n                        let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                        v3_onion_service_id_registry.insert(client_service_id)\n                    };\n                    let requested_channel0 = CString::new(requested_channel.as_str()).expect(\"requested_channel should be a valid ASCII string and not have an intermediate null byte\",\n                    );\n                    let channel_supported = callback(\n                        context,\n                        handle,\n                        client_service_id as *const GoslingV3OnionServiceId,\n                        requested_channel0.as_ptr(),\n                        requested_channel.len(),\n                    );\n\n                    // cleanup\n                    get_v3_onion_service_id_registry().remove(client_service_id);\n                    channel_supported\n                }\n                None =\u003e bail!(\"missing required endpoint_server_channel_supported() callback\"),\n            };\n\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e context\n                    .0\n                    .endpoint_server_handle_channel_request_received(handle, channel_supported)?,\n                None =\u003e return Err(anyhow!(\"context is invalid\")),\n            };\n        }\n        ContextEvent::EndpointServerHandshakeCompleted {\n            handle,\n            endpoint_service_id,\n            client_service_id,\n            channel_name,\n            stream,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_completed_callback {\n                let (endpoint_service_id, client_service_id) = {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    let endpoint_service_id =\n                        v3_onion_service_id_registry.insert(endpoint_service_id);\n                    let client_service_id = v3_onion_service_id_registry.insert(client_service_id);\n                    (endpoint_service_id, client_service_id)\n                };\n\n                let channel_name0 = CString::new(channel_name.as_str())\n                    .expect(\"channel_name should be a valid ASCII string and not have an intermediate null byte\");\n\n                #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n                let stream = stream.into_raw_fd();\n                #[cfg(target_os = \"windows\")]\n                let stream = stream.into_raw_socket();\n\n                callback(\n                    context,\n                    handle,\n                    endpoint_service_id as *const GoslingV3OnionServiceId,\n                    client_service_id as *const GoslingV3OnionServiceId,\n                    channel_name0.as_ptr(),\n                    channel_name.len(),\n                    stream,\n                );\n\n                // cleanup\n                {\n                    let mut v3_onion_service_id_registry = get_v3_onion_service_id_registry();\n                    v3_onion_service_id_registry.remove(endpoint_service_id);\n                    v3_onion_service_id_registry.remove(client_service_id);\n                }\n            } else {\n                bail!(\"missing required endpoint_server_handshake_completed() callback\");\n            }\n        }\n        ContextEvent::EndpointServerHandshakeRejected {\n            handle,\n            client_allowed,\n            client_requested_channel_valid,\n            client_proof_signature_valid,\n        } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_rejected_callback {\n                callback(\n                    context,\n                    handle,\n                    client_allowed,\n                    client_requested_channel_valid,\n                    client_proof_signature_valid,\n                );\n            }\n        }\n        ContextEvent::EndpointServerHandshakeFailed { handle, reason } =\u003e {\n            if let Some(callback) = callbacks.endpoint_server_handshake_failed_callback {\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", reason).as_str()));\n                callback(context, handle, key as *const GoslingError);\n                get_error_registry().remove(key);\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Update the internal gosling context state and process event callbacks\n///\n/// @param context: the context object we are updating\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_poll_events(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        // we need to scope the context registry explicitly here\n        // in case our callbacks want to call any gosling functions\n        // to avoid deadlock (since a mutex is held while the context_tuple_registry\n        // is accesible)\n        let (mut context_events, callbacks) =\n            match get_context_tuple_registry().get_mut(context as usize) {\n                Some(context) =\u003e {\n                    // get our new events\n                    let mut new_events = context.0.update()?;\n                    // get a copy of our callbacks\n                    let callbacks = context.1.clone();\n\n                    // append new_events to any existing events if they exist,\n                    // otherwise just pass through new_events\n                    let context_events = match std::mem::take(\u0026mut context.2) {\n                        Some(mut context_events) =\u003e {\n                            context_events.append(\u0026mut new_events);\n                            context_events\n                        }\n                        None =\u003e {\n                            // no previous events so just pass through the new events\n                            new_events\n                        }\n                    };\n                    (context_events, callbacks)\n                }\n                None =\u003e bail_invalid_handle!(context),\n            };\n\n        // consume the events and trigger any callbacks\n        while let Some(event) = context_events.pop_front() {\n            let result = handle_context_event(event, context, \u0026callbacks);\n            if result.is_err() {\n                // if we have remaining events to consume, save them off on\n                // the context\n                if !context_events.is_empty() {\n                    if let Some(context) = get_context_tuple_registry().get_mut(context as usize) {\n                        context.2 = Some(context_events);\n                    }\n                }\n                // return the error\n                return result;\n            }\n        }\n        Ok(())\n    });\n}\n","traces":[{"line":57,"address":[1692224,1692411],"length":1,"stats":{"Line":0}},{"line":72,"address":[1692448],"length":1,"stats":{"Line":1}},{"line":81,"address":[1692497],"length":1,"stats":{"Line":2}},{"line":82,"address":[2783895],"length":1,"stats":{"Line":1}},{"line":83,"address":[2783918],"length":1,"stats":{"Line":1}},{"line":86,"address":[2784599],"length":1,"stats":{"Line":1}},{"line":89,"address":[2784615,2784866],"length":1,"stats":{"Line":2}},{"line":90,"address":[2785031],"length":1,"stats":{"Line":1}},{"line":95,"address":[2785259],"length":1,"stats":{"Line":1}},{"line":97,"address":[2785392,2785321],"length":1,"stats":{"Line":2}},{"line":98,"address":[2785544],"length":1,"stats":{"Line":1}},{"line":103,"address":[2786091,2786919,2785968,2786351],"length":1,"stats":{"Line":2}},{"line":104,"address":[2785568],"length":1,"stats":{"Line":1}},{"line":105,"address":[2785624,2785616],"length":1,"stats":{"Line":2}},{"line":106,"address":[2785635,2785620],"length":1,"stats":{"Line":2}},{"line":107,"address":[2785651],"length":1,"stats":{"Line":1}},{"line":109,"address":[2785857],"length":1,"stats":{"Line":1}},{"line":110,"address":[2785917],"length":1,"stats":{"Line":1}},{"line":113,"address":[2786204,2786431],"length":1,"stats":{"Line":2}},{"line":114,"address":[2786849,2786775],"length":1,"stats":{"Line":1}},{"line":116,"address":[2786809],"length":1,"stats":{"Line":1}},{"line":126,"address":[1692576],"length":1,"stats":{"Line":1}},{"line":130,"address":[1692601],"length":1,"stats":{"Line":2}},{"line":131,"address":[2787052],"length":1,"stats":{"Line":1}},{"line":133,"address":[2787069],"length":1,"stats":{"Line":1}},{"line":134,"address":[2787252,2787091],"length":1,"stats":{"Line":2}},{"line":135,"address":[2787370],"length":1,"stats":{"Line":1}},{"line":138,"address":[2787383,2787561,2787753,2787047,2787507],"length":1,"stats":{"Line":3}},{"line":148,"address":[1692624],"length":1,"stats":{"Line":1}},{"line":152,"address":[1692649],"length":1,"stats":{"Line":2}},{"line":153,"address":[2787820],"length":1,"stats":{"Line":1}},{"line":155,"address":[2787837],"length":1,"stats":{"Line":1}},{"line":156,"address":[2787859,2788020],"length":1,"stats":{"Line":2}},{"line":157,"address":[2788138],"length":1,"stats":{"Line":1}},{"line":160,"address":[2787815,2788151,2788275,2788521,2788329],"length":1,"stats":{"Line":3}},{"line":170,"address":[1692672],"length":1,"stats":{"Line":0}},{"line":174,"address":[1692697],"length":1,"stats":{"Line":0}},{"line":175,"address":[2788588],"length":1,"stats":{"Line":0}},{"line":177,"address":[2788605],"length":1,"stats":{"Line":0}},{"line":178,"address":[2788627,2788788],"length":1,"stats":{"Line":0}},{"line":179,"address":[2788906],"length":1,"stats":{"Line":0}},{"line":182,"address":[2789097,2789289,2788583,2788919,2789043],"length":1,"stats":{"Line":0}},{"line":198,"address":[1692720],"length":1,"stats":{"Line":1}},{"line":207,"address":[1692762],"length":1,"stats":{"Line":2}},{"line":208,"address":[2789383],"length":1,"stats":{"Line":1}},{"line":209,"address":[2789406],"length":1,"stats":{"Line":1}},{"line":210,"address":[2789585],"length":1,"stats":{"Line":1}},{"line":212,"address":[2790080],"length":1,"stats":{"Line":1}},{"line":213,"address":[2790122],"length":1,"stats":{"Line":1}},{"line":215,"address":[2790293],"length":1,"stats":{"Line":1}},{"line":216,"address":[2790544,2790324],"length":1,"stats":{"Line":2}},{"line":217,"address":[2790692],"length":1,"stats":{"Line":1}},{"line":222,"address":[2790716,2790878],"length":1,"stats":{"Line":2}},{"line":223,"address":[2790894,2793319],"length":1,"stats":{"Line":1}},{"line":224,"address":[2791079,2791159],"length":1,"stats":{"Line":2}},{"line":225,"address":[2791186,2791242],"length":1,"stats":{"Line":0}},{"line":228,"address":[2791318,2791212],"length":1,"stats":{"Line":2}},{"line":230,"address":[2791414,2791343],"length":1,"stats":{"Line":2}},{"line":231,"address":[2791555],"length":1,"stats":{"Line":1}},{"line":235,"address":[2791576,2791700],"length":1,"stats":{"Line":2}},{"line":236,"address":[2791725,2791790],"length":1,"stats":{"Line":2}},{"line":237,"address":[2791925],"length":1,"stats":{"Line":1}},{"line":241,"address":[2792070,2791946],"length":1,"stats":{"Line":2}},{"line":243,"address":[2792095,2792160],"length":1,"stats":{"Line":2}},{"line":244,"address":[2792300],"length":1,"stats":{"Line":1}},{"line":248,"address":[2792597,2792696,2793132,2792887],"length":1,"stats":{"Line":2}},{"line":249,"address":[2792457,2792321],"length":1,"stats":{"Line":2}},{"line":250,"address":[2792465],"length":1,"stats":{"Line":1}},{"line":251,"address":[2792521],"length":1,"stats":{"Line":1}},{"line":252,"address":[2792582],"length":1,"stats":{"Line":1}},{"line":264,"address":[1692848],"length":1,"stats":{"Line":0}},{"line":269,"address":[1692880],"length":1,"stats":{"Line":0}},{"line":270,"address":[2793361],"length":1,"stats":{"Line":0}},{"line":271,"address":[2793378],"length":1,"stats":{"Line":0}},{"line":273,"address":[2793535],"length":1,"stats":{"Line":0}},{"line":274,"address":[2793566,2793769],"length":1,"stats":{"Line":0}},{"line":275,"address":[2793905],"length":1,"stats":{"Line":0}},{"line":279,"address":[2793926,2794047],"length":1,"stats":{"Line":0}},{"line":281,"address":[2794129,2794072],"length":1,"stats":{"Line":0}},{"line":282,"address":[2794265],"length":1,"stats":{"Line":0}},{"line":286,"address":[2794281],"length":1,"stats":{"Line":0}},{"line":287,"address":[2794517,2793351,2794414,2794772],"length":1,"stats":{"Line":0}},{"line":301,"address":[1692912],"length":1,"stats":{"Line":1}},{"line":311,"address":[1692954],"length":1,"stats":{"Line":2}},{"line":312,"address":[2794855],"length":1,"stats":{"Line":1}},{"line":313,"address":[2794878],"length":1,"stats":{"Line":1}},{"line":314,"address":[2795069],"length":1,"stats":{"Line":1}},{"line":317,"address":[2795592],"length":1,"stats":{"Line":1}},{"line":318,"address":[2795623,2795718],"length":1,"stats":{"Line":2}},{"line":319,"address":[2795858],"length":1,"stats":{"Line":1}},{"line":323,"address":[2795879,2796027],"length":1,"stats":{"Line":2}},{"line":325,"address":[2796117,2796052],"length":1,"stats":{"Line":2}},{"line":326,"address":[2796260],"length":1,"stats":{"Line":1}},{"line":331,"address":[2796437,2796281],"length":1,"stats":{"Line":2}},{"line":333,"address":[2796453,2797425],"length":1,"stats":{"Line":1}},{"line":334,"address":[2796708,2796640],"length":1,"stats":{"Line":2}},{"line":335,"address":[2796783,2796729],"length":1,"stats":{"Line":0}},{"line":338,"address":[2797314,2796905,2797179],"length":1,"stats":{"Line":1}},{"line":340,"address":[2796865,2797051,2796768],"length":1,"stats":{"Line":2}},{"line":352,"address":[1693024],"length":1,"stats":{"Line":0}},{"line":357,"address":[1693056],"length":1,"stats":{"Line":0}},{"line":358,"address":[2797473],"length":1,"stats":{"Line":0}},{"line":360,"address":[2797490],"length":1,"stats":{"Line":0}},{"line":361,"address":[2797673,2797512],"length":1,"stats":{"Line":0}},{"line":362,"address":[2797803],"length":1,"stats":{"Line":0}},{"line":366,"address":[2798142,2797960,2797824,2797463,2798208],"length":1,"stats":{"Line":0}},{"line":368,"address":[2797816,2798014],"length":1,"stats":{"Line":0}},{"line":382,"address":[1693088],"length":1,"stats":{"Line":1}},{"line":393,"address":[1693135],"length":1,"stats":{"Line":2}},{"line":394,"address":[2798279],"length":1,"stats":{"Line":1}},{"line":395,"address":[2798302],"length":1,"stats":{"Line":1}},{"line":396,"address":[2798493],"length":1,"stats":{"Line":1}},{"line":397,"address":[2798684],"length":1,"stats":{"Line":1}},{"line":400,"address":[2799207],"length":1,"stats":{"Line":1}},{"line":401,"address":[2799238,2799333],"length":1,"stats":{"Line":2}},{"line":402,"address":[2799473],"length":1,"stats":{"Line":1}},{"line":406,"address":[2799497,2799651],"length":1,"stats":{"Line":2}},{"line":408,"address":[2799747,2799676],"length":1,"stats":{"Line":2}},{"line":409,"address":[2799888],"length":1,"stats":{"Line":1}},{"line":413,"address":[2799912,2800060],"length":1,"stats":{"Line":2}},{"line":415,"address":[2800085,2800150],"length":1,"stats":{"Line":2}},{"line":416,"address":[2800293],"length":1,"stats":{"Line":1}},{"line":421,"address":[2800314,2800470],"length":1,"stats":{"Line":2}},{"line":423,"address":[2800486,2801564],"length":1,"stats":{"Line":1}},{"line":424,"address":[2800673,2800741],"length":1,"stats":{"Line":2}},{"line":425,"address":[2800819,2800762],"length":1,"stats":{"Line":0}},{"line":428,"address":[2800964,2801438,2801246],"length":1,"stats":{"Line":1}},{"line":429,"address":[2800804],"length":1,"stats":{"Line":1}},{"line":430,"address":[2800909],"length":1,"stats":{"Line":1}},{"line":431,"address":[2800924],"length":1,"stats":{"Line":1}},{"line":444,"address":[1693216],"length":1,"stats":{"Line":0}},{"line":449,"address":[1693248],"length":1,"stats":{"Line":0}},{"line":450,"address":[2801617],"length":1,"stats":{"Line":0}},{"line":452,"address":[2801634],"length":1,"stats":{"Line":0}},{"line":453,"address":[2801817,2801656],"length":1,"stats":{"Line":0}},{"line":454,"address":[2801947],"length":1,"stats":{"Line":0}},{"line":458,"address":[2802286,2801968,2802104,2801607,2802352],"length":1,"stats":{"Line":0}},{"line":460,"address":[2802158,2801960],"length":1,"stats":{"Line":0}},{"line":464,"address":[1693280,1696889,1696808],"length":1,"stats":{"Line":1}},{"line":469,"address":[1693357],"length":1,"stats":{"Line":1}},{"line":473,"address":[1693520],"length":1,"stats":{"Line":1}},{"line":478,"address":[1693592,1696061],"length":1,"stats":{"Line":1}},{"line":479,"address":[1696193,1696088],"length":1,"stats":{"Line":0}},{"line":482,"address":[1696306,1696389],"length":1,"stats":{"Line":0}},{"line":488,"address":[1696585,1696502],"length":1,"stats":{"Line":0}},{"line":489,"address":[1696608],"length":1,"stats":{"Line":0}},{"line":490,"address":[1696631],"length":1,"stats":{"Line":0}},{"line":491,"address":[1696693],"length":1,"stats":{"Line":0}},{"line":496,"address":[1696918,1693633],"length":1,"stats":{"Line":2}},{"line":497,"address":[1696930],"length":1,"stats":{"Line":1}},{"line":500,"address":[1693683],"length":1,"stats":{"Line":1}},{"line":501,"address":[1693719,1696942],"length":1,"stats":{"Line":1}},{"line":502,"address":[1696970,1697072],"length":1,"stats":{"Line":0}},{"line":504,"address":[1697268,1697185],"length":1,"stats":{"Line":0}},{"line":510,"address":[1693761],"length":1,"stats":{"Line":1}},{"line":515,"address":[1693835,1697364],"length":1,"stats":{"Line":2}},{"line":516,"address":[1697422],"length":1,"stats":{"Line":1}},{"line":517,"address":[1697446],"length":1,"stats":{"Line":1}},{"line":519,"address":[1693811],"length":1,"stats":{"Line":1}},{"line":520,"address":[1693815],"length":1,"stats":{"Line":1}},{"line":522,"address":[1697470],"length":1,"stats":{"Line":1}},{"line":523,"address":[1697609,1697533],"length":1,"stats":{"Line":2}},{"line":529,"address":[1697651],"length":1,"stats":{"Line":1}},{"line":530,"address":[1697666],"length":1,"stats":{"Line":1}},{"line":533,"address":[1697761],"length":1,"stats":{"Line":1}},{"line":534,"address":[1699836],"length":1,"stats":{"Line":0}},{"line":538,"address":[1697772,1697900],"length":1,"stats":{"Line":2}},{"line":542,"address":[1697916],"length":1,"stats":{"Line":1}},{"line":543,"address":[1697972],"length":1,"stats":{"Line":1}},{"line":544,"address":[1698007],"length":1,"stats":{"Line":1}},{"line":545,"address":[1698022],"length":1,"stats":{"Line":1}},{"line":549,"address":[1698109],"length":1,"stats":{"Line":1}},{"line":551,"address":[1698238],"length":1,"stats":{"Line":1}},{"line":552,"address":[1699581,1698465],"length":1,"stats":{"Line":0}},{"line":555,"address":[1697393,1699998],"length":1,"stats":{"Line":0}},{"line":558,"address":[1698688,1698595,1698781],"length":1,"stats":{"Line":3}},{"line":559,"address":[1698926,1699046,1699194,1699373,1699438],"length":1,"stats":{"Line":3}},{"line":561,"address":[1699245,1698942],"length":1,"stats":{"Line":1}},{"line":565,"address":[1693901],"length":1,"stats":{"Line":1}},{"line":572,"address":[1694073,1700066],"length":1,"stats":{"Line":2}},{"line":573,"address":[1700418],"length":1,"stats":{"Line":1}},{"line":574,"address":[1700193,1700086],"length":1,"stats":{"Line":2}},{"line":575,"address":[1700286,1700218],"length":1,"stats":{"Line":2}},{"line":577,"address":[1700325],"length":1,"stats":{"Line":1}},{"line":582,"address":[1700442],"length":1,"stats":{"Line":1}},{"line":585,"address":[1700586,1700667],"length":1,"stats":{"Line":2}},{"line":593,"address":[1700886],"length":1,"stats":{"Line":1}},{"line":594,"address":[1700948],"length":1,"stats":{"Line":1}},{"line":600,"address":[1701037],"length":1,"stats":{"Line":1}},{"line":601,"address":[1701099,1701178],"length":1,"stats":{"Line":2}},{"line":602,"address":[1701193],"length":1,"stats":{"Line":1}},{"line":604,"address":[1701254],"length":1,"stats":{"Line":1}},{"line":606,"address":[1700108,1701486],"length":1,"stats":{"Line":0}},{"line":609,"address":[1694115],"length":1,"stats":{"Line":0}},{"line":610,"address":[1694168,1701642],"length":1,"stats":{"Line":0}},{"line":611,"address":[1701762,1701662,1701933],"length":1,"stats":{"Line":0}},{"line":612,"address":[1702273],"length":1,"stats":{"Line":0}},{"line":613,"address":[1702277],"length":1,"stats":{"Line":0}},{"line":620,"address":[1694210,1702514],"length":1,"stats":{"Line":2}},{"line":621,"address":[1702526],"length":1,"stats":{"Line":1}},{"line":624,"address":[1694260],"length":1,"stats":{"Line":1}},{"line":625,"address":[1694280,1702557],"length":1,"stats":{"Line":1}},{"line":626,"address":[1702569],"length":1,"stats":{"Line":0}},{"line":629,"address":[1694342],"length":1,"stats":{"Line":1}},{"line":634,"address":[1694416],"length":1,"stats":{"Line":1}},{"line":635,"address":[1702610],"length":1,"stats":{"Line":1}},{"line":636,"address":[1702630,1702777],"length":1,"stats":{"Line":2}},{"line":644,"address":[1702576,1702704],"length":1,"stats":{"Line":0}},{"line":647,"address":[1702987],"length":1,"stats":{"Line":1}},{"line":648,"address":[1703046],"length":1,"stats":{"Line":1}},{"line":649,"address":[1703074,1703165],"length":1,"stats":{"Line":2}},{"line":655,"address":[1703361,1703278],"length":1,"stats":{"Line":2}},{"line":656,"address":[1703384],"length":1,"stats":{"Line":1}},{"line":659,"address":[1703105,1703012],"length":1,"stats":{"Line":0}},{"line":661,"address":[1703517],"length":1,"stats":{"Line":1}},{"line":662,"address":[1703620],"length":1,"stats":{"Line":1}},{"line":663,"address":[1703636],"length":1,"stats":{"Line":1}},{"line":665,"address":[1703493],"length":1,"stats":{"Line":1}},{"line":666,"address":[1703497],"length":1,"stats":{"Line":1}},{"line":669,"address":[1703660],"length":1,"stats":{"Line":1}},{"line":671,"address":[1703688],"length":1,"stats":{"Line":1}},{"line":672,"address":[1705460],"length":1,"stats":{"Line":0}},{"line":676,"address":[1703827,1703699],"length":1,"stats":{"Line":2}},{"line":680,"address":[1703843],"length":1,"stats":{"Line":1}},{"line":685,"address":[1703943],"length":1,"stats":{"Line":1}},{"line":686,"address":[1704068],"length":1,"stats":{"Line":1}},{"line":687,"address":[1704173,1705224],"length":1,"stats":{"Line":0}},{"line":690,"address":[1705605,1703575],"length":1,"stats":{"Line":0}},{"line":693,"address":[1704388,1704202,1704295],"length":1,"stats":{"Line":3}},{"line":694,"address":[1704547,1704667,1704829,1705008,1705073],"length":1,"stats":{"Line":3}},{"line":698,"address":[1704563],"length":1,"stats":{"Line":1}},{"line":703,"address":[1694458],"length":1,"stats":{"Line":1}},{"line":707,"address":[1694508],"length":1,"stats":{"Line":1}},{"line":710,"address":[1705683],"length":1,"stats":{"Line":1}},{"line":712,"address":[1705703],"length":1,"stats":{"Line":1}},{"line":713,"address":[1705911,1705832],"length":1,"stats":{"Line":2}},{"line":719,"address":[1705953],"length":1,"stats":{"Line":1}},{"line":720,"address":[1705968],"length":1,"stats":{"Line":1}},{"line":724,"address":[1705774,1705649],"length":1,"stats":{"Line":0}},{"line":728,"address":[1706081,1706214],"length":1,"stats":{"Line":2}},{"line":729,"address":[1706525,1706704,1706761,1706363],"length":1,"stats":{"Line":2}},{"line":738,"address":[1694608],"length":1,"stats":{"Line":1}},{"line":745,"address":[1694744,1706782],"length":1,"stats":{"Line":2}},{"line":747,"address":[1706912,1706802],"length":1,"stats":{"Line":2}},{"line":748,"address":[1706937,1706989],"length":1,"stats":{"Line":2}},{"line":751,"address":[1707105],"length":1,"stats":{"Line":1}},{"line":755,"address":[1707330,1707249],"length":1,"stats":{"Line":2}},{"line":756,"address":[1707355,1707423],"length":1,"stats":{"Line":2}},{"line":760,"address":[1707469],"length":1,"stats":{"Line":1}},{"line":761,"address":[1707531,1707602],"length":1,"stats":{"Line":2}},{"line":768,"address":[1707672],"length":1,"stats":{"Line":1}},{"line":769,"address":[1707734],"length":1,"stats":{"Line":1}},{"line":775,"address":[1707823],"length":1,"stats":{"Line":1}},{"line":776,"address":[1708005],"length":1,"stats":{"Line":1}},{"line":777,"address":[1708168],"length":1,"stats":{"Line":1}},{"line":779,"address":[1706824,1708431],"length":1,"stats":{"Line":0}},{"line":782,"address":[1694894],"length":1,"stats":{"Line":0}},{"line":790,"address":[1694914,1708600],"length":1,"stats":{"Line":0}},{"line":802,"address":[1694956],"length":1,"stats":{"Line":0}},{"line":803,"address":[1708669,1695009],"length":1,"stats":{"Line":0}},{"line":804,"address":[1708792,1708963,1708692],"length":1,"stats":{"Line":0}},{"line":805,"address":[1709303],"length":1,"stats":{"Line":0}},{"line":806,"address":[1709307],"length":1,"stats":{"Line":0}},{"line":812,"address":[1695054],"length":1,"stats":{"Line":1}},{"line":818,"address":[1695166,1709536],"length":1,"stats":{"Line":2}},{"line":820,"address":[1709666,1709559],"length":1,"stats":{"Line":2}},{"line":821,"address":[1709691,1709759],"length":1,"stats":{"Line":2}},{"line":823,"address":[1709813],"length":1,"stats":{"Line":1}},{"line":827,"address":[1709957,1710045],"length":1,"stats":{"Line":2}},{"line":835,"address":[1710068],"length":1,"stats":{"Line":1}},{"line":836,"address":[1710130],"length":1,"stats":{"Line":1}},{"line":841,"address":[1710205],"length":1,"stats":{"Line":1}},{"line":843,"address":[1709581,1710422],"length":1,"stats":{"Line":0}},{"line":846,"address":[1695211],"length":1,"stats":{"Line":0}},{"line":847,"address":[1710578,1695264],"length":1,"stats":{"Line":0}},{"line":848,"address":[1710701,1710872,1710601],"length":1,"stats":{"Line":0}},{"line":849,"address":[1711212],"length":1,"stats":{"Line":0}},{"line":850,"address":[1711216],"length":1,"stats":{"Line":0}},{"line":856,"address":[1695309],"length":1,"stats":{"Line":1}},{"line":860,"address":[1711445,1695383],"length":1,"stats":{"Line":2}},{"line":862,"address":[1711568,1711468],"length":1,"stats":{"Line":2}},{"line":863,"address":[1711661,1711593],"length":1,"stats":{"Line":2}},{"line":865,"address":[1711715],"length":1,"stats":{"Line":1}},{"line":871,"address":[1711966,1711883],"length":1,"stats":{"Line":2}},{"line":872,"address":[1711989],"length":1,"stats":{"Line":1}},{"line":876,"address":[1712048],"length":1,"stats":{"Line":1}},{"line":879,"address":[1695436],"length":1,"stats":{"Line":1}},{"line":880,"address":[1712257,1695456],"length":1,"stats":{"Line":1}},{"line":881,"address":[1712272],"length":1,"stats":{"Line":0}},{"line":884,"address":[1695559],"length":1,"stats":{"Line":1}},{"line":889,"address":[1695595],"length":1,"stats":{"Line":1}},{"line":891,"address":[1712313],"length":1,"stats":{"Line":1}},{"line":893,"address":[1712483,1712336],"length":1,"stats":{"Line":2}},{"line":894,"address":[1712579,1712508],"length":1,"stats":{"Line":2}},{"line":896,"address":[1712633],"length":1,"stats":{"Line":1}},{"line":902,"address":[1712884,1712801],"length":1,"stats":{"Line":2}},{"line":903,"address":[1712907],"length":1,"stats":{"Line":1}},{"line":907,"address":[1712997],"length":1,"stats":{"Line":1}},{"line":910,"address":[1712279,1712410],"length":1,"stats":{"Line":0}},{"line":913,"address":[1713312,1713179],"length":1,"stats":{"Line":2}},{"line":914,"address":[1713413,1713737,1713794,1693341,1713558],"length":1,"stats":{"Line":3}},{"line":916,"address":[1713609],"length":1,"stats":{"Line":0}},{"line":917,"address":[1713372,1713462],"length":1,"stats":{"Line":0}},{"line":920,"address":[1695660],"length":1,"stats":{"Line":1}},{"line":927,"address":[1713815,1695785],"length":1,"stats":{"Line":2}},{"line":928,"address":[1714170],"length":1,"stats":{"Line":1}},{"line":929,"address":[1713945,1713838],"length":1,"stats":{"Line":2}},{"line":930,"address":[1713970,1714038],"length":1,"stats":{"Line":2}},{"line":932,"address":[1714077],"length":1,"stats":{"Line":1}},{"line":936,"address":[1714194],"length":1,"stats":{"Line":1}},{"line":940,"address":[1714338,1714434],"length":1,"stats":{"Line":2}},{"line":949,"address":[1714465],"length":1,"stats":{"Line":1}},{"line":950,"address":[1714527],"length":1,"stats":{"Line":1}},{"line":956,"address":[1714616],"length":1,"stats":{"Line":1}},{"line":957,"address":[1714678,1714757],"length":1,"stats":{"Line":2}},{"line":958,"address":[1714772],"length":1,"stats":{"Line":1}},{"line":961,"address":[1713860,1714887],"length":1,"stats":{"Line":0}},{"line":964,"address":[1695898],"length":1,"stats":{"Line":0}},{"line":970,"address":[1695918,1715075],"length":1,"stats":{"Line":0}},{"line":980,"address":[1695963],"length":1,"stats":{"Line":0}},{"line":981,"address":[1696016,1715125],"length":1,"stats":{"Line":0}},{"line":982,"address":[1715145,1715401,1715233],"length":1,"stats":{"Line":0}},{"line":983,"address":[1715702],"length":1,"stats":{"Line":0}},{"line":984,"address":[1715706],"length":1,"stats":{"Line":0}},{"line":988,"address":[1696872],"length":1,"stats":{"Line":1}},{"line":997,"address":[1715904],"length":1,"stats":{"Line":1}},{"line":1001,"address":[1715929],"length":1,"stats":{"Line":2}},{"line":1006,"address":[2803627],"length":1,"stats":{"Line":1}},{"line":1007,"address":[2802412,2802516],"length":1,"stats":{"Line":2}},{"line":1008,"address":[2802652],"length":1,"stats":{"Line":1}},{"line":1010,"address":[2802939,2804673,2802804,2802673],"length":1,"stats":{"Line":2}},{"line":1012,"address":[2802914],"length":1,"stats":{"Line":1}},{"line":1016,"address":[2803143],"length":1,"stats":{"Line":1}},{"line":1017,"address":[2803274],"length":1,"stats":{"Line":0}},{"line":1018,"address":[2803322],"length":1,"stats":{"Line":0}},{"line":1019,"address":[2803550],"length":1,"stats":{"Line":0}},{"line":1023,"address":[2803200],"length":1,"stats":{"Line":1}},{"line":1026,"address":[2803332],"length":1,"stats":{"Line":1}},{"line":1032,"address":[2803788],"length":1,"stats":{"Line":1}},{"line":1033,"address":[2803870,2803921],"length":1,"stats":{"Line":2}},{"line":1034,"address":[2803937,2803992],"length":1,"stats":{"Line":2}},{"line":1037,"address":[2804024],"length":1,"stats":{"Line":0}},{"line":1038,"address":[2804528,2804045,2804184,2804102],"length":1,"stats":{"Line":0}},{"line":1039,"address":[2804267,2804376],"length":1,"stats":{"Line":0}},{"line":1043,"address":[2804061],"length":1,"stats":{"Line":0}},{"line":1046,"address":[2804581],"length":1,"stats":{"Line":1}}],"covered":250,"coverable":346},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","crypto.rs"],"content":"// standard\nuse std::os::raw::c_char;\nuse std::str;\n\n// extern crates\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::error::*;\nuse crate::ffi::*;\nuse crate::macros::*;\n\n/// An ed25519 private key used to create a v3 onion service\npub struct GoslingEd25519PrivateKey;\ndefine_registry! {Ed25519PrivateKey}\n\n/// An x25519 private key used to decrypt v3 onion service descriptors\npub struct GoslingX25519PrivateKey;\ndefine_registry! {X25519PrivateKey}\n\n/// An x25519 public key used to encrypt v3 onoin service descriptors\npub struct GoslingX25519PublicKey;\ndefine_registry! {X25519PublicKey}\n\n/// A v3 onion service id\npub struct GoslingV3OnionServiceId;\ndefine_registry! {V3OnionServiceId}\n\n//\n// Free Functions\n//\n\n/// Frees a gosling_ed25519_private_key object\n///\n/// @param in_private_key: the private key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_ed25519_private_key_free(in_private_key: *mut GoslingEd25519PrivateKey) {\n    impl_registry_free!(in_private_key, Ed25519PrivateKey);\n}\n\n/// Frees a gosling_x25519_private_key object\n///\n/// @param in_private_key: the private key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_private_key_free(in_private_key: *mut GoslingX25519PrivateKey) {\n    impl_registry_free!(in_private_key, X25519PrivateKey);\n}\n\n/// Frees a gosling_x25519_public_key object\n///\n/// @param public_key: the public key to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_public_key_free(in_public_key: *mut GoslingX25519PublicKey) {\n    impl_registry_free!(in_public_key, X25519PublicKey);\n}\n\n/// Frees a gosling_v3_onion_service_id object\n///\n/// @param in_service_id: the service id object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_v3_onion_service_id_free(in_service_id: *mut GoslingV3OnionServiceId) {\n    impl_registry_free!(in_service_id, V3OnionServiceId);\n}\n\n//\n// Clone Functions\n//\n\n/// Copy method for gosling_ed25519_private_key\n///\n/// @param out_private_key: returned copy\n/// @param private_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_clone(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_private_key);\n        ensure_not_null!(private_key);\n\n        let private_key = match get_ed25519_private_key_registry().get(private_key as usize) {\n            Some(private_key) =\u003e private_key.clone(),\n            None =\u003e bail_invalid_handle!(private_key),\n        };\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_x25519_public_key\n///\n/// @param out_public_key: returned copy\n/// @param public_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_public_key_clone(\n    out_public_key: *mut *mut GoslingX25519PublicKey,\n    public_key: *const GoslingX25519PublicKey,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_public_key);\n        ensure_not_null!(public_key);\n\n        let public_key = match get_x25519_public_key_registry().get(public_key as usize) {\n            Some(public_key) =\u003e public_key.clone(),\n            None =\u003e bail_invalid_handle!(public_key),\n        };\n        let handle = get_x25519_public_key_registry().insert(public_key);\n        *out_public_key = handle as *mut GoslingX25519PublicKey;\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_x25519_private_key\n///\n/// @param out_private_key: returned copy\n/// @param private_key: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_private_key_clone(\n    out_private_key: *mut *mut GoslingX25519PrivateKey,\n    private_key: *const GoslingX25519PrivateKey,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_private_key);\n        ensure_not_null!(private_key);\n\n        let private_key = match get_x25519_private_key_registry().get(private_key as usize) {\n            Some(private_key) =\u003e private_key.clone(),\n            None =\u003e bail_invalid_handle!(private_key),\n        };\n        let handle = get_x25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingX25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_v3_onion_service_id\n///\n/// @param out_service_id: returned copy\n/// @param service_id: original to copy\n/// @param error: fliled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_clone(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    service_id: *const GoslingV3OnionServiceId,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_service_id);\n        ensure_not_null!(service_id);\n\n        let service_id = match get_v3_onion_service_id_registry().get(service_id as usize) {\n            Some(service_id) =\u003e service_id.clone(),\n            None =\u003e bail_invalid_handle!(service_id),\n        };\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n//\n// Ed25519 Privat4e Key Functions\n//\n\n/// Creation method for securely generating a new gosling_ed25510_private_key\n///\n/// @param out_private_key: returned generated ed25519 private key\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_generate(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_private_key);\n\n        let private_key = Ed25519PrivateKey::generate();\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting the KeyBlob string returned by ADD_ONION\n/// command into a gosling_ed25519_private_key\n///\n/// @param out_private_key: returned ed25519 private key\n/// @param key_blob: an ed25519 KeyBlob string in the form\n///  \"ED25519-V3:abcd1234...\"\n/// @param key_blob_length: number of chars in key_blob not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ed25519_private_key_from_keyblob(\n    out_private_key: *mut *mut GoslingEd25519PrivateKey,\n    key_blob: *const c_char,\n    key_blob_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_private_key);\n        ensure_not_null!(key_blob);\n\n        if key_blob_length != ED25519_PRIVATE_KEY_KEYBLOB_LENGTH {\n            bail!(\"key_blob_length must be exactly ED25519_PRIVATE_KEY_KEYBLOB_LENGTH ({}); received '{}'\", ED25519_PRIVATE_KEY_KEYBLOB_LENGTH, key_blob_length);\n        }\n\n        let key_blob_view = std::slice::from_raw_parts(key_blob as *const u8, key_blob_length);\n        let key_blob_str = std::str::from_utf8(key_blob_view)?;\n        let private_key = Ed25519PrivateKey::from_key_blob(key_blob_str)?;\n\n        let handle = get_ed25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingEd25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an ed25519 private key to a null-\n/// terminated KeyBlob string for use with ADD_ONION command\n///\n/// @param private_key: the private key to encode\n/// @param out_key_blob: buffer to be filled with ed25519 KeyBlob in\n///  the form \"ED25519-V3:abcd1234...\\0\"\n/// @param key_blob_size: size of out_key_blob buffer in bytes, must be at\n///  least 100 characters (99 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_ed25519_private_key_to_keyblob(\n    private_key: *const GoslingEd25519PrivateKey,\n    out_key_blob: *mut c_char,\n    key_blob_size: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(private_key);\n        ensure_not_null!(out_key_blob);\n\n        if key_blob_size \u003c ED25519_PRIVATE_KEY_KEYBLOB_SIZE {\n            bail!(\n                \"key_blob_size must be at least ED25519_PRIVATE_KEY_KEYBLOB_SIZE ('{}'), received '{}'\",\n                ED25519_PRIVATE_KEY_KEYBLOB_SIZE,\n                key_blob_size\n            );\n        }\n\n        let registry = get_ed25519_private_key_registry();\n        match registry.get(private_key as usize) {\n            Some(private_key) =\u003e {\n                let private_key_blob = private_key.to_key_blob();\n                unsafe {\n                    // copy keyblob into output buffer\n                    let key_blob_view =\n                        std::slice::from_raw_parts_mut(out_key_blob as *mut u8, key_blob_size);\n                    std::ptr::copy(\n                        private_key_blob.as_ptr(),\n                        key_blob_view.as_mut_ptr(),\n                        ED25519_PRIVATE_KEY_KEYBLOB_LENGTH,\n                    );\n                    // add final null-terminator\n                    key_blob_view[ED25519_PRIVATE_KEY_KEYBLOB_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail_invalid_handle!(private_key);\n            }\n        };\n\n        Ok(())\n    })\n}\n\n//\n// X25519 Private Key Functions\n//\n\n/// Conversion method for converting a base64-encoded string used by the\n/// ONION_CLIENT_AUTH_ADD command into a gosling_x25519_private_key\n///\n/// @param out_private_key: returned x25519 private key\n/// @param base64: an x25519 private key encoded as a base64 string\n/// @param base64_length: the number of chars in base64 not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_private_key_from_base64(\n    out_private_key: *mut *mut GoslingX25519PrivateKey,\n    base64: *const c_char,\n    base64_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_private_key);\n        ensure_not_null!(base64);\n\n        if base64_length != X25519_PRIVATE_KEY_BASE64_LENGTH {\n            bail!(\"base64_length must be exactly X25519_PRIVATE_KEY_BASE64_LENGTH ({}); received '{}'\", X25519_PRIVATE_KEY_BASE64_LENGTH, base64_length);\n        }\n\n        let base64_view = std::slice::from_raw_parts(base64 as *const u8, base64_length);\n        let base64_str = std::str::from_utf8(base64_view)?;\n        let private_key = X25519PrivateKey::from_base64(base64_str)?;\n\n        let handle = get_x25519_private_key_registry().insert(private_key);\n        *out_private_key = handle as *mut GoslingX25519PrivateKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an x25519 private key to a null-\n/// terminated base64 string for use with ONION_CLIENT_AUTH_ADD command\n///\n/// @param private_key: the private key to encode\n/// @param out_base64: buffer to be filled with x25519 key encoded as base64\n/// @param base64_size: size of out_base64 buffer in bytes, must be at\n///  least 45 characters (44 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_private_key_to_base64(\n    private_key: *const GoslingX25519PrivateKey,\n    out_base64: *mut c_char,\n    base64_size: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(private_key);\n        ensure_not_null!(out_base64);\n\n        if base64_size \u003c X25519_PRIVATE_KEY_BASE64_SIZE {\n            bail!(\n                \"base64_size must be at least '{}', received '{}'\",\n                X25519_PRIVATE_KEY_BASE64_SIZE,\n                base64_size\n            );\n        }\n\n        let registry = get_x25519_private_key_registry();\n        match registry.get(private_key as usize) {\n            Some(private_key) =\u003e {\n                let private_key_blob = private_key.to_base64();\n                unsafe {\n                    // copy base64 into output buffer\n                    let base64_view =\n                        std::slice::from_raw_parts_mut(out_base64 as *mut u8, base64_size);\n                    std::ptr::copy(\n                        private_key_blob.as_ptr(),\n                        base64_view.as_mut_ptr(),\n                        X25519_PRIVATE_KEY_BASE64_LENGTH,\n                    );\n                    // add final null-terminator\n                    base64_view[X25519_PRIVATE_KEY_BASE64_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail_invalid_handle!(private_key);\n            }\n        };\n\n        Ok(())\n    })\n}\n\n//\n// X25519 Public Key Functions\n//\n\n/// Conversion method for converting a base32-encoded string used by the\n/// ADD_ONION command into a gosling_x25519_public_key\n///\n/// @param out_public_key: returned x25519 public key\n/// @param base32: an x25519 public key encoded as a base32 string\n/// @param base32_length: the number of chars in base32 not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_x25519_public_key_from_base32(\n    out_public_key: *mut *mut GoslingX25519PublicKey,\n    base32: *const c_char,\n    base32_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_public_key);\n        ensure_not_null!(base32);\n\n        if base32_length != X25519_PUBLIC_KEY_BASE32_LENGTH {\n            bail!(\n                \"base32_length must be exactly X25519_PUBLIC_KEY_BASE32_LENGTH ({}); received '{}'\",\n                X25519_PUBLIC_KEY_BASE32_LENGTH,\n                base32_length\n            );\n        }\n\n        let base32_view = std::slice::from_raw_parts(base32 as *const u8, base32_length);\n        let base32_str = std::str::from_utf8(base32_view)?;\n        let public_key = X25519PublicKey::from_base32(base32_str)?;\n\n        let handle = get_x25519_public_key_registry().insert(public_key);\n        *out_public_key = handle as *mut GoslingX25519PublicKey;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an x25519 public key to a null-\n/// terminated base64 string for use with ADD_ONION command\n///\n/// @param public_key: the public key to encode\n/// @param out_base32: buffer to be filled with x25519 key encoded as base32\n/// @param base32_size: size of out_base32 buffer in bytes, must be at\n///  least 53 characters (52 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_x25519_public_key_to_base32(\n    public_key: *const GoslingX25519PublicKey,\n    out_base32: *mut c_char,\n    base32_size: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(public_key);\n        ensure_not_null!(out_base32);\n\n        if base32_size \u003c X25519_PUBLIC_KEY_BASE32_SIZE {\n            bail!(\n                \"base32_size must be at least '{}', received '{}'\",\n                X25519_PUBLIC_KEY_BASE32_SIZE,\n                base32_size\n            );\n        }\n\n        let registry = get_x25519_public_key_registry();\n        match registry.get(public_key as usize) {\n            Some(public_key) =\u003e {\n                let public_base32 = public_key.to_base32();\n                unsafe {\n                    // copy base32 into output buffer\n                    let base32_view =\n                        std::slice::from_raw_parts_mut(out_base32 as *mut u8, base32_size);\n                    std::ptr::copy(\n                        public_base32.as_ptr(),\n                        base32_view.as_mut_ptr(),\n                        X25519_PUBLIC_KEY_BASE32_LENGTH,\n                    );\n                    // add final null-terminator\n                    base32_view[X25519_PUBLIC_KEY_BASE32_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail_invalid_handle!(public_key);\n            }\n        };\n\n        Ok(())\n    })\n}\n\n//\n// V3 Onion Service Id Functions\n//\n\n/// Conversion method for converting a v3 onion service string into a\n/// gosling_v3_onion_service_id object\n///\n/// @param out_service_id: returned service id object\n/// @param service_id_string: a v3 onion service id string\n/// @param service_id_string_length: the number of chars in service_id_string not including any\n///  null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_from_string(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    service_id_string: *const c_char,\n    service_id_string_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_service_id);\n        ensure_not_null!(service_id_string);\n\n        if service_id_string_length != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            bail!(\"service_id_string_length must be exactly V3_ONION_SERVICE_ID_STRING_LENGTH ({}); received '{}'\", V3_ONION_SERVICE_ID_STRING_LENGTH, service_id_string_length);\n        }\n\n        let service_id_view =\n            std::slice::from_raw_parts(service_id_string as *const u8, service_id_string_length);\n        let service_id_str = std::str::from_utf8(service_id_view)?;\n        let service_id = V3OnionServiceId::from_string(service_id_str)?;\n\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting an ed25519 private key  into a\n/// gosling_v3_onion_service_id object\n///\n/// @param out_service_id: returned service id object\n/// @param ed25519_private_key: an e25519 private key\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_v3_onion_service_id_from_ed25519_private_key(\n    out_service_id: *mut *mut GoslingV3OnionServiceId,\n    ed25519_private_key: *const GoslingEd25519PrivateKey,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_service_id);\n        ensure_not_null!(ed25519_private_key);\n\n        let service_id = {\n            let ed25519_private_key_registry = get_ed25519_private_key_registry();\n            let ed25519_private_key =\n                match ed25519_private_key_registry.get(ed25519_private_key as usize) {\n                    Some(ed25519_private_key) =\u003e ed25519_private_key,\n                    None =\u003e bail_invalid_handle!(ed25519_private_key),\n                };\n            V3OnionServiceId::from_private_key(ed25519_private_key)\n        };\n\n        let handle = get_v3_onion_service_id_registry().insert(service_id);\n        *out_service_id = handle as *mut GoslingV3OnionServiceId;\n\n        Ok(())\n    })\n}\n\n/// Conversion method for converting v3 onion service id to a null-terminated\n/// string\n///\n/// @param service_id: the service id to encode\n/// @param out_service_id_string: buffer to be filled with x25519 key encoded as base32\n/// @param service_id_string_size: size of out_service_id_string buffer in bytes,\n///  must be at least 57 characters (56 for string + 1 for null-terminator)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_v3_onion_service_id_to_string(\n    service_id: *const GoslingV3OnionServiceId,\n    out_service_id_string: *mut c_char,\n    service_id_string_size: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(service_id);\n        ensure_not_null!(out_service_id_string);\n\n        if service_id_string_size \u003c V3_ONION_SERVICE_ID_STRING_SIZE {\n            bail!(\n                \"service_id_string_size must be at least '{}', received '{}'\",\n                V3_ONION_SERVICE_ID_STRING_SIZE,\n                service_id_string_size\n            );\n        }\n\n        let registry = get_v3_onion_service_id_registry();\n        match registry.get(service_id as usize) {\n            Some(service_id) =\u003e {\n                let service_id_string = service_id.to_string();\n                unsafe {\n                    // copy service_id_string into output buffer\n                    let service_id_string_view = std::slice::from_raw_parts_mut(\n                        out_service_id_string as *mut u8,\n                        service_id_string_size,\n                    );\n                    std::ptr::copy(\n                        service_id_string.as_ptr(),\n                        service_id_string_view.as_mut_ptr(),\n                        V3_ONION_SERVICE_ID_STRING_LENGTH,\n                    );\n                    // add final null-terminator\n                    service_id_string_view[V3_ONION_SERVICE_ID_STRING_LENGTH] = 0u8;\n                };\n            }\n            None =\u003e {\n                bail_invalid_handle!(service_id);\n            }\n        };\n\n        Ok(())\n    })\n}\n\n/// Checks if a service id string is valid per tor rend spec:\n/// https://gitweb.torproject.org/torspec.git/tree/rend-spec-v3.txt\n///\n/// @param service_id_string: string containing the v3 service id to be validated\n/// @param service_id_string_length: the number of chars in service_id_string not including any\n///  null-terminator; must be V3_ONION_SERVICE_ID_STRING_LENGTH (56)\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_string_is_valid_v3_onion_service_id(\n    service_id_string: *const c_char,\n    service_id_string_length: usize,\n    error: *mut *mut GoslingError,\n) -\u003e bool {\n    translate_failures(false, error, || -\u003e anyhow::Result\u003cbool\u003e {\n        ensure_not_null!(service_id_string);\n\n        if service_id_string_length != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            bail!(\n                \"service_id_string_length must be V3_ONION_SERVICE_ID_STRING_LENGTH (56); received '{}'\",\n                service_id_string_length\n            );\n        }\n\n        let service_id_string_slice = unsafe {\n            std::slice::from_raw_parts(service_id_string as *const u8, service_id_string_length)\n        };\n        Ok(V3OnionServiceId::is_valid(str::from_utf8(\n            service_id_string_slice,\n        )?))\n    })\n}\n","traces":[{"line":41,"address":[1674768,1674959],"length":1,"stats":{"Line":0}},{"line":50,"address":[1675146,1674992],"length":1,"stats":{"Line":0}},{"line":59,"address":[1675168,1675310],"length":1,"stats":{"Line":0}},{"line":68,"address":[1675344,1675493],"length":1,"stats":{"Line":0}},{"line":83,"address":[1675520],"length":1,"stats":{"Line":1}},{"line":88,"address":[1974159,1973136],"length":1,"stats":{"Line":2}},{"line":89,"address":[1973161],"length":1,"stats":{"Line":1}},{"line":90,"address":[1973178],"length":1,"stats":{"Line":1}},{"line":92,"address":[1973305,1973539],"length":1,"stats":{"Line":2}},{"line":93,"address":[1973675,1973822],"length":1,"stats":{"Line":2}},{"line":96,"address":[1973886],"length":1,"stats":{"Line":1}},{"line":97,"address":[1974138,1974078],"length":1,"stats":{"Line":1}},{"line":99,"address":[1974112],"length":1,"stats":{"Line":1}},{"line":110,"address":[1675584],"length":1,"stats":{"Line":1}},{"line":115,"address":[1675616],"length":1,"stats":{"Line":2}},{"line":116,"address":[1974225],"length":1,"stats":{"Line":1}},{"line":117,"address":[1974242],"length":1,"stats":{"Line":1}},{"line":119,"address":[1974369,1974570],"length":1,"stats":{"Line":2}},{"line":120,"address":[1974706],"length":1,"stats":{"Line":1}},{"line":123,"address":[1974854],"length":1,"stats":{"Line":1}},{"line":124,"address":[1974988,1975040],"length":1,"stats":{"Line":1}},{"line":126,"address":[1975022],"length":1,"stats":{"Line":1}},{"line":137,"address":[1675648],"length":1,"stats":{"Line":1}},{"line":142,"address":[1675680],"length":1,"stats":{"Line":2}},{"line":143,"address":[1975113],"length":1,"stats":{"Line":1}},{"line":144,"address":[1975130],"length":1,"stats":{"Line":1}},{"line":146,"address":[1975479,1975257],"length":1,"stats":{"Line":2}},{"line":147,"address":[1975615,1975758],"length":1,"stats":{"Line":2}},{"line":150,"address":[1975822],"length":1,"stats":{"Line":1}},{"line":151,"address":[1976014,1976074],"length":1,"stats":{"Line":1}},{"line":153,"address":[1976048],"length":1,"stats":{"Line":1}},{"line":164,"address":[1675712],"length":1,"stats":{"Line":1}},{"line":169,"address":[1675744],"length":1,"stats":{"Line":2}},{"line":170,"address":[1976161],"length":1,"stats":{"Line":1}},{"line":171,"address":[1976178],"length":1,"stats":{"Line":1}},{"line":173,"address":[1976305,1976515],"length":1,"stats":{"Line":2}},{"line":174,"address":[1976651],"length":1,"stats":{"Line":1}},{"line":177,"address":[1976799],"length":1,"stats":{"Line":1}},{"line":178,"address":[1976988,1976933],"length":1,"stats":{"Line":1}},{"line":180,"address":[1976969],"length":1,"stats":{"Line":1}},{"line":194,"address":[1675776],"length":1,"stats":{"Line":1}},{"line":198,"address":[1675801],"length":1,"stats":{"Line":2}},{"line":199,"address":[1977060],"length":1,"stats":{"Line":1}},{"line":201,"address":[1977077],"length":1,"stats":{"Line":1}},{"line":202,"address":[1977099,1977272],"length":1,"stats":{"Line":2}},{"line":203,"address":[1977493,1977436],"length":1,"stats":{"Line":1}},{"line":205,"address":[1977470],"length":1,"stats":{"Line":1}},{"line":219,"address":[1675824],"length":1,"stats":{"Line":0}},{"line":225,"address":[1675861],"length":1,"stats":{"Line":0}},{"line":226,"address":[1977588],"length":1,"stats":{"Line":0}},{"line":227,"address":[1977608],"length":1,"stats":{"Line":0}},{"line":229,"address":[1977739],"length":1,"stats":{"Line":0}},{"line":230,"address":[1978180,1978098],"length":1,"stats":{"Line":0}},{"line":233,"address":[1977906],"length":1,"stats":{"Line":0}},{"line":234,"address":[1977945,1978318,1978401],"length":1,"stats":{"Line":0}},{"line":235,"address":[1978350,1978495,1978592],"length":1,"stats":{"Line":0}},{"line":237,"address":[1978573,1978744],"length":1,"stats":{"Line":0}},{"line":238,"address":[1978916,1978974],"length":1,"stats":{"Line":0}},{"line":240,"address":[1978950],"length":1,"stats":{"Line":0}},{"line":255,"address":[1675920],"length":1,"stats":{"Line":0}},{"line":261,"address":[1675957],"length":1,"stats":{"Line":0}},{"line":262,"address":[1979068],"length":1,"stats":{"Line":0}},{"line":263,"address":[1979088],"length":1,"stats":{"Line":0}},{"line":265,"address":[1979219],"length":1,"stats":{"Line":0}},{"line":266,"address":[1979512,1979594],"length":1,"stats":{"Line":0}},{"line":273,"address":[1979369],"length":1,"stats":{"Line":0}},{"line":274,"address":[1979400,1979782],"length":1,"stats":{"Line":0}},{"line":275,"address":[1979916],"length":1,"stats":{"Line":0}},{"line":276,"address":[1979932],"length":1,"stats":{"Line":0}},{"line":280,"address":[1980149,1980060],"length":1,"stats":{"Line":0}},{"line":282,"address":[1980188],"length":1,"stats":{"Line":0}},{"line":287,"address":[1980377,1980419],"length":1,"stats":{"Line":0}},{"line":295,"address":[1980444],"length":1,"stats":{"Line":0}},{"line":312,"address":[1676016],"length":1,"stats":{"Line":0}},{"line":318,"address":[1676053],"length":1,"stats":{"Line":0}},{"line":319,"address":[1980516],"length":1,"stats":{"Line":0}},{"line":320,"address":[1980536],"length":1,"stats":{"Line":0}},{"line":322,"address":[1980663],"length":1,"stats":{"Line":0}},{"line":323,"address":[1981062,1980980],"length":1,"stats":{"Line":0}},{"line":326,"address":[1980788],"length":1,"stats":{"Line":0}},{"line":327,"address":[1980827,1981194,1981284],"length":1,"stats":{"Line":0}},{"line":328,"address":[1981226,1981378,1981469],"length":1,"stats":{"Line":0}},{"line":330,"address":[1981621,1981450],"length":1,"stats":{"Line":0}},{"line":331,"address":[1981793,1981848],"length":1,"stats":{"Line":0}},{"line":333,"address":[1981825],"length":1,"stats":{"Line":0}},{"line":347,"address":[1676112],"length":1,"stats":{"Line":0}},{"line":353,"address":[1676149],"length":1,"stats":{"Line":0}},{"line":354,"address":[1981948],"length":1,"stats":{"Line":0}},{"line":355,"address":[1981968],"length":1,"stats":{"Line":0}},{"line":357,"address":[1982099],"length":1,"stats":{"Line":0}},{"line":358,"address":[1982474,1982392],"length":1,"stats":{"Line":0}},{"line":365,"address":[1982249],"length":1,"stats":{"Line":0}},{"line":366,"address":[1982662,1982280],"length":1,"stats":{"Line":0}},{"line":367,"address":[1982796],"length":1,"stats":{"Line":0}},{"line":368,"address":[1982812],"length":1,"stats":{"Line":0}},{"line":372,"address":[1982940,1983029],"length":1,"stats":{"Line":0}},{"line":374,"address":[1983068],"length":1,"stats":{"Line":0}},{"line":379,"address":[1983225,1983267],"length":1,"stats":{"Line":0}},{"line":387,"address":[1983292],"length":1,"stats":{"Line":0}},{"line":404,"address":[1676208],"length":1,"stats":{"Line":0}},{"line":410,"address":[1676245],"length":1,"stats":{"Line":0}},{"line":411,"address":[1983356],"length":1,"stats":{"Line":0}},{"line":412,"address":[1983376],"length":1,"stats":{"Line":0}},{"line":414,"address":[1983503],"length":1,"stats":{"Line":0}},{"line":415,"address":[1983902,1983820],"length":1,"stats":{"Line":0}},{"line":422,"address":[1983628],"length":1,"stats":{"Line":0}},{"line":423,"address":[1983667,1984034,1984124],"length":1,"stats":{"Line":0}},{"line":424,"address":[1984066,1984218,1984296],"length":1,"stats":{"Line":0}},{"line":426,"address":[1984398,1984250],"length":1,"stats":{"Line":0}},{"line":427,"address":[1984533,1984486],"length":1,"stats":{"Line":0}},{"line":429,"address":[1984518],"length":1,"stats":{"Line":0}},{"line":443,"address":[1676304],"length":1,"stats":{"Line":0}},{"line":449,"address":[1676341],"length":1,"stats":{"Line":0}},{"line":450,"address":[1984604],"length":1,"stats":{"Line":0}},{"line":451,"address":[1984624],"length":1,"stats":{"Line":0}},{"line":453,"address":[1984755],"length":1,"stats":{"Line":0}},{"line":454,"address":[1985130,1985048],"length":1,"stats":{"Line":0}},{"line":461,"address":[1984905],"length":1,"stats":{"Line":0}},{"line":462,"address":[1984936,1985318],"length":1,"stats":{"Line":0}},{"line":463,"address":[1985452],"length":1,"stats":{"Line":0}},{"line":464,"address":[1985468],"length":1,"stats":{"Line":0}},{"line":468,"address":[1985685,1985596],"length":1,"stats":{"Line":0}},{"line":470,"address":[1985724],"length":1,"stats":{"Line":0}},{"line":475,"address":[1985923,1985881],"length":1,"stats":{"Line":0}},{"line":483,"address":[1985948],"length":1,"stats":{"Line":0}},{"line":501,"address":[1676400],"length":1,"stats":{"Line":0}},{"line":507,"address":[1676437],"length":1,"stats":{"Line":0}},{"line":508,"address":[1986012],"length":1,"stats":{"Line":0}},{"line":509,"address":[1986032],"length":1,"stats":{"Line":0}},{"line":511,"address":[1986159],"length":1,"stats":{"Line":0}},{"line":512,"address":[1986558,1986476],"length":1,"stats":{"Line":0}},{"line":516,"address":[1986284],"length":1,"stats":{"Line":0}},{"line":517,"address":[1986780,1986323,1986690],"length":1,"stats":{"Line":0}},{"line":518,"address":[1986874,1986984,1986722],"length":1,"stats":{"Line":0}},{"line":520,"address":[1986938,1987086],"length":1,"stats":{"Line":0}},{"line":521,"address":[1987221,1987174],"length":1,"stats":{"Line":0}},{"line":523,"address":[1987206],"length":1,"stats":{"Line":0}},{"line":535,"address":[1676496],"length":1,"stats":{"Line":1}},{"line":540,"address":[1676528],"length":1,"stats":{"Line":2}},{"line":541,"address":[1987297],"length":1,"stats":{"Line":1}},{"line":542,"address":[1987314],"length":1,"stats":{"Line":1}},{"line":545,"address":[1987441],"length":1,"stats":{"Line":1}},{"line":547,"address":[1987651,1987472],"length":1,"stats":{"Line":2}},{"line":548,"address":[1987787],"length":1,"stats":{"Line":1}},{"line":551,"address":[1987803],"length":1,"stats":{"Line":1}},{"line":554,"address":[1987939],"length":1,"stats":{"Line":1}},{"line":555,"address":[1988073,1988128],"length":1,"stats":{"Line":1}},{"line":557,"address":[1988109],"length":1,"stats":{"Line":1}},{"line":571,"address":[1676560],"length":1,"stats":{"Line":0}},{"line":577,"address":[1676597],"length":1,"stats":{"Line":0}},{"line":578,"address":[1988188],"length":1,"stats":{"Line":0}},{"line":579,"address":[1988208],"length":1,"stats":{"Line":0}},{"line":581,"address":[1988339],"length":1,"stats":{"Line":0}},{"line":582,"address":[1988632,1988714],"length":1,"stats":{"Line":0}},{"line":589,"address":[1988489],"length":1,"stats":{"Line":0}},{"line":590,"address":[1988902,1988520],"length":1,"stats":{"Line":0}},{"line":591,"address":[1989036],"length":1,"stats":{"Line":0}},{"line":592,"address":[1989052],"length":1,"stats":{"Line":0}},{"line":595,"address":[1989194,1989269],"length":1,"stats":{"Line":0}},{"line":596,"address":[1989180,1989188],"length":1,"stats":{"Line":0}},{"line":597,"address":[1989191,1989184],"length":1,"stats":{"Line":0}},{"line":600,"address":[1989308],"length":1,"stats":{"Line":0}},{"line":605,"address":[1989467,1989509],"length":1,"stats":{"Line":0}},{"line":613,"address":[1989534],"length":1,"stats":{"Line":0}},{"line":626,"address":[1676656],"length":1,"stats":{"Line":0}},{"line":631,"address":[1676688],"length":1,"stats":{"Line":0}},{"line":632,"address":[1989611],"length":1,"stats":{"Line":0}},{"line":634,"address":[1989628],"length":1,"stats":{"Line":0}},{"line":635,"address":[1989856,1989939],"length":1,"stats":{"Line":0}},{"line":642,"address":[1989759],"length":1,"stats":{"Line":0}},{"line":644,"address":[1989800,1990043,1990136],"length":1,"stats":{"Line":0}}],"covered":54,"coverable":171},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","error.rs"],"content":"// standard\nuse std::ffi::CString;\nuse std::os::raw::c_char;\n\n// extern crates\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\n\n// internal crates\nuse crate::ffi::*;\nuse crate::macros::*;\n\n/// Error Handling\n#[derive(Clone)]\npub struct Error {\n    message: CString,\n}\n\nimpl Error {\n    pub fn new(message: \u0026str) -\u003e Error {\n        Error {\n            message: CString::new(message).unwrap_or_default(),\n        }\n    }\n\n    pub fn message(\u0026self) -\u003e \u0026CString {\n        \u0026self.message\n    }\n}\n\ndefine_registry! {Error}\n\n/// A wrapper object containing an error message\npub struct GoslingError;\n\n/// Get error message from gosling_error\n///\n/// @param error: the error object to get the message from\n/// @return null-terminated string with error message whose\n///  lifetime is tied to the source\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_error_get_message(error: *const GoslingError) -\u003e *const c_char {\n    if !error.is_null() {\n        let key = error as usize;\n\n        let registry = get_error_registry();\n        if registry.contains_key(key) {\n            if let Some(x) = registry.get(key) {\n                return x.message().as_ptr();\n            }\n        }\n    }\n\n    std::ptr::null()\n}\n\n/// Copy method for gosling_error\n///\n/// @param out_error: returned copy\n/// @param orig_error: original to copy\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_error_clone(\n    out_error: *mut *mut GoslingError,\n    orig_error: *const GoslingError,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_error);\n        ensure_not_null!(orig_error);\n\n        let orig_error = match get_error_registry().get(orig_error as usize) {\n            Some(orig_error) =\u003e orig_error.clone(),\n            None =\u003e bail_invalid_handle!(orig_error),\n        };\n        let handle = get_error_registry().insert(orig_error);\n        *out_error = handle as *mut GoslingError;\n\n        Ok(())\n    })\n}\n\n/// Frees gosling_error and invalidates any message strings\n/// returned by gosling_error_get_message() from the given\n/// error object.\n///\n/// @param error: the error object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_error_free(error: *mut GoslingError) {\n    impl_registry_free!(error, Error);\n}\n\n/// Wrapper around rust code which may panic or return a failing Result to be used at FFI boundaries.\n/// Converts panics or error Results into GoslingErrors if a memory location is provided.\n///\n/// @param default: The default value to return in the event of failure\n/// @param out_error: A pointer to pointer to GoslingError 'struct' for the C FFI\n/// @param closure: The functionality we need to encapsulate behind the error handling logic\n/// @return The result of closure() on success, or the value of default on failure.\npub(crate) fn translate_failures\u003cR, F\u003e(\n    default: R,\n    out_error: *mut *mut GoslingError,\n    closure: F,\n) -\u003e R\nwhere\n    F: FnOnce() -\u003e anyhow::Result\u003cR\u003e + std::panic::UnwindSafe,\n{\n    match std::panic::catch_unwind(closure) {\n        // handle success\n        Ok(Ok(retval)) =\u003e retval,\n        // handle runtime error\n        Ok(Err(err)) =\u003e {\n            if !out_error.is_null() {\n                // populate error with runtime error message\n                let key = get_error_registry().insert(Error::new(format!(\"{:?}\", err).as_str()));\n                unsafe {\n                    *out_error = key as *mut GoslingError;\n                };\n            }\n            default\n        }\n        // handle panic\n        Err(_) =\u003e {\n            if !out_error.is_null() {\n                // populate error with panic message\n                let key = get_error_registry().insert(Error::new(\"panic occurred\"));\n                unsafe {\n                    *out_error = key as *mut GoslingError;\n                };\n            }\n            default\n        }\n    }\n}\n","traces":[{"line":21,"address":[1679584],"length":1,"stats":{"Line":0}},{"line":23,"address":[1679604],"length":1,"stats":{"Line":0}},{"line":27,"address":[1679648],"length":1,"stats":{"Line":0}},{"line":44,"address":[1679664,1680035],"length":1,"stats":{"Line":0}},{"line":45,"address":[1679681],"length":1,"stats":{"Line":0}},{"line":46,"address":[1679695],"length":1,"stats":{"Line":0}},{"line":48,"address":[1679708],"length":1,"stats":{"Line":0}},{"line":49,"address":[1679827,1679730],"length":1,"stats":{"Line":0}},{"line":50,"address":[1679865],"length":1,"stats":{"Line":0}},{"line":51,"address":[1679948],"length":1,"stats":{"Line":0}},{"line":56,"address":[1679766],"length":1,"stats":{"Line":0}},{"line":66,"address":[1680064],"length":1,"stats":{"Line":0}},{"line":71,"address":[1867568,1868609],"length":1,"stats":{"Line":0}},{"line":72,"address":[1867593],"length":1,"stats":{"Line":0}},{"line":73,"address":[1867610],"length":1,"stats":{"Line":0}},{"line":75,"address":[1867752,1867986],"length":1,"stats":{"Line":0}},{"line":76,"address":[1868277,1868122],"length":1,"stats":{"Line":0}},{"line":79,"address":[1868357],"length":1,"stats":{"Line":0}},{"line":80,"address":[1868525,1868588],"length":1,"stats":{"Line":0}},{"line":82,"address":[1868561],"length":1,"stats":{"Line":0}},{"line":93,"address":[1680305,1680128],"length":1,"stats":{"Line":0}},{"line":104,"address":[1872592,1918428,1949808,1914444,1883979,1878731,1910512,1911823,1924992,1926284,1956352,1931484,1897440,1898331,1951100,1934971,1966363,1885676,1887008,1928876,1936704,1921947,1921052,1876544,1955036,1877419,1937996,1967659,1890908,1919760,1920651,1871280,1939328,1869968,1961556,1945852,1872564,1958956,1894411,1965468,1937595,1879132,1875207,1897420,1892204,1901376,1962860,1961584,1889616,1876524,1930180,1955056,1881360,1903980,1880444,1914043,1915355,1953744,1969372,1889596,1868656,1963771,1910091,1932800,1949387,1912731,1950699,1869547,1959851,1941932,1913132,1919331,1927179,1902267,1907483,1875232,1885275,1884400,1893508,1921072,1932379,1947184,1968060,1918448,1928896,1970684,1940620,1957644,1901356,1965067,1877840,1894832,1945872,1933675,1969392,1896144,1943264,1957243,1971579,1870859,1942843,1961155,1919732,1903579,1873904,1960252,1881792,1890507,1904000,1905312,1943244,1893107,1883084,1881767,1909180,1940219,1957664,1949788,1898752,1900064,1932780,1944155,1956332,1948075,1869948,1964192,1894812,1923259,1886587,1890928,1906588,1922348,1908779,1968080,1948476,1941952,1914464,1947164,1935372,1924571,1900044,1946763,1948496,1970283,1885696,1915756,1952432,1911840,1893536,1936283,1934096,1902688,1929779,1931504,1936684,1965488,1909200,1927580,1952003,1962459,1915776,1951120,1874800,1892224,1968971,1871260,1928475,1960272,1899643,1907884,1922368,1880043,1911416,1964172,1955931,1888300,1926304,1902668,1904891,1907904,1923680,1880464,1873475,1906608,1938907,1876123,1888320,1917152,1884380,1923660,1910492,1958976,1934076,1931083,1935392,1940640,1906187,1966784,1971980,1924972,1900955,1883104,1958555,1966764,1944576,1953724,1872163,1882683,1895723,1939308,1941531,1913152,1873876,1970704,1944556,1962880,1879152,1905292,1953323,1938016,1952404,1891803,1898732,1877820,1918027,1927600,1954635,1896124,1887899,1916722,1925883,1930208,1889195,1917133,1886988,1897019,1945451],"length":1,"stats":{"Line":36}},{"line":112,"address":[],"length":0,"stats":{"Line":72}},{"line":114,"address":[1874080,1888497,1871465,1925185,1963073,1896321,1881985,1919953,1926481,1872777,1883281,1870161,1946065,1902881,1914657,1921249,1935585,1891105,1904193,1893713,1879345,1931681,1878033,1940833,1956545,1910696,1947377,1944753,1892409,1905489,1951305,1960457,1953937,1915998,1952625,1964369,1970881,1887201,1968273,1875425,1909393,1880640,1876721,1898945,1948689,1950001,1966961,1889809,1929081,1927777,1942145,1955233,1908081,1885889,1913345,1918633,1961761,1938209,1922561,1936897,1930385,1957857,1917329,1901569,1939521,1912033,1900257,1932977,1934273,1959153,1895025,1897633,1943457,1923873,1965665,1969585,1868849,1906785,1884577],"length":1,"stats":{"Line":36}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":34},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","ffi.rs"],"content":"// standard\nuse std::sync::atomic::{AtomicBool, Ordering};\n\n// extern crates\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\n\n// internal crates\nuse crate::context::*;\nuse crate::crypto::*;\nuse crate::error::*;\nuse crate::macros::*;\nuse crate::tor_provider::*;\nuse crate::utils::*;\n\n// tags used for types we put in ObjectRegistrys\npub(crate) const ERROR_TAG: usize = 0x1;\npub(crate) const ED25519_PRIVATE_KEY_TAG: usize = 0x2;\npub(crate) const X25519_PRIVATE_KEY_TAG: usize = 0x3;\npub(crate) const X25519_PUBLIC_KEY_TAG: usize = 0x4;\npub(crate) const V3_ONION_SERVICE_ID_TAG: usize = 0x5;\npub(crate) const IP_ADDR_TAG: usize = 0x6;\npub(crate) const TARGET_ADDR_TAG: usize = 0x7;\n#[cfg(feature = \"legacy-tor-provider\")]\npub(crate) const PROXY_CONFIG_TAG: usize = 0x8;\n#[cfg(feature = \"legacy-tor-provider\")]\npub(crate) const PLUGGABLE_TRANSPORT_CONFIG_TAG: usize = 0x9;\n#[cfg(feature = \"legacy-tor-provider\")]\npub(crate) const BRIDGE_LINE_TAG: usize = 0xA;\npub(crate) const TOR_PROVIDER_CONFIG_TAG: usize = 0xB;\npub(crate) const TOR_PROVIDER_TAG: usize = 0xC;\npub(crate) const CONTEXT_TUPLE_TAG: usize = 0xD;\n\n/// A handle for the gosling library\npub struct GoslingLibrary;\n\nstatic GOSLING_LIBRARY_INITED: AtomicBool = AtomicBool::new(false);\nconst GOSLING_LIBRARY_HANDLE: usize = {\n    // integer constant in the form 0x6000..5E (GOOOOOSE)\n    (0x60 \u003c\u003c ((std::mem::size_of::\u003cusize\u003e() - 1) * 8)) + 0x5E\n};\n\n/// Initializes the Gosling library. This function must be called before using any of the\n/// other Gosling functions.\n///\n/// @return: returns 0 on success\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_library_init(\n    out_library: *mut *mut GoslingLibrary,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_library);\n\n        if GOSLING_LIBRARY_INITED.load(Ordering::Relaxed) {\n            // error handling\n            bail!(\"gosling is already initialized\");\n        } else {\n            GOSLING_LIBRARY_INITED.store(true, Ordering::Relaxed);\n            *out_library = GOSLING_LIBRARY_HANDLE as *mut GoslingLibrary;\n        }\n        Ok(())\n    })\n}\n\n/// Frees all resources associated with the Gosling library. No-op if the library\n/// is not initialized or if it has already been freed\n#[no_mangle]\n#[allow(unused_variables)]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_library_free(in_library: *mut GoslingLibrary) {\n    if GOSLING_LIBRARY_INITED.load(Ordering::Relaxed) {\n        clear_error_registry();\n\n        clear_ed25519_private_key_registry();\n        clear_x25519_private_key_registry();\n        clear_x25519_public_key_registry();\n        clear_v3_onion_service_id_registry();\n        clear_ip_addr_registry();\n        clear_target_addr_registry();\n        #[cfg(feature = \"legacy-tor-provider\")]\n        clear_proxy_config_registry();\n        #[cfg(feature = \"legacy-tor-provider\")]\n        clear_pluggable_transport_config_registry();\n        #[cfg(feature = \"legacy-tor-provider\")]\n        clear_bridge_line_registry();\n        clear_tor_provider_registry();\n        clear_tor_provider_config_registry();\n        clear_context_tuple_registry();\n\n        GOSLING_LIBRARY_INITED.store(false, Ordering::Relaxed);\n    }\n}\n","traces":[{"line":50,"address":[1657456],"length":1,"stats":{"Line":1}},{"line":54,"address":[3122384],"length":1,"stats":{"Line":2}},{"line":55,"address":[3122396],"length":1,"stats":{"Line":1}},{"line":57,"address":[3122414],"length":1,"stats":{"Line":1}},{"line":59,"address":[3122603],"length":1,"stats":{"Line":0}},{"line":61,"address":[3122552],"length":1,"stats":{"Line":1}},{"line":62,"address":[3122647,3122675,3122579],"length":1,"stats":{"Line":2}},{"line":64,"address":[1774833],"length":1,"stats":{"Line":1}},{"line":73,"address":[1657504],"length":1,"stats":{"Line":1}},{"line":74,"address":[1657513],"length":1,"stats":{"Line":1}},{"line":75,"address":[1657544],"length":1,"stats":{"Line":1}},{"line":77,"address":[1657549],"length":1,"stats":{"Line":1}},{"line":78,"address":[1657554],"length":1,"stats":{"Line":1}},{"line":79,"address":[1657559],"length":1,"stats":{"Line":1}},{"line":80,"address":[1657564],"length":1,"stats":{"Line":1}},{"line":81,"address":[2962625],"length":1,"stats":{"Line":1}},{"line":82,"address":[1657574],"length":1,"stats":{"Line":1}},{"line":84,"address":[2962635],"length":1,"stats":{"Line":1}},{"line":86,"address":[1657584],"length":1,"stats":{"Line":1}},{"line":88,"address":[1657589],"length":1,"stats":{"Line":1}},{"line":89,"address":[1657594],"length":1,"stats":{"Line":1}},{"line":90,"address":[1657599],"length":1,"stats":{"Line":1}},{"line":91,"address":[1657604],"length":1,"stats":{"Line":1}},{"line":93,"address":[1657609],"length":1,"stats":{"Line":1}}],"covered":23,"coverable":24},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","lib.rs"],"content":"// some internal functions take a lot of args but thats ok\n#![allow(clippy::too_many_arguments)]\n// we don't generate Rust docs since this crate should never be used from\n// Rust, only from languages where the c-ffi is the only option; developers\n// should consult the Doxygen generated docs\n#![allow(clippy::missing_safety_doc)]\n\npub mod callbacks;\npub mod context;\npub mod crypto;\npub mod error;\npub mod ffi;\nmod macros;\nmod object_registry;\npub mod tor_provider;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","macros.rs"],"content":"// implemeents per-type registry types\nmacro_rules! define_registry {\n    ($type:ty) =\u003e {\n        paste::paste! {\n            // ensure tag fits in 4 bits\n            static_assertions::const_assert!([\u003c$type:snake:upper _TAG\u003e] \u003c= 0b1111);\n\n            static [\u003c$type:snake:upper _REGISTRY\u003e]: std::sync::Mutex\u003ccrate::object_registry::ObjectRegistry\u003c$type, { [\u003c$type:snake:upper _TAG\u003e] }, 4\u003e\u003e = std::sync::Mutex::new(crate::object_registry::ObjectRegistry::new());\n\n            pub(crate) fn [\u003cget_ $type:snake _registry\u003e]\u003c'a\u003e() -\u003e std::sync::MutexGuard\u003c'a, crate::object_registry::ObjectRegistry\u003c$type, { [\u003c$type:snake:upper _TAG\u003e] }, 4\u003e\u003e {\n                match [\u003c$type:snake:upper _REGISTRY\u003e].lock() {\n                    Ok(registry) =\u003e registry,\n                    Err(_) =\u003e unreachable!(\"another thread panicked while holding this registry's mutex\"),\n                }\n            }\n\n            pub(crate) fn [\u003cclear_ $type:snake _registry\u003e]() {\n                match [\u003c$type:snake:upper _REGISTRY\u003e].lock() {\n                    Ok(mut registry) =\u003e *registry = crate::object_registry::ObjectRegistry::new(),\n                    Err(_) =\u003e unreachable!(\"another thread panicked while holding this registry's mutex\"),\n                }\n            }\n        }\n    }\n}\npub(crate) use define_registry;\n\n// macro for defining the implementation of freeing objects\n// owned by an ObjectRegistry\nmacro_rules! impl_registry_free {\n    ($obj:expr, $type:ty) =\u003e {\n        if $obj.is_null() {\n            return;\n        }\n\n        let key = $obj as usize;\n        paste::paste! {\n            [\u003cget_ $type:snake _registry\u003e]().remove(key);\n        }\n    };\n}\npub(crate) use impl_registry_free;\n\n//\n// Argument validation macros\n//\n\n// ensure pointer is not null\nmacro_rules! ensure_not_null {\n    ($ptr:ident) =\u003e {\n        paste::paste! {\n            if $ptr.is_null() {\n                bail!(stringify!([\u003c$ptr\u003e] must not be null));\n            }\n        }\n    };\n}\npub(crate) use ensure_not_null;\n\nmacro_rules! ensure_not_equal {\n    ($value:ident, $constant:literal) =\u003e {\n        if $value == $constant {\n            bail!(stringify!([\u003c$value\u003e must not be \u003c$constant\u003e]));\n        }\n    }\n}\npub(crate) use ensure_not_equal;\n\n// bail because handle invalid\nmacro_rules! bail_invalid_handle {\n    ($handle:ident) =\u003e {\n        paste::paste! {\n            bail!(stringify!([\u003c$handle\u003e] is invalid))\n        }\n    };\n}\npub(crate) use bail_invalid_handle;\n","traces":[{"line":10,"address":[1680536,1680352,1680558],"length":1,"stats":{"Line":7}},{"line":11,"address":[1653047,1652343],"length":1,"stats":{"Line":7}},{"line":12,"address":[1652368,1653072],"length":1,"stats":{"Line":7}},{"line":13,"address":[1652467,1653171],"length":1,"stats":{"Line":0}},{"line":17,"address":[1667456,1668864,1669246,1667134,1668607,1668542,1670015,1667199,1669311,1669568,1666752,1667838,1668160,1669950,1667903],"length":1,"stats":{"Line":13}},{"line":18,"address":[1666759,1667463,1668871,1669575,1668167],"length":1,"stats":{"Line":13}},{"line":19,"address":[1652642,1653304,1653636,1652932,1652600,1653346],"length":1,"stats":{"Line":13}},{"line":20,"address":[1680967],"length":1,"stats":{"Line":0}},{"line":32,"address":[1650961,1650782],"length":1,"stats":{"Line":0}},{"line":36,"address":[1650796,1650975],"length":1,"stats":{"Line":0}},{"line":38,"address":[1650809,1651034,1650987,1650853],"length":1,"stats":{"Line":0}},{"line":52,"address":[1643354,1644522,1639986,1639964,1642834,1647018,1644543,1640180,1648242,1637961,1640007,1648263,1647039,1638914,1642370,1649732,1650281,1647004,1638881,1638897,1643340,1643375,1637978,1644508,1645756,1645770,1645791],"length":1,"stats":{"Line":43}},{"line":53,"address":[1639079,1643540,1648443,1640387,1637993,1640025,1645806,1640198,1648278,1649778,1642466,1642975,1638143,1650327,1644554,1643390,1647174,1638929,1647050,1644678,1645956],"length":1,"stats":{"Line":0}},{"line":62,"address":[1750774,1753704,1745111,1753352,1754041,1748647,1747535,1744753,1757699],"length":1,"stats":{"Line":6}},{"line":63,"address":[1745276,1747654,1744918,1754206,1757849,1748766,1753517,1753869,1750936],"length":1,"stats":{"Line":0}},{"line":73,"address":[1649989,1650623,1648696,1640751,1639317,1638474,1646291,1641004,1650086,1640640,1638369,1646186,1643770,1648805,1639422,1643875,1650529,1641109],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":16},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","object_registry.rs"],"content":"// standard\nuse std::collections::BTreeMap;\nuse std::option::Option;\n\n// An ObjectRegistry\u003cT\u003e maintains ownership of objects and maps them to usize keys\n// which can be safely handed out to external consumers as opaque pointer.\n// Keys are represented as a usize; the high bits are a unique identifier (calculated\n// as the number of keys handed out at the time of key creation, but this is an implementation\n// detail) while the low bits are a user-provided tag used to disambiguate keys from different\n// ObjectRegistry's.\n//\n// T: the type we are storing in the registry\n// TAG: a usize constant which occupy the low bits of returned keys\n// TAG_BITS: the number of bits needed to store the tag (the remainder of the usize bits are used\n//   for the unique id portion of the returne dkeys)\npub struct ObjectRegistry\u003cT, const TAG: usize, const TAG_BITS: u32\u003e {\n    // our internal mapping from handles to Ts\n    map: Option\u003cBTreeMap\u003cusize, T\u003e\u003e,\n    // number of Ts registered to this registry over its lifetime\n    counter: usize,\n}\n\n// Rust only supports 8-bit bytes\nconst BITS_PER_BYTE: u32 = 8;\n\nimpl\u003cT, const TAG: usize, const TAG_BITS: u32\u003e ObjectRegistry\u003cT, TAG, TAG_BITS\u003e {\n    // the number of bits available to the counter portion of an object key\n    const COUNTER_BITS: u32 = std::mem::size_of::\u003cusize\u003e() as u32 * BITS_PER_BYTE - TAG_BITS;\n    // the largest value the counter portion of the key can be without rolling over to 0\n    const COUNTER_MAX: usize = !0usize \u003e\u003e TAG_BITS;\n\n    // return the next key to return on successful insertion\n    fn next_key(\u0026mut self) -\u003e usize {\n        assert!(self.counter \u003c Self::COUNTER_MAX);\n        self.counter += 1;\n        (self.counter \u003c\u003c TAG_BITS) | TAG\n    }\n\n    // returns a new empty ObjectRegisry\n    pub const fn new() -\u003e ObjectRegistry\u003cT, TAG, TAG_BITS\u003e {\n        assert!(TAG_BITS == 0 || (TAG \u003c\u003c Self::COUNTER_BITS) \u003e\u003e Self::COUNTER_BITS == TAG);\n\n        ObjectRegistry {\n            map: None,\n            counter: 0,\n        }\n    }\n\n    // determine if the registry has an object with the specified key\n    pub fn contains_key(\u0026self, key: usize) -\u003e bool {\n        match \u0026self.map {\n            Some(map) =\u003e map.contains_key(\u0026key),\n            None =\u003e false,\n        }\n    }\n\n    // remove and return an object with the specified key\n    pub fn remove(\u0026mut self, key: usize) -\u003e Option\u003cT\u003e {\n        match \u0026mut self.map {\n            Some(map) =\u003e map.remove(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    // add object into registry and return key to reference it\n    pub fn insert(\u0026mut self, val: T) -\u003e usize {\n        let key = self.next_key();\n        match \u0026mut self.map {\n            Some(map) =\u003e {\n                if map.insert(key, val).is_some() {\n                    panic!();\n                }\n            }\n            None =\u003e {\n                let mut map = BTreeMap::new();\n                map.insert(key, val);\n                self.map = Some(map);\n            }\n        }\n        key\n    }\n\n    // gets a reference to a value by the given key\n    pub fn get(\u0026self, key: usize) -\u003e Option\u003c\u0026T\u003e {\n        match \u0026self.map {\n            Some(map) =\u003e map.get(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    // gets a mutable reference to a value by the given key\n    pub fn get_mut(\u0026mut self, key: usize) -\u003e Option\u003c\u0026mut T\u003e {\n        match \u0026mut self.map {\n            Some(map) =\u003e map.get_mut(\u0026key),\n            None =\u003e None,\n        }\n    }\n\n    #[cfg(test)]\n    // gets just the tag portion of a key assuming it came from\n    // this registry\n    fn get_tag_from_key(\u0026self, key: usize) -\u003e usize {\n        // zero out the counter bits and return tag\n        (key \u003c\u003c Self::COUNTER_BITS) \u003e\u003e Self::COUNTER_BITS\n    }\n\n    #[cfg(test)]\n    // gets the counter portion of a key assuming it came from\n    // this registry\n    fn get_counter_from_key(\u0026self, key: usize) -\u003e usize {\n        // rotate out the tag bits\n        key \u003e\u003e TAG_BITS\n    }\n\n    #[cfg(test)]\n    // calculate the key given the counter assuming it would be used\n    // by this registry\n    fn get_key_from_counter(\u0026self, counter: usize) -\u003e usize {\n        (counter \u003c\u003c TAG_BITS) | TAG\n    }\n}\n\n#[test]\nfn test_object_registry() -\u003e anyhow::Result\u003c()\u003e {\n    // create a new ObjectRegistry\n    type Int32Registry0_16 = ObjectRegistry\u003ci32, 1234usize, 16\u003e;\n    let mut registry = Int32Registry0_16::new();\n    assert_eq!(\n        Int32Registry0_16::COUNTER_BITS,\n        std::mem::size_of::\u003cusize\u003e() as u32 * BITS_PER_BYTE - 16\n    );\n\n    // add some objects to the registry and get their keys\n    let key1 = registry.insert(10);\n    let key2 = registry.insert(20);\n    let key3 = registry.insert(30);\n\n    // check that the registry contains the keys we just added\n    assert!(registry.contains_key(key1));\n    assert!(registry.contains_key(key2));\n    assert!(registry.contains_key(key3));\n\n    // check that we can get the objects back using their keys\n    assert_eq!(registry.get(key1), Some(\u002610));\n    assert_eq!(registry.get(key2), Some(\u002620));\n    assert_eq!(registry.get(key3), Some(\u002630));\n\n    // check that we can get mutable references to the objects and modify them\n    let obj = registry.get_mut(key1).unwrap();\n    *obj = 100;\n    assert_eq!(registry.get(key1), Some(\u0026100));\n\n    // check that we can remove objects from the registry and they are no longer contained\n    let obj = registry.remove(key2).unwrap();\n    assert_eq!(obj, 20);\n    assert!(!registry.contains_key(key2));\n\n    // check that the tag bits of the keys match the TAG constant we provided\n    assert_eq!(registry.get_tag_from_key(key1), 1234usize);\n    assert_eq!(registry.get_tag_from_key(key2), 1234usize);\n    assert_eq!(registry.get_tag_from_key(key3), 1234usize);\n\n    // check that the counter bits of the keys are unique and increasing\n    let counter1 = registry.get_counter_from_key(key1);\n    let counter2 = registry.get_counter_from_key(key2);\n    let counter3 = registry.get_counter_from_key(key3);\n    assert!(counter1 \u003c counter2 \u0026\u0026 counter2 \u003c counter3);\n\n    // check that we can calculate the key given the counter and it matches the key we got from insert()\n    assert_eq!(registry.get_key_from_counter(1), key1);\n    assert_eq!(registry.get_key_from_counter(2), key2);\n    assert_eq!(registry.get_key_from_counter(3), key3);\n\n    Ok(())\n}\n\n#[test]\nfn test_object_registry_key_collision() -\u003e anyhow::Result\u003c()\u003e {\n    // create two registries with different TAG values\n    let mut registry_a: ObjectRegistry\u003cString, 1usize, 8\u003e = ObjectRegistry::new();\n    let mut registry_b: ObjectRegistry\u003cString, 2usize, 8\u003e = ObjectRegistry::new();\n\n    // insert objects into the registries\n    let key_a_1 = registry_a.insert(\"a1\".to_string());\n    let key_a_2 = registry_a.insert(\"a2\".to_string());\n    let key_b_1 = registry_b.insert(\"b1\".to_string());\n    let key_b_2 = registry_b.insert(\"b2\".to_string());\n\n    // counter portions should be the same\n    assert_eq!(\n        registry_a.get_counter_from_key(key_a_1),\n        registry_b.get_counter_from_key(key_b_1)\n    );\n    assert_eq!(\n        registry_a.get_counter_from_key(key_a_2),\n        registry_b.get_counter_from_key(key_b_2)\n    );\n\n    // ensure the keys do not collide\n    assert!(key_a_1 != key_b_1);\n    assert!(key_a_2 != key_b_2);\n    assert!(key_a_1 != key_b_2);\n    assert!(key_a_2 != key_b_1);\n\n    Ok(())\n}\n#[test]\nfn test_object_registry_empty_tag() -\u003e anyhow::Result\u003c()\u003e {\n    // create a registry with tag 0 and tag bits 0\n    let mut reg = ObjectRegistry::\u003ci32, 0, 0\u003e::new();\n\n    // add some values and check their keys\n    let key1 = reg.insert(1);\n    let key2 = reg.insert(2);\n    assert_eq!(key1, 1);\n    assert_eq!(key2, 2);\n\n    Ok(())\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":11}},{"line":34,"address":[],"length":0,"stats":{"Line":11}},{"line":35,"address":[],"length":0,"stats":{"Line":11}},{"line":36,"address":[],"length":0,"stats":{"Line":11}},{"line":40,"address":[],"length":0,"stats":{"Line":17}},{"line":41,"address":[],"length":0,"stats":{"Line":16}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":67,"address":[],"length":0,"stats":{"Line":22}},{"line":68,"address":[],"length":0,"stats":{"Line":11}},{"line":69,"address":[],"length":0,"stats":{"Line":11}},{"line":70,"address":[],"length":0,"stats":{"Line":22}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":11}},{"line":76,"address":[],"length":0,"stats":{"Line":20}},{"line":77,"address":[],"length":0,"stats":{"Line":11}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}}],"covered":32,"coverable":39},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","tor_provider.rs"],"content":"// standard\n#[cfg(feature = \"legacy-tor-provider\")]\nuse std::os::raw::c_char;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse std::path::Path;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse std::str::FromStr;\n\n// extern crates\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse tor_interface::censorship_circumvention::*;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse tor_interface::legacy_tor_client::*;\n#[cfg(feature = \"mock-tor-provider\")]\nuse tor_interface::mock_tor_client::*;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse tor_interface::proxy::*;\nuse tor_interface::*;\n\n// internal crates\nuse crate::error::*;\nuse crate::ffi::*;\nuse crate::macros::*;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse crate::utils::*;\n\n/// Proxy settings object used by tor provider to connect to the tor network\n#[cfg(feature = \"legacy-tor-provider\")]\npub struct GoslingProxyConfig;\n#[cfg(feature = \"legacy-tor-provider\")]\ndefine_registry! {ProxyConfig}\n\n/// Pluggable transports settings object used by tor provider to launch pluggable transports\n#[cfg(feature = \"legacy-tor-provider\")]\npub struct GoslingPluggableTransportConfig;\n#[cfg(feature = \"legacy-tor-provider\")]\ndefine_registry! {PluggableTransportConfig}\n\n/// Bridge line to use with particular pluggable transport when connecting to the tor network\n#[cfg(feature = \"legacy-tor-provider\")]\npub struct GoslingBridgeLine;\n#[cfg(feature = \"legacy-tor-provider\")]\ndefine_registry! {BridgeLine}\n\n/// A tor provider config object used to construct a tor provider\npub struct GoslingTorProviderConfig;\npub(crate) enum TorProviderConfig {\n    #[cfg(feature = \"mock-tor-provider\")]\n    MockTorClientConfig,\n    #[cfg(feature = \"legacy-tor-provider\")]\n    LegacyTorClientConfig(tor_interface::legacy_tor_client::LegacyTorClientConfig),\n}\ndefine_registry! {TorProviderConfig}\n\n/// A tor provider object used by a context to connect to the tor network\npub struct GoslingTorProvider;\n/// cbindgen:ignore\ntype TorProvider = Box\u003cdyn tor_provider::TorProvider\u003e;\ndefine_registry! {TorProvider}\n\n//\n// Memory freeing functions\n//\n\n/// Frees a gosling_proxy_config\n///\n/// @param in_proxy: the proxy settings object to free\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_proxy_config_free(in_proxy_config: *mut GoslingProxyConfig) {\n    impl_registry_free!(in_proxy_config, ProxyConfig);\n}\n\n/// Frees a gosling_pluggable_transport_config\n///\n/// @param in_pluggable_transport: the pluggable transport object to free\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_pluggable_transport_config_free(\n    in_pluggable_transport_config: *mut GoslingPluggableTransportConfig,\n) {\n    impl_registry_free!(in_pluggable_transport_config, PluggableTransportConfig);\n}\n\n/// Frees a gosling_bridge_line\n///\n/// @param in_bridge_line: the bridge line object to free\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_bridge_line_free(in_bridge_line: *mut GoslingBridgeLine) {\n    impl_registry_free!(in_bridge_line, BridgeLine);\n}\n\n/// Frees a gosling_tor_provider_config\n///\n/// @param in_tor_provider_config: the tor provider config object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_tor_provider_config_free(\n    in_tor_provider_config: *mut GoslingTorProviderConfig,\n) {\n    impl_registry_free!(in_tor_provider_config, TorProviderConfig);\n}\n\n/// Frees a gosling_tor_provider object\n///\n/// @param in_tor_provider: the tor provider object to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_tor_provider_free(in_tor_provider: *mut GoslingTorProvider) {\n    impl_registry_free!(in_tor_provider, TorProvider);\n}\n\n//\n// Proxy\n//\n\n/// Create a socks4 proxy definition\n///\n/// @param out_proxy_config: returned proxy config object\n/// @param proxy_address: the host address of the proxy, must not be an onion service\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_proxy_config_new_socks4(\n    out_proxy_config: *mut *mut GoslingProxyConfig,\n    proxy_address: *const GoslingTargetAddress,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_proxy_config);\n        ensure_not_null!(proxy_address);\n\n        let proxy_address = match get_target_addr_registry().get(proxy_address as usize) {\n            Some(target_address) =\u003e target_address.clone(),\n            None =\u003e bail_invalid_handle!(proxy_address),\n        };\n        let proxy_config = Socks4ProxyConfig::new(proxy_address)?;\n\n        let handle = get_proxy_config_registry().insert(proxy_config.into());\n        *out_proxy_config = handle as *mut GoslingProxyConfig;\n\n        Ok(())\n    });\n}\n\n/// Create a socks5 proxy definition\n///\n/// @param out_proxy: returned proxy config object\n/// @param proxy_address: the host address of the proxy, must not be an onion service\n/// @param username: username to authenticate with socks5 proxy\n/// @param username_length: number of characters in username, not counting any null-\n///  terminator\n/// @param password: password to authenticate with socks5 proxy\n/// @param password_length: number of characters in username, not counting any null-\n///  terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_proxy_config_new_socks5(\n    out_proxy_config: *mut *mut GoslingProxyConfig,\n    proxy_address: *const GoslingTargetAddress,\n    username: *const c_char,\n    username_length: usize,\n    password: *const c_char,\n    password_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_proxy_config);\n        ensure_not_null!(proxy_address);\n\n        let proxy_address = match get_target_addr_registry().get(proxy_address as usize) {\n            Some(target_address) =\u003e target_address.clone(),\n            None =\u003e bail_invalid_handle!(proxy_address),\n        };\n\n        let username = if username.is_null() || username_length == 0 {\n            None\n        } else {\n            let username = std::slice::from_raw_parts(username as *const u8, username_length);\n            let username = std::str::from_utf8(username)?;\n            Some(username.to_string())\n        };\n\n        let password = if password.is_null() || password_length == 0 {\n            None\n        } else {\n            let password = std::slice::from_raw_parts(password as *const u8, password_length);\n            let password = std::str::from_utf8(password)?;\n            Some(password.to_string())\n        };\n\n        let proxy_config = Socks5ProxyConfig::new(proxy_address, username, password)?;\n\n        let handle = get_proxy_config_registry().insert(proxy_config.into());\n        *out_proxy_config = handle as *mut GoslingProxyConfig;\n\n        Ok(())\n    });\n}\n\n/// Create a https proxy definition\n///\n/// @param out_proxy_config: returned proxy config object\n/// @param proxy_address: the host address of the proxy, must not be an onion service\n/// @param username: username to authenticate with https proxy\n/// @param username_length: number of characters in username, not counting any null-\n///  terminator\n/// @param password: password to authenticate with https proxy\n/// @param password_length: number of characters in username, not counting any null-\n///  terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_proxy_config_new_https(\n    out_proxy_config: *mut *mut GoslingProxyConfig,\n    proxy_address: *const GoslingTargetAddress,\n    username: *const c_char,\n    username_length: usize,\n    password: *const c_char,\n    password_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_proxy_config);\n        ensure_not_null!(proxy_address);\n\n        let proxy_address = match get_target_addr_registry().get(proxy_address as usize) {\n            Some(target_address) =\u003e target_address.clone(),\n            None =\u003e bail_invalid_handle!(proxy_address),\n        };\n\n        let username = if username.is_null() || username_length == 0 {\n            None\n        } else {\n            let username = std::slice::from_raw_parts(username as *const u8, username_length);\n            let username = std::str::from_utf8(username)?;\n            Some(username.to_string())\n        };\n\n        let password = if password.is_null() || password_length == 0 {\n            None\n        } else {\n            let password = std::slice::from_raw_parts(password as *const u8, password_length);\n            let password = std::str::from_utf8(password)?;\n            Some(password.to_string())\n        };\n\n        let proxy_config = HttpsProxyConfig::new(proxy_address, username, password)?;\n\n        let handle = get_proxy_config_registry().insert(proxy_config.into());\n        *out_proxy_config = handle as *mut GoslingProxyConfig;\n\n        Ok(())\n    });\n}\n\n//\n// Pluggable Transport\n//\n\n/// Create a new pluggable transport config object\n///\n/// @param out_pluggable_transport_config: returned pluggable transport object\n/// @param transports: comma-delimited list of transports this pluggable transport\n///  supports\n/// @param transports_length: number of characters in transports, not counting any\n///  null-terminator\n/// @param path_to_binary: path to the pluggable transport binary, either absolute or\n///  relative to the tor daemon process\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_pluggable_transport_config_new(\n    out_pluggable_transport_config: *mut *mut GoslingPluggableTransportConfig,\n    transports: *const c_char,\n    transports_length: usize,\n    path_to_binary: *const c_char,\n    path_to_binary_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_pluggable_transport_config);\n        ensure_not_null!(transports);\n        ensure_not_equal!(transports_length, 0);\n        ensure_not_null!(path_to_binary);\n        ensure_not_equal!(path_to_binary_length, 0);\n\n        let transports = std::slice::from_raw_parts(transports as *const u8, transports_length);\n        let transports = std::str::from_utf8(transports)?;\n        let transports: Vec\u003cString\u003e = transports.split(',').map(|s| s.to_string()).collect();\n\n        let path_to_binary =\n            std::slice::from_raw_parts(path_to_binary as *const u8, path_to_binary_length);\n        let path_to_binary = std::str::from_utf8(path_to_binary)?;\n        let path_to_binary = Path::new(path_to_binary);\n        path_to_binary.canonicalize()?;\n\n        let pluggable_transport_config =\n            PluggableTransportConfig::new(transports, path_to_binary.into())?;\n        let handle = get_pluggable_transport_config_registry().insert(pluggable_transport_config);\n        *out_pluggable_transport_config = handle as *mut GoslingPluggableTransportConfig;\n\n        Ok(())\n    })\n}\n\n/// Add a command-line option to be used when launching the pluggable transport\n///\n/// @param pluggable_transport_config: the pluggable transport ocnfig object to update\n/// @param option: cmd-line option or flag to pass to the pluggable transport on launch\n/// @param option_length: number of characters in option, not counting any null-\n///  terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_pluggable_transport_config_add_cmdline_option(\n    pluggable_transport_config: *mut GoslingPluggableTransportConfig,\n    option: *const c_char,\n    option_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(pluggable_transport_config);\n        ensure_not_null!(option);\n        ensure_not_equal!(option_length, 0);\n\n        let option = std::slice::from_raw_parts(option as *const u8, option_length);\n        let option = std::str::from_utf8(option)?;\n\n        match get_pluggable_transport_config_registry().get_mut(pluggable_transport_config as usize)\n        {\n            Some(config) =\u003e config.add_option(option.to_string()),\n            None =\u003e bail_invalid_handle!(pluggable_transport_config),\n        }\n\n        Ok(())\n    });\n}\n\n//\n// Bridge Line\n//\n\n/// Construct bridge line from string\n///\n/// @param out_bridge_line: returned bridge line object\n/// @param bridge_line: a bridge address to connect to using a pluggable transport. For\n///  more information, see: https://tb-manual.torproject.org/bridges/\n/// @param bridge_line_length: number of characters in bridge_line, not counting any\n///  null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_bridge_line_from_string(\n    out_bridge_line: *mut *mut GoslingBridgeLine,\n    bridge_line: *const c_char,\n    bridge_line_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_bridge_line);\n        ensure_not_null!(bridge_line);\n        ensure_not_equal!(bridge_line_length, 0);\n\n        let bridge_line = std::slice::from_raw_parts(bridge_line as *const u8, bridge_line_length);\n        let bridge_line = std::str::from_utf8(bridge_line)?;\n        let bridge_line = BridgeLine::from_str(bridge_line)?;\n\n        let handle = get_bridge_line_registry().insert(bridge_line);\n        *out_bridge_line = handle as *mut GoslingBridgeLine;\n\n        Ok(())\n    });\n}\n\n//\n// Tor Provider Config Construction Functions\n//\n\n/// Create a tor provider config to build a mock no-internet tor provider for testing.\n///\n/// @param out_tor_provider: returned tor provider\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"mock-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_config_new_mock_client_config(\n    out_tor_provider_config: *mut *mut GoslingTorProviderConfig,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_tor_provider_config);\n\n        let handle =\n            get_tor_provider_config_registry().insert(TorProviderConfig::MockTorClientConfig);\n        *out_tor_provider_config = handle as *mut GoslingTorProviderConfig;\n\n        Ok(())\n    });\n}\n\n/// Create a tor provider config to build a bundled legacy tor daemon.\n///\n/// @param out_tor_provider_config: returned tor provider config\n/// @param tor_bin_path: the file system path to the tor binary; if this is null the tor executable\n///  found in the system PATH variable is used\n/// @param tor_bin_path_length: the number of chars in tor_bin_path not including any null terminator\n/// @param tor_working_directory: the file system path to store tor's data\n/// @param tor_working_directory_length: the number of chars in tor_working_directory not including any\n///  null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_config_new_bundled_legacy_client_config(\n    out_tor_provider_config: *mut *mut GoslingTorProviderConfig,\n    tor_bin_path: *const c_char,\n    tor_bin_path_length: usize,\n    tor_working_directory: *const c_char,\n    tor_working_directory_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_tor_provider_config);\n        if tor_bin_path.is_null() \u0026\u0026 tor_bin_path_length != 0 {\n            bail!(\"tor_bin_path is null so tor_bin_path_length must be 0\");\n        }\n        if !tor_bin_path.is_null() \u0026\u0026 tor_bin_path_length == 0 {\n            bail!(\"tor_bin_path is not null so tor_bin_path_length must be greater than 0\");\n        }\n        ensure_not_null!(tor_working_directory);\n        ensure_not_equal!(tor_working_directory_length, 0);\n\n        // tor bin\n        let tor_bin_path = if tor_bin_path.is_null() {\n            which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?\n        } else {\n            let tor_bin_path =\n                std::slice::from_raw_parts(tor_bin_path as *const u8, tor_bin_path_length);\n            let tor_bin_path = std::str::from_utf8(tor_bin_path)?;\n            let tor_bin_path = Path::new(tor_bin_path);\n            tor_bin_path.canonicalize()?\n        };\n\n        // tor working dir\n        let tor_working_directory = std::slice::from_raw_parts(\n            tor_working_directory as *const u8,\n            tor_working_directory_length,\n        );\n        let tor_working_directory = std::str::from_utf8(tor_working_directory)?;\n        let tor_working_directory = Path::new(tor_working_directory).to_path_buf();\n        let tor_config = LegacyTorClientConfig::BundledTor {\n            tor_bin_path: tor_bin_path,\n            data_directory: tor_working_directory,\n            proxy_settings: None,\n            allowed_ports: None,\n            pluggable_transports: None,\n            bridge_lines: None,\n        };\n\n        let handle = get_tor_provider_config_registry()\n            .insert(TorProviderConfig::LegacyTorClientConfig(tor_config));\n        *out_tor_provider_config = handle as *mut GoslingTorProviderConfig;\n\n        Ok(())\n    });\n}\n\n/// Create a tor provider config to build a system legacy tor daemon\n///\n/// @param out_tor_provider_config: returned tor provider config\n/// @param tor_socks_host: tor daemon socks server host\n/// @param tor_socks_port: tor daemon socks server port\n/// @param tor_control_host: tor daemon control host\n/// @param tor_control_port: tor daemon control port\n/// @param tor_control_passwd: authentication password\n/// @param tor_control_passwd_length: the number of chars in tor_control_password not\n///  including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_config_new_system_legacy_client_config(\n    out_tor_provider_config: *mut *mut GoslingTorProviderConfig,\n    tor_socks_host: *const GoslingIpAddress,\n    tor_socks_port: u16,\n    tor_control_host: *const GoslingIpAddress,\n    tor_control_port: u16,\n    tor_control_passwd: *const c_char,\n    tor_control_passwd_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_tor_provider_config);\n        ensure_not_null!(tor_socks_host);\n        ensure_not_equal!(tor_socks_port, 0);\n        ensure_not_null!(tor_control_host);\n        ensure_not_equal!(tor_control_port, 0);\n        ensure_not_null!(tor_control_passwd);\n        ensure_not_equal!(tor_control_passwd_length, 0);\n\n        // constructor tor_socks_addr\n        let tor_socks_host = match get_ip_addr_registry().get(tor_socks_host as usize) {\n            Some(tor_socks_host) =\u003e tor_socks_host.clone(),\n            None =\u003e bail_invalid_handle!(tor_socks_host),\n        };\n        let tor_socks_addr = std::net::SocketAddr::new(tor_socks_host, tor_socks_port);\n\n        // construct tor_control_addr\n        let tor_control_host = match get_ip_addr_registry().get(tor_control_host as usize) {\n            Some(tor_control_host) =\u003e tor_control_host.clone(),\n            None =\u003e bail_invalid_handle!(tor_control_host),\n        };\n        let tor_control_addr = std::net::SocketAddr::new(tor_control_host, tor_control_port);\n\n        // construct tor_control_password\n        let tor_control_passwd =\n            std::slice::from_raw_parts(tor_control_passwd as *const u8, tor_control_passwd_length);\n        let tor_control_passwd = std::str::from_utf8(tor_control_passwd)?.to_string();\n\n        let tor_config = LegacyTorClientConfig::SystemTor {\n            tor_socks_addr,\n            tor_control_addr,\n            tor_control_passwd,\n        };\n\n        let handle = get_tor_provider_config_registry()\n            .insert(TorProviderConfig::LegacyTorClientConfig(tor_config));\n        *out_tor_provider_config = handle as *mut GoslingTorProviderConfig;\n\n        Ok(())\n    });\n}\n\n//\n// Tor Provider Config Modification Functions\n//\n\n/// Set a tor provider config's proxy configuration. A tor provider config\n/// does not need to support proxy configuration, so this function may fail\n/// as a result. The currently supported tor provider configs are:\n/// - Legacy Bundled Client\n///\n/// @param tor_provider_config: the tor provider config to update\n/// @param proxy_config: the proxy configuration to use; must not be null\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_config_set_proxy_config(\n    tor_provider_config: *mut GoslingTorProviderConfig,\n    proxy_config: *const GoslingProxyConfig,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(tor_provider_config);\n        ensure_not_null!(proxy_config);\n\n        match get_tor_provider_config_registry().get_mut(tor_provider_config as usize) {\n            Some(tor_provider_config) =\u003e match tor_provider_config {\n                TorProviderConfig::LegacyTorClientConfig(LegacyTorClientConfig::BundledTor {\n                    proxy_settings,\n                    ..\n                }) =\u003e {\n                    *proxy_settings = match get_proxy_config_registry().get(proxy_config as usize) {\n                        Some(proxy_config) =\u003e Some(proxy_config.clone()),\n                        None =\u003e bail_invalid_handle!(proxy_config),\n                    };\n                }\n                _ =\u003e bail!(\"tor_provider_config does not support this operation\"),\n            },\n            None =\u003e bail_invalid_handle!(tor_provider_config),\n        }\n\n        Ok(())\n    })\n}\n\n/// Set a tor provider config's allowed ports list. A tor provider config does\n/// not need to support a port allow-list, so this function may fail as a result.\n/// The currently supported tor provider configs are:\n/// - Legacy Bundled Client\n///\n/// @param tor_provider_config: the tor provider config to update\n/// @param allowed_ports: an array of ports the local system's firewall allows\n///  connections to; must not be null\n/// @param allowed_ports_count: the number of ports in the allowed_ports array; must\n///  not be 0\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_config_set_allowed_ports(\n    tor_provider_config: *mut GoslingTorProviderConfig,\n    allowed_ports: *const u16,\n    allowed_ports_count: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(tor_provider_config);\n        ensure_not_null!(allowed_ports);\n        ensure_not_equal!(allowed_ports_count, 0);\n\n        let allowed_ports_slice =\n            std::slice::from_raw_parts(allowed_ports as *const u16, allowed_ports_count);\n        match get_tor_provider_config_registry().get_mut(tor_provider_config as usize) {\n            Some(tor_provider_config) =\u003e match tor_provider_config {\n                TorProviderConfig::LegacyTorClientConfig(LegacyTorClientConfig::BundledTor {\n                    allowed_ports,\n                    ..\n                }) =\u003e {\n                    *allowed_ports = Some(allowed_ports_slice.into());\n                }\n                _ =\u003e bail!(\"tor_provider_config does not support this operation\"),\n            },\n            None =\u003e bail_invalid_handle!(tor_provider_config),\n        }\n\n        Ok(())\n    })\n}\n/// Add a pluggable transport config to a tor provider config. A tor provider config\n/// does not need to support pluggable transport configuration, so this function may\n/// fail as a result. The currently supported tor provider configs are:\n/// - Legacy Bundled Client\n///\n/// This function may be called multiple times allowing a tor provider config to be\n/// configured with multiple pluggable-transports.\n///\n/// @param tor_provider_config: the tor provider config to update\n/// @param pluggable_transport_config: the pluggable transport config to add to the tor\n///  provider config; must not be null\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_config_add_pluggable_transport_config(\n    tor_provider_config: *mut GoslingTorProviderConfig,\n    pluggable_transport_config: *const GoslingPluggableTransportConfig,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(tor_provider_config);\n        ensure_not_null!(pluggable_transport_config);\n\n        match get_tor_provider_config_registry().get_mut(tor_provider_config as usize) {\n            Some(tor_provider_config) =\u003e match tor_provider_config {\n                TorProviderConfig::LegacyTorClientConfig(LegacyTorClientConfig::BundledTor {\n                    pluggable_transports,\n                    ..\n                }) =\u003e {\n                    let pluggable_transport_config = match get_pluggable_transport_config_registry()\n                        .get(pluggable_transport_config as usize)\n                    {\n                        Some(pluggable_transport_config) =\u003e pluggable_transport_config.clone(),\n                        None =\u003e bail_invalid_handle!(pluggable_transport_config),\n                    };\n\n                    match pluggable_transports {\n                        None =\u003e *pluggable_transports = Some(vec![pluggable_transport_config]),\n                        Some(pluggable_transports) =\u003e {\n                            pluggable_transports.push(pluggable_transport_config)\n                        }\n                    }\n                }\n                _ =\u003e bail!(\"tor_provider_config does not support this operation\"),\n            },\n            None =\u003e bail_invalid_handle!(tor_provider_config),\n        }\n\n        Ok(())\n    })\n}\n\n/// Add a pluggable transport config to a tor provider config. A tor provider config\n/// does not need to support pluggable transport configuration, so this function may\n/// fail as a result. The currently supported tor provider configs are:\n/// - Legacy Bundled Client\n///\n/// This function may be called multiple times allowing a tor provider config to be\n/// configured with multiple pluggable-transports.\n///\n/// @param tor_provider_config: the tor provider config to update\n/// @param pluggable_transport_config: the pluggabel transport config to add to the tor\n///  provider config\n/// @param error: filled on error\n#[no_mangle]\n#[cfg(feature = \"legacy-tor-provider\")]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_config_add_bridge_line(\n    tor_provider_config: *mut GoslingTorProviderConfig,\n    bridge_line: *const GoslingBridgeLine,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(tor_provider_config);\n        ensure_not_null!(bridge_line);\n\n        match get_tor_provider_config_registry().get_mut(tor_provider_config as usize) {\n            Some(tor_provider_config) =\u003e match tor_provider_config {\n                TorProviderConfig::LegacyTorClientConfig(LegacyTorClientConfig::BundledTor {\n                    bridge_lines,\n                    ..\n                }) =\u003e {\n                    let bridge_line = match get_bridge_line_registry().get(bridge_line as usize) {\n                        Some(bridge_line) =\u003e bridge_line.clone(),\n                        None =\u003e bail_invalid_handle!(bridge_line),\n                    };\n\n                    match bridge_lines {\n                        None =\u003e *bridge_lines = Some(vec![bridge_line]),\n                        Some(bridge_lines) =\u003e bridge_lines.push(bridge_line),\n                    }\n                }\n                _ =\u003e bail!(\"tor_provider_config does not support this operation\"),\n            },\n            None =\u003e bail_invalid_handle!(tor_provider_config),\n        }\n\n        Ok(())\n    })\n}\n\n/// Create a tor provider from the provided tor provider config.\n///\n/// @param out_tor_provider: returned tor provider\n/// @param tor_provider_config: tor provider configuration\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_tor_provider_from_tor_provider_config(\n    out_tor_provider: *mut *mut GoslingTorProvider,\n    tor_provider_config: *const GoslingTorProviderConfig,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_tor_provider);\n        ensure_not_null!(tor_provider_config);\n\n        let tor_provider: Box\u003cdyn tor_provider::TorProvider\u003e =\n            match get_tor_provider_config_registry().get(tor_provider_config as usize) {\n                Some(tor_provider_config) =\u003e match tor_provider_config {\n                    #[cfg(feature = \"mock-tor-provider\")]\n                    TorProviderConfig::MockTorClientConfig =\u003e {\n                        let tor_provider: MockTorClient = Default::default();\n                        Box::new(tor_provider)\n                    }\n                    #[cfg(feature = \"legacy-tor-provider\")]\n                    TorProviderConfig::LegacyTorClientConfig(legacy_tor_config) =\u003e {\n                        let tor_provider: LegacyTorClient =\n                            LegacyTorClient::new(legacy_tor_config.clone())?;\n                        Box::new(tor_provider)\n                    }\n                },\n                None =\u003e bail_invalid_handle!(tor_provider_config),\n            };\n\n        let handle = get_tor_provider_registry().insert(tor_provider);\n        *out_tor_provider = handle as *mut GoslingTorProvider;\n\n        Ok(())\n    });\n}\n","traces":[{"line":74,"address":[1664383,1664192],"length":1,"stats":{"Line":0}},{"line":84,"address":[1664416,1664585],"length":1,"stats":{"Line":0}},{"line":96,"address":[1664608,1664795],"length":1,"stats":{"Line":0}},{"line":105,"address":[1664832,1665017],"length":1,"stats":{"Line":0}},{"line":116,"address":[1665040,1665217],"length":1,"stats":{"Line":0}},{"line":132,"address":[1665248],"length":1,"stats":{"Line":0}},{"line":137,"address":[1737216,1738715,1738769],"length":1,"stats":{"Line":0}},{"line":138,"address":[1737249],"length":1,"stats":{"Line":0}},{"line":139,"address":[1737266],"length":1,"stats":{"Line":0}},{"line":141,"address":[1737399,1737633],"length":1,"stats":{"Line":0}},{"line":142,"address":[1737904,1737769],"length":1,"stats":{"Line":0}},{"line":145,"address":[1737968,1738272,1738751],"length":1,"stats":{"Line":0}},{"line":147,"address":[1738256,1738384],"length":1,"stats":{"Line":0}},{"line":148,"address":[1738613,1738681],"length":1,"stats":{"Line":0}},{"line":150,"address":[1738649],"length":1,"stats":{"Line":0}},{"line":168,"address":[1665312],"length":1,"stats":{"Line":0}},{"line":177,"address":[1665354],"length":1,"stats":{"Line":0}},{"line":178,"address":[1738855],"length":1,"stats":{"Line":0}},{"line":179,"address":[1738878],"length":1,"stats":{"Line":0}},{"line":181,"address":[1739300,1739049],"length":1,"stats":{"Line":0}},{"line":182,"address":[1739441,1739579],"length":1,"stats":{"Line":0}},{"line":186,"address":[1739651,1739723],"length":1,"stats":{"Line":0}},{"line":187,"address":[1739697],"length":1,"stats":{"Line":0}},{"line":189,"address":[1739736],"length":1,"stats":{"Line":0}},{"line":190,"address":[1739797,1739901,1740047],"length":1,"stats":{"Line":0}},{"line":191,"address":[1739894,1739960],"length":1,"stats":{"Line":0}},{"line":194,"address":[1740127,1740169,1740024],"length":1,"stats":{"Line":0}},{"line":195,"address":[1740151],"length":1,"stats":{"Line":0}},{"line":197,"address":[1740182],"length":1,"stats":{"Line":0}},{"line":198,"address":[1740649,1740347,1740243],"length":1,"stats":{"Line":0}},{"line":199,"address":[1740409,1740340],"length":1,"stats":{"Line":0}},{"line":202,"address":[1741533,1740986,1740692,1740457],"length":1,"stats":{"Line":0}},{"line":204,"address":[1740970,1741098],"length":1,"stats":{"Line":0}},{"line":205,"address":[1741460,1741383],"length":1,"stats":{"Line":0}},{"line":207,"address":[1741417],"length":1,"stats":{"Line":0}},{"line":225,"address":[1665440],"length":1,"stats":{"Line":0}},{"line":234,"address":[1665482],"length":1,"stats":{"Line":0}},{"line":235,"address":[1741703],"length":1,"stats":{"Line":0}},{"line":236,"address":[1741726],"length":1,"stats":{"Line":0}},{"line":238,"address":[1741897,1742148],"length":1,"stats":{"Line":0}},{"line":239,"address":[1742427,1742289],"length":1,"stats":{"Line":0}},{"line":243,"address":[1742499,1742571],"length":1,"stats":{"Line":0}},{"line":244,"address":[1742545],"length":1,"stats":{"Line":0}},{"line":246,"address":[1742584],"length":1,"stats":{"Line":0}},{"line":247,"address":[1742645,1742749,1742895],"length":1,"stats":{"Line":0}},{"line":248,"address":[1742808,1742742],"length":1,"stats":{"Line":0}},{"line":251,"address":[1742872,1742975,1743017],"length":1,"stats":{"Line":0}},{"line":252,"address":[1742999],"length":1,"stats":{"Line":0}},{"line":254,"address":[1743030],"length":1,"stats":{"Line":0}},{"line":255,"address":[1743195,1743497,1743091],"length":1,"stats":{"Line":0}},{"line":256,"address":[1743188,1743257],"length":1,"stats":{"Line":0}},{"line":259,"address":[1743305,1744381,1743540,1743834],"length":1,"stats":{"Line":0}},{"line":261,"address":[1743818,1743946],"length":1,"stats":{"Line":0}},{"line":262,"address":[1744231,1744308],"length":1,"stats":{"Line":0}},{"line":264,"address":[1744265],"length":1,"stats":{"Line":0}},{"line":285,"address":[1665568],"length":1,"stats":{"Line":0}},{"line":293,"address":[1665615],"length":1,"stats":{"Line":0}},{"line":294,"address":[1744551],"length":1,"stats":{"Line":0}},{"line":295,"address":[1744574],"length":1,"stats":{"Line":0}},{"line":297,"address":[1745069],"length":1,"stats":{"Line":0}},{"line":300,"address":[1745430],"length":1,"stats":{"Line":0}},{"line":301,"address":[1745677,1745469],"length":1,"stats":{"Line":0}},{"line":302,"address":[1747296,1747349,1745552],"length":1,"stats":{"Line":0}},{"line":305,"address":[1745828,1745636],"length":1,"stats":{"Line":0}},{"line":306,"address":[1745844,1747220,1745950],"length":1,"stats":{"Line":0}},{"line":307,"address":[1745933,1746022],"length":1,"stats":{"Line":0}},{"line":308,"address":[1746062,1747205],"length":1,"stats":{"Line":0}},{"line":311,"address":[1746262,1747178,1747150,1746670],"length":1,"stats":{"Line":0}},{"line":312,"address":[1746654,1746798],"length":1,"stats":{"Line":0}},{"line":313,"address":[1747021,1747093],"length":1,"stats":{"Line":0}},{"line":315,"address":[1747055],"length":1,"stats":{"Line":0}},{"line":329,"address":[1665680],"length":1,"stats":{"Line":0}},{"line":335,"address":[1665717],"length":1,"stats":{"Line":0}},{"line":336,"address":[1747388],"length":1,"stats":{"Line":0}},{"line":337,"address":[1747408],"length":1,"stats":{"Line":0}},{"line":340,"address":[1747799],"length":1,"stats":{"Line":0}},{"line":341,"address":[1747900,1747988,1747838],"length":1,"stats":{"Line":0}},{"line":343,"address":[1747942,1748132],"length":1,"stats":{"Line":0}},{"line":345,"address":[1748276,1748411],"length":1,"stats":{"Line":0}},{"line":349,"address":[1748443],"length":1,"stats":{"Line":0}},{"line":368,"address":[1665776],"length":1,"stats":{"Line":0}},{"line":374,"address":[1665813],"length":1,"stats":{"Line":0}},{"line":375,"address":[1748500],"length":1,"stats":{"Line":0}},{"line":376,"address":[1748520],"length":1,"stats":{"Line":0}},{"line":379,"address":[1748911],"length":1,"stats":{"Line":0}},{"line":380,"address":[1749119,1748950,1749012],"length":1,"stats":{"Line":0}},{"line":381,"address":[1749464,1749213,1749044],"length":1,"stats":{"Line":0}},{"line":383,"address":[1749616,1749445],"length":1,"stats":{"Line":0}},{"line":384,"address":[1749868,1749929],"length":1,"stats":{"Line":0}},{"line":386,"address":[1749902],"length":1,"stats":{"Line":0}},{"line":401,"address":[1665872],"length":1,"stats":{"Line":1}},{"line":405,"address":[1665897],"length":1,"stats":{"Line":2}},{"line":406,"address":[1750012],"length":1,"stats":{"Line":1}},{"line":409,"address":[1750175,1750029],"length":1,"stats":{"Line":1}},{"line":410,"address":[1750261,1750310],"length":1,"stats":{"Line":1}},{"line":412,"address":[1750295],"length":1,"stats":{"Line":1}},{"line":429,"address":[1665920],"length":1,"stats":{"Line":1}},{"line":437,"address":[1665967],"length":1,"stats":{"Line":2}},{"line":438,"address":[1750396],"length":1,"stats":{"Line":1}},{"line":439,"address":[1750612,1750416],"length":1,"stats":{"Line":2}},{"line":440,"address":[1750622],"length":1,"stats":{"Line":0}},{"line":442,"address":[1750589,1750676],"length":1,"stats":{"Line":1}},{"line":443,"address":[1750709],"length":1,"stats":{"Line":0}},{"line":445,"address":[1750691],"length":1,"stats":{"Line":1}},{"line":449,"address":[1751986,1751084,1751789],"length":1,"stats":{"Line":2}},{"line":450,"address":[1751882,1751991,1751292],"length":1,"stats":{"Line":2}},{"line":453,"address":[1751105],"length":1,"stats":{"Line":0}},{"line":454,"address":[1751144,1751591,1751460],"length":1,"stats":{"Line":0}},{"line":455,"address":[1751492],"length":1,"stats":{"Line":0}},{"line":456,"address":[1751685,1751516,1751791],"length":1,"stats":{"Line":0}},{"line":460,"address":[1752081,1751845],"length":1,"stats":{"Line":2}},{"line":461,"address":[1751831,1751839],"length":1,"stats":{"Line":2}},{"line":462,"address":[1751835,1751842],"length":1,"stats":{"Line":2}},{"line":464,"address":[1753077,1752097,1752203],"length":1,"stats":{"Line":1}},{"line":465,"address":[1752186,1752275],"length":1,"stats":{"Line":2}},{"line":466,"address":[1752380],"length":1,"stats":{"Line":1}},{"line":467,"address":[1752294],"length":1,"stats":{"Line":1}},{"line":469,"address":[1752334],"length":1,"stats":{"Line":1}},{"line":470,"address":[1752356],"length":1,"stats":{"Line":1}},{"line":471,"address":[1752364],"length":1,"stats":{"Line":1}},{"line":472,"address":[1752372],"length":1,"stats":{"Line":1}},{"line":475,"address":[1752742,1752909,1752676],"length":1,"stats":{"Line":3}},{"line":476,"address":[1752787,1752942],"length":1,"stats":{"Line":1}},{"line":477,"address":[1753020,1752954],"length":1,"stats":{"Line":1}},{"line":479,"address":[1752986],"length":1,"stats":{"Line":1}},{"line":497,"address":[1666032],"length":1,"stats":{"Line":0}},{"line":507,"address":[1666081],"length":1,"stats":{"Line":0}},{"line":508,"address":[1753156],"length":1,"stats":{"Line":0}},{"line":509,"address":[1753176],"length":1,"stats":{"Line":0}},{"line":511,"address":[1753665],"length":1,"stats":{"Line":0}},{"line":513,"address":[1754020],"length":1,"stats":{"Line":0}},{"line":517,"address":[1754445,1754352],"length":1,"stats":{"Line":0}},{"line":518,"address":[1754580],"length":1,"stats":{"Line":0}},{"line":521,"address":[1754728],"length":1,"stats":{"Line":0}},{"line":524,"address":[1754879,1754786],"length":1,"stats":{"Line":0}},{"line":525,"address":[1755014],"length":1,"stats":{"Line":0}},{"line":528,"address":[1755162],"length":1,"stats":{"Line":0}},{"line":532,"address":[1755244],"length":1,"stats":{"Line":0}},{"line":533,"address":[1755283,1755514],"length":1,"stats":{"Line":0}},{"line":535,"address":[1755379],"length":1,"stats":{"Line":0}},{"line":541,"address":[1755828,1755495,1755661],"length":1,"stats":{"Line":0}},{"line":542,"address":[1755706,1755861],"length":1,"stats":{"Line":0}},{"line":543,"address":[1755934,1755873],"length":1,"stats":{"Line":0}},{"line":545,"address":[1755905],"length":1,"stats":{"Line":0}},{"line":564,"address":[1666176],"length":1,"stats":{"Line":0}},{"line":569,"address":[1666208],"length":1,"stats":{"Line":0}},{"line":570,"address":[1756017],"length":1,"stats":{"Line":0}},{"line":571,"address":[1756034],"length":1,"stats":{"Line":0}},{"line":573,"address":[1756401,1756167],"length":1,"stats":{"Line":0}},{"line":574,"address":[1756537,1756682],"length":1,"stats":{"Line":0}},{"line":576,"address":[1756737],"length":1,"stats":{"Line":0}},{"line":579,"address":[1756745,1757248,1756852,1757314],"length":1,"stats":{"Line":0}},{"line":580,"address":[1756988,1757120],"length":1,"stats":{"Line":0}},{"line":584,"address":[1756703,1757476],"length":1,"stats":{"Line":0}},{"line":589,"address":[1757437],"length":1,"stats":{"Line":0}},{"line":607,"address":[1666240],"length":1,"stats":{"Line":0}},{"line":613,"address":[1666277],"length":1,"stats":{"Line":0}},{"line":614,"address":[1757548],"length":1,"stats":{"Line":0}},{"line":615,"address":[1757568],"length":1,"stats":{"Line":0}},{"line":619,"address":[1757994],"length":1,"stats":{"Line":0}},{"line":620,"address":[1758155,1758049],"length":1,"stats":{"Line":0}},{"line":621,"address":[1758434,1758289],"length":1,"stats":{"Line":0}},{"line":623,"address":[1758499],"length":1,"stats":{"Line":0}},{"line":626,"address":[1758518],"length":1,"stats":{"Line":0}},{"line":628,"address":[1758730,1758455],"length":1,"stats":{"Line":0}},{"line":633,"address":[1758708],"length":1,"stats":{"Line":0}},{"line":651,"address":[1666336],"length":1,"stats":{"Line":0}},{"line":656,"address":[1666368],"length":1,"stats":{"Line":0}},{"line":657,"address":[1758825],"length":1,"stats":{"Line":0}},{"line":658,"address":[1758842],"length":1,"stats":{"Line":0}},{"line":660,"address":[1758999,1759233],"length":1,"stats":{"Line":0}},{"line":661,"address":[1759514,1759369],"length":1,"stats":{"Line":0}},{"line":663,"address":[1759569],"length":1,"stats":{"Line":0}},{"line":666,"address":[1759703,1759588],"length":1,"stats":{"Line":0}},{"line":667,"address":[1759695],"length":1,"stats":{"Line":0}},{"line":669,"address":[1759831,1759968],"length":1,"stats":{"Line":0}},{"line":673,"address":[1760037],"length":1,"stats":{"Line":0}},{"line":674,"address":[1760208,1760077],"length":1,"stats":{"Line":0}},{"line":675,"address":[1760094],"length":1,"stats":{"Line":0}},{"line":676,"address":[1760102,1760554],"length":1,"stats":{"Line":0}},{"line":680,"address":[1760608,1759535],"length":1,"stats":{"Line":0}},{"line":685,"address":[1760543],"length":1,"stats":{"Line":0}},{"line":704,"address":[1666400],"length":1,"stats":{"Line":0}},{"line":709,"address":[1666432],"length":1,"stats":{"Line":0}},{"line":710,"address":[1760681],"length":1,"stats":{"Line":0}},{"line":711,"address":[1760698],"length":1,"stats":{"Line":0}},{"line":713,"address":[1760855,1761089],"length":1,"stats":{"Line":0}},{"line":714,"address":[1761225,1761370],"length":1,"stats":{"Line":0}},{"line":716,"address":[1761425],"length":1,"stats":{"Line":0}},{"line":719,"address":[1761444,1761551],"length":1,"stats":{"Line":0}},{"line":720,"address":[1761824,1761687],"length":1,"stats":{"Line":0}},{"line":724,"address":[1761893],"length":1,"stats":{"Line":0}},{"line":725,"address":[1762099,1761933],"length":1,"stats":{"Line":0}},{"line":726,"address":[1762469,1761953],"length":1,"stats":{"Line":0}},{"line":729,"address":[1761391,1762523],"length":1,"stats":{"Line":0}},{"line":734,"address":[1762458],"length":1,"stats":{"Line":0}},{"line":745,"address":[1666464],"length":1,"stats":{"Line":1}},{"line":750,"address":[1666496],"length":1,"stats":{"Line":2}},{"line":751,"address":[1762615],"length":1,"stats":{"Line":1}},{"line":752,"address":[1762635],"length":1,"stats":{"Line":1}},{"line":755,"address":[1763085,1762810,1763609],"length":1,"stats":{"Line":3}},{"line":756,"address":[1763593,1763230],"length":1,"stats":{"Line":2}},{"line":759,"address":[1763384],"length":1,"stats":{"Line":1}},{"line":760,"address":[1763570],"length":1,"stats":{"Line":1}},{"line":763,"address":[1763411],"length":1,"stats":{"Line":1}},{"line":765,"address":[1763427,1763651,1763983,1764543],"length":1,"stats":{"Line":2}},{"line":766,"address":[1763838,1764127],"length":1,"stats":{"Line":2}},{"line":772,"address":[1764204],"length":1,"stats":{"Line":1}},{"line":773,"address":[1764372,1764438],"length":1,"stats":{"Line":1}},{"line":775,"address":[1764411],"length":1,"stats":{"Line":1}}],"covered":43,"coverable":210},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","src","utils.rs"],"content":"// standard\nuse std::convert::TryFrom;\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, TcpStream};\nuse std::os::raw::c_char;\n#[cfg(unix)]\nuse std::os::unix::io::IntoRawFd;\n#[cfg(windows)]\nuse std::os::windows::io::IntoRawSocket;\nuse std::str::FromStr;\n\n// extern\nuse anyhow::bail;\n#[cfg(feature = \"impl-lib\")]\nuse cgosling_proc_macros::*;\nuse tor_interface::tor_provider::{CircuitToken, DomainAddr, OnionAddr, OnionAddrV3, TargetAddr};\n\n// internal\nuse crate::context::*;\nuse crate::crypto::*;\nuse crate::error::*;\nuse crate::ffi::*;\nuse crate::macros::*;\n\n/// The maximum number of bytes needed to store a target address\n/// in the format domainname:port (including null-terminator)\n/// Maximum length of a human-readbale domain name is 253 bytes (per RFC 1035)\n/// see: https://stackoverflow.com/a/32294443\n/// Maximum length of the :port section is 6 bytes\n/// null-terminator is 1 byte\npub const TARGET_ADDRESS_STRING_SIZE: usize = 260;\n\n/// An internet socket address, either IPv4 or IPv6\npub struct GoslingIpAddress;\ndefine_registry! {IpAddr}\n\n/// An endpoint to connect to over tor\npub struct GoslingTargetAddress;\ndefine_registry! {TargetAddr}\n\n/// A stream isolation token\npub type GoslingCircuitToken = usize;\n\n//\n// Free Functions\n//\n\n/// Frees a gosling_ip_address object\n///\n/// @param in_ip_address: the ip address to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_ip_address_free(in_ip_address: *mut GoslingIpAddress) {\n    impl_registry_free!(in_ip_address, IpAddr);\n}\n\n/// Frees a gosling_target_address object\n///\n/// @param in_target_address: the target address to free\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_target_address_free(in_target_address: *mut GoslingTargetAddress) {\n    impl_registry_free!(in_target_address, TargetAddr);\n}\n\n//\n// Clone Functions\n//\n\n/// Copy method for gosling_ip_address\n///\n/// @param out_ip_address: returned copy\n/// @param ip_address: original to copy\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ip_address_clone(\n    out_ip_address: *mut *mut GoslingIpAddress,\n    ip_address: *const GoslingIpAddress,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_ip_address);\n        ensure_not_null!(ip_address);\n\n        let ip_address = match get_ip_addr_registry().get(ip_address as usize) {\n            Some(ip_address) =\u003e ip_address.clone(),\n            None =\u003e bail_invalid_handle!(ip_address),\n        };\n        let handle = get_ip_addr_registry().insert(ip_address);\n        *out_ip_address = handle as *mut GoslingIpAddress;\n\n        Ok(())\n    })\n}\n\n/// Copy method for gosling_target_address\n///\n/// @param out_target_address: returned copy\n/// @param target_address: original to copy\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_target_address_clone(\n    out_target_address: *mut *mut GoslingTargetAddress,\n    target_address: *const GoslingTargetAddress,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_target_address);\n        ensure_not_null!(target_address);\n\n        let target_address = match get_target_addr_registry().get(target_address as usize) {\n            Some(target_address) =\u003e target_address.clone(),\n            None =\u003e bail_invalid_handle!(target_address),\n        };\n        let handle = get_target_addr_registry().insert(target_address);\n        *out_target_address = handle as *mut GoslingTargetAddress;\n\n        Ok(())\n    })\n}\n\n//\n// Connect Method\n//\n\n/// Connect to a target address using the provided gosling context's tor provider.\n///\n/// @param context: the context to use to connect with\n/// @param target_address: the destination address to connect to\n/// @param circuit_token: the circuit isolation token\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub extern \"C\" fn gosling_context_connect(\n    context: *mut GoslingContext,\n    out_tcp_socket: *mut GoslingTcpSocket,\n    target_address: *const GoslingTargetAddress,\n    circuit_token: GoslingCircuitToken,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n        ensure_not_null!(out_tcp_socket);\n        ensure_not_null!(target_address);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let context = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context,\n            None =\u003e bail_invalid_handle!(context),\n        };\n\n        let target_address = match get_target_addr_registry().get(target_address as usize) {\n            Some(target_address) =\u003e target_address.clone(),\n            None =\u003e bail_invalid_handle!(target_address),\n        };\n\n        let onion_stream = context.0.connect(target_address, Some(circuit_token))?;\n        let tcp_stream: TcpStream = onion_stream.into();\n\n        #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n        let tcp_socket = tcp_stream.into_raw_fd();\n        #[cfg(target_os = \"windows\")]\n        let tcp_socket = tcp_stream.into_raw_socket();\n\n        unsafe {\n            *out_tcp_socket = tcp_socket;\n        }\n        Ok(())\n    })\n}\n\n//\n// Ip Address Methods\n//\n\n/// Create ip address from four ipv4 octets.\n///\n/// @param out_ip_address: returned ip address\n/// @param a: first octet\n/// @param b: second octet\n/// @param c: third octet\n/// @param d: fourth octet\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ip_address_from_ipv4(\n    out_ip_address: *mut *mut GoslingIpAddress,\n    a: u8,\n    b: u8,\n    c: u8,\n    d: u8,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_ip_address);\n\n        let ip_addr = Ipv4Addr::new(a, b, c, d);\n        let handle = get_ip_addr_registry().insert(ip_addr.into());\n        *out_ip_address = handle as *mut GoslingIpAddress;\n\n        Ok(())\n    })\n}\n\n/// Create target address from eight ipv6 16-bit sgements\n///\n/// @param out_ip_address: returned ip address\n/// @param a: first segment\n/// @param b: second segment\n/// @param c: third segment\n/// @param d: fourth segment\n/// @param e: fifth segment\n/// @param f: sixth segment\n/// @param g: seventh segment\n/// @param h: eigth segment\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_ip_address_from_ipv6(\n    out_ip_address: *mut *mut GoslingIpAddress,\n    a: u16,\n    b: u16,\n    c: u16,\n    d: u16,\n    e: u16,\n    f: u16,\n    g: u16,\n    h: u16,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_ip_address);\n        let ip_addr = Ipv6Addr::new(a, b, c, d, e, f, g, h);\n        let handle = get_ip_addr_registry().insert(ip_addr.into());\n        *out_ip_address = handle as *mut GoslingIpAddress;\n\n        Ok(())\n    })\n}\n\n//\n// Target Address Methods\n//\n\n/// Create target address from an ip address and a port.\n///\n/// @param out_target_address: returned target address\n/// @param ip_address: target ip address\n/// @param port: target port\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_target_address_from_ip_address(\n    out_target_address: *mut *mut GoslingTargetAddress,\n    ip_address: *const GoslingIpAddress,\n    port: u16,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_target_address);\n        ensure_not_null!(ip_address);\n\n        let ip_address = match get_ip_addr_registry().get(ip_address as usize) {\n            Some(ip_address) =\u003e ip_address.clone(),\n            None =\u003e bail_invalid_handle!(ip_address),\n        };\n\n        let target_address = TargetAddr::Socket(SocketAddr::new(ip_address, port));\n\n        let handle = get_target_addr_registry().insert(target_address);\n        *out_target_address = handle as *mut GoslingTargetAddress;\n\n        Ok(())\n    })\n}\n\n/// Create target address from domain and port.\n/// The resulting target address is in the format domain:port\n///\n/// @param out_target_address: returned target address\n/// @param domain: the target domain\n/// @param domain_length: the number of chars in domain not including any null-terminator\n/// @param port: the target port\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_target_address_from_domain(\n    out_target_address: *mut *mut GoslingTargetAddress,\n    domain: *const c_char,\n    domain_length: usize,\n    port: u16,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_target_address);\n        ensure_not_null!(domain);\n        if domain_length == 0 {\n            bail!(\"domain_length must be greater than 0\");\n        }\n\n        let domain_view = std::slice::from_raw_parts(domain as *const u8, domain_length);\n        let domain_str = std::str::from_utf8(domain_view)?;\n\n        let target_address =\n            TargetAddr::Domain(DomainAddr::try_from((domain_str.to_string(), port))?);\n        let handle = get_target_addr_registry().insert(target_address);\n        *out_target_address = handle as *mut GoslingTargetAddress;\n\n        Ok(())\n    })\n}\n\n/// Create target address from onion service id and port.\n///\n/// @param out_target_address: returned target address\n/// @param service_id: the target onion service id\n/// @param port: the target port\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_target_address_from_v3_onion_service_id(\n    out_target_address: *mut *mut GoslingTargetAddress,\n    service_id: *const GoslingV3OnionServiceId,\n    port: u16,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_target_address);\n        ensure_not_null!(service_id);\n\n        let service_id = match get_v3_onion_service_id_registry().get(service_id as usize) {\n            Some(service_id) =\u003e service_id.clone(),\n            None =\u003e bail_invalid_handle!(service_id),\n        };\n\n        let target_address =\n            TargetAddr::OnionService(OnionAddr::V3(OnionAddrV3::new(service_id, port)));\n        let handle = get_target_addr_registry().insert(target_address);\n        *out_target_address = handle as *mut GoslingTargetAddress;\n\n        Ok(())\n    })\n}\n\n/// Create target address from some string representation\n///\n/// @param out_target_address: returned target address\n/// @param target_address: serialised target address\n/// @param target_address_length: the number of chars in string not including any null-terminator\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_target_address_from_string(\n    out_target_address: *mut *mut GoslingTargetAddress,\n    target_address: *const c_char,\n    target_address_length: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(out_target_address);\n        ensure_not_null!(target_address);\n        if target_address_length == 0 {\n            bail!(\"target_address_length must be greater than 0\");\n        }\n\n        let target_address_view =\n            std::slice::from_raw_parts(target_address as *const u8, target_address_length);\n        let target_address_str = std::str::from_utf8(target_address_view)?;\n\n        let target_address = TargetAddr::from_str(target_address_str)?;\n        let handle = get_target_addr_registry().insert(target_address);\n        *out_target_address = handle as *mut GoslingTargetAddress;\n\n        Ok(())\n    })\n}\n\n/// Write target address to null-terminated string\n///\n/// @param target_address: the target address to write\n/// @param out_target_address_string: buffer to be filled with string\n/// @param target_address_string_size: size of the out_string buffer in bytes. The maximum\n///  required size is 262 bytes.\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_target_address_to_string(\n    target_address: *const GoslingTargetAddress,\n    out_target_address_string: *mut c_char,\n    target_address_string_size: usize,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(target_address);\n        ensure_not_null!(out_target_address_string);\n\n        let target_address_string = match get_target_addr_registry().get(target_address as usize) {\n            Some(target_address) =\u003e target_address.to_string(),\n            None =\u003e bail_invalid_handle!(target_address),\n        };\n\n        let target_address_string_len = target_address_string.len();\n        if target_address_string_len \u003e= target_address_string_size {\n            bail!(\n                \"string_size must be at least '{}', received '{}'\",\n                target_address_string_len,\n                target_address_string_size\n            );\n        }\n\n        unsafe {\n            // copy target_address_string into output buffer\n            let target_address_string_view = std::slice::from_raw_parts_mut(\n                out_target_address_string as *mut u8,\n                target_address_string_size,\n            );\n            std::ptr::copy(\n                target_address_string.as_ptr(),\n                target_address_string_view.as_mut_ptr(),\n                target_address_string_len,\n            );\n            // add final null-terminator\n            target_address_string_view[target_address_string_len] = 0u8;\n        }\n\n        Ok(())\n    })\n}\n\n//\n// Circuit Token Methods\n//\n\n/// Generate a circuit token to isolate connect calls\n///\n/// @param context: the context to use to connect with\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_context_generate_circuit_token(\n    context: *mut GoslingContext,\n    error: *mut *mut GoslingError,\n) -\u003e GoslingCircuitToken {\n    translate_failures(!0usize, error, || -\u003e anyhow::Result\u003cCircuitToken\u003e {\n        ensure_not_null!(context);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        let token = match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context.0.generate_circuit_token(),\n            None =\u003e bail_invalid_handle!(context),\n        };\n        Ok(token)\n    })\n}\n\n/// Release a context's circuit token.\n///\n/// @param context: the context to use to connect with\n/// @param circuit_token: circuit token to destroy\n/// @param error: filled on error\n#[no_mangle]\n#[cfg_attr(feature = \"impl-lib\", rename_impl)]\npub unsafe extern \"C\" fn gosling_context_release_circuit_token(\n    context: *mut GoslingContext,\n    circuit_token: GoslingCircuitToken,\n    error: *mut *mut GoslingError,\n) {\n    translate_failures((), error, || -\u003e anyhow::Result\u003c()\u003e {\n        ensure_not_null!(context);\n\n        let mut context_tuple_registry = get_context_tuple_registry();\n        match context_tuple_registry.get_mut(context as usize) {\n            Some(context) =\u003e context.0.release_circuit_token(circuit_token),\n            None =\u003e bail_invalid_handle!(context),\n        };\n        Ok(())\n    })\n}\n","traces":[{"line":52,"address":[1650910,1650768],"length":1,"stats":{"Line":0}},{"line":61,"address":[1651109,1650944],"length":1,"stats":{"Line":0}},{"line":76,"address":[1651136],"length":1,"stats":{"Line":0}},{"line":81,"address":[1638831,1637936],"length":1,"stats":{"Line":0}},{"line":82,"address":[1637953],"length":1,"stats":{"Line":0}},{"line":83,"address":[1637970],"length":1,"stats":{"Line":0}},{"line":85,"address":[1638307,1638097],"length":1,"stats":{"Line":0}},{"line":86,"address":[1638443],"length":1,"stats":{"Line":0}},{"line":89,"address":[1638591],"length":1,"stats":{"Line":0}},{"line":90,"address":[1638755,1638810],"length":1,"stats":{"Line":0}},{"line":92,"address":[1638791],"length":1,"stats":{"Line":0}},{"line":103,"address":[1651200],"length":1,"stats":{"Line":0}},{"line":108,"address":[1638864,1639903],"length":1,"stats":{"Line":0}},{"line":109,"address":[1638889],"length":1,"stats":{"Line":0}},{"line":110,"address":[1638906],"length":1,"stats":{"Line":0}},{"line":112,"address":[1639255,1639033],"length":1,"stats":{"Line":0}},{"line":113,"address":[1639534,1639391],"length":1,"stats":{"Line":0}},{"line":116,"address":[1639598],"length":1,"stats":{"Line":0}},{"line":117,"address":[1639822,1639882],"length":1,"stats":{"Line":0}},{"line":119,"address":[1639856],"length":1,"stats":{"Line":0}},{"line":135,"address":[1651264],"length":1,"stats":{"Line":0}},{"line":142,"address":[1639952,1642273,1642327],"length":1,"stats":{"Line":0}},{"line":143,"address":[1639980],"length":1,"stats":{"Line":0}},{"line":144,"address":[1640000],"length":1,"stats":{"Line":0}},{"line":145,"address":[1640173],"length":1,"stats":{"Line":0}},{"line":147,"address":[1640341],"length":1,"stats":{"Line":0}},{"line":148,"address":[1640372,1640580],"length":1,"stats":{"Line":0}},{"line":149,"address":[1640714],"length":1,"stats":{"Line":0}},{"line":153,"address":[1640735,1640856,1640943],"length":1,"stats":{"Line":0}},{"line":154,"address":[1641215,1641078],"length":1,"stats":{"Line":0}},{"line":158,"address":[1641289,1641902,1642287],"length":1,"stats":{"Line":0}},{"line":159,"address":[1642105,1641733],"length":1,"stats":{"Line":0}},{"line":162,"address":[1642112],"length":1,"stats":{"Line":0}},{"line":167,"address":[1642217,1642139],"length":1,"stats":{"Line":0}},{"line":169,"address":[1642172],"length":1,"stats":{"Line":0}},{"line":187,"address":[1651376],"length":1,"stats":{"Line":0}},{"line":195,"address":[1642352,1642792],"length":1,"stats":{"Line":0}},{"line":196,"address":[1642364],"length":1,"stats":{"Line":0}},{"line":198,"address":[1642384],"length":1,"stats":{"Line":0}},{"line":199,"address":[1642429,1642575],"length":1,"stats":{"Line":0}},{"line":200,"address":[1642708,1642758],"length":1,"stats":{"Line":0}},{"line":202,"address":[1642742],"length":1,"stats":{"Line":0}},{"line":220,"address":[1651488],"length":1,"stats":{"Line":0}},{"line":232,"address":[1643296,1642816],"length":1,"stats":{"Line":0}},{"line":233,"address":[1642828],"length":1,"stats":{"Line":0}},{"line":234,"address":[1642852],"length":1,"stats":{"Line":0}},{"line":235,"address":[1642935,1643084],"length":1,"stats":{"Line":0}},{"line":236,"address":[1643262,1643212],"length":1,"stats":{"Line":0}},{"line":238,"address":[1643246],"length":1,"stats":{"Line":0}},{"line":254,"address":[1651728],"length":1,"stats":{"Line":0}},{"line":260,"address":[1644454,1643328],"length":1,"stats":{"Line":0}},{"line":261,"address":[1643348],"length":1,"stats":{"Line":0}},{"line":262,"address":[1643368],"length":1,"stats":{"Line":0}},{"line":264,"address":[1643494,1643709],"length":1,"stats":{"Line":0}},{"line":265,"address":[1643844],"length":1,"stats":{"Line":0}},{"line":269,"address":[1643997],"length":1,"stats":{"Line":0}},{"line":271,"address":[1644105,1644171],"length":1,"stats":{"Line":0}},{"line":272,"address":[1644433,1644375],"length":1,"stats":{"Line":0}},{"line":274,"address":[1644407],"length":1,"stats":{"Line":0}},{"line":288,"address":[1651824],"length":1,"stats":{"Line":0}},{"line":295,"address":[1645699,1644496],"length":1,"stats":{"Line":0}},{"line":296,"address":[1644516],"length":1,"stats":{"Line":0}},{"line":297,"address":[1644536],"length":1,"stats":{"Line":0}},{"line":298,"address":[1644663],"length":1,"stats":{"Line":0}},{"line":299,"address":[1644782],"length":1,"stats":{"Line":0}},{"line":302,"address":[1644830],"length":1,"stats":{"Line":0}},{"line":303,"address":[1644869,1644934,1645106],"length":1,"stats":{"Line":0}},{"line":306,"address":[1645200,1645298,1644966],"length":1,"stats":{"Line":0}},{"line":307,"address":[1645416,1645282],"length":1,"stats":{"Line":0}},{"line":308,"address":[1645620,1645678],"length":1,"stats":{"Line":0}},{"line":310,"address":[1645652],"length":1,"stats":{"Line":0}},{"line":322,"address":[1651936],"length":1,"stats":{"Line":0}},{"line":328,"address":[1646940,1645744],"length":1,"stats":{"Line":0}},{"line":329,"address":[1645764],"length":1,"stats":{"Line":0}},{"line":330,"address":[1645784],"length":1,"stats":{"Line":0}},{"line":332,"address":[1646125,1645910],"length":1,"stats":{"Line":0}},{"line":333,"address":[1646260],"length":1,"stats":{"Line":0}},{"line":338,"address":[1646413],"length":1,"stats":{"Line":0}},{"line":339,"address":[1646657,1646591],"length":1,"stats":{"Line":0}},{"line":340,"address":[1646919,1646861],"length":1,"stats":{"Line":0}},{"line":342,"address":[1646893],"length":1,"stats":{"Line":0}},{"line":354,"address":[1652032],"length":1,"stats":{"Line":0}},{"line":360,"address":[1646992,1648181],"length":1,"stats":{"Line":0}},{"line":361,"address":[1647012],"length":1,"stats":{"Line":0}},{"line":362,"address":[1647032],"length":1,"stats":{"Line":0}},{"line":363,"address":[1647159],"length":1,"stats":{"Line":0}},{"line":364,"address":[1647278],"length":1,"stats":{"Line":0}},{"line":368,"address":[1647332],"length":1,"stats":{"Line":0}},{"line":369,"address":[1647531,1647433,1647371],"length":1,"stats":{"Line":0}},{"line":371,"address":[1647777,1647625,1647465],"length":1,"stats":{"Line":0}},{"line":372,"address":[1647761,1647895],"length":1,"stats":{"Line":0}},{"line":373,"address":[1648160,1648099],"length":1,"stats":{"Line":0}},{"line":375,"address":[1648133],"length":1,"stats":{"Line":0}},{"line":388,"address":[1652128],"length":1,"stats":{"Line":0}},{"line":394,"address":[1649682,1648224],"length":1,"stats":{"Line":0}},{"line":395,"address":[1648236],"length":1,"stats":{"Line":0}},{"line":396,"address":[1648256],"length":1,"stats":{"Line":0}},{"line":398,"address":[1648636,1648397],"length":1,"stats":{"Line":0}},{"line":399,"address":[1648770],"length":1,"stats":{"Line":0}},{"line":403,"address":[1648976],"length":1,"stats":{"Line":0}},{"line":404,"address":[1649006],"length":1,"stats":{"Line":0}},{"line":405,"address":[1649542,1649460],"length":1,"stats":{"Line":0}},{"line":414,"address":[1649042,1649172],"length":1,"stats":{"Line":0}},{"line":415,"address":[1649036,1649028],"length":1,"stats":{"Line":0}},{"line":416,"address":[1649032,1649039],"length":1,"stats":{"Line":0}},{"line":418,"address":[1649291],"length":1,"stats":{"Line":0}},{"line":419,"address":[1649212],"length":1,"stats":{"Line":0}},{"line":424,"address":[1649367,1649427],"length":1,"stats":{"Line":0}},{"line":427,"address":[1649394],"length":1,"stats":{"Line":0}},{"line":441,"address":[1652224],"length":1,"stats":{"Line":0}},{"line":445,"address":[1649712,1650234],"length":1,"stats":{"Line":0}},{"line":446,"address":[1649724],"length":1,"stats":{"Line":0}},{"line":448,"address":[1649741],"length":1,"stats":{"Line":0}},{"line":449,"address":[1649763,1649933],"length":1,"stats":{"Line":0}},{"line":450,"address":[1650200,1650057],"length":1,"stats":{"Line":0}},{"line":453,"address":[1650208],"length":1,"stats":{"Line":0}},{"line":464,"address":[1652272],"length":1,"stats":{"Line":0}},{"line":469,"address":[1650256,1650733],"length":1,"stats":{"Line":0}},{"line":470,"address":[1650273],"length":1,"stats":{"Line":0}},{"line":472,"address":[1650290],"length":1,"stats":{"Line":0}},{"line":473,"address":[1650473,1650312],"length":1,"stats":{"Line":0}},{"line":474,"address":[1650591],"length":1,"stats":{"Line":0}},{"line":477,"address":[1650712],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":123},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling","tests","ffi.rs"],"content":"// standard\nuse std::ffi::{CStr, CString};\nuse std::io::{BufRead, BufReader, Write};\nuse std::net::TcpStream;\nuse std::os::raw::c_char;\n#[cfg(unix)]\nuse std::os::unix::io::{FromRawFd, RawFd};\n#[cfg(windows)]\nuse std::os::windows::io::{FromRawSocket, RawSocket};\nuse std::ptr;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\n// external crates\nuse anyhow::bail;\n#[cfg(test)]\nuse serial_test::serial;\n\n// internal crates\nuse cgosling::callbacks::*;\nuse cgosling::context::*;\nuse cgosling::crypto::*;\nuse cgosling::error::*;\nuse cgosling::ffi::*;\nuse cgosling::tor_provider::*;\n\nmacro_rules! require_noerror {\n    ($func:ident($($arg:tt)*)) =\u003e {\n        // println!(\"--- {}{}\", stringify!($func), stringify!(($($arg)*)));\n        unsafe {\n            let mut error: *mut GoslingError = ptr::null_mut();\n            $func($($arg)*, \u0026mut error);\n            if !error.is_null() {\n                let msg = gosling_error_get_message(error);\n                let msg = format!(\"{:?}\", CStr::from_ptr(msg));\n                gosling_error_free(error);\n                anyhow::bail!(msg);\n            }\n        }\n    }\n}\n\n// simple bson document: { msg : \"hello world\" }\nconst CHALLENGE_BSON: [u8; 26] = [\n    0x1a, 0x00, 0x00, 0x00, // document length 26 == 0x0000001a\n    0x02, b'm', b's', b'g', 0x00, // string msg\n    0x0c, 0x00, 0x00, 0x00, // strlen(\"hello world\\x00\") 12 = 0x0000000c\n    b'h', b'e', b'l', b'l', b'o', b' ', b'w', b'o', b'r', b'l', b'd', 0x00, // \"hello world\"\n    0x00, // document null-terminator\n];\n\n// empty bson document: {}\nconst CHALLENGE_RESPONSE_BSON: [u8; 5] = [\n    0x05, 0x00, 0x00, 0x00, // document length 5 == 0x00000005\n    0x00, // document null-terminator\n];\n\nstatic ENDPOINT_NAME: \u0026CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"endpoint_name\\0\") };\nstatic CHANNEL_NAME: \u0026CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"channel_name\\0\") };\n\nfn create_client_identity_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn challenge_response_size_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        _challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n    ) -\u003e usize {\n        assert!(!context.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n\n        CHALLENGE_RESPONSE_BSON.len()\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_challenge_response_size_callback(\n            context,\n            Some(challenge_response_size_callback)\n        )\n    );\n\n    extern \"C\" fn build_challenge_response_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        challenge_buffer: *const u8,\n        challenge_buffer_size: usize,\n        out_challenge_response_buffer: *mut u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!challenge_buffer.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n        let challenge_buffer = unsafe {\n            std::slice::from_raw_parts(challenge_buffer as *const u8, challenge_buffer_size)\n        };\n        assert_eq!(challenge_buffer, CHALLENGE_BSON);\n        assert!(!out_challenge_response_buffer.is_null());\n        let out_challenge_response_buffer = unsafe {\n            std::slice::from_raw_parts_mut(\n                out_challenge_response_buffer as *mut u8,\n                challenge_response_buffer_size,\n            )\n        };\n\n        out_challenge_response_buffer.clone_from_slice(\u0026CHALLENGE_RESPONSE_BSON);\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_build_challenge_response_callback(\n            context,\n            Some(build_challenge_response_callback)\n        )\n    );\n\n    Ok(())\n}\n\nfn create_server_identity_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn client_allowed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!client_service_id.is_null());\n\n        true\n    }\n    require_noerror!(gosling_context_set_identity_server_client_allowed_callback(\n        context,\n        Some(client_allowed_callback)\n    ));\n\n    extern \"C\" fn endpoint_supported_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        if endpoint_name == ENDPOINT_NAME {\n            return true;\n        }\n        false\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_endpoint_supported_callback(\n            context,\n            Some(endpoint_supported_callback)\n        )\n    );\n\n    extern \"C\" fn challenge_size_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n    ) -\u003e usize {\n        assert!(!context.is_null());\n        CHALLENGE_BSON.len()\n    }\n    require_noerror!(gosling_context_set_identity_server_challenge_size_callback(\n        context,\n        Some(challenge_size_callback)\n    ));\n\n    extern \"C\" fn build_challenge_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        out_challenge_buffer: *mut u8,\n        challenge_buffer_size: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!out_challenge_buffer.is_null());\n        assert_eq!(challenge_buffer_size, CHALLENGE_BSON.len());\n\n        let out_challenge_buffer = unsafe {\n            std::slice::from_raw_parts_mut(out_challenge_buffer as *mut u8, challenge_buffer_size)\n        };\n        out_challenge_buffer.clone_from_slice(\u0026CHALLENGE_BSON);\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_build_challenge_callback(\n            context,\n            Some(build_challenge_callback)\n        )\n    );\n\n    extern \"C\" fn verify_challenge_response_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        challenge_response_buffer: *const u8,\n        challenge_response_buffer_size: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!challenge_response_buffer.is_null());\n        if challenge_response_buffer_size != CHALLENGE_RESPONSE_BSON.len() {\n            return false;\n        }\n\n        let challenge_response_buffer = unsafe {\n            std::slice::from_raw_parts(challenge_response_buffer, challenge_response_buffer_size)\n        };\n        if challenge_response_buffer != CHALLENGE_RESPONSE_BSON {\n            return false;\n        }\n        true\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_verify_challenge_response_callback(\n            context,\n            Some(verify_challenge_response_callback)\n        )\n    );\n\n    Ok(())\n}\n\nfn create_server_endpoint_handshake(context: *mut GoslingContext) -\u003e anyhow::Result\u003c()\u003e {\n    extern \"C\" fn channel_supported_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n    ) -\u003e bool {\n        assert!(!context.is_null());\n        assert!(!channel_name.is_null());\n        assert!(!client_service_id.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        if channel_name == CHANNEL_NAME {\n            return true;\n        }\n        false\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_channel_supported_callback(\n            context,\n            Some(channel_supported_callback)\n        )\n    );\n\n    Ok(())\n}\n\n#[test]\n#[serial]\n#[cfg(feature = \"mock-tor-provider\")]\nfn test_gosling_ffi_handshake_mock_client() -\u003e anyhow::Result\u003c()\u003e {\n    let library = test_gosling_ffi_handshake_preamble()?;\n\n    // construct a shared mock config\n    let mut mock_tor_provider_config: *mut GoslingTorProviderConfig = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_config_new_mock_client_config(\n        \u0026mut mock_tor_provider_config\n    ));\n\n    // construct tor providers\n    let mut alice_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_from_tor_provider_config(\n        \u0026mut alice_tor_provider,\n        mock_tor_provider_config\n    ));\n\n    let mut pat_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_from_tor_provider_config(\n        \u0026mut pat_tor_provider,\n        mock_tor_provider_config\n    ));\n\n    // do test\n    test_gosling_ffi_handshake_impl(library, alice_tor_provider, pat_tor_provider)\n}\n\n#[test]\n#[serial]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn test_gosling_ffi_handshake_legacy_client() -\u003e anyhow::Result\u003c()\u003e {\n    let library = test_gosling_ffi_handshake_preamble()?;\n\n    // construct tor providers\n\n    let mut alice_working_dir = std::env::temp_dir();\n    alice_working_dir.push(\"cgosling_bundled_test_alice\");\n    let alice_working_dir: CString = CString::new(alice_working_dir.to_str().unwrap())?;\n\n    let mut alice_tor_provider_config: *mut GoslingTorProviderConfig = ptr::null_mut();\n    require_noerror!(\n        gosling_tor_provider_config_new_bundled_legacy_client_config(\n            \u0026mut alice_tor_provider_config,\n            ptr::null(),\n            0usize,\n            alice_working_dir.as_ptr(),\n            alice_working_dir.as_bytes().len()\n        )\n    );\n\n    let mut alice_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_from_tor_provider_config(\n        \u0026mut alice_tor_provider,\n        alice_tor_provider_config\n    ));\n\n    let mut pat_working_dir = std::env::temp_dir();\n    pat_working_dir.push(\"cgosling_bundled_test_pat\");\n    let pat_working_dir: CString = CString::new(pat_working_dir.to_str().unwrap())?;\n\n    let mut pat_tor_provider_config: *mut GoslingTorProviderConfig = ptr::null_mut();\n    require_noerror!(\n        gosling_tor_provider_config_new_bundled_legacy_client_config(\n            \u0026mut pat_tor_provider_config,\n            ptr::null(),\n            0usize,\n            pat_working_dir.as_ptr(),\n            pat_working_dir.as_bytes().len()\n        )\n    );\n\n    let mut pat_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_from_tor_provider_config(\n        \u0026mut pat_tor_provider,\n        pat_tor_provider_config\n    ));\n\n    // do test\n    test_gosling_ffi_handshake_impl(library, alice_tor_provider, pat_tor_provider)\n}\n\n// test bundled tor client with pluggable transport\n#[test]\n#[serial]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn test_gosling_ffi_handshake_bundled_pt_client() -\u003e anyhow::Result\u003c()\u003e {\n    let library = test_gosling_ffi_handshake_preamble()?;\n\n    // construct a shared pt config using lyrebird\n    let mut pt_config: *mut GoslingPluggableTransportConfig = ptr::null_mut();\n    let transports: CString = CString::new(\"obfs4\")?;\n\n    let teb_path = std::env::var(\"TEB_PATH\")?;\n    if teb_path.is_empty() {\n        println!(\"TEB_PATH environment variable empty, so skipping test_legacy_pluggable_transport_bootstrap()\");\n        return Ok(());\n    }\n    let mut lyrebird_path = std::path::PathBuf::from(\u0026teb_path);\n    let lyrebird_bin = format!(\"lyrebird{}\", std::env::consts::EXE_SUFFIX);\n    lyrebird_path.push(lyrebird_bin);\n    assert!(std::path::Path::exists(\u0026lyrebird_path));\n    assert!(std::path::Path::is_file(\u0026lyrebird_path));\n    let lyrebird_path: CString = CString::new(lyrebird_path.to_str().unwrap())?;\n\n    require_noerror!(gosling_pluggable_transport_config_new(\n        \u0026mut pt_config,\n        transports.as_ptr(),\n        transports.as_bytes().len(),\n        lyrebird_path.as_ptr(),\n        lyrebird_path.as_bytes().len()\n    ));\n\n    // construct a obfs4 bridge line to use with lyrebird\n    let mut bridge_line: *mut GoslingBridgeLine = ptr::null_mut();\n    let bridge_line_str = \"obfs4 207.172.185.193:22223 F34AC0CDBC06918E54292A474578C99834A58893 cert=MjqosoyVylLQuLo4LH+eQ5hS7Z44s2CaMfQbIjJtn4bGRnvLv8ldSvSED5JpvWSxm09XXg iat-mode=0\";\n    let bridge_line_str = CString::new(bridge_line_str)?;\n\n    require_noerror!(gosling_bridge_line_from_string(\n        \u0026mut bridge_line,\n        bridge_line_str.as_ptr(),\n        bridge_line_str.as_bytes().len()\n    ));\n\n    // construct tor providers\n\n    let mut alice_working_dir = std::env::temp_dir();\n    alice_working_dir.push(\"cgosling_bundled_pt_test_alice\");\n    let alice_working_dir: CString = CString::new(alice_working_dir.to_str().unwrap())?;\n\n    let mut alice_tor_provider_config: *mut GoslingTorProviderConfig = ptr::null_mut();\n    require_noerror!(\n        gosling_tor_provider_config_new_bundled_legacy_client_config(\n            \u0026mut alice_tor_provider_config,\n            ptr::null(),\n            0usize,\n            alice_working_dir.as_ptr(),\n            alice_working_dir.as_bytes().len()\n        )\n    );\n\n    // add pt config\n    require_noerror!(gosling_tor_provider_config_add_pluggable_transport_config(\n        alice_tor_provider_config,\n        pt_config\n    ));\n\n    // add bridge line\n    require_noerror!(gosling_tor_provider_config_add_bridge_line(\n        alice_tor_provider_config,\n        bridge_line\n    ));\n\n    let mut alice_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_from_tor_provider_config(\n        \u0026mut alice_tor_provider,\n        alice_tor_provider_config\n    ));\n\n    let mut pat_working_dir = std::env::temp_dir();\n    pat_working_dir.push(\"cgosling_bundled_pt_test_pat\");\n    let pat_working_dir: CString = CString::new(pat_working_dir.to_str().unwrap())?;\n\n    let mut pat_tor_provider_config: *mut GoslingTorProviderConfig = ptr::null_mut();\n    require_noerror!(\n        gosling_tor_provider_config_new_bundled_legacy_client_config(\n            \u0026mut pat_tor_provider_config,\n            ptr::null(),\n            0usize,\n            pat_working_dir.as_ptr(),\n            pat_working_dir.as_bytes().len()\n        )\n    );\n\n    let mut pat_tor_provider: *mut GoslingTorProvider = ptr::null_mut();\n    require_noerror!(gosling_tor_provider_from_tor_provider_config(\n        \u0026mut pat_tor_provider,\n        pat_tor_provider_config\n    ));\n\n    // do test\n    test_gosling_ffi_handshake_impl(library, alice_tor_provider, pat_tor_provider)\n}\n\nfn test_gosling_ffi_handshake_preamble() -\u003e anyhow::Result\u003c*mut GoslingLibrary\u003e {\n    // init libary\n\n    println!(\"--- init gosling library\");\n    let mut library: *mut GoslingLibrary = ptr::null_mut();\n    require_noerror!(gosling_library_init(\u0026mut library));\n\n    println!(\"--- library: {:?}\", library);\n\n    Ok(library)\n}\n\nfn test_gosling_ffi_handshake_impl(\n    library: *mut GoslingLibrary,\n    alice_tor_provider: *mut GoslingTorProvider,\n    pat_tor_provider: *mut GoslingTorProvider,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // init alice\n\n    println!(\"--- init alice\");\n    let mut alice_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    require_noerror!(gosling_ed25519_private_key_generate(\u0026mut alice_private_key));\n\n    let mut alice_identity: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    require_noerror!(gosling_v3_onion_service_id_from_ed25519_private_key(\n        \u0026mut alice_identity,\n        alice_private_key\n    ));\n\n    let mut alice_context: *mut GoslingContext = ptr::null_mut();\n    require_noerror!(gosling_context_init(\n        \u0026mut alice_context,\n        alice_tor_provider,\n        420,\n        420,\n        alice_private_key\n    ));\n\n    create_server_identity_handshake(alice_context)?;\n    create_server_endpoint_handshake(alice_context)?;\n    // init pat\n\n    println!(\"--- init pat\");\n    let mut pat_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    require_noerror!(gosling_ed25519_private_key_generate(\u0026mut pat_private_key));\n\n    let mut pat_identity: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    require_noerror!(gosling_v3_onion_service_id_from_ed25519_private_key(\n        \u0026mut pat_identity,\n        pat_private_key\n    ));\n\n    let mut pat_context: *mut GoslingContext = ptr::null_mut();\n    require_noerror!(gosling_context_init(\n        \u0026mut pat_context,\n        pat_tor_provider,\n        420,\n        420,\n        pat_private_key\n    ));\n\n    create_client_identity_handshake(pat_context)?;\n\n    // bootstrap alice\n\n    static ALICE_BOOTSTRAP_COMPLETE: AtomicBool = AtomicBool::new(false);\n    ALICE_BOOTSTRAP_COMPLETE.store(false, Ordering::Relaxed);\n\n    extern \"C\" fn alice_bootstrap_complete_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n        ALICE_BOOTSTRAP_COMPLETE.store(true, Ordering::Relaxed);\n        println!(\"--- alice bootstraped\");\n    }\n    require_noerror!(gosling_context_set_tor_bootstrap_completed_callback(\n        alice_context,\n        Some(alice_bootstrap_complete_callback)\n    ));\n\n    println!(\"--- begin alice bootstrap\");\n    require_noerror!(gosling_context_bootstrap_tor(alice_context));\n    while !ALICE_BOOTSTRAP_COMPLETE.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(alice_context));\n    }\n\n    // init alice's identity server\n    static ALICE_IDENTITY_SERVER_READY: AtomicBool = AtomicBool::new(false);\n    ALICE_IDENTITY_SERVER_READY.store(false, Ordering::Relaxed);\n\n    extern \"C\" fn alice_identity_server_published_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n        println!(\"--- alice identity server published\");\n\n        ALICE_IDENTITY_SERVER_READY.store(true, Ordering::Relaxed);\n    }\n    require_noerror!(gosling_context_set_identity_server_published_callback(\n        alice_context,\n        Some(alice_identity_server_published_callback)\n    ));\n\n    println!(\"--- start alice identity server\");\n    require_noerror!(gosling_context_start_identity_server(alice_context));\n\n    while !ALICE_IDENTITY_SERVER_READY.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(alice_context));\n    }\n\n    // bootstrap pat\n\n    static PAT_BOOTSTRAP_COMPLETE: AtomicBool = AtomicBool::new(false);\n    PAT_BOOTSTRAP_COMPLETE.store(false, Ordering::Relaxed);\n\n    extern \"C\" fn pat_bootstrap_complete_callback(context: *mut GoslingContext) -\u003e () {\n        assert!(!context.is_null());\n\n        println!(\"--- pat bootstrapped\");\n\n        PAT_BOOTSTRAP_COMPLETE.store(true, Ordering::Relaxed);\n    }\n    require_noerror!(gosling_context_set_tor_bootstrap_completed_callback(\n        pat_context,\n        Some(pat_bootstrap_complete_callback)\n    ));\n\n    println!(\"--- begin pat bootstrap\");\n    require_noerror!(gosling_context_bootstrap_tor(pat_context));\n    while !PAT_BOOTSTRAP_COMPLETE.load(Ordering::Relaxed) {\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    // pat requests an endpoint from alice\n\n    static mut PAT_ENDPOINT_REQUEST_COMPLETE: bool = false;\n    static mut ALICE_ENDPOINT_SERVICE_ID: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    static mut PAT_ONION_AUTH_PRIVATE_KEY: *mut GoslingX25519PrivateKey = ptr::null_mut();\n    unsafe {\n        PAT_ENDPOINT_REQUEST_COMPLETE = false;\n        ALICE_ENDPOINT_SERVICE_ID = ptr::null_mut();\n        PAT_ONION_AUTH_PRIVATE_KEY = ptr::null_mut();\n    }\n\n    extern \"C\" fn pat_identity_client_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        identity_service_id: *const GoslingV3OnionServiceId,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_auth_private_key: *const GoslingX25519PrivateKey,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!identity_service_id.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!endpoint_name.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n        assert!(!client_auth_private_key.is_null());\n\n        let mut error: *mut GoslingError = ptr::null_mut();\n\n        let mut alice_endpoint_service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n        unsafe {\n            gosling_v3_onion_service_id_clone(\n                \u0026mut alice_endpoint_service_id,\n                endpoint_service_id,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!alice_endpoint_service_id.is_null());\n        unsafe {\n            ALICE_ENDPOINT_SERVICE_ID = alice_endpoint_service_id;\n        }\n\n        let mut pat_onion_auth_private_key: *mut GoslingX25519PrivateKey = ptr::null_mut();\n        unsafe {\n            gosling_x25519_private_key_clone(\n                \u0026mut pat_onion_auth_private_key,\n                client_auth_private_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_onion_auth_private_key.is_null());\n        unsafe {\n            PAT_ONION_AUTH_PRIVATE_KEY = pat_onion_auth_private_key;\n        }\n\n        println!(\"--- pat identity handshake completed\");\n\n        unsafe {\n            PAT_ENDPOINT_REQUEST_COMPLETE = true;\n        }\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_handshake_completed_callback(\n            pat_context,\n            Some(pat_identity_client_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn pat_identity_client_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n\n        panic!(\"--- pat identity handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_identity_client_handshake_failed_callback(\n            pat_context,\n            Some(pat_identity_client_handshake_failed_callback)\n        )\n    );\n\n    static mut ALICE_ENDPOINT_REQUEST_COMPLETE: bool = false;\n    static mut ALICE_ENDPOINT_PRIVATE_KEY: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n    static mut PAT_IDENTITY_SERVICE_ID: *mut GoslingV3OnionServiceId = ptr::null_mut();\n    static mut PAT_ONION_AUTH_PUBLIC_KEY: *mut GoslingX25519PublicKey = ptr::null_mut();\n    unsafe {\n        ALICE_ENDPOINT_REQUEST_COMPLETE = false;\n        ALICE_ENDPOINT_PRIVATE_KEY = ptr::null_mut();\n        PAT_IDENTITY_SERVICE_ID = ptr::null_mut();\n        PAT_ONION_AUTH_PUBLIC_KEY = ptr::null_mut();\n    }\n\n    extern \"C\" fn alice_identity_server_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_private_key: *const GoslingEd25519PrivateKey,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n        client_service_id: *const GoslingV3OnionServiceId,\n        client_auth_public_key: *const GoslingX25519PublicKey,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_private_key.is_null());\n        assert!(!endpoint_name.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n        assert!(!client_service_id.is_null());\n        assert!(!client_auth_public_key.is_null());\n\n        let mut error: *mut GoslingError = ptr::null_mut();\n\n        let mut alice_endpoint_private_key: *mut GoslingEd25519PrivateKey = ptr::null_mut();\n        unsafe {\n            gosling_ed25519_private_key_clone(\n                \u0026mut alice_endpoint_private_key,\n                endpoint_private_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!alice_endpoint_private_key.is_null());\n        unsafe {\n            ALICE_ENDPOINT_PRIVATE_KEY = alice_endpoint_private_key;\n        }\n\n        let mut pat_identity_service_id: *mut GoslingV3OnionServiceId = ptr::null_mut();\n        unsafe {\n            gosling_v3_onion_service_id_clone(\n                \u0026mut pat_identity_service_id,\n                client_service_id,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_identity_service_id.is_null());\n        unsafe {\n            PAT_IDENTITY_SERVICE_ID = pat_identity_service_id;\n        }\n\n        let mut pat_onion_auth_public_key: *mut GoslingX25519PublicKey = ptr::null_mut();\n        unsafe {\n            gosling_x25519_public_key_clone(\n                \u0026mut pat_onion_auth_public_key,\n                client_auth_public_key,\n                \u0026mut error,\n            );\n        }\n        assert!(error.is_null());\n        assert!(!pat_onion_auth_public_key.is_null());\n        unsafe {\n            PAT_ONION_AUTH_PUBLIC_KEY = pat_onion_auth_public_key;\n        }\n\n        println!(\"--- alice identity handshake completed\");\n\n        unsafe {\n            ALICE_ENDPOINT_REQUEST_COMPLETE = true;\n        }\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_handshake_completed_callback(\n            alice_context,\n            Some(alice_identity_server_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_identity_server_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n\n        panic!(\"--- alice identity handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_identity_server_handshake_failed_callback(\n            alice_context,\n            Some(alice_identity_server_handshake_failed_callback)\n        )\n    );\n\n    let mut pat_begin_identity_handshake_succeeded = false;\n    for k in 1..=3 {\n        println!(\"--- pat begin identity handshake attempt {}\", k);\n\n        let mut error: *mut GoslingError = ptr::null_mut();\n        gosling_context_begin_identity_handshake(\n            pat_context,\n            alice_identity,\n            ENDPOINT_NAME.as_ptr(),\n            ENDPOINT_NAME.to_bytes().len(),\n            \u0026mut error,\n        );\n\n        if error.is_null() {\n            pat_begin_identity_handshake_succeeded = true;\n            break;\n        } else {\n            let error_message = unsafe {\n                CStr::from_ptr(gosling_error_get_message(error))\n                    .to_str()\n                    .unwrap()\n            };\n            println!(\"--- pat begin identity hanshake failed: {}\", error_message);\n            gosling_error_free(error);\n        }\n    }\n    assert!(pat_begin_identity_handshake_succeeded);\n\n    while unsafe { !ALICE_ENDPOINT_REQUEST_COMPLETE } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    // start alice's enddpoint server\n\n    static mut ALICE_ENDPOINT_PUBLISHED: bool = false;\n    unsafe {\n        ALICE_ENDPOINT_PUBLISHED = false;\n    }\n\n    extern \"C\" fn alice_endpoint_server_published_callback(\n        context: *mut GoslingContext,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        endpoint_name: *const c_char,\n        endpoint_name_length: usize,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        let endpoint_name = unsafe { CStr::from_ptr(endpoint_name) };\n        assert_eq!(endpoint_name.to_bytes().len(), endpoint_name_length);\n        assert_eq!(endpoint_name, ENDPOINT_NAME);\n\n        println!(\"--- alice endpoint server published\");\n        unsafe {\n            ALICE_ENDPOINT_PUBLISHED = true;\n        }\n    }\n    require_noerror!(gosling_context_set_endpoint_server_published_callback(\n        alice_context,\n        Some(alice_endpoint_server_published_callback)\n    ));\n\n    println!(\"--- start init alice endpoint server\");\n    require_noerror!(gosling_context_start_endpoint_server(\n        alice_context,\n        ALICE_ENDPOINT_PRIVATE_KEY,\n        ENDPOINT_NAME.as_ptr(),\n        ENDPOINT_NAME.to_bytes().len(),\n        PAT_IDENTITY_SERVICE_ID,\n        PAT_ONION_AUTH_PUBLIC_KEY\n    ));\n\n    while unsafe { !PAT_ENDPOINT_REQUEST_COMPLETE || !ALICE_ENDPOINT_PUBLISHED } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    #[cfg(target_os = \"windows\")]\n    type TcpSocket = RawSocket;\n    #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n    type TcpSocket = RawFd;\n\n    static mut PAT_SOCKET: Option\u003cTcpSocket\u003e = None;\n    static mut ALICE_SOCKET: Option\u003cTcpSocket\u003e = None;\n    unsafe {\n        PAT_SOCKET = None;\n        ALICE_SOCKET = None;\n    }\n\n    extern \"C\" fn pat_enpdoint_client_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: TcpSocket,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!channel_name.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        assert_eq!(channel_name, CHANNEL_NAME);\n\n        unsafe {\n            PAT_SOCKET = Some(stream);\n        }\n        println!(\"--- pat endpoint handshake complete\");\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_client_handshake_completed_callback(\n            pat_context,\n            Some(pat_enpdoint_client_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn pat_endpoint_client_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n        panic!(\"--- pat endpoint handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_client_handshake_failed_callback(\n            pat_context,\n            Some(pat_endpoint_client_handshake_failed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_endpoint_server_handshake_completed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        endpoint_service_id: *const GoslingV3OnionServiceId,\n        client_service_id: *const GoslingV3OnionServiceId,\n        channel_name: *const c_char,\n        channel_name_length: usize,\n        stream: TcpSocket,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!endpoint_service_id.is_null());\n        assert!(!client_service_id.is_null());\n        assert!(!channel_name.is_null());\n        let channel_name = unsafe { CStr::from_ptr(channel_name) };\n        assert_eq!(channel_name.to_bytes().len(), channel_name_length);\n        assert_eq!(channel_name, CHANNEL_NAME);\n\n        unsafe { ALICE_SOCKET = Some(stream) };\n        println!(\"--- alice endpoint hanshake complete\");\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_handshake_completed_callback(\n            alice_context,\n            Some(alice_endpoint_server_handshake_completed_callback)\n        )\n    );\n\n    extern \"C\" fn alice_endpoint_server_handshake_failed_callback(\n        context: *mut GoslingContext,\n        _handshake_handle: usize,\n        error: *const GoslingError,\n    ) -\u003e () {\n        assert!(!context.is_null());\n        assert!(!error.is_null());\n\n        let error_message = unsafe {\n            CStr::from_ptr(gosling_error_get_message(error))\n                .to_str()\n                .unwrap()\n        };\n        panic!(\"--- alice endpoint handshake failed: {}\", error_message);\n    }\n    require_noerror!(\n        gosling_context_set_endpoint_server_handshake_failed_callback(\n            alice_context,\n            Some(alice_endpoint_server_handshake_failed_callback)\n        )\n    );\n\n    let mut pat_begin_endpoint_handshake_succeeded = false;\n    for k in 1..=3 {\n        println!(\"--- pat begin endpoint handshake attempt {}\", k);\n\n        let mut error: *mut GoslingError = ptr::null_mut();\n        unsafe {\n            gosling_context_begin_endpoint_handshake(\n                pat_context,\n                ALICE_ENDPOINT_SERVICE_ID,\n                PAT_ONION_AUTH_PRIVATE_KEY,\n                CHANNEL_NAME.as_ptr(),\n                CHANNEL_NAME.to_bytes().len(),\n                \u0026mut error,\n            );\n        }\n\n        if error.is_null() {\n            pat_begin_endpoint_handshake_succeeded = true;\n            break;\n        } else {\n            let error_message = unsafe {\n                CStr::from_ptr(gosling_error_get_message(error))\n                    .to_str()\n                    .unwrap()\n            };\n            println!(\"--- pat begin endpoint hanshake failed: {}\", error_message);\n            gosling_error_free(error);\n        }\n    }\n    assert!(pat_begin_endpoint_handshake_succeeded);\n\n    while unsafe { PAT_SOCKET.is_none() || ALICE_SOCKET.is_none() } {\n        require_noerror!(gosling_context_poll_events(alice_context));\n        require_noerror!(gosling_context_poll_events(pat_context));\n    }\n\n    #[cfg(unix)]\n    let (mut pat_stream, alice_stream) = unsafe {\n        (\n            TcpStream::from_raw_fd(PAT_SOCKET.unwrap()),\n            TcpStream::from_raw_fd(ALICE_SOCKET.unwrap()),\n        )\n    };\n    #[cfg(windows)]\n    let (mut pat_stream, alice_stream) = unsafe {\n        (\n            TcpStream::from_raw_socket(PAT_SOCKET.unwrap()),\n            TcpStream::from_raw_socket(ALICE_SOCKET.unwrap()),\n        )\n    };\n\n    println!(\"--- pat writes message\");\n\n    static MESSAGE: \u0026str = \"Hello Alice!\\n\";\n\n    pat_stream.write(MESSAGE.as_bytes())?;\n    pat_stream.flush()?;\n\n    println!(\"--- alice waits for message\");\n\n    alice_stream.set_nonblocking(false)?;\n    let mut alice_reader = BufReader::new(alice_stream);\n    let mut alice_read_string: String = Default::default();\n    let mut alice_message_read: bool = false;\n    while !alice_message_read {\n        match alice_reader.read_line(\u0026mut alice_read_string) {\n            Ok(0) =\u003e {\n                println!(\"--- alice reads 0\");\n            }\n            Ok(val) =\u003e {\n                assert_eq!(val, MESSAGE.len());\n                assert_eq!(alice_read_string, MESSAGE);\n                // remove trailing new-line\n                alice_read_string.truncate(alice_read_string.len() - 1);\n\n                println!(\"--- alice received '{}'\", alice_read_string);\n                alice_message_read = true;\n            }\n            Err(err) =\u003e bail!(\"{}\", err),\n        }\n    }\n\n    // we have to free gosling library at the end or else the backing TorProvider will go away\n    // and then pat_stream and alice_stream will no longer be valid\n    println!(\"--- free gosling library\");\n    gosling_library_free(library);\n\n    Ok(())\n}\n","traces":[{"line":29,"address":[1727060,1733343,1729076],"length":1,"stats":{"Line":3}},{"line":30,"address":[1707148,1719541,1722404,1721081,1710926,1713122,1717217,1712249,1718650,1709990,1723277,1708209,1707516,1715945,1720293],"length":1,"stats":{"Line":47}},{"line":31,"address":[1708226,1717330,1710127,1721101,1718787,1712362,1722517,1713142,1716175,1707533,1723297,1707157,1710946,1719569,1720321],"length":1,"stats":{"Line":47}},{"line":32,"address":[1716202,1710159,1710973,1718819,1719588,1722549,1712394,1713169,1717357,1707555,1721128,1708248,1723324,1707173,1720340],"length":1,"stats":{"Line":47}},{"line":33,"address":[1710262,1712485,1713202,1719691,1717453,1720379,1719627,1710198,1720443,1721167,1722582,1707229,1711069,1718858,1723357,1716241,1713270,1708575,1723425,1711012,1717396,1712427,1721224,1716305,1722640,1707904,1718922],"length":1,"stats":{"Line":0}},{"line":34,"address":[1717461,1717610,1708603,1719079,1708016,1719699,1707254,1723570,1710419,1707338,1707932,1710270,1718930,1721232,1716462,1708687,1711226,1712630,1723433,1720600,1722785,1719848,1722648,1713415,1711077,1720451,1721381,1716313,1712493,1713278],"length":1,"stats":{"Line":0}},{"line":35,"address":[1711339,1719192,1722898,1721494,1708798,1719961,1712743,1717723,1713528,1710532,1708127,1720713,1707437,1723683,1716575],"length":1,"stats":{"Line":0}},{"line":36,"address":[1720249,1713588,1711399,1721001,1723197,1707844,1716635,1719252,1718028,1721554,1722958,1717783,1719497,1708316,1710837,1711627,1713042,1713832,1720021,1712803,1708894,1720773,1707623,1710592,1721782,1716880,1723743,1723987,1708531,1709107],"length":1,"stats":{"Line":0}},{"line":60,"address":[1727782,1727040],"length":1,"stats":{"Line":1}},{"line":61,"address":[1728384],"length":1,"stats":{"Line":1}},{"line":67,"address":[1728461,1728408],"length":1,"stats":{"Line":1}},{"line":68,"address":[1728418,1728489],"length":1,"stats":{"Line":1}},{"line":72,"address":[1727125],"length":1,"stats":{"Line":1}},{"line":79,"address":[1728560],"length":1,"stats":{"Line":1}},{"line":87,"address":[1728627,1728653],"length":1,"stats":{"Line":1}},{"line":88,"address":[1728642,1728730],"length":1,"stats":{"Line":1}},{"line":89,"address":[1728681,1728758],"length":1,"stats":{"Line":1}},{"line":91,"address":[1728813],"length":1,"stats":{"Line":1}},{"line":93,"address":[1728834],"length":1,"stats":{"Line":1}},{"line":94,"address":[1729022,1728942],"length":1,"stats":{"Line":1}},{"line":102,"address":[1728989],"length":1,"stats":{"Line":1}},{"line":104,"address":[1727434],"length":1,"stats":{"Line":1}},{"line":111,"address":[1728062],"length":1,"stats":{"Line":1}},{"line":114,"address":[1729056,1729864],"length":1,"stats":{"Line":1}},{"line":115,"address":[1732416],"length":1,"stats":{"Line":1}},{"line":120,"address":[1732440,1732467],"length":1,"stats":{"Line":1}},{"line":121,"address":[1732507,1732455],"length":1,"stats":{"Line":1}},{"line":125,"address":[1729189],"length":1,"stats":{"Line":1}},{"line":130,"address":[1732544],"length":1,"stats":{"Line":1}},{"line":136,"address":[1732661,1732575],"length":1,"stats":{"Line":1}},{"line":137,"address":[1732589],"length":1,"stats":{"Line":1}},{"line":138,"address":[1732689,1732604],"length":1,"stats":{"Line":1}},{"line":139,"address":[1732739],"length":1,"stats":{"Line":1}},{"line":144,"address":[1729513],"length":1,"stats":{"Line":1}},{"line":151,"address":[1732784],"length":1,"stats":{"Line":1}},{"line":155,"address":[1732798,1732818],"length":1,"stats":{"Line":1}},{"line":158,"address":[1730188],"length":1,"stats":{"Line":1}},{"line":163,"address":[1732848],"length":1,"stats":{"Line":1}},{"line":169,"address":[1732904,1732879],"length":1,"stats":{"Line":1}},{"line":170,"address":[1732975,1732893],"length":1,"stats":{"Line":1}},{"line":171,"address":[1732932,1733003],"length":1,"stats":{"Line":1}},{"line":174,"address":[1733057],"length":1,"stats":{"Line":1}},{"line":176,"address":[1733087],"length":1,"stats":{"Line":1}},{"line":178,"address":[1730838],"length":1,"stats":{"Line":1}},{"line":185,"address":[1733120],"length":1,"stats":{"Line":1}},{"line":191,"address":[1733178,1733153],"length":1,"stats":{"Line":1}},{"line":192,"address":[1733219,1733167],"length":1,"stats":{"Line":1}},{"line":193,"address":[1733211],"length":1,"stats":{"Line":1}},{"line":194,"address":[1733299],"length":1,"stats":{"Line":0}},{"line":198,"address":[1733256],"length":1,"stats":{"Line":1}},{"line":200,"address":[1733272],"length":1,"stats":{"Line":1}},{"line":205,"address":[1731488],"length":1,"stats":{"Line":1}},{"line":212,"address":[1732094],"length":1,"stats":{"Line":1}},{"line":215,"address":[1733328,1733955],"length":1,"stats":{"Line":1}},{"line":216,"address":[1734000],"length":1,"stats":{"Line":1}},{"line":223,"address":[1734044,1734071],"length":1,"stats":{"Line":1}},{"line":224,"address":[1734059,1734115],"length":1,"stats":{"Line":1}},{"line":225,"address":[1734223,1734103],"length":1,"stats":{"Line":1}},{"line":226,"address":[1734148],"length":1,"stats":{"Line":1}},{"line":227,"address":[1734251,1734163],"length":1,"stats":{"Line":1}},{"line":228,"address":[1734301],"length":1,"stats":{"Line":1}},{"line":233,"address":[1733392],"length":1,"stats":{"Line":1}},{"line":240,"address":[1733657],"length":1,"stats":{"Line":1}},{"line":428,"address":[1734336,1735199],"length":1,"stats":{"Line":1}},{"line":431,"address":[1734343],"length":1,"stats":{"Line":1}},{"line":432,"address":[1734412],"length":1,"stats":{"Line":1}},{"line":435,"address":[1734804],"length":1,"stats":{"Line":1}},{"line":437,"address":[1734879],"length":1,"stats":{"Line":1}},{"line":440,"address":[1736670,1735248],"length":1,"stats":{"Line":1}},{"line":447,"address":[1735333],"length":1,"stats":{"Line":1}},{"line":448,"address":[1735896],"length":1,"stats":{"Line":1}},{"line":451,"address":[1736263],"length":1,"stats":{"Line":1}},{"line":452,"address":[1736311],"length":1,"stats":{"Line":1}},{"line":457,"address":[1737002],"length":1,"stats":{"Line":1}},{"line":458,"address":[1737050],"length":1,"stats":{"Line":1}},{"line":466,"address":[1738118,1737675],"length":1,"stats":{"Line":1}},{"line":467,"address":[1738312,1738055],"length":1,"stats":{"Line":1}},{"line":470,"address":[1738159],"length":1,"stats":{"Line":1}},{"line":471,"address":[1738218],"length":1,"stats":{"Line":1}},{"line":474,"address":[1738628],"length":1,"stats":{"Line":1}},{"line":475,"address":[1738676],"length":1,"stats":{"Line":1}},{"line":480,"address":[1739329],"length":1,"stats":{"Line":1}},{"line":481,"address":[1739377],"length":1,"stats":{"Line":1}},{"line":489,"address":[1740002,1740517],"length":1,"stats":{"Line":1}},{"line":494,"address":[1740382],"length":1,"stats":{"Line":1}},{"line":496,"address":[1762032],"length":1,"stats":{"Line":1}},{"line":497,"address":[1762041,1762112],"length":1,"stats":{"Line":1}},{"line":498,"address":[1762051],"length":1,"stats":{"Line":1}},{"line":499,"address":[1762078],"length":1,"stats":{"Line":1}},{"line":501,"address":[1740456],"length":1,"stats":{"Line":1}},{"line":506,"address":[1740809],"length":1,"stats":{"Line":1}},{"line":507,"address":[1740880],"length":1,"stats":{"Line":1}},{"line":508,"address":[1741490],"length":1,"stats":{"Line":1}},{"line":509,"address":[1741880],"length":1,"stats":{"Line":1}},{"line":514,"address":[1741929],"length":1,"stats":{"Line":1}},{"line":516,"address":[1762144],"length":1,"stats":{"Line":1}},{"line":517,"address":[1762224,1762153],"length":1,"stats":{"Line":1}},{"line":518,"address":[1762163],"length":1,"stats":{"Line":1}},{"line":520,"address":[1762192],"length":1,"stats":{"Line":1}},{"line":522,"address":[1741995],"length":1,"stats":{"Line":1}},{"line":527,"address":[1742879],"length":1,"stats":{"Line":1}},{"line":528,"address":[1742950],"length":1,"stats":{"Line":1}},{"line":530,"address":[1743560],"length":1,"stats":{"Line":1}},{"line":531,"address":[1743950],"length":1,"stats":{"Line":1}},{"line":537,"address":[1743999],"length":1,"stats":{"Line":1}},{"line":539,"address":[1762256],"length":1,"stats":{"Line":1}},{"line":540,"address":[1762265,1762336],"length":1,"stats":{"Line":1}},{"line":542,"address":[1762275],"length":1,"stats":{"Line":1}},{"line":544,"address":[1762304],"length":1,"stats":{"Line":1}},{"line":546,"address":[1744073],"length":1,"stats":{"Line":1}},{"line":551,"address":[1744949],"length":1,"stats":{"Line":1}},{"line":552,"address":[1745020],"length":1,"stats":{"Line":1}},{"line":553,"address":[1745630],"length":1,"stats":{"Line":1}},{"line":554,"address":[1746020],"length":1,"stats":{"Line":1}},{"line":563,"address":[1746069],"length":1,"stats":{"Line":1}},{"line":564,"address":[1746100],"length":1,"stats":{"Line":1}},{"line":565,"address":[1746135],"length":1,"stats":{"Line":1}},{"line":568,"address":[1762368],"length":1,"stats":{"Line":1}},{"line":577,"address":[1762448,1762475],"length":1,"stats":{"Line":1}},{"line":578,"address":[1762463,1762520],"length":1,"stats":{"Line":1}},{"line":579,"address":[1762565,1762508],"length":1,"stats":{"Line":1}},{"line":580,"address":[1762553,1762673],"length":1,"stats":{"Line":1}},{"line":581,"address":[1762598],"length":1,"stats":{"Line":1}},{"line":582,"address":[1762613,1762701],"length":1,"stats":{"Line":1}},{"line":583,"address":[1762751],"length":1,"stats":{"Line":1}},{"line":584,"address":[1762865,1762994],"length":1,"stats":{"Line":1}},{"line":586,"address":[1762904],"length":1,"stats":{"Line":1}},{"line":588,"address":[1762940],"length":1,"stats":{"Line":1}},{"line":596,"address":[1763022,1762974],"length":1,"stats":{"Line":1}},{"line":597,"address":[1763050,1763166],"length":1,"stats":{"Line":1}},{"line":599,"address":[1763073],"length":1,"stats":{"Line":1}},{"line":602,"address":[1763112],"length":1,"stats":{"Line":1}},{"line":610,"address":[1763194,1763146],"length":1,"stats":{"Line":1}},{"line":611,"address":[1763305,1763222],"length":1,"stats":{"Line":1}},{"line":613,"address":[1763240],"length":1,"stats":{"Line":1}},{"line":616,"address":[1763255],"length":1,"stats":{"Line":1}},{"line":619,"address":[1763290],"length":1,"stats":{"Line":1}},{"line":622,"address":[1746190],"length":1,"stats":{"Line":1}},{"line":629,"address":[1763344],"length":1,"stats":{"Line":0}},{"line":634,"address":[1763380,1763411],"length":1,"stats":{"Line":0}},{"line":635,"address":[1763734,1763395],"length":1,"stats":{"Line":0}},{"line":637,"address":[1763444,1763599],"length":1,"stats":{"Line":0}},{"line":642,"address":[1763669],"length":1,"stats":{"Line":0}},{"line":644,"address":[1747102],"length":1,"stats":{"Line":1}},{"line":656,"address":[1747738],"length":1,"stats":{"Line":1}},{"line":657,"address":[1747769],"length":1,"stats":{"Line":1}},{"line":658,"address":[1747804],"length":1,"stats":{"Line":1}},{"line":659,"address":[1747839],"length":1,"stats":{"Line":1}},{"line":662,"address":[1763776],"length":1,"stats":{"Line":1}},{"line":671,"address":[1763882,1763855],"length":1,"stats":{"Line":1}},{"line":672,"address":[1763870,1763927],"length":1,"stats":{"Line":1}},{"line":673,"address":[1763915,1764035],"length":1,"stats":{"Line":1}},{"line":674,"address":[1763960],"length":1,"stats":{"Line":1}},{"line":675,"address":[1764063,1763975],"length":1,"stats":{"Line":1}},{"line":676,"address":[1764113],"length":1,"stats":{"Line":1}},{"line":677,"address":[1764220,1764251],"length":1,"stats":{"Line":1}},{"line":678,"address":[1764235,1764398],"length":1,"stats":{"Line":1}},{"line":680,"address":[1764308],"length":1,"stats":{"Line":1}},{"line":682,"address":[1764344],"length":1,"stats":{"Line":1}},{"line":690,"address":[1764378,1764426],"length":1,"stats":{"Line":1}},{"line":691,"address":[1764454,1764569],"length":1,"stats":{"Line":1}},{"line":693,"address":[1764476],"length":1,"stats":{"Line":1}},{"line":696,"address":[1764515],"length":1,"stats":{"Line":1}},{"line":704,"address":[1764549,1764597],"length":1,"stats":{"Line":1}},{"line":705,"address":[1764741,1764625],"length":1,"stats":{"Line":1}},{"line":707,"address":[1764648],"length":1,"stats":{"Line":1}},{"line":710,"address":[1764687],"length":1,"stats":{"Line":1}},{"line":718,"address":[1764721,1764769],"length":1,"stats":{"Line":1}},{"line":719,"address":[1764797,1764880],"length":1,"stats":{"Line":1}},{"line":721,"address":[1764815],"length":1,"stats":{"Line":1}},{"line":724,"address":[1764830],"length":1,"stats":{"Line":1}},{"line":727,"address":[1764865],"length":1,"stats":{"Line":1}},{"line":730,"address":[1747886],"length":1,"stats":{"Line":1}},{"line":737,"address":[1764912],"length":1,"stats":{"Line":0}},{"line":742,"address":[1764948,1764979],"length":1,"stats":{"Line":0}},{"line":743,"address":[1765302,1764963],"length":1,"stats":{"Line":0}},{"line":745,"address":[1765167,1765012],"length":1,"stats":{"Line":0}},{"line":750,"address":[1765237],"length":1,"stats":{"Line":0}},{"line":752,"address":[1748566],"length":1,"stats":{"Line":1}},{"line":759,"address":[1749194],"length":1,"stats":{"Line":1}},{"line":760,"address":[1749202,1749594,1749653],"length":1,"stats":{"Line":3}},{"line":761,"address":[1749761],"length":1,"stats":{"Line":1}},{"line":763,"address":[1749860],"length":1,"stats":{"Line":1}},{"line":765,"address":[1749872],"length":1,"stats":{"Line":1}},{"line":766,"address":[1749888],"length":1,"stats":{"Line":1}},{"line":767,"address":[1749904],"length":1,"stats":{"Line":1}},{"line":768,"address":[1749931],"length":1,"stats":{"Line":1}},{"line":772,"address":[1749991],"length":1,"stats":{"Line":1}},{"line":773,"address":[1750403],"length":1,"stats":{"Line":1}},{"line":777,"address":[1750199,1750013],"length":1,"stats":{"Line":0}},{"line":781,"address":[1750309],"length":1,"stats":{"Line":0}},{"line":782,"address":[1750384],"length":1,"stats":{"Line":0}},{"line":785,"address":[1749634,1750416],"length":1,"stats":{"Line":1}},{"line":787,"address":[1750444],"length":1,"stats":{"Line":1}},{"line":788,"address":[1750604],"length":1,"stats":{"Line":1}},{"line":789,"address":[1761106],"length":1,"stats":{"Line":1}},{"line":796,"address":[1750456],"length":1,"stats":{"Line":1}},{"line":799,"address":[1765344],"length":1,"stats":{"Line":1}},{"line":805,"address":[1765415,1765389],"length":1,"stats":{"Line":1}},{"line":806,"address":[1765403,1765523],"length":1,"stats":{"Line":1}},{"line":807,"address":[1765448],"length":1,"stats":{"Line":1}},{"line":808,"address":[1765463,1765551],"length":1,"stats":{"Line":1}},{"line":809,"address":[1765601],"length":1,"stats":{"Line":1}},{"line":811,"address":[1765698],"length":1,"stats":{"Line":1}},{"line":813,"address":[1765733],"length":1,"stats":{"Line":1}},{"line":816,"address":[1750499],"length":1,"stats":{"Line":1}},{"line":821,"address":[1750904],"length":1,"stats":{"Line":1}},{"line":822,"address":[1751079],"length":1,"stats":{"Line":1}},{"line":831,"address":[1751699,1752030],"length":1,"stats":{"Line":2}},{"line":832,"address":[1752286],"length":1,"stats":{"Line":1}},{"line":833,"address":[1759923],"length":1,"stats":{"Line":1}},{"line":844,"address":[1752071],"length":1,"stats":{"Line":1}},{"line":845,"address":[1752108],"length":1,"stats":{"Line":1}},{"line":848,"address":[1765760],"length":1,"stats":{"Line":1}},{"line":856,"address":[1765826,1765852],"length":1,"stats":{"Line":1}},{"line":857,"address":[1765897,1765840],"length":1,"stats":{"Line":1}},{"line":858,"address":[1765885,1766005],"length":1,"stats":{"Line":1}},{"line":859,"address":[1765930],"length":1,"stats":{"Line":1}},{"line":860,"address":[1765945,1766033],"length":1,"stats":{"Line":1}},{"line":861,"address":[1766083],"length":1,"stats":{"Line":1}},{"line":864,"address":[1766184],"length":1,"stats":{"Line":1}},{"line":866,"address":[1766228],"length":1,"stats":{"Line":1}},{"line":868,"address":[1752181],"length":1,"stats":{"Line":1}},{"line":875,"address":[1766272],"length":1,"stats":{"Line":0}},{"line":880,"address":[1766339,1766308],"length":1,"stats":{"Line":0}},{"line":881,"address":[1766323,1766662],"length":1,"stats":{"Line":0}},{"line":884,"address":[1766372,1766527],"length":1,"stats":{"Line":0}},{"line":888,"address":[1766597],"length":1,"stats":{"Line":0}},{"line":890,"address":[1752630],"length":1,"stats":{"Line":1}},{"line":897,"address":[1766704],"length":1,"stats":{"Line":1}},{"line":906,"address":[1766782,1766809],"length":1,"stats":{"Line":1}},{"line":907,"address":[1766854,1766797],"length":1,"stats":{"Line":1}},{"line":908,"address":[1766842,1766899],"length":1,"stats":{"Line":1}},{"line":909,"address":[1766887,1767007],"length":1,"stats":{"Line":1}},{"line":910,"address":[1766932],"length":1,"stats":{"Line":1}},{"line":911,"address":[1766947,1767035],"length":1,"stats":{"Line":1}},{"line":912,"address":[1767085],"length":1,"stats":{"Line":1}},{"line":914,"address":[1767198],"length":1,"stats":{"Line":1}},{"line":915,"address":[1767242],"length":1,"stats":{"Line":1}},{"line":917,"address":[1753294],"length":1,"stats":{"Line":1}},{"line":924,"address":[1767296],"length":1,"stats":{"Line":0}},{"line":929,"address":[1767363,1767332],"length":1,"stats":{"Line":0}},{"line":930,"address":[1767347,1767686],"length":1,"stats":{"Line":0}},{"line":933,"address":[1767396,1767551],"length":1,"stats":{"Line":0}},{"line":937,"address":[1767621],"length":1,"stats":{"Line":0}},{"line":939,"address":[1753974],"length":1,"stats":{"Line":1}},{"line":946,"address":[1754602],"length":1,"stats":{"Line":1}},{"line":947,"address":[1755002,1755061,1754610],"length":1,"stats":{"Line":3}},{"line":948,"address":[1755169],"length":1,"stats":{"Line":1}},{"line":950,"address":[1755268],"length":1,"stats":{"Line":1}},{"line":953,"address":[1755280],"length":1,"stats":{"Line":1}},{"line":954,"address":[1755296],"length":1,"stats":{"Line":1}},{"line":955,"address":[1755311],"length":1,"stats":{"Line":1}},{"line":956,"address":[1755326],"length":1,"stats":{"Line":1}},{"line":957,"address":[1755353],"length":1,"stats":{"Line":1}},{"line":962,"address":[1755421],"length":1,"stats":{"Line":1}},{"line":963,"address":[1755833],"length":1,"stats":{"Line":1}},{"line":967,"address":[1755629,1755443],"length":1,"stats":{"Line":0}},{"line":971,"address":[1755739],"length":1,"stats":{"Line":0}},{"line":972,"address":[1755814],"length":1,"stats":{"Line":0}},{"line":975,"address":[1755846,1755042],"length":1,"stats":{"Line":1}},{"line":977,"address":[1755874],"length":1,"stats":{"Line":1}},{"line":978,"address":[1756137],"length":1,"stats":{"Line":1}},{"line":979,"address":[1758740],"length":1,"stats":{"Line":1}},{"line":985,"address":[1756004,1755935],"length":1,"stats":{"Line":2}},{"line":986,"address":[1756016,1756237],"length":1,"stats":{"Line":2}},{"line":997,"address":[1756354,1756287],"length":1,"stats":{"Line":2}},{"line":1001,"address":[1756373,1756595,1758340],"length":1,"stats":{"Line":1}},{"line":1002,"address":[1756580,1756648,1756738,1758319],"length":1,"stats":{"Line":2}},{"line":1004,"address":[1756783,1756712],"length":1,"stats":{"Line":2}},{"line":1006,"address":[1735309,1756933,1756802,1758298],"length":1,"stats":{"Line":2}},{"line":1007,"address":[1756903],"length":1,"stats":{"Line":1}},{"line":1008,"address":[1756986],"length":1,"stats":{"Line":1}},{"line":1009,"address":[1757033],"length":1,"stats":{"Line":1}},{"line":1010,"address":[1757041],"length":1,"stats":{"Line":1}},{"line":1011,"address":[1757067,1757179],"length":1,"stats":{"Line":2}},{"line":1013,"address":[1757408,1757337],"length":1,"stats":{"Line":0}},{"line":1015,"address":[1757363],"length":1,"stats":{"Line":1}},{"line":1016,"address":[1757379,1757440],"length":1,"stats":{"Line":2}},{"line":1017,"address":[1757576],"length":1,"stats":{"Line":1}},{"line":1019,"address":[1757701],"length":1,"stats":{"Line":1}},{"line":1021,"address":[1757871],"length":1,"stats":{"Line":1}},{"line":1022,"address":[1757940],"length":1,"stats":{"Line":1}},{"line":1024,"address":[1757222,1757953],"length":1,"stats":{"Line":0}},{"line":1030,"address":[1757090,1758179],"length":1,"stats":{"Line":2}},{"line":1031,"address":[1758206],"length":1,"stats":{"Line":1}},{"line":1033,"address":[1758217],"length":1,"stats":{"Line":1}}],"covered":254,"coverable":287},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","cgosling-proc-macros","src","lib.rs"],"content":"use proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, ItemFn};\n\n// This macro renames a function call to a _impl variant.\n//\n// Why is this necessary? Basically, cargo  cannot currently be relied\n// on to build cdylibs correctly due to various issues limited to but\n// probably not including:\n// - not setting soname for linux shared libraries\n// - naming import libs incorrectly for mingw windows\n// - not generating correct symlinks based on version and major version for linux and macos\n//\n// The recommended solution is to use the cdylib_link_lines crate to work around\n// some of these problems, but I've run into other fun issues with that crate:\n// - import libs output to wrong directory for mingw windows\n// - import_name being set incorrectly for macos\n// - hasn't been updated in some years and seems abandoned\n//\n// So now dear reader, we come to this monstrosity. This is just one part of\n// the rest of the build system hack to solve all the above problems; namely\n// we will only use rustc to generate a static library, and from there build\n// a shared library using native C tools via CMake which handles all of the\n// above problems.\n//\n// So we need to build our cgosling crate as a static lib twice: first with the\n// ordinary functions names and second with the functions renamed in the form\n// foo() to foo_impl(). The foo_impl() variant will then be linked into a shared\n// library and called through exported functions of the foo() variety using\n// the ordinary toolchain.\n//\n// The cgosling shared library target will call the underlying functions via simple\n// passthrough with the final (logical) call chain being like a so:\n// - shared_library::foo() -\u003e static_library::foo_impl()\n//\n// Static library callers will have the following call chain:\n// - static_library::foo()\n//\n// I'm sorry it had to be this way\n#[proc_macro_attribute]\npub fn rename_impl(_attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    // parse the input as a function\n    let mut impl_fn: ItemFn = parse_macro_input!(item);\n\n    // append \"_impl\" to the original function name for the _impl function\n    impl_fn.sig.ident = syn::Ident::new(\n        \u0026format!(\"{}_impl\", impl_fn.sig.ident),\n        impl_fn.sig.ident.span(),\n    );\n\n    let expanded = quote! {\n        #impl_fn\n    };\n\n    // Return the combined TokenStream\n    TokenStream::from(expanded)\n}\n","traces":[{"line":41,"address":[262670,261616,262554],"length":1,"stats":{"Line":0}},{"line":43,"address":[261690,261642,262563,261860],"length":1,"stats":{"Line":0}},{"line":46,"address":[262194,262314],"length":1,"stats":{"Line":0}},{"line":47,"address":[261963,261769],"length":1,"stats":{"Line":0}},{"line":48,"address":[262157],"length":1,"stats":{"Line":0}},{"line":51,"address":[262365],"length":1,"stats":{"Line":0}},{"line":56,"address":[262484],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","arbitrary_types.rs"],"content":"// extern\nuse bson::Document;\nuse bson::spec::BinarySubtype::Generic;\nuse curve25519_dalek::Scalar;\nuse tor_interface::tor_crypto::*;\n\n// fuzzing\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::{Arbitrary, Error, Unstructured};\n\n// Generate Arbitray Types\n\n// Ed25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519PrivateKey {\n    pub value: Ed25519PrivateKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519PrivateKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        // expanded secret key raw bytes\n        let mut raw: [u8; 64] = [0u8; 64];\n\n        // construct a valid Scalar\n        let mut scalar: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut scalar)?;\n\n        scalar = curve25519_dalek::scalar::clamp_integer(scalar.clone());\n        scalar = Scalar::from_bytes_mod_order(scalar).to_bytes();\n        raw[00..32].copy_from_slice(\u0026scalar);\n\n        let mut hash: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut hash)?;\n\n        raw[32..64].copy_from_slice(\u0026hash);\n\n        let value = Ed25519PrivateKey::from_raw(\u0026raw).unwrap();\n\n        Ok(ArbitraryEd25519PrivateKey{value})\n    }\n}\n\n// Ed25519 Public Key\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519PublicKey {\n    pub value: Ed25519PublicKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519PublicKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = Ed25519PublicKey::from_private_key(\u0026private.value);\n\n        Ok(ArbitraryEd25519PublicKey{value})\n    }\n}\n\n// Ed25519 Signature\n#[derive(Debug)]\npub(crate) struct ArbitraryEd25519Signature {\n    pub value: Ed25519Signature,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryEd25519Signature {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut message: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut message)?;\n\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = private.value.sign_message(\u0026message);\n\n        Ok(ArbitraryEd25519Signature{value})\n    }\n}\n\n// V3OnionServicId\n// x25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryV3OnionServiceId {\n    pub value: V3OnionServiceId,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryV3OnionServiceId {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let private = ArbitraryEd25519PrivateKey::arbitrary(u)?;\n        let value = V3OnionServiceId::from_private_key(\u0026private.value);\n\n        Ok(ArbitraryV3OnionServiceId{value})\n    }\n}\n\n// x25519 Private Key\n#[derive(Debug)]\npub(crate) struct ArbitraryX25519PrivateKey {\n    pub value: X25519PrivateKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryX25519PrivateKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut raw: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut raw)?;\n\n        raw[0] \u0026= 240;\n        raw[31] \u0026= 127;\n        raw[31] |= 64;\n\n        let value = X25519PrivateKey::from_raw(\u0026raw).unwrap();\n\n        Ok(ArbitraryX25519PrivateKey{value})\n    }\n}\n\n// x25519 Public Key\n#[derive(Debug)]\npub(crate) struct ArbitraryX25519PublicKey {\n    pub value: X25519PublicKey,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryX25519PublicKey {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut raw: [u8; 32] = [0u8; 32];\n        u.fill_buffer(\u0026mut raw)?;\n\n        let value = X25519PublicKey::from_raw(\u0026raw);\n\n        Ok(ArbitraryX25519PublicKey{value})\n    }\n}\n\n// Bson\n#[derive(Debug)]\npub(crate) struct ArbitraryBSON {\n    pub value: bson::Bson,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryBSON {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        #[derive(Arbitrary)]\n        enum BSONType {\n            Null, // 0\n            Boolean, // 1\n            Int32, // 2\n            Int64, // 3\n            Double, // 4\n            String, // 5\n            Binary, // 6\n            Array, // 7\n            Document, // 8\n        }\n\n        let value = match BSONType::arbitrary(u)? {\n            BSONType::Null =\u003e bson::Bson::Null,\n            BSONType::Boolean =\u003e bson::Bson::Boolean(bool::arbitrary(u)?),\n            BSONType::Int32 =\u003e bson::Bson::Int32(i32::arbitrary(u)?),\n            BSONType::Int64 =\u003e bson::Bson::Int64(i64::arbitrary(u)?),\n            BSONType::Double =\u003e bson::Bson::Double(f64::arbitrary(u)?),\n            BSONType::String =\u003e {\n                match std::ffi::CString::arbitrary(u)?.into_string() {\n                    Ok(value) =\u003e bson::Bson::String(value),\n                    Err(_) =\u003e bson::Bson::Null,\n                }\n            },\n            BSONType::Binary =\u003e bson::Bson::Binary(bson::Binary {subtype: Generic, bytes: Vec::\u003cu8\u003e::arbitrary(u)?}),\n            BSONType::Array =\u003e bson::Bson::Array(Vec::\u003cArbitraryBSON\u003e::arbitrary(u)?.drain(..).map(|val| val.value).collect()),\n            BSONType::Document =\u003e bson::Bson::Document(ArbitraryBSONDocument::arbitrary(u)?.value),\n        };\n\n        Ok(ArbitraryBSON{value})\n    }\n}\n\n#[derive(Debug)]\npub(crate) struct ArbitraryBSONDocument {\n    pub value: Document,\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for ArbitraryBSONDocument {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut value = Document::new();\n        for key in Vec::\u003cstd::ffi::CString\u003e::arbitrary(u)?.drain(..) {\n            match key.into_string() {\n                Ok(key) =\u003e value.insert(key, ArbitraryBSON::arbitrary(u)?.value),\n                Err(_) =\u003e None,\n            };\n        }\n        Ok(ArbitraryBSONDocument{value})\n    }\n}\n\n// argument for a bson doc\n#[derive(Arbitrary, Debug)]\npub(crate) enum Argument\u003cT\u003e {\n    // no value\n    Missing,\n    // a valid value\n    Valid,\n    // an invalid value of the same type\n    Invalid(T),\n    // an invalid value of an arbitrary type\n    Random(ArbitraryBSON),\n}","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":61},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_endpoint_client.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\n\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nstruct ErrorSection {\n    cookie: Argument\u003ci64\u003e,\n    code: Argument\u003ci32\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nstruct ResponseSection {\n    cookie: Argument\u003ci64\u003e,\n    state: Argument\u003ci32\u003e,\n    result: Argument\u003cArbitraryBSON\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Response {\n    Noise(Vec\u003cu8\u003e),\n    Document(ArbitraryBSONDocument),\n    HonkRPC {\n        single_message: bool,\n        pending: Option\u003cResponseSection\u003e,\n        complete: Option\u003cResponseSection\u003e,\n        error: Option\u003cErrorSection\u003e,\n    },\n}\n\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    alice_endpoint_ed25519: ArbitraryEd25519PrivateKey,\n    server_cookie: Cookie,\n\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n\n    begin_handshake_response: Response,\n    send_response_response: Response,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a malicious/broken server, Bob is a valid client\nfuzz_target!(|data: HandshakeData| {\n\n    // Bob client data\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_service_id_string = bob_service_id.to_string();\n    let bob_private_x25519 = data.bob_private_x25519.value;\n    let bob_public_x25519 = X25519PublicKey::from_private_key(\u0026bob_private_x25519);\n\n    // Alice server data\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_endpoint_ed25519 = data.alice_endpoint_ed25519.value;\n    let alice_endpoint_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_endpoint_ed25519);\n    let alice_endpoint_onion_service_id_string = alice_endpoint_onion_service_id.to_string();\n\n    //\n    // Init malicious Alice server and Bob client\n    //\n\n    // init alice\n    let mut alice_tor = MockTorClient::new();\n\n    // bootstrap alice\n    alice_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n\n    let alice_listener = alice_tor.listener(\u0026alice_endpoint_ed25519, 420, Some(\u0026[bob_public_x25519])).unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::OnionServicePublished{service_id} =\u003e {\n                    assert_eq!(service_id, alice_endpoint_onion_service_id);\n                    identity_server_published = true;\n                },\n                _ =\u003e ()\n            }\n        }\n    }\n\n    // init bob\n    let bob_tor = MockTorClient::new();\n\n    // create bob gosling context\n    let mut bob = Context::new(Box::new(bob_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, Some(std::time::Duration::from_millis(32)), bob_private_key).unwrap();\n    bob.bootstrap().unwrap();\n    let mut bootstrap_complete: bool = false;\n    while !bootstrap_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n    //\n    // Bob initiates handshake\n    //\n    let handshake_handle = bob.endpoint_client_begin_handshake(alice_endpoint_onion_service_id.clone(), bob_private_x25519, VALID_CHANNEL.to_string()).unwrap();\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // alice waits for connect, return OnionStream\n    let mut alice_stream : TcpStream = match alice_listener.accept().unwrap() {\n        Some(stream) =\u003e stream.into(),\n        None =\u003e panic!(\"listener accept failed\"),\n    };\n    alice_stream.set_nonblocking(false).unwrap();\n    alice_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n\n    //\n    // Alice receives begin_handshake() and build responses\n    //\n\n    let begin_handshake_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let begin_handshake_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_ENDPOINT_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_ENDPOINT_BEGIN_HANDSHAKE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        assert_eq!(arguments.get_str(\"client_identity\").unwrap(), bob_service_id_string);\n        assert_eq!(arguments.get_str(\"channel\").unwrap(), VALID_CHANNEL);\n        begin_handshake_cookie\n    };\n\n\n\n    // messages can be built such that multiple errors exist so lets track\n    // all the layers of possible errors\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.begin_handshake_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE \u0026\u0026 state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state == PENDING_REQUEST_STATE {\n                                expect_timeout = true;\n                            } else if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        let mut result = Document::new();\n                        result.insert(\"server_cookie\", Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.server_cookie.to_vec()}));\n                        Some(Bson::Document(result))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!begin_handshake_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives begin_handshake() response and builds reply\n    //\n    for event in bob.update().unwrap().drain(..) {\n        match event {\n            ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                assert_eq!(handshake_handle, handle);\n                match reason {\n                    context::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                        assert!(expect_timeout, \"{:?}\", reason);\n                    }\n                    context::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                        assert!(expect_bson_too_small, \"{:?}\", reason);\n                    },\n                    context::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                        assert!(expect_bson_too_large, \"{:?}\", reason);\n                    },\n                    context::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                        assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                    },\n                    context::Error::EndpointClientError(\n                        endpoint_client::Error::HonkRPCFailure(\n                            honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                        assert!(expect_unknown_error_section, \"{:?}\", reason);\n                    },\n                    context::Error::EndpointClientError(\n                        endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                        assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                    },\n                    error =\u003e panic!(\"unexpected error: {:?}\", error),\n                }\n                // bob should have closed the connection on alice after handshake failure\n                return;\n            }\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    // handle dangling unexpected response\n    for event in bob.update().unwrap().drain(..) {\n        match event {\n            ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                assert_eq!(handshake_handle, handle);\n                match reason {\n                    context::Error::EndpointClientError(\n                        endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                        assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                    },\n                    error =\u003e panic!(\"unexpected error: {:?}\", error),\n                }\n                // bob should have closed the connection on alice after handshake failure\n                return;\n            }\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // give it a chance to timeout if it is mean to\n    while expect_timeout {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        context::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e (),\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    // println!(\"expect_timeout: {}\", expect_timeout);\n\n    // Alice receives send_reponse() and builds response\n    let send_response_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let send_response_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_ENDPOINT_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_ENDPOINT_SEND_RESPONSE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        let client_cookie = arguments.get_binary_generic(\"client_cookie\").unwrap();\n        let client_identity_proof_signature = arguments.get_binary_generic(\"client_identity_proof_signature\").unwrap();\n\n        send_response_cookie\n    };\n\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.send_response_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE || state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE \u0026\u0026 state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state == PENDING_REQUEST_STATE {\n                                expect_timeout = true;\n                            } else if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        Some(Bson::Document(doc!{}))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!send_response_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives send_response() response and finishes handshake\n    //\n    let mut send_response_complete: bool = false;\n    while !send_response_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        context::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        context::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointClientError(\n                            endpoint_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointClientError(\n                            endpoint_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                },\n                ContextEvent::EndpointClientHandshakeCompleted{handle, endpoint_service_id, channel_name, stream: _} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(channel_name, VALID_CHANNEL);\n                    send_response_complete = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_endpoint_server.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse data_encoding::HEXLOWER;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\nuse honk_rpc::honk_rpc::{get_message_overhead, get_response_section_size};\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nenum BeginHandshakeMessage {\n    // random bytes\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc request\n    Request{\n        version: Argument\u003cString\u003e,\n        client_identity: Argument\u003cArbitraryV3OnionServiceId\u003e,\n        channel: Argument\u003cString\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nenum SendResponseMessage {\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc requst\n    Request{\n        client_cookie: Argument\u003cCookie\u003e,\n        client_identity_proof_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    alice_endpoint_ed25519: ArbitraryEd25519PrivateKey,\n    channel_supported: bool,\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n    client_cookie: Cookie,\n    // client messages\n    begin_handshake_cookie: i64,\n    begin_handshake: BeginHandshakeMessage,\n    send_response_cookie: i64,\n    send_response: SendResponseMessage,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a valid server, Bob connects and sends garbage at certain point in the form of bad data in correctly structured+ordered gosling bison messages or noise\nfuzz_target!(|data: HandshakeData| {\n\n    // alice server data\n    let alice_identity_ed25519 = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_identity_ed25519);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_endpoint_ed25519 = data.alice_endpoint_ed25519.value;\n    let alice_endpoint_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_endpoint_ed25519);\n    let alice_endpoint_onion_service_id_string = alice_endpoint_onion_service_id.to_string();\n\n\n    // bob client data\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_onion_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_onion_service_id_string = bob_onion_service_id.to_string();\n    let bob_private_x25519 = data.bob_private_x25519.value;\n    let bob_public_x25519 = X25519PublicKey::from_private_key(\u0026bob_private_x25519);\n\n    //\n    // Init Alice server and malicious Bob client\n    //\n\n    // init alice\n    let alice_tor = MockTorClient::new();\n\n    // create alice gosling context\n    let mut alice = Context::new(Box::new(alice_tor), 420, 420, std::time::Duration::from_millis(32), ENDPOINT_MAX_MESSAGE_SIZE, Some(std::time::Duration::from_millis(32)), alice_identity_ed25519.clone()).unwrap();\n\n    // bootstrap alice\n    alice.bootstrap().unwrap();\n    let mut endpoint_server_published: bool = false;\n    while !endpoint_server_published {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    // start alice endpoint server\n                    match alice.endpoint_server_start(alice_endpoint_ed25519.clone(), VALID_ENDPOINT.to_string(), bob_onion_service_id.clone(), bob_public_x25519.clone()) {\n                        Ok(()) =\u003e (),\n                        Err(context::Error::InvalidArgument(_)) =\u003e {\n                            assert_eq!(alice_onion_service_id_string, alice_endpoint_onion_service_id_string);\n                            return;\n                        },\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                ContextEvent::EndpointServerPublished{endpoint_service_id, endpoint_name} =\u003e {\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    endpoint_server_published = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n\n    // init bob\n    let mut bob_tor = MockTorClient::new();\n\n    // bootstrap bob\n    bob_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in bob_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n    bob_tor.add_client_auth(\u0026alice_endpoint_onion_service_id, \u0026bob_private_x25519).unwrap();\n\n    // bob connects to alice\n    let mut bob_stream = bob_tor.connect((alice_endpoint_onion_service_id.clone(), 420).into(), None).unwrap();\n    bob_stream.set_nonblocking(false).unwrap();\n    bob_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n\n    //\n    // Alice waits for handshake started\n    //\n    let mut alice_handshake_started: bool = false;\n    let mut alice_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    while !alice_handshake_started {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerHandshakeStarted{handle} =\u003e {\n                    alice_handshake_started = true;\n                    alice_handshake_handle = handle;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob sends begin_handshake()\n    //\n    #[derive(PartialEq, Debug)]\n    enum ExpectedBeginHandshakeResponse {\n        // Success Case\n        EndpointRequestReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorBadGoslingVersion,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = ExpectedBeginHandshakeResponse::EndpointRequestReceived;\n\n    let message = match \u0026data.begin_handshake {\n        BeginHandshakeMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedBeginHandshakeResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedBeginHandshakeResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedBeginHandshakeResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedBeginHandshakeResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        BeginHandshakeMessage::Request{\n            version,\n            client_identity,\n            channel} =\u003e {\n            match (\u0026version, \u0026client_identity, \u0026channel) {\n                (Argument::Valid, Argument::Valid | Argument::Invalid(_), Argument::Valid | Argument::Invalid(_)) =\u003e (),\n                (Argument::Missing | Argument::Invalid(_) | Argument::Random(_), _, _) =\u003e  expected_response = ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion,\n                _ =\u003e expected_response = ExpectedBeginHandshakeResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_endpoint\".to_string()));\n            section.insert(\"function\", Bson::String(\"begin_handshake\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.begin_handshake_cookie));\n\n            let mut arguments = Document::new();\n            let version = match version {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(GOSLING_PROTOCOL_VERSION.to_string())),\n                Argument::Invalid(invalid) =\u003e {\n                    if invalid == GOSLING_PROTOCOL_VERSION {\n                        Some(Bson::String(\"invalid_version\".to_string()))\n                    } else {\n                        Some(Bson::String(invalid.clone()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(version) = version {\n                arguments.insert(\"version\", version);\n            }\n\n            let client_identity = match client_identity {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(bob_onion_service_id_string.clone())),\n                Argument::Invalid(invalid) =\u003e {\n                    let invalid = invalid.value.to_string();\n                    Some(Bson::String(invalid))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(client_identity) = client_identity {\n                arguments.insert(\"client_identity\", client_identity);\n            }\n\n            let channel = match channel {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(VALID_CHANNEL.to_string())),\n                Argument::Invalid(value) =\u003e {\n                    if value == VALID_CHANNEL {\n                        Some(Bson::String(\"invalid_channel\".to_string()))\n                    } else if value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::String(Default::default()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(value)}) =\u003e {\n                    if !value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::Null)\n                    }\n                },\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(channel) = channel {\n                arguments.insert(\"channel\", channel);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedBeginHandshakeResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n\n    //\n    // Alice handles begin_handshake()\n    //\n    let mut alice_begin_handshake_handled: bool = false;\n    while !alice_begin_handshake_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerChannelRequestReceived{handle, client_service_id: _, requested_channel} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(expected_response, ExpectedBeginHandshakeResponse::EndpointRequestReceived);\n                    #[derive(PartialEq, Debug)]\n                    enum ExpectedHandleEndpointRequestReceiveResult {\n                        Success,\n                        // Error Cases\n                        ErrorSectionTooLarge,\n                    }\n\n                    let mut expected_result = ExpectedHandleEndpointRequestReceiveResult::Success;\n\n                    // calculate the expected size of our reponse message\n                    let begin_handshake_complete_message_size = {\n                        let result = doc!{\n                            \"server_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: [0u8; COOKIE_SIZE].to_vec()}),\n                        };\n                        let response_section_size = get_response_section_size(Some(Bson::Document(result))).unwrap();\n                        get_message_overhead().unwrap() + response_section_size\n                    };\n                    if begin_handshake_complete_message_size \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                        expected_result = ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge;\n                    }\n\n                    match alice.endpoint_server_handle_channel_request_received(\n                        alice_handshake_handle,\n                        data.channel_supported \u0026\u0026 requested_channel == VALID_CHANNEL) {\n                        Ok(()) =\u003e assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::Success),\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n\n                    alice_begin_handshake_handled = true;\n                }\n                ContextEvent::EndpointServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(endpoint_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedBeginHandshakeResponse::ErrorBadClient ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_begin_handshake_handled = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n        // Alice sends Bob begin_handshake() response (or does nothing)\n    for event in alice.update().unwrap().drain(..) {\n        match event {\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    //\n    // Bob reads begin_handshake() response or error sections\n    //\n\n    // bob receives begin_handshake() pending response\n    let begin_handshake_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure =\u003e {\n            match begin_handshake_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_BAD_VERSION,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived |\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n\n    // bob receives begin_handshake() result\n    let begin_handshake_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    let mut server_cookie: Cookie = Default::default();\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion |\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let section = \u0026sections[0];\n                    match section {\n                        Bson::Document(section) =\u003e {\n                            assert_eq!(section.get_i32(\"id\"), Ok(RESPONSE_SECTION));\n                            let response = section;\n                            assert_eq!(response.get_i64(\"cookie\"), Ok(data.begin_handshake_cookie));\n                            assert_eq!(response.get_i32(\"state\"), Ok(COMPLETE_REQUEST_STATE));\n                            let result = response.get_document(\"result\").unwrap();\n                            server_cookie = result.get_binary_generic(\"server_cookie\").unwrap().clone().try_into().unwrap();\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    //\n    // Bsob sends send_response()\n    //\n\n    #[derive(PartialEq, Debug)]\n    enum ExpectedSendResponseResponse {\n        // Success Case\n        EmptyDocumentReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = match (data.channel_supported, data.begin_handshake) {\n        (true, BeginHandshakeMessage::Request{version: Argument::Valid, client_identity: Argument::Valid, channel: Argument::Valid}) =\u003e ExpectedSendResponseResponse::EmptyDocumentReceived,\n        _ =\u003e ExpectedSendResponseResponse::ErrorBadClient,\n    };\n\n    let message = match data.send_response {\n        SendResponseMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedSendResponseResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedSendResponseResponse::ErrorBsonTooSmall\n                    } else if size \u003e ENDPOINT_MAX_MESSAGE_SIZE {\n                        ExpectedSendResponseResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedSendResponseResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedSendResponseResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedSendResponseResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes\n        },\n        SendResponseMessage::Request{\n            client_cookie,\n            client_identity_proof_signature} =\u003e {\n            match (\u0026client_cookie, \u0026client_identity_proof_signature) {\n                (Argument::Valid, Argument::Valid) =\u003e (),\n                (Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_)) =\u003e expected_response = ExpectedSendResponseResponse::ErrorBadClient,\n                _ =\u003e expected_response = ExpectedSendResponseResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_endpoint\".to_string()));\n            section.insert(\"function\", Bson::String(\"send_response\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.send_response_cookie));\n\n            let mut arguments = Document::new();\n            let client_cookie = match client_cookie {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.client_cookie.to_vec()})),\n                Argument::Invalid(value) =\u003e {\n                    // ensure the cookie is actually invalid\n                    if value == data.client_cookie {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.map(|x| !x).to_vec()}))\n                    } else {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.to_vec()}))\n                    }\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_cookie) = client_cookie {\n                arguments.insert(\"client_cookie\", client_cookie);\n            }\n\n            let client_identity_proof_signature = match client_identity_proof_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_identity_proof = build_client_proof(\"gosling-endpoint\", VALID_CHANNEL, \u0026bob_onion_service_id, \u0026alice_endpoint_onion_service_id, \u0026data.client_cookie, \u0026server_cookie);\n                    let client_identity_proof_signature = bob_private_key.sign_message(\u0026client_identity_proof);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_identity_proof_signature) = client_identity_proof_signature {\n                arguments.insert(\"client_identity_proof_signature\", client_identity_proof_signature);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e ENDPOINT_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedSendResponseResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Alice handles send_response()\n    //\n\n    let mut alice_send_response_handled: bool = false;\n    while !alice_send_response_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::EndpointServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(\n                            endpoint_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        context::Error::EndpointServerError(endpoint_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedSendResponseResponse::ErrorBadClient ||\n                                    expected_response == ExpectedSendResponseResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_send_response_handled = true;\n                },\n                ContextEvent::EndpointServerHandshakeCompleted{handle, endpoint_service_id, client_service_id, channel_name, stream: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(endpoint_service_id, alice_endpoint_onion_service_id);\n                    assert_eq!(client_service_id, bob_onion_service_id);\n                    assert_eq!(channel_name, VALID_CHANNEL);\n                    alice_send_response_handled = true;\n                    assert_eq!(expected_response, ExpectedSendResponseResponse::EmptyDocumentReceived);\n                },\n                ContextEvent::EndpointServerHandshakeRejected { handle, client_allowed: _, client_requested_channel_valid: _, client_proof_signature_valid: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice_send_response_handled = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob reads send_response() response or error sections\n    //\n\n    // first read response (pending) or error section\n    let send_response_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure =\u003e {\n            match send_response_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EmptyDocumentReceived =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"state\": COMPLETE_REQUEST_STATE,\n                                \"result\": doc!{},\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // success!\n    ()\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_identity_client.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\n\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nstruct ErrorSection {\n    cookie: Argument\u003ci64\u003e,\n    code: Argument\u003ci32\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nstruct ResponseSection {\n    cookie: Argument\u003ci64\u003e,\n    state: Argument\u003ci32\u003e,\n    result: Argument\u003cArbitraryBSON\u003e,\n}\n\n#[derive(Arbitrary, Debug)]\nenum Response {\n    Noise(Vec\u003cu8\u003e),\n    Document(ArbitraryBSONDocument),\n    HonkRPC {\n        single_message: bool,\n        pending: Option\u003cResponseSection\u003e,\n        complete: Option\u003cResponseSection\u003e,\n        error: Option\u003cErrorSection\u003e,\n    },\n}\n\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    server_cookie: Cookie,\n    endpoint_challenge: ArbitraryBSONDocument,\n    endpoint_service_id: ArbitraryV3OnionServiceId,\n\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    endpoint_challenge_response: ArbitraryBSONDocument,\n\n    begin_handshake_response: Response,\n    send_response_response: Response,\n\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a malicious/broken server, Bob is a valid client\nfuzz_target!(|data: HandshakeData| {\n\n    //\n    // Init malicious Alice server and Bon client\n    //\n\n    // init alice\n    let mut alice_tor = MockTorClient::new();\n\n    // bootstrap alice\n    alice_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let alice_onion_service_id_string = alice_onion_service_id.to_string();\n    let alice_listener = alice_tor.listener(\u0026alice_private_key, 420, None).unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::OnionServicePublished{service_id} =\u003e {\n                    assert_eq!(service_id, alice_onion_service_id);\n                    identity_server_published = true;\n                },\n                _ =\u003e ()\n            }\n        }\n    }\n\n    // init bob\n    let bob_tor = MockTorClient::new();\n\n    // create bob gosling context\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_service_id_string = bob_service_id.to_string();\n    let mut bob = Context::new(Box::new(bob_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, None, bob_private_key).unwrap();\n    bob.bootstrap().unwrap();\n    let mut bootstrap_complete: bool = false;\n    while !bootstrap_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob initiates handshake\n    //\n    let handshake_handle = bob.identity_client_begin_handshake(alice_onion_service_id.clone(), VALID_ENDPOINT.to_string()).unwrap();\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n    // alice waits for connect, return OnionStream\n    let mut alice_stream : TcpStream = match alice_listener.accept().unwrap() {\n        Some(stream) =\u003e stream.into(),\n        None =\u003e panic!(\"listener accept failed\"),\n    };\n    alice_stream.set_nonblocking(false).unwrap();\n    alice_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n    //\n    // Alice receives begin_handshake() and build responses\n    //\n\n    let begin_handshake_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let begin_handshake_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_IDENTITY_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_IDENTITY_BEGIN_HANDSHAKE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        assert_eq!(arguments.get_str(\"client_identity\").unwrap(), bob_service_id_string);\n        assert_eq!(arguments.get_str(\"endpoint\").unwrap(), VALID_ENDPOINT);\n        begin_handshake_cookie\n    };\n\n    // messages can be built such that multiple errors exist so lets track\n    // all the layers of possible errors\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.begin_handshake_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != begin_handshake_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state == PENDING_REQUEST_STATE {\n                                expect_timeout = true;\n                            } else if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        let mut result = Document::new();\n                        result.insert(\"server_cookie\", Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.server_cookie.to_vec()}));\n                        result.insert(\"endpoint_challenge\", data.endpoint_challenge.value.clone());\n                        Some(Bson::Document(result))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(begin_handshake_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == begin_handshake_cookie {\n                            Some(Bson::Int64(!begin_handshake_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives begin_handshake() response and builds reply\n    //\n    let mut begin_handshake_complete: bool = false;\n    while !begin_handshake_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityClientError(\n                            identity_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                }\n                ContextEvent::IdentityClientChallengeReceived{handle, endpoint_challenge} =\u003e {\n                    assert!(!begin_handshake_complete);\n                    assert!(!expect_timeout);\n                    assert!(!expect_bson_too_small);\n                    assert!(!expect_bson_too_large);\n                    assert!(!expect_honkrpc_message_parse_failure);\n                    assert!(!expect_gosling_unexpected_response);\n                    assert_eq!(handshake_handle, handle);\n                    // compare the raw bytes ince an arbitrary bson doc may have Double(NaN) which fails equality test\n                    assert_eq!({\n                        let mut bytes: Vec\u003cu8\u003e = Default::default();\n                        endpoint_challenge.to_writer(\u0026mut bytes).unwrap();\n                        bytes\n                    },{\n                        let mut bytes: Vec\u003cu8\u003e = Default::default();\n                        data.endpoint_challenge.value.to_writer(\u0026mut bytes).unwrap();\n                        bytes\n                    });\n\n                    // just reply with an empty challenge response\n                    match bob.identity_client_handle_challenge_received(handle, data.endpoint_challenge_response.value.clone()) {\n                        Ok(()) =\u003e begin_handshake_complete = true,\n                        // there is a limit to how large a response can be based on the honk-rpc max message size\n                        Err(context::Error::IdentityClientError(identity_client::Error::EndpointChallengeResponseTooLarge(_,_))) =\u003e return,\n                        Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n    // first update to queue the HonkRPC call\n    assert_eq!(0, bob.update().unwrap().len());\n    // second upate sends the HonkRPC message\n    assert_eq!(0, bob.update().unwrap().len());\n\n\n    // Alice receives send_reponse() and builds response\n    let send_response_cookie = {\n        let honkrpc_msg = bson::document::Document::from_reader(\u0026mut alice_stream).unwrap();\n        assert_eq!(honkrpc_msg.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n        let sections = honkrpc_msg.get_array(\"sections\").unwrap();\n        assert_eq!(sections.len(), 1);\n        let honkrpc_request = match \u0026sections[0] {\n            Bson::Document(document) =\u003e document,\n            bson =\u003e panic!(\"unexpected bson in sections array: {}\", bson),\n        };\n        assert_eq!(honkrpc_request.get_i32(\"id\").unwrap(), REQUEST_SECTION);\n        let send_response_cookie = honkrpc_request.get_i64(\"cookie\").unwrap();\n        assert_eq!(honkrpc_request.get_str(\"namespace\").unwrap(), GOSLING_IDENTITY_NAMESPACE);\n        assert_eq!(honkrpc_request.get_str(\"function\").unwrap(), GOSLING_IDENTITY_SEND_RESPONSE_FUNCTION);\n        let arguments = honkrpc_request.get_document(\"arguments\").unwrap();\n        let client_cookie = arguments.get_binary_generic(\"client_cookie\").unwrap();\n        let client_identity_proof_signature = arguments.get_binary_generic(\"client_identity_proof_signature\").unwrap();\n        let client_authorization_key = arguments.get_binary_generic(\"client_authorization_key\").unwrap();\n        let client_authorization_key_signbit = arguments.get_bool(\"client_authorization_key_signbit\").unwrap();\n        let client_authorization_signature = arguments.get_binary_generic(\"client_authorization_signature\").unwrap();\n        let challenge_response = arguments.get_document(\"challenge_response\").unwrap();\n\n        send_response_cookie\n    };\n\n    let mut expect_timeout: bool = false;\n    let mut expect_bson_parse_failure: bool = false;\n    let mut expect_bson_too_small: bool = false;\n    let mut expect_bson_too_large: bool = false;\n    let mut expect_honkrpc_message_parse_failure: bool = false;\n    let mut expect_gosling_unexpected_response: bool = false;\n    let mut expect_unknown_error_section: bool = false;\n\n    let message: Vec\u003cu8\u003e = match data.send_response_response {\n        Response::Noise(bytes) =\u003e {\n            match bytes.len() {\n                0..=3 =\u003e expect_timeout = true,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        expect_bson_too_small = true;\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        expect_bson_too_large = true;\n                    } else if size as usize \u003e len {\n                        expect_timeout = true;\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e expect_honkrpc_message_parse_failure = true,\n                            Err(_) =\u003e expect_bson_parse_failure = true,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        Response::Document(document) =\u003e {\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            document.value.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expect_bson_too_large = true;\n            } else {\n                expect_honkrpc_message_parse_failure = true;\n            }\n            bytes\n        },\n        Response::HonkRPC{single_message, pending, complete, error} =\u003e {\n            let mut sections: Vec\u003cDocument\u003e = Default::default();\n\n            // build our pending section\n            if let Some(pending) = pending {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match pending.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match pending.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(PENDING_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == PENDING_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state != PENDING_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match pending.result {\n                    Argument::Missing =\u003e None,\n                    Argument::Valid =\u003e None,\n                    Argument::Invalid(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        Some(bson.value)\n                    }\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            }\n            // build our complete section\n            if let Some(complete) = complete {\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(RESPONSE_SECTION));\n\n                let cookie = match complete.cookie {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int64(cookie) = bson.value {\n                            if cookie != send_response_cookie {\n                                expect_gosling_unexpected_response = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n\n                        Some(bson.value)\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let state = match complete.state {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int32(COMPLETE_REQUEST_STATE)),\n                    Argument::Invalid(state) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if state == COMPLETE_REQUEST_STATE {\n                            Some(Bson::Int32(!state))\n                        } else {\n                            Some(Bson::Int32(state))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        if let Bson::Int32(state) = bson.value {\n                            if state == PENDING_REQUEST_STATE {\n                                expect_timeout = true;\n                            } else if state != COMPLETE_REQUEST_STATE {\n                                expect_honkrpc_message_parse_failure = true;\n                            }\n                        } else {\n                            expect_honkrpc_message_parse_failure = true;\n                        }\n                        Some(bson.value)\n                    }\n                };\n                if let Some(state) = state {\n                    section.insert(\"state\", state);\n                }\n\n                let result = match complete.result {\n                    Argument::Missing =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        None\n                    },\n                    Argument::Valid =\u003e {\n                        Some(Bson::String(data.endpoint_service_id.value.to_string()))\n                    },\n                    Argument::Invalid(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        Some(bson.value)\n                    },\n                };\n                if let Some(result) = result {\n                    section.insert(\"result\", result);\n                }\n\n                sections.push(section);\n            } else if let Some(error) = error {\n                // build an error section if there's no complete section\n                let mut section = Document::new();\n                section.insert(\"id\", Bson::Int32(ERROR_SECTION));\n\n                let cookie = match error.cookie {\n                    Argument::Missing =\u003e {\n                        expect_unknown_error_section = true;\n                        None\n                    },\n                    Argument::Valid =\u003e Some(Bson::Int64(send_response_cookie)),\n                    Argument::Invalid(cookie) =\u003e {\n                        expect_gosling_unexpected_response = true;\n                        if cookie == send_response_cookie {\n                            Some(Bson::Int64(!send_response_cookie))\n                        } else {\n                            Some(Bson::Int64(cookie))\n                        }\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int64(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(cookie) = cookie {\n                    section.insert(\"cookie\", cookie);\n                }\n\n                let code = match error.code {\n                    Argument::Missing =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    }\n                    Argument::Valid =\u003e {\n                        // error success\n                        expect_gosling_unexpected_response = true;\n                        Some(Bson::Int32(0i32))\n                    },\n                    Argument::Invalid(code) =\u003e {\n                        // all i32 are somehow valid error codes\n                        expect_honkrpc_message_parse_failure = true;\n                        None\n                    },\n                    Argument::Random(bson) =\u003e {\n                        expect_honkrpc_message_parse_failure = true;\n                        if let Bson::Int32(value) = bson.value {\n                            Some(Bson::Null)\n                        } else {\n                            Some(bson.value)\n                        }\n                    }\n                };\n                if let Some(code) = code {\n                    section.insert(\"code\", code);\n                }\n\n                sections.push(section);\n            } else {\n                expect_timeout = true;\n            }\n\n            // convert sections into honk-rpc messages and serialize to byte vecs\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            if single_message {\n                let mut message = Document::new();\n                message.insert(\"honk_rpc\", HONK_RPC);\n\n                if sections.len() == 0 {\n                    expect_honkrpc_message_parse_failure = true;\n                }\n\n                message.insert(\"sections\", sections);\n\n                message.to_writer(\u0026mut bytes).unwrap();\n                if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                    expect_bson_too_large = true;\n                }\n            } else {\n                let mut bytes_written = 0usize;\n                for section in sections.drain(..) {\n                    let mut message = Document::new();\n                    message.insert(\"honk_rpc\", HONK_RPC);\n                    message.insert(\"sections\", vec![section]);\n\n                    message.to_writer(\u0026mut bytes).unwrap();\n\n                    if bytes.len() - bytes_written \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expect_bson_too_large = true;\n                    }\n                    bytes_written = bytes.len();\n                }\n            }\n\n            bytes\n        },\n    };\n    alice_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Bob receives send_response() response and finishes handshake\n    //\n    let mut send_response_complete: bool = false;\n    while !send_response_complete {\n        for event in bob.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityClientHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    match reason {\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert!(expect_timeout, \"{:?}\", reason);\n                        }\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert!(expect_bson_too_small, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert!(expect_bson_too_large, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert!(expect_honkrpc_message_parse_failure, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityClientError(\n                            identity_client::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::UnknownErrorSectionReceived(_))) =\u003e {\n                            assert!(expect_unknown_error_section, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityClientError(\n                            identity_client::Error::UnexpectedResponseReceived(_)) =\u003e {\n                            assert!(expect_gosling_unexpected_response, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    // bob should have closed the connection on alice after handshake failure\n                    return;\n                },\n                ContextEvent::IdentityClientHandshakeCompleted{handle, identity_service_id, endpoint_service_id, endpoint_name, client_auth_private_key} =\u003e {\n                    assert_eq!(handshake_handle, handle);\n                    assert_eq!(identity_service_id, alice_onion_service_id);\n                    assert_eq!(endpoint_service_id, data.endpoint_service_id.value);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    send_response_complete = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","fuzz_identity_server.rs"],"content":"#![no_main]\n\n// std\nuse std::io::{Cursor, Write};\nuse std::time::Duration;\n\n// gosling\nuse ::gosling::*;\nuse context::*;\n\n// extern\nuse bson::Bson;\nuse bson::Document;\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse data_encoding::HEXLOWER;\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\nuse honk_rpc::honk_rpc::{get_message_overhead, get_response_section_size};\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\nmod arbitrary_types;\nuse crate::arbitrary_types::*;\n\nmod utils;\nuse crate::utils::*;\n\n#[derive(Arbitrary, Debug)]\nenum BeginHandshakeMessage {\n    // random bytes\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc request\n    Request{\n        version: Argument\u003cString\u003e,\n        client_identity: Argument\u003cArbitraryV3OnionServiceId\u003e,\n        endpoint: Argument\u003cString\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nenum SendResponseMessage {\n    Noise(Vec\u003cu8\u003e),\n    /* HonkRpcMessage */\n    /* BSON */\n    // a valid honkrpc requst\n    Request{\n        client_cookie: Argument\u003cCookie\u003e,\n        client_identity_proof_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n        client_authorization_key: Argument\u003cArbitraryX25519PrivateKey\u003e,\n        client_authorization_key_signbit: Argument\u003cbool\u003e,\n        client_authorization_signature: Argument\u003cArbitraryEd25519Signature\u003e,\n        challenge_response: Argument\u003cArbitraryBSONDocument\u003e,\n    },\n}\n\n#[derive(Arbitrary, Debug)]\nstruct HandshakeData {\n    // server data\n    alice_private_ed25519: ArbitraryEd25519PrivateKey,\n    client_allowed: bool,\n    endpoint_supported: bool,\n    endpoint_challenge: ArbitraryBSONDocument,\n    // client data\n    bob_private_ed25519: ArbitraryEd25519PrivateKey,\n    bob_private_x25519: ArbitraryX25519PrivateKey,\n    client_cookie: Cookie,\n    // client messages\n    begin_handshake_cookie: i64,\n    begin_handshake: BeginHandshakeMessage,\n    send_response_cookie: i64,\n    send_response: SendResponseMessage,\n}\n\n// two gosling instance, Alice and Bob\n// Alice is a valid server, Bob connects and sends garbage at certain point in the form of bad data in correctly structured+ordered gosling bison messages or noise\nfuzz_target!(|data: HandshakeData| {\n\n    //\n    // Init Alice server and malicious Bob client\n    //\n\n    // init alice\n    let alice_tor = MockTorClient::new();\n\n    // create alice gosling context\n    let alice_private_key = data.alice_private_ed25519.value;\n    let alice_onion_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n    let mut alice = Context::new(Box::new(alice_tor), 420, 420, std::time::Duration::from_millis(32), IDENTITY_MAX_MESSAGE_SIZE, None, alice_private_key).unwrap();\n\n    // bootstrap alice\n    alice.bootstrap().unwrap();\n    let mut identity_server_published: bool = false;\n    while !identity_server_published {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived{progress: _, tag: _, summary: _} =\u003e (),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    // start alice identity server\n                    alice.identity_server_start().unwrap();\n                }\n                ContextEvent::TorLogReceived{line: _} =\u003e (),\n                ContextEvent::IdentityServerPublished =\u003e {\n                    identity_server_published = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    // init bob\n    let mut bob_tor = MockTorClient::new();\n\n    // bootstrap bob\n    bob_tor.bootstrap().unwrap();\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in bob_tor.update().unwrap().drain(..) {\n            match event {\n                TorEvent::BootstrapComplete =\u003e {\n                    bootstrap_complete = true;\n                }\n                _ =\u003e ()\n            }\n        }\n    }\n\n    let bob_private_key = data.bob_private_ed25519.value;\n    let bob_onion_service_id = V3OnionServiceId::from_private_key(\u0026bob_private_key);\n    let bob_onion_service_id_string = bob_onion_service_id.to_string();\n\n    // bob connects to alice\n    let mut bob_stream = bob_tor.connect((alice_onion_service_id.clone(), 420).into(), None).unwrap();\n    bob_stream.set_nonblocking(false).unwrap();\n    bob_stream.set_read_timeout(Some(Duration::from_millis(100u64))).unwrap();\n\n    //\n    // Alice waits for handshake started\n    //\n    let mut alice_handshake_started: bool = false;\n    let mut alice_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    while !alice_handshake_started {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerHandshakeStarted{handle} =\u003e {\n                    alice_handshake_started = true;\n                    alice_handshake_handle = handle;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob sends begin_handshake()\n    //\n    #[derive(PartialEq, Debug)]\n    enum ExpectedBeginHandshakeResponse {\n        // Success Case\n        EndpointRequestReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorBadGoslingVersion,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = ExpectedBeginHandshakeResponse::EndpointRequestReceived;\n\n    let message = match \u0026data.begin_handshake {\n        BeginHandshakeMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedBeginHandshakeResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedBeginHandshakeResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedBeginHandshakeResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedBeginHandshakeResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes.clone()\n        },\n        BeginHandshakeMessage::Request{\n            version,\n            client_identity,\n            endpoint} =\u003e {\n            match (\u0026version, \u0026client_identity, \u0026endpoint) {\n                (Argument::Valid, Argument::Valid | Argument::Invalid(_), Argument::Valid | Argument::Invalid(_)) =\u003e (),\n                (Argument::Missing | Argument::Invalid(_) | Argument::Random(_), _, _) =\u003e  expected_response = ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion,\n                _ =\u003e expected_response = ExpectedBeginHandshakeResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_identity\".to_string()));\n            section.insert(\"function\", Bson::String(\"begin_handshake\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.begin_handshake_cookie));\n\n            let mut arguments = Document::new();\n            let version = match version {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(GOSLING_PROTOCOL_VERSION.to_string())),\n                Argument::Invalid(invalid) =\u003e {\n                    if invalid == GOSLING_PROTOCOL_VERSION {\n                        Some(Bson::String(\"invalid_version\".to_string()))\n                    } else {\n                        Some(Bson::String(invalid.clone()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(version) = version {\n                arguments.insert(\"version\", version);\n            }\n\n            let client_identity = match client_identity {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(bob_onion_service_id_string.clone())),\n                Argument::Invalid(invalid) =\u003e {\n                    let invalid = invalid.value.to_string();\n                    Some(Bson::String(invalid))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(client_identity) = client_identity {\n                arguments.insert(\"client_identity\", client_identity);\n            }\n\n            let endpoint = match endpoint {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::String(VALID_ENDPOINT.to_string())),\n                Argument::Invalid(value) =\u003e {\n                    if value == VALID_ENDPOINT {\n                        Some(Bson::String(\"invalid_endpoint\".to_string()))\n                    } else if value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::String(Default::default()))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::String(value)}) =\u003e {\n                    if !value.is_ascii() {\n                        Some(Bson::String(value.clone()))\n                    } else {\n                        Some(Bson::Null)\n                    }\n                },\n                Argument::Random(bson) =\u003e Some(bson.value.clone()),\n            };\n            if let Some(endpoint) = endpoint {\n                arguments.insert(\"endpoint\", endpoint);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedBeginHandshakeResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n    //\n    // Alice handles begin_handshake()\n    //\n    let mut alice_begin_handshake_handled: bool = false;\n    while !alice_begin_handshake_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerEndpointRequestReceived{handle, client_service_id: _, requested_endpoint} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(expected_response, ExpectedBeginHandshakeResponse::EndpointRequestReceived);\n                    #[derive(PartialEq, Debug)]\n                    enum ExpectedHandleEndpointRequestReceiveResult {\n                        Success,\n                        // Error Cases\n                        ErrorSectionTooLarge,\n                    }\n\n                    let mut expected_result = ExpectedHandleEndpointRequestReceiveResult::Success;\n\n                    // calculate the expected size of our reponse message\n                    let begin_handshake_complete_message_size = {\n                        let result = doc!{\n                            \"server_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: [0u8; COOKIE_SIZE].to_vec()}),\n                            \"endpoint_challenge\" : data.endpoint_challenge.value.clone(),\n                        };\n                        let response_section_size = get_response_section_size(Some(Bson::Document(result))).unwrap();\n                        get_message_overhead().unwrap() + response_section_size\n                    };\n                    if begin_handshake_complete_message_size \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                        expected_result = ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge;\n                    }\n\n                    match alice.identity_server_handle_endpoint_request_received(\n                        alice_handshake_handle,\n                        data.client_allowed,\n                        data.endpoint_supported \u0026\u0026 requested_endpoint == VALID_ENDPOINT,\n                        data.endpoint_challenge.value.clone()) {\n                        Err(context::Error::IdentityServerError(identity_server::Error::EndpointChallengeTooLarge(_,_))) =\u003e {\n                            assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::ErrorSectionTooLarge);\n                            return;\n                        },\n                        Ok(()) =\u003e {\n                            assert_eq!(expected_result, ExpectedHandleEndpointRequestReceiveResult::Success);\n                        }\n                        result =\u003e panic!(\"unexpected result: {:?}\", result)\n                    }\n\n                    alice_begin_handshake_handled = true;\n                }\n                ContextEvent::IdentityServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedBeginHandshakeResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(identity_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedBeginHandshakeResponse::ErrorBadClient ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion ||\n                                    expected_response == ExpectedBeginHandshakeResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_begin_handshake_handled = true;\n                }\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n        // Alice sends Bob begin_handshake() response (or does nothing)\n    for event in alice.update().unwrap().drain(..) {\n        match event {\n            event =\u003e panic!(\"unexpected event: {:?}\", event),\n        }\n    }\n\n    //\n    // Bob reads begin_handshake() response or error sections\n    //\n\n    // bob receives begin_handshake() pending response\n    let begin_handshake_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure =\u003e {\n            match begin_handshake_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_BAD_VERSION,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived |\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // bob receives begin_handshake() result\n    let begin_handshake_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    let mut server_cookie: Cookie = Default::default();\n    match expected_response {\n        ExpectedBeginHandshakeResponse::ErrorTimedOut |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooSmall |\n        ExpectedBeginHandshakeResponse::ErrorBsonTooLarge |\n        ExpectedBeginHandshakeResponse::ErrorBsonParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorMessageParseFailure |\n        ExpectedBeginHandshakeResponse::ErrorBadGoslingVersion |\n        ExpectedBeginHandshakeResponse::ErrorInvalidArg =\u003e {\n            match begin_handshake_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::ErrorBadClient =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.begin_handshake_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedBeginHandshakeResponse::EndpointRequestReceived =\u003e {\n            match begin_handshake_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let section = \u0026sections[0];\n                    match section {\n                        Bson::Document(section) =\u003e {\n                            assert_eq!(section.get_i32(\"id\"), Ok(RESPONSE_SECTION));\n                            let response = section;\n                            assert_eq!(response.get_i64(\"cookie\"), Ok(data.begin_handshake_cookie));\n                            assert_eq!(response.get_i32(\"state\"), Ok(COMPLETE_REQUEST_STATE));\n                            let result = response.get_document(\"result\").unwrap();\n                            server_cookie = result.get_binary_generic(\"server_cookie\").unwrap().clone().try_into().unwrap();\n                            let endpoint_challenge = result.get_document(\"endpoint_challenge\").unwrap();\n                            // compare the raw bytes ince an arbitrary bson doc may have Double(NaN) which fails equality test\n                            assert_eq!({\n                                let mut bytes: Vec\u003cu8\u003e = Default::default();\n                                endpoint_challenge.to_writer(\u0026mut bytes).unwrap();\n                                bytes\n                            },{\n                                let mut bytes: Vec\u003cu8\u003e = Default::default();\n                                data.endpoint_challenge.value.to_writer(\u0026mut bytes).unwrap();\n                                bytes\n                            });\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n\n    }\n\n    //\n    // Bsob sends send_response()\n    //\n\n    #[derive(PartialEq, Debug)]\n    enum ExpectedSendResponseResponse {\n        // Success Case\n        EndpointOnionServiceIdReceived,\n        // Error Cases\n        ErrorTimedOut,\n        ErrorBsonParseFailure,\n        ErrorBsonTooSmall,\n        ErrorBsonTooLarge,\n        ErrorMessageParseFailure,\n        ErrorInvalidArg,\n        ErrorBadClient,\n    }\n    let mut expected_response = match (data.client_allowed \u0026\u0026 data.endpoint_supported, data.begin_handshake) {\n        (true, BeginHandshakeMessage::Request{version: Argument::Valid, client_identity: Argument::Valid, endpoint: Argument::Valid}) =\u003e ExpectedSendResponseResponse::EndpointOnionServiceIdReceived,\n        _ =\u003e ExpectedSendResponseResponse::ErrorBadClient,\n    };\n\n    let message = match data.send_response {\n        SendResponseMessage::Noise(bytes) =\u003e {\n            expected_response = match bytes.len() {\n                0..=3 =\u003e ExpectedSendResponseResponse::ErrorTimedOut,\n                len =\u003e {\n                    let size: i32 = (bytes[0] as i32)\n                                  | (bytes[1] as i32) \u003c\u003c 8\n                                  | (bytes[2] as i32) \u003c\u003c 16\n                                  | (bytes[3] as i32) \u003c\u003c 24;\n                    if size \u003c= 4 {\n                        ExpectedSendResponseResponse::ErrorBsonTooSmall\n                    } else if size \u003e IDENTITY_MAX_MESSAGE_SIZE {\n                        ExpectedSendResponseResponse::ErrorBsonTooLarge\n                    } else if size as usize \u003e len {\n                        ExpectedSendResponseResponse::ErrorTimedOut\n                    } else {\n                        match bson::document::Document::from_reader(Cursor::new(bytes.clone())) {\n                            Ok(_) =\u003e ExpectedSendResponseResponse::ErrorMessageParseFailure,\n                            Err(_) =\u003e ExpectedSendResponseResponse::ErrorBsonParseFailure,\n                        }\n                    }\n                }\n            };\n            bytes\n        },\n        SendResponseMessage::Request{\n            client_cookie,\n            client_identity_proof_signature,\n            client_authorization_key,\n            client_authorization_key_signbit,\n            client_authorization_signature,\n            challenge_response} =\u003e {\n            match (\u0026client_cookie, \u0026client_identity_proof_signature, \u0026client_authorization_key, \u0026client_authorization_key_signbit, \u0026client_authorization_signature, \u0026challenge_response) {\n                (Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid, Argument::Valid) =\u003e (),\n                (Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_),\n                 Argument::Valid | Argument::Invalid(_)) =\u003e expected_response = ExpectedSendResponseResponse::ErrorBadClient,\n                _ =\u003e expected_response = ExpectedSendResponseResponse::ErrorInvalidArg,\n            }\n\n            let mut message = Document::new();\n            message.insert(\"honk_rpc\", Bson::Int32(HONK_RPC));\n\n            let mut section = Document::new();\n            section.insert(\"id\", Bson::Int32(REQUEST_SECTION));\n            section.insert(\"namespace\", Bson::String(\"gosling_identity\".to_string()));\n            section.insert(\"function\", Bson::String(\"send_response\".to_string()));\n            section.insert(\"cookie\", Bson::Int64(data.send_response_cookie));\n\n            let mut arguments = Document::new();\n            let client_cookie = match client_cookie {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: data.client_cookie.to_vec()})),\n                Argument::Invalid(value) =\u003e {\n                    // ensure the cookie is actually invalid\n                    if value == data.client_cookie {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.map(|x| !x).to_vec()}))\n                    } else {\n                        Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: value.to_vec()}))\n                    }\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_cookie) = client_cookie {\n                arguments.insert(\"client_cookie\", client_cookie);\n            }\n\n            let client_identity_proof_signature = match client_identity_proof_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_identity_proof = build_client_proof(\"gosling-identity\", VALID_ENDPOINT, \u0026bob_onion_service_id, \u0026alice_onion_service_id, \u0026data.client_cookie, \u0026server_cookie);\n                    let client_identity_proof_signature = bob_private_key.sign_message(\u0026client_identity_proof);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                }\n                Argument::Random(ArbitraryBSON{value: Bson::Binary(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_identity_proof_signature) = client_identity_proof_signature {\n                arguments.insert(\"client_identity_proof_signature\", client_identity_proof_signature);\n            }\n\n            let client_authorization_key = match client_authorization_key {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_authorization_key = X25519PublicKey::from_private_key(\u0026data.bob_private_x25519.value);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    let client_authorization_key = X25519PublicKey::from_private_key(\u0026invalid.value);\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}))\n                },\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_key) = client_authorization_key {\n                arguments.insert(\"client_authorization_key\", client_authorization_key);\n            }\n\n            let client_authorization_signing_key_private = Ed25519PrivateKey::from_private_x25519(\u0026data.bob_private_x25519.value).unwrap();\n            let client_authorization_key_signbit = match client_authorization_key_signbit {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let signbit = client_authorization_signing_key_private.1;\n                    Some(Bson::Boolean(bool::from(signbit)))\n                },\n                Argument::Invalid(_) =\u003e {\n                    let signbit = client_authorization_signing_key_private.1;\n                    Some(Bson::Boolean(!bool::from(signbit)))\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::Boolean(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_key_signbit) = client_authorization_key_signbit {\n                arguments.insert(\"client_authorization_key_signbit\", client_authorization_key_signbit);\n            }\n\n            let client_authorization_signature = match client_authorization_signature {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e {\n                    let client_authorization_signature = client_authorization_signing_key_private.0.sign_message(bob_onion_service_id_string.as_bytes());\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_signature.to_bytes().to_vec()}))\n                },\n                Argument::Invalid(invalid) =\u003e {\n                    Some(Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: invalid.value.to_bytes().to_vec()}))\n                },\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(client_authorization_signature) = client_authorization_signature {\n                arguments.insert(\"client_authorization_signature\", client_authorization_signature);\n            }\n\n            let challenge_response = match challenge_response {\n                Argument::Missing =\u003e None,\n                Argument::Valid =\u003e Some(Bson::Document(Document::new())),\n                Argument::Invalid(ArbitraryBSONDocument{value}) =\u003e {\n                    // server is expecting an empty response so to be invalid\n                    // it must contain *some* member\n                    if value == Document::new() {\n                        Some(Bson::Document(doc!{\"foo\": Bson::Null}))\n                    } else {\n                        Some(Bson::Document(value))\n                    }\n                },\n                Argument::Random(ArbitraryBSON{value: Bson::Document(_)}) =\u003e Some(Bson::Null),\n                Argument::Random(bson) =\u003e Some(bson.value),\n            };\n            if let Some(challenge_response) = challenge_response {\n                arguments.insert(\"challenge_response\", challenge_response);\n            }\n\n            section.insert(\"arguments\", arguments);\n            message.insert(\"sections\", vec![section]);\n            let mut bytes: Vec\u003cu8\u003e = Default::default();\n            message.to_writer(\u0026mut bytes).unwrap();\n            if bytes.len() \u003e IDENTITY_MAX_MESSAGE_SIZE as usize {\n                expected_response = ExpectedSendResponseResponse::ErrorBsonTooLarge;\n            }\n            bytes\n        },\n    };\n    bob_stream.write(message.as_slice()).unwrap();\n\n\n    //\n    // Alice handles send_response()\n    //\n\n    let mut alice_send_response_handled: bool = false;\n    while !alice_send_response_handled {\n        for event in alice.update().unwrap().drain(..) {\n            match event {\n                ContextEvent::IdentityServerHandshakeFailed{handle, reason} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    match reason {\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageReadTimedOut(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorTimedOut, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentParseFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonParseFailure, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooSmall(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooSmall, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::BsonDocumentSizeTooLarge(_, _))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorBsonTooLarge, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(\n                            identity_server::Error::HonkRPCFailure(\n                                honk_rpc::honk_rpc::Error::MessageConversionFailed(_))) =\u003e {\n                            assert_eq!(expected_response, ExpectedSendResponseResponse::ErrorMessageParseFailure, \"{:?}\", reason);\n                        },\n                        context::Error::IdentityServerError(identity_server::Error::BadClient) =\u003e {\n                            assert!(expected_response == ExpectedSendResponseResponse::ErrorBadClient ||\n                                    expected_response == ExpectedSendResponseResponse::ErrorInvalidArg, \"{:?}\", reason);\n                        },\n                        error =\u003e panic!(\"unexpected error: {:?}\", error),\n                    }\n                    alice_send_response_handled = true;\n                },\n                ContextEvent::IdentityServerChallengeResponseReceived{handle, challenge_response} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice.identity_server_handle_challenge_response_received(handle, challenge_response == Document::new()).unwrap();\n                },\n                ContextEvent::IdentityServerHandshakeCompleted{handle, endpoint_private_key: _, endpoint_name, client_service_id: _, client_auth_public_key: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    assert_eq!(endpoint_name, VALID_ENDPOINT);\n                    alice_send_response_handled = true;\n                    assert_eq!(expected_response, ExpectedSendResponseResponse::EndpointOnionServiceIdReceived);\n                },\n                ContextEvent::IdentityServerHandshakeRejected { handle, client_allowed: _, client_requested_endpoint_valid: _, client_proof_signature_valid: _, client_auth_signature_valid: _, challenge_response_valid: _} =\u003e {\n                    assert_eq!(handle, alice_handshake_handle);\n                    alice_send_response_handled = true;\n                },\n                event =\u003e panic!(\"unexpected event: {:?}\", event),\n            }\n        }\n    }\n\n    //\n    // Bob reads send_response() response or error sections\n    //\n\n    // first read response (pending) or error section\n    let send_response_pending = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure =\u003e {\n            match send_response_pending {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_INVALID_ARG,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EndpointOnionServiceIdReceived |\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_pending {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": RESPONSE_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"state\": PENDING_REQUEST_STATE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        }\n    }\n\n    // next read response (result) or error section\n    let send_response_result = bson::document::Document::from_reader(\u0026mut bob_stream);\n    match expected_response {\n        ExpectedSendResponseResponse::ErrorTimedOut |\n        ExpectedSendResponseResponse::ErrorBsonTooSmall |\n        ExpectedSendResponseResponse::ErrorBsonTooLarge |\n        ExpectedSendResponseResponse::ErrorBsonParseFailure |\n        ExpectedSendResponseResponse::ErrorMessageParseFailure |\n        ExpectedSendResponseResponse::ErrorInvalidArg =\u003e {\n            match send_response_result {\n                Err(bson::de::Error::Io(_)) =\u003e return,\n                Ok(message) =\u003e panic!(\"unexpected message: {:?}\", message),\n                Err(error) =\u003e panic!(\"unexpected error: {:?}\", error),\n            }\n        },\n        ExpectedSendResponseResponse::ErrorBadClient =\u003e {\n            match send_response_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message, doc!{\n                        \"honk_rpc\": HONK_RPC,\n                        \"sections\": [\n                            {\n                                \"id\": ERROR_SECTION,\n                                \"cookie\": data.send_response_cookie,\n                                \"code\": ERROR_CODE_FAILURE,\n                            }\n                        ]\n                    }, \"expected response: {:?}\", expected_response);\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n        ExpectedSendResponseResponse::EndpointOnionServiceIdReceived =\u003e {\n            match send_response_result {\n                Ok(message) =\u003e {\n                    assert_eq!(message.get_i32(\"honk_rpc\").unwrap(), HONK_RPC);\n                    let sections = message.get_array(\"sections\").unwrap();\n                    assert_eq!(sections.len(), 1);\n                    let response = \u0026sections[0];\n                    match response {\n                        Bson::Document(response) =\u003e {\n                            assert_eq!(response.get_i32(\"id\").unwrap(), RESPONSE_SECTION, \"{:?}\", message);\n                            assert_eq!(response.get_i64(\"cookie\").unwrap(), data.send_response_cookie, \"{:?}\", message);\n                            assert_eq!(response.get_i32(\"state\").unwrap(), COMPLETE_REQUEST_STATE, \"{:?}\", message);\n                            match response.get(\"result\") {\n                                Some(Bson::String(serviceid)) =\u003e {\n                                    // ensure returned valueis a valid service id\n                                    V3OnionServiceId::from_string(serviceid).unwrap();\n                                },\n                                Some(bson) =\u003e panic!(\"unexpected result: {:?}\", bson),\n                                None =\u003e panic!(\"unexpected send_response result message: {:?}\", message),\n                            }\n                        },\n                        bson =\u003e panic!(\"unexpected section: {:?}\", bson),\n                    }\n                },\n                Err(error) =\u003e panic!(\"unexpected expected response and error: {:?}, {:?}\", expected_response, error),\n            }\n        },\n    }\n\n    // success!\n    ()\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","fuzz","fuzz_targets","utils.rs"],"content":"// extern\nuse data_encoding::HEXLOWER;\nuse tor_interface::tor_crypto::*;\n\n\n// honk-rpc constants\npub(crate) const HONK_RPC: i32 = 0x00000100; // semver 0.1.0\npub(crate) const ERROR_SECTION: i32 = 0;\npub(crate) const ERROR_CODE_BAD_VERSION: i32 = 0;\npub(crate) const ERROR_CODE_REQUEST_COOKIE_REQUIRED: i32 = 1;\npub(crate) const ERROR_CODE_INVALID_ARG: i32 = 2;\npub(crate) const ERROR_CODE_FAILURE: i32 = 3;\npub(crate) const REQUEST_SECTION: i32 = 1;\npub(crate) const RESPONSE_SECTION: i32 = 2;\npub(crate) const PENDING_REQUEST_STATE: i32 = 0;\npub(crate) const COMPLETE_REQUEST_STATE: i32 = 1;\n\n// gosling constants\npub(crate) const INVALID_HANDSHAKE_HANDLE: gosling::context::HandshakeHandle = !0usize;\npub(crate) const GOSLING_PROTOCOL_VERSION: \u0026str = \"0.1.0\";\npub(crate) const GOSLING_IDENTITY_NAMESPACE: \u0026str = \"gosling_identity\";\npub(crate) const GOSLING_IDENTITY_BEGIN_HANDSHAKE_FUNCTION: \u0026str = \"begin_handshake\";\npub(crate) const GOSLING_IDENTITY_SEND_RESPONSE_FUNCTION: \u0026str = \"send_response\";\npub(crate) const GOSLING_ENDPOINT_NAMESPACE: \u0026str = \"gosling_endpoint\";\npub(crate) const GOSLING_ENDPOINT_BEGIN_HANDSHAKE_FUNCTION: \u0026str = \"begin_handshake\";\npub(crate) const GOSLING_ENDPOINT_SEND_RESPONSE_FUNCTION: \u0026str = \"send_response\";\npub(crate) const VALID_ENDPOINT: \u0026str = \"valid_endpoint\";\npub(crate) const VALID_CHANNEL: \u0026str = \"valid_channel\";\npub(crate) const IDENTITY_MAX_MESSAGE_SIZE: i32 = 1024;\npub(crate) const ENDPOINT_MAX_MESSAGE_SIZE: i32 = 384;\npub(crate) const COOKIE_SIZE: usize = 32usize;\npub(crate) type Cookie = [u8; COOKIE_SIZE];\n\n\npub(crate) fn build_client_proof(\n    domain_separator: \u0026str,\n    request: \u0026str,\n    client_service_id: \u0026V3OnionServiceId,\n    server_service_id: \u0026V3OnionServiceId,\n    client_cookie: \u0026Cookie,\n    server_cookie: \u0026Cookie,\n) -\u003e Vec\u003cu8\u003e {\n    let mut client_proof: Vec\u003cu8\u003e= Default::default();\n\n    client_proof.extend_from_slice(domain_separator.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(request.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(client_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(server_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(client_cookie).as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(server_cookie).as_bytes());\n\n    client_proof\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","ascii_string.rs"],"content":"#[cfg(test)]\nuse anyhow::bail;\nuse std::ops::Deref;\n\n#[derive(thiserror::Error, Debug)]\npub(crate) enum Error {\n    #[error(\"input string is not ASCII: {0}\")]\n    InvalidAscii(String),\n}\n\n/// An immutable wrapper around a String guaranteed to be ASCII encoded\n#[derive(Clone, PartialEq)]\npub(crate) struct AsciiString {\n    value: String,\n}\n\nimpl AsciiString {\n    pub fn new(value: String) -\u003e Result\u003cAsciiString, Error\u003e {\n        if value.is_ascii() {\n            Ok(Self { value })\n        } else {\n            Err(Error::InvalidAscii(value))\n        }\n    }\n}\n\nimpl Deref for AsciiString {\n    type Target = String;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.value\n    }\n}\n\nimpl std::fmt::Debug for AsciiString {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.value.fmt(f)\n    }\n}\n\nimpl std::fmt::Display for AsciiString {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.value.fmt(f)\n    }\n}\n\n#[test]\nfn test_ascii_string() -\u003e anyhow::Result\u003c()\u003e {\n    let valid_ascii: [String; 8] = [\n        \"\".to_string(),\n        \" !\\\"#$%\u0026'()*+,-./\".to_string(),\n        \"0123456789\".to_string(),\n        \":\u003c=\u003e?@\".to_string(),\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".to_string(),\n        \"[\\\\]^_`\".to_string(),\n        \"abcdefghijklmnopqstuvwxyz\".to_string(),\n        \"{|}~\".to_string(),\n    ];\n\n    for string in valid_ascii {\n        match AsciiString::new(string) {\n            Ok(string) =\u003e println!(\"ascii: '{}'\", string),\n            Err(err) =\u003e bail!(\"unexpected error: {}\", err),\n        }\n    }\n\n    let utf8: [String; 2] = [\"\".to_string(), \"heart \".to_string()];\n\n    for string in utf8 {\n        match AsciiString::new(string) {\n            Ok(string) =\u003e bail!(\"this is not ascii: {}\", string),\n            Err(_) =\u003e (),\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":18,"address":[3740672,3741024],"length":1,"stats":{"Line":2}},{"line":19,"address":[2002658,2002797,2002590],"length":1,"stats":{"Line":5}},{"line":20,"address":[3807417],"length":1,"stats":{"Line":2}},{"line":22,"address":[3740801],"length":1,"stats":{"Line":1}},{"line":30,"address":[2721360],"length":1,"stats":{"Line":2}},{"line":36,"address":[2002960],"length":1,"stats":{"Line":0}},{"line":37,"address":[2002974],"length":1,"stats":{"Line":0}},{"line":42,"address":[2002992],"length":1,"stats":{"Line":2}},{"line":43,"address":[2003006],"length":1,"stats":{"Line":2}}],"covered":7,"coverable":9},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","context.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::collections::{BTreeMap, HashMap, VecDeque};\nuse std::net::TcpStream;\nuse std::time::Duration;\n\n// extern crates\nuse honk_rpc::honk_rpc::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::endpoint_client;\nuse crate::endpoint_client::*;\nuse crate::endpoint_server;\nuse crate::endpoint_server::*;\nuse crate::identity_client;\nuse crate::identity_client::*;\nuse crate::identity_server;\nuse crate::identity_server::*;\n\n/// A handle to an in-progres identity or endpoint handshake\npub type HandshakeHandle = usize;\nconst DEFAULT_ENDPOINT_TIMEOUT: Duration = Duration::from_secs(60);\nconst DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE: i32 = 384;\n\n/// The error type for the [`Context`] type.\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    /// An invalid argument was provided to a function\n    #[error(\"invalid argument: {0}\")]\n    InvalidArgument(String),\n\n    /// Function requiring tor connectivity called before bootstrap\n    #[error(\n        \"context is not connected, must call bootstrap() and wait for TorBootstrapCompleted event\"\n    )]\n    TorNotConnected(),\n\n    /// Provided handle does not map to an in-flight handshake\n    #[error(\"handshake handle {0} not found\")]\n    HandshakeHandleNotFound(HandshakeHandle),\n\n    /// Requesting an invalid operation\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    /// An underlying `std::io::Error`\n    #[error(transparent)]\n    Io(#[from] std::io::Error),\n\n    /// An underlying `honk_rpc::honk_rpc::Error`\n    #[error(transparent)]\n    HonkRpc(#[from] honk_rpc::honk_rpc::Error),\n\n    /// An underlying `tor_interface::tor_crypto::Error`\n    #[error(transparent)]\n    TorCrypto(#[from] tor_interface::tor_crypto::Error),\n\n    /// An underlying `tor_interface::tor_provider::Error`\n    #[error(transparent)]\n    TorProvider(#[from] tor_interface::tor_provider::Error),\n\n    /// Failure ocurred in outgoing identity handshake\n    #[error(transparent)]\n    IdentityClientError(#[from] identity_client::Error),\n\n    /// Failure ocurred in incoming identity handshake\n    #[error(transparent)]\n    IdentityServerError(#[from] identity_server::Error),\n\n    /// Failure ocurred in outgoing endpoint handshake\n    #[error(transparent)]\n    EndpointClientError(#[from] endpoint_client::Error),\n\n    /// Failure ocurred in incoming endpoint handshake\n    #[error(transparent)]\n    EndpointServerError(#[from] endpoint_server::Error),\n}\n\n/// The gosling protocol implementation.\n///\n/// The `Context` object provides various methods for starting and progressing identity and endpoint handshakes. The general usage pattern developers will follow is to construct a `Context` object, connect to the Tor Network using [`Context::bootstrap()`], optionally start an identity or endpoint servers, and listen for and handle incoming identity and endpoint clients using [`Context::update()`] and the various associated methods. Depending on the application's requirements, the developer can also initiate identity and endpoint handshakes as necessary.\n///\n/// The Gosling Protocol specification can be found here:\n/// - [https://gosling.technology/gosling-spec.xhtml](https://gosling.technology/gosling-spec.xhtml)\npub struct Context {\n    // our tor instance\n    tor_provider: Box\u003cdyn TorProvider\u003e,\n    bootstrap_complete: bool,\n    identity_port: u16,\n    endpoint_port: u16,\n    identity_timeout: Duration,\n    identity_max_message_size: i32,\n    endpoint_timeout: Duration,\n\n    //\n    // Servers and Clients for in-process handshakes\n    //\n    next_handshake_handle: HandshakeHandle,\n    identity_clients: BTreeMap\u003cHandshakeHandle, IdentityClient\u003e,\n    identity_servers: BTreeMap\u003cHandshakeHandle, IdentityServer\u003e,\n    endpoint_clients: BTreeMap\u003cHandshakeHandle, EndpointClient\u003e,\n    endpoint_servers: BTreeMap\u003cHandshakeHandle, EndpointServer\u003e,\n\n    //\n    // Listeners for incoming connections\n    //\n    identity_listener: Option\u003cOnionListener\u003e,\n    identity_server_published: bool,\n    // maps the endpoint service id to the (enpdoint name, alowed client, onion listener tuple, published)\n    endpoint_listeners: HashMap\u003cV3OnionServiceId, (String, V3OnionServiceId, OnionListener, bool)\u003e,\n\n    //\n    // Server Config Data\n    //\n\n    // Private key behind the identity onion service\n    identity_private_key: Ed25519PrivateKey,\n    // Identity server's service id\n    identity_service_id: V3OnionServiceId,\n}\n\n/// Events to signal completion of asynchronous [`Context`] operations\n#[derive(Debug)]\npub enum ContextEvent {\n    //\n    // Tor Events\n    //\n\n    /// Tor bootstrap progress\n    TorBootstrapStatusReceived {\n        /// Bootstrap percent compeletion\n        progress: u32,\n        /// A short string indicating the completed bootstrap step\n        tag: String,\n        /// A longer human-readable summary of the bootstrap progress\n        summary: String,\n    },\n\n    /// Tor bootstrap completed\n    TorBootstrapCompleted,\n\n    /// Human-readable logs from the [`Context`]'s [`TorProvider`]\n    TorLogReceived {\n        /// Human-readable debug log\n        line: String,\n    },\n\n    //\n    // Identity Client Events\n    //\n\n    /// An identity client has received a challenge request from an identy server\n    ///\n    /// To continue the handshake, the client must call [`Context::identity_client_handle_challenge_received()`]\n    IdentityClientChallengeReceived {\n        /// The handle of the in-progress handshake\n        handle: HandshakeHandle,\n        /// An application specific challenge object used by the identity client to create a challenge response object\n        endpoint_challenge: bson::document::Document,\n    },\n\n    /// An identity client has successfully completed an identity handshake and may now access the requested endpoint server.\n    IdentityClientHandshakeCompleted {\n        /// The handle of the completed handshake\n        handle: HandshakeHandle,\n        /// The onion-service service-id of the identity server the client has completed an identity handshake with\n        identity_service_id: V3OnionServiceId,\n        /// The onion-service service-id of the requested endpoint server\n        endpoint_service_id: V3OnionServiceId,\n        /// The ASCII-encoded name of the requested endpoint server\n        endpoint_name: String,\n        /// The private x25519 client-auth key required to access the requested endpoint server\n        client_auth_private_key: X25519PrivateKey,\n    },\n\n    /// An incoming identit handshake has failed\n    IdentityClientHandshakeFailed {\n        /// The handle of the failed handshake\n        handle: HandshakeHandle,\n        /// The failure reason\n        reason: Error,\n    },\n\n    /// The identity server's onion-service has been published and may be reachable by identity clients\n    IdentityServerPublished,\n\n    /// An identity server has received an incoming connection and the handshake is ready to begin\n    IdentityServerHandshakeStarted {\n        /// The handle of the new handshake\n        handle: HandshakeHandle,\n    },\n\n    /// An identity server has received a request for an endpoint from an identity client.\n    ///\n    /// To continue the handshake, the server must call [`Context::identity_server_handle_endpoint_request_received()`]\n    IdentityServerEndpointRequestReceived {\n        /// The handle of the in-progress handshake\n        handle: HandshakeHandle,\n        /// The alleged onion-service service-id of the connecting client\n        client_service_id: V3OnionServiceId,\n        /// The ASCII-encoded name of the requested endpoint server\n        requested_endpoint: String,\n    },\n\n    /// An identity server has received a challenge response from an identity client.\n    ///\n    /// To continue the handshake, the server must call [`Context::identity_server_handle_challenge_response_received()`]\n    IdentityServerChallengeResponseReceived {\n        /// The handle of the in-progress handshake\n        handle: HandshakeHandle,\n        /// An application specific challenge response object created by the identity client in response to the identity server's challenge object\n        challenge_response: bson::document::Document,\n    },\n\n    /// An identity server's handshake has completed.\n    IdentityServerHandshakeCompleted {\n        /// The handle of the completed handshake\n        handle: HandshakeHandle,\n        /// The ed25519 private key of requested endpoint server\n        endpoint_private_key: Ed25519PrivateKey,\n        /// The ASCII-encoded name of the requested endpoint server\n        endpoint_name: String,\n        /// The onion-service service-id of the authenticated client\n        client_service_id: V3OnionServiceId,\n        /// The public x25519 client-auth key used to encrypt the endpoint server's onion-service descriptor\n        client_auth_public_key: X25519PublicKey,\n    },\n\n    /// An identity server has rejected an identity client's endpoint-request.\n    ///\n    /// There are multiple potential reasons why a handshake may be rejected and this event provides a breakdown on which part(s) failed specifically.\n    IdentityServerHandshakeRejected {\n        /// The handle of the rejected handshake\n        handle: HandshakeHandle,\n        /// `false` if the client was rejected based on their onion-service service-id\n        client_allowed: bool,\n        /// `false` if the requested endpoint name was not understood by the server\n        client_requested_endpoint_valid: bool,\n        /// `false` if the client failed its authentication proof (i.e. potential attempt at identity client impersonation)\n        client_proof_signature_valid: bool,\n        /// `false` if the client fails its x25519 key-ownership proof (i.e. potential attempt at use an x25519 public key not owned by the client)\n        client_auth_signature_valid: bool,\n        /// `false` if the client's challenge response was not suitable\n        challenge_response_valid: bool,\n    },\n\n    /// An incoming identity handshake has failed.\n    IdentityServerHandshakeFailed {\n        /// The handle of the failed handshake\n        handle: HandshakeHandle,\n        /// The failure reason\n        reason: Error,\n    },\n\n    //\n    // Endpoint Client Events\n    //\n\n    /// An endpoint client has successfully completed an endpoint handshake and may now communicate freely with the endpoint server.\n    EndpointClientHandshakeCompleted {\n        /// The handle of the completed handshake\n        handle: HandshakeHandle,\n        /// The onion-service service-id of the endpoint server the client has connected to\n        endpoint_service_id: V3OnionServiceId,\n        /// The ASCII-encoded name of the requested channel on the endpoint server\n        channel_name: String,\n        /// The resulting TCP connection to the endpoint server\n        stream: TcpStream,\n    },\n\n    /// An outgoing endpoint handshake has failed.\n    EndpointClientHandshakeFailed {\n        /// The handle of the failed handshake\n        handle: HandshakeHandle,\n        /// The failure reason\n        reason: Error,\n    },\n\n    //\n    // Endpint Server Events\n    //\n\n    /// The endpoint servers onion-service has been published and may be reachable by endpoint clients.\n    EndpointServerPublished {\n        /// The onion-service service-id of the published endpoint server\n        endpoint_service_id: V3OnionServiceId,\n        /// The name of the published endpoint server\n        endpoint_name: String,\n    },\n\n    /// An endpoint server has received an incoming connection and the handshake is ready to begin.\n    EndpointServerHandshakeStarted {\n        /// The handle of the new handshake\n        handle: HandshakeHandle,\n    },\n\n    /// An endpoint server has received a request for a channel from an endpoint client.\n    ///\n    /// To continue the handshake, the server must call [`Context::endpoint_server_handle_channel_request_received()`]\n    EndpointServerChannelRequestReceived {\n        /// The handle of the in-progress handshake\n        handle: HandshakeHandle,\n        /// The alleged onion-service service-id of the connecting client\n        client_service_id: V3OnionServiceId,\n        /// The ASCII-encoded name of the requested channel\n        requested_channel: String,\n    },\n\n    /// An endpoint server's handshake has completed\n    EndpointServerHandshakeCompleted {\n        /// The handle of the completed handshake\n        handle: HandshakeHandle,\n        /// The onion-service service-id of the endpoint server which an endpoint client has connected to\n        endpoint_service_id: V3OnionServiceId,\n        /// The onion-service service-id of the connected client\n        client_service_id: V3OnionServiceId,\n        /// The ASCII-encoded name of the client's requested channel\n        channel_name: String,\n        /// The resulting TCP connection to tohe endpoint clientt\n        stream: TcpStream,\n    },\n\n    /// An endpoint server has rejected an endpoint client's channel request.\n    ///\n    /// There are multiple potential reasons why a handshake may be rejected and this event provides a breakdown on which part(s) failed specifically.\n    EndpointServerHandshakeRejected {\n        /// The handle of the rejected handshake\n        handle: HandshakeHandle,\n        /// `false` if the client was rejected based on their onion-service service-id\n        client_allowed: bool,\n        /// `false` if the requested channel name was not understood by the server\n        client_requested_channel_valid: bool,\n        /// `false` if the client failed its authentication proof (i.e. potential attempt at endpoint client impersonation)\n        client_proof_signature_valid: bool,\n    },\n\n    /// An incoming endpoint handshake has failed.\n    EndpointServerHandshakeFailed {\n        /// The handle of the failed handshake\n        handle: HandshakeHandle,\n        /// The failure reason\n        reason: Error,\n    },\n}\n\nimpl Context {\n    /// Construct a new `Context` object.\n    ///\n    /// # Parameters\n    /// - `tor_provider`: an implementation of the [`TorProvider`] trait which provides our Tor Network connectivity\n    /// - `identity_port`: the virt-port this `Context`'s identity server's onion-service will listen on for new identity handshakes.\n    /// - `endpoint_port`: the virt-port this `Context`'s endpoint servers' onion-services will listen on for new endpoint handshakes.\n    /// - `identity_timeout`: the maximum amount of time this `Context`' will allow an identity handshake to delay between steps before rejecting the request.\n    /// - `identity_max_message_size`: the maximum size of the underlying Honk-RPC BSON message this `Context`'s identity handshake will send and accept.\n    /// - `endpoint_timeout`: the maximum amount of time this `Context`' will allow an endpoint handshake to delay between steps before rejecting the request.\n    /// - `identity_private_key`: the ed25519 private key used to start this `Context`'s identity server's onion-service\n    /// # Returns\n    /// A newly constructed `Context`.\n    pub fn new(\n        tor_provider: Box\u003cdyn TorProvider\u003e,\n        identity_port: u16,\n        endpoint_port: u16,\n        identity_timeout: Duration,\n        identity_max_message_size: i32,\n        endpoint_timeout: Option\u003cDuration\u003e,\n        identity_private_key: Ed25519PrivateKey,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        let identity_service_id = V3OnionServiceId::from_private_key(\u0026identity_private_key);\n\n        Ok(Self {\n            tor_provider,\n            bootstrap_complete: false,\n            identity_port,\n            identity_max_message_size,\n            endpoint_port,\n            identity_timeout,\n            endpoint_timeout: match endpoint_timeout {\n                Some(timeout) =\u003e timeout,\n                None =\u003e DEFAULT_ENDPOINT_TIMEOUT,\n            },\n\n            next_handshake_handle: Default::default(),\n            identity_clients: Default::default(),\n            identity_servers: Default::default(),\n            endpoint_clients: Default::default(),\n            endpoint_servers: Default::default(),\n\n            identity_listener: None,\n            identity_server_published: false,\n            endpoint_listeners: Default::default(),\n\n            identity_private_key,\n            identity_service_id,\n        })\n    }\n\n    /// Initiate bootstrap of the `Context`'s owned [`TorProvider`]. Bootstrap status is communicated through [`ContextEvent`]s returned from the [`Context::update()`] method.\n    pub fn bootstrap(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.tor_provider.bootstrap()?;\n        Ok(())\n    }\n\n    /// Initiate an identity handshake with an identity server. Handshake progression is communicated through  [`ContextEvent`]s returned from the [`Context::update()`] method.\n    ///\n    /// # Parameters\n    /// - `identitity_server_id`: the long term identity onion-service service-id of a remote peer\n    /// - `endpoint`: the ASCII-encoded requested endpoint\n    /// # Returns\n    /// A `HandshakeHandle` used to refer to this particular identity handshake.\n    pub fn identity_client_begin_handshake(\n        \u0026mut self,\n        identity_server_id: V3OnionServiceId,\n        endpoint: String,\n    ) -\u003e Result\u003cHandshakeHandle, Error\u003e {\n        let endpoint = match AsciiString::new(endpoint) {\n            Ok(endpoint) =\u003e endpoint,\n            Err(_) =\u003e {\n                return Err(Error::InvalidArgument(\n                    \"endpoint must be an ASCII string\".to_string(),\n                ))\n            }\n        };\n\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        // open tcp stream to remove ident server\n        let stream: TcpStream = self\n            .tor_provider\n            .connect(\n                (identity_server_id.clone(), self.identity_port).into(),\n                None,\n            )?\n            .into();\n        stream.set_nonblocking(true)?;\n        let mut client_rpc = Session::new(stream);\n        client_rpc.set_max_wait_time(self.identity_timeout);\n        client_rpc.set_max_message_size(self.identity_max_message_size)?;\n\n        let ident_client = IdentityClient::new(\n            client_rpc,\n            identity_server_id,\n            endpoint,\n            self.identity_private_key.clone(),\n            X25519PrivateKey::generate(),\n        )?;\n\n        let handshake_handle = self.next_handshake_handle;\n        self.next_handshake_handle += 1;\n        self.identity_clients.insert(handshake_handle, ident_client);\n\n        Ok(handshake_handle)\n    }\n\n    /// Abort an in-process outgoing identity handshake.\n    ///\n    /// # Parameters\n    /// - `handle`: the handle of the in-progress outoing identity handshake to abort\n    pub fn identity_client_abort_handshake(\n        \u0026mut self,\n        handle: HandshakeHandle,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(_identity_client) = self.identity_clients.remove(\u0026handle) {\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    /// Handle an identity server's endpoint challenge. Callers must construct an identity client's endpoint challenge-response. The particulars of creating and verifying the challenge-response BSON documents are undefined and application-specific.\n    ///\n    /// # Parameters\n    /// - `handle`: the handle of the in-progress outgoing identity handshake\n    /// - `challenge_response`: an application-specific BSON document which somehow responds to an identity server's challenge.\n    pub fn identity_client_handle_challenge_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        challenge_response: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_client) = self.identity_clients.get_mut(\u0026handle) {\n            identity_client.send_response(challenge_response)?;\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    /// Start this `Context`'s identity server. Publish status is communicated through [`ContextEvent`]s returned from the [`Context::update()`] method.\n    pub fn identity_server_start(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n        if self.identity_listener.is_some() {\n            return Err(Error::IncorrectUsage(\n                \"identity server already started\".to_string(),\n            ));\n        }\n\n        let identity_listener =\n            self.tor_provider\n                .listener(\u0026self.identity_private_key, self.identity_port, None)?;\n        identity_listener.set_nonblocking(true)?;\n\n        self.identity_listener = Some(identity_listener);\n        Ok(())\n    }\n\n    /// Stops this `Context`'s identity server and ends any in-progress incoming identity handshakes.\n    pub fn identity_server_stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if self.identity_listener.is_none() {\n            return Err(Error::IncorrectUsage(\n                \"identity server is not started\".to_string(),\n            ));\n        }\n\n        // clear out current identity listener\n        self.identity_listener = None;\n        // clear out published flag\n        self.identity_server_published = false;\n        // clear out any in-process identity handshakes\n        self.identity_servers = Default::default();\n        Ok(())\n    }\n\n    /// Handle an identity client's incoming endpoint request. Callers must determine whether the connected identity client is allowed to access the requested endpoint, decide whether the requested endpoint is supported by this `Context`, and build an endpoint challenge for the identity client. The particulars of creating the endpoint challenge is undefined and application-specific.\n    ///\n    /// # Parameters\n    /// - `handle`: the handle of the in-progress incoming identity handshake\n    /// - `client_allowed`: whether the connected identity client is allowed to access the requested endpoint\n    /// - `endpoint_supported`: whether the requested endpoint is supported\n    /// - `endpoint_challenge`: an application-specific BSON document which the connected identity client must respond to\n    pub fn identity_server_handle_endpoint_request_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        client_allowed: bool,\n        endpoint_supported: bool,\n        endpoint_challenge: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_server) = self.identity_servers.get_mut(\u0026handle) {\n            Ok(identity_server.handle_endpoint_request_received(\n                client_allowed,\n                endpoint_supported,\n                endpoint_challenge,\n            )?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    // confirm that a received endpoint challenge response is valid\n\n    /// Handle an identity client's incoming endpoint challenge-response. Callers must determine whether the connected identity client's challenge-response is valid. The particulars of verifying the challenge-response is undefined and application-specific.\n    ///\n    /// # Parameters\n    /// - `handle`: the handle of the in-progress incoming identity handshake\n    /// - `challenge_response_valid`: whether the received challenge-response is valid\n    pub fn identity_server_handle_challenge_response_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        challenge_response_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(identity_server) = self.identity_servers.get_mut(\u0026handle) {\n            Ok(identity_server.handle_challenge_response_received(challenge_response_valid)?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    /// Initiate an endpoint handshake with an identity server. An endpoint client acquires the `endpoint_server_id` and `client_auth_key` by completing an identity handshake or through some other side-channnel. Handshake progression is communicated through [`ContextEvent`]s returned from the [`Context::update()`] method.\n    ///\n    /// # Parameters\n    /// - `endpoint_server_id`: the endpoint onion-service service-id of a remote peer\n    /// - `client_uath_key`: the x25519 private-key required to decrypt the endpoint server's onion-service descriptor\n    /// - `channel`: the ASCII-encoded requested channel\n    pub fn endpoint_client_begin_handshake(\n        \u0026mut self,\n        endpoint_server_id: V3OnionServiceId,\n        client_auth_key: X25519PrivateKey,\n        channel: String,\n    ) -\u003e Result\u003cHandshakeHandle, Error\u003e {\n        let channel = match AsciiString::new(channel) {\n            Ok(channel) =\u003e channel,\n            Err(_) =\u003e {\n                return Err(Error::InvalidArgument(\n                    \"channel must be an ASCII string\".to_string(),\n                ))\n            }\n        };\n\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        self.tor_provider\n            .add_client_auth(\u0026endpoint_server_id, \u0026client_auth_key)?;\n        let stream: TcpStream = self\n            .tor_provider\n            .connect(\n                (endpoint_server_id.clone(), self.endpoint_port).into(),\n                None,\n            )?\n            .into();\n        stream.set_nonblocking(true)?;\n\n        let mut session = Session::new(stream);\n        session.set_max_wait_time(self.endpoint_timeout);\n        session.set_max_message_size(DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE)?;\n\n        let endpoint_client = EndpointClient::new(\n            session,\n            endpoint_server_id,\n            channel,\n            self.identity_private_key.clone(),\n        );\n\n        let handshake_handle = self.next_handshake_handle;\n        self.next_handshake_handle += 1;\n        self.endpoint_clients\n            .insert(handshake_handle, endpoint_client);\n        Ok(handshake_handle)\n    }\n\n    /// Abort an in-process outgoing endpoint handshake\n    ///\n    /// # Parameters\n    /// - `handle`: the handle of the in-progress outoing identity handshake to abort\n    pub fn endpoint_client_abort_handshake(\n        \u0026mut self,\n        handle: HandshakeHandle,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(_endpoint_client) = self.endpoint_clients.remove(\u0026handle) {\n            Ok(())\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    /// Start one of this `Context`'s endpoint servers. Publish status is communicated through [`ContextEvent`]s returned from the [`Context::update()`] method.\n    ///\n    /// # Parameters\n    /// - `endpoint_private_key`: the ed25519 private key used to start this endpoint server's onion-service\n    /// - `endpoint_name`: the ASCII-encoded endpoint name\n    /// - `client_identity`: the onion-service service-id of the client which will be connecting to this endpoint server\n    /// - `client_auth`: the x25519 public-key used to encrypt the endpoint server's onion-service descriptor\n    pub fn endpoint_server_start(\n        \u0026mut self,\n        endpoint_private_key: Ed25519PrivateKey,\n        endpoint_name: String,\n        client_identity: V3OnionServiceId,\n        client_auth: X25519PublicKey,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        let endpoint_public_key = Ed25519PublicKey::from_private_key(\u0026endpoint_private_key);\n        let endpoint_service_id = V3OnionServiceId::from_public_key(\u0026endpoint_public_key);\n\n        if endpoint_service_id == self.identity_service_id {\n            return Err(Error::InvalidArgument(\n                \"endpoint server must be different from identity server\".to_string(),\n            ));\n        }\n\n        if self.endpoint_listeners.contains_key(\u0026endpoint_service_id) {\n            return Err(Error::IncorrectUsage(\n                \"endpoint server already started\".to_string(),\n            ));\n        }\n\n        let endpoint_listener = self.tor_provider.listener(\n            \u0026endpoint_private_key,\n            self.endpoint_port,\n            Some(\u0026[client_auth]),\n        )?;\n        endpoint_listener.set_nonblocking(true)?;\n\n        self.endpoint_listeners.insert(\n            endpoint_service_id,\n            (endpoint_name, client_identity, endpoint_listener, false),\n        );\n        Ok(())\n    }\n\n    /// Handle an endpoint client's incoming channel request. Callers must determine whether the requested channel is supported by this `Context`. The particulars of making this determination is undefined and application-specific.\n    ///\n    /// # Parameters\n    /// - `handle`: the handle of the in-progress incoming endpoint handshake\n    /// - `channel_supported`: whether the requested channel is supported\n    pub fn endpoint_server_handle_channel_request_received(\n        \u0026mut self,\n        handle: HandshakeHandle,\n        channel_supported: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if let Some(endpoint_server) = self.endpoint_servers.get_mut(\u0026handle) {\n            Ok(endpoint_server.handle_channel_request_received(channel_supported)?)\n        } else {\n            Err(Error::HandshakeHandleNotFound(handle))\n        }\n    }\n\n    /// Stop one of this `Context`'s endpoint servers and ends any of its in-progress incoming endpoint handshakes.\n    ///\n    /// # Parameters\n    /// - `endpoint_identity`: the onion-service service-id of the enpdoint server to stop\n    pub fn endpoint_server_stop(\n        \u0026mut self,\n        endpoint_identity: V3OnionServiceId,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if !self.bootstrap_complete {\n            return Err(Error::TorNotConnected());\n        }\n\n        if let Some(_listener) = self.endpoint_listeners.remove(\u0026endpoint_identity) {\n            Ok(())\n        } else {\n            Err(Error::InvalidArgument(format!(\n                \"endpoint server with service id {} not found\",\n                endpoint_identity\n            )))\n        }\n    }\n\n    fn identity_server_handle_accept(\n        identity_listener: \u0026OnionListener,\n        identity_timeout: Duration,\n        identity_max_message_size: i32,\n        identity_private_key: \u0026Ed25519PrivateKey,\n    ) -\u003e Result\u003cOption\u003cIdentityServer\u003e, Error\u003e {\n        if let Some(stream) = identity_listener.accept()? {\n            let stream: TcpStream = stream.into();\n            if stream.set_nonblocking(true).is_err() {\n                return Ok(None);\n            }\n\n            let mut server_rpc = Session::new(stream);\n            server_rpc.set_max_wait_time(identity_timeout);\n            server_rpc.set_max_message_size(identity_max_message_size)?;\n            let service_id = V3OnionServiceId::from_private_key(identity_private_key);\n            let identity_server = IdentityServer::new(server_rpc, service_id);\n\n            Ok(Some(identity_server))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn endpoint_server_handle_accept(\n        endpoint_listener: \u0026OnionListener,\n        endpoint_timeout: Duration,\n        client_service_id: \u0026V3OnionServiceId,\n        endpoint_service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003cOption\u003cEndpointServer\u003e, Error\u003e {\n        if let Some(stream) = endpoint_listener.accept()? {\n            let stream: TcpStream = stream.into();\n            if stream.set_nonblocking(true).is_err() {\n                return Ok(None);\n            }\n\n            let mut server_rpc = Session::new(stream);\n            server_rpc.set_max_wait_time(endpoint_timeout);\n            server_rpc.set_max_message_size(DEFAULT_ENDPOINT_MAX_MESSAGE_SIZE)?;\n\n            let endpoint_server = EndpointServer::new(\n                server_rpc,\n                client_service_id.clone(),\n                endpoint_service_id.clone(),\n            );\n\n            Ok(Some(endpoint_server))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// A direct pass-through to the underlying [`TorProvider`]'s [`TorProvider::connect()`] method.\n    pub fn connect(\n        \u0026mut self,\n        target_addr: TargetAddr,\n        circuit_token: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, Error\u003e {\n        Ok(self.tor_provider.connect(target_addr, circuit_token)?)\n    }\n\n    /// A direct pass-through to the underlying [`TorProvider`]'s [`TorProvider::generate_token()`] method.\n    pub fn generate_circuit_token(\u0026mut self) -\u003e CircuitToken {\n        self.tor_provider.generate_token()\n    }\n\n    /// A direct pass-through to the underlying [`TorProvider`]'s [`TorProvider::release_token()`] method.\n    pub fn release_circuit_token(\u0026mut self, circuit_token: CircuitToken) {\n        self.tor_provider.release_token(circuit_token)\n    }\n\n    /// This function updates the `Context`'s underlying [`TorProvider`], handles new handshakes requests, and updates in-progress handshakes. This function needs to be regularly called to process the returned [`ContextEvent`]s.\n    pub fn update(\u0026mut self) -\u003e Result\u003cVecDeque\u003cContextEvent\u003e, Error\u003e {\n        // events to return\n        let mut events: VecDeque\u003cContextEvent\u003e = Default::default();\n\n        // first handle new identity connections\n        if let Some(identity_listener) = \u0026self.identity_listener {\n            match Self::identity_server_handle_accept(\n                identity_listener,\n                self.identity_timeout,\n                self.identity_max_message_size,\n                \u0026self.identity_private_key,\n            ) {\n                Ok(Some(identity_server)) =\u003e {\n                    let handle = self.next_handshake_handle;\n                    self.next_handshake_handle += 1;\n                    self.identity_servers.insert(handle, identity_server);\n                    events.push_back(ContextEvent::IdentityServerHandshakeStarted { handle });\n                }\n                Ok(None) =\u003e {}\n                // identity listener failed, remove it\n                // TODO: signal caller identity listener is down\n                Err(_) =\u003e self.identity_listener = None,\n            }\n        }\n\n        // next handle new endpoint connections\n        self.endpoint_listeners.retain(\n            |endpoint_service_id, (_endpoint_name, allowed_client, listener, _published)| -\u003e bool {\n                match Self::endpoint_server_handle_accept(\n                    listener,\n                    self.endpoint_timeout,\n                    allowed_client,\n                    endpoint_service_id,\n                ) {\n                    Ok(Some(endpoint_server)) =\u003e {\n                        let handle = self.next_handshake_handle;\n                        self.next_handshake_handle += 1;\n                        self.endpoint_servers.insert(handle, endpoint_server);\n                        events.push_back(ContextEvent::EndpointServerHandshakeStarted { handle });\n                        true\n                    }\n                    Ok(None) =\u003e true,\n                    // endpoint listener failed, remove it\n                    // TODO: signal caller endpoint listener is down\n                    Err(_) =\u003e false,\n                }\n            },\n        );\n\n        // consume tor events\n        // TODO: so curently the only failure mode of this function is a result of the\n        // LegacyTorClient failing; we should probably consider a LegacyTorClient failure fatal, since\n        // reading the LegacyTorClient::update() function it seems the only failure modes are a\n        // failure to DEL_ONION (which realistically speaking could only be due to a logic\n        // error on our part by deleting an onion that doesn't exist, or a parse error of\n        // the response) and a failure to read async events which is either again a parsing\n        // bug on our end or a malformed/buggy tor daemon which we also cannot recover\n        // from.\n        for event in self.tor_provider.update()?.drain(..) {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e {\n                    events.push_back(ContextEvent::TorBootstrapStatusReceived {\n                        progress,\n                        tag,\n                        summary,\n                    });\n                }\n                TorEvent::BootstrapComplete =\u003e {\n                    events.push_back(ContextEvent::TorBootstrapCompleted);\n                    self.bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    events.push_back(ContextEvent::TorLogReceived { line });\n                }\n                TorEvent::OnionServicePublished { service_id } =\u003e {\n                    if service_id == self.identity_service_id {\n                        if !self.identity_server_published {\n                            events.push_back(ContextEvent::IdentityServerPublished);\n                            self.identity_server_published = true;\n                        }\n                    } else if let Some((endpoint_name, _, _, published)) =\n                        self.endpoint_listeners.get_mut(\u0026service_id)\n                    {\n                        // ingore duplicate publish events\n                        if !*published {\n                            events.push_back(ContextEvent::EndpointServerPublished {\n                                endpoint_service_id: service_id,\n                                endpoint_name: endpoint_name.clone(),\n                            });\n                            *published = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        // update the ident client handshakes\n        self.identity_clients\n            .retain(|handle, identity_client| -\u003e bool {\n                let handle = *handle;\n                match identity_client.update() {\n                    Ok(Some(IdentityClientEvent::ChallengeReceived { endpoint_challenge })) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientChallengeReceived {\n                            handle,\n                            endpoint_challenge,\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                        identity_service_id,\n                        endpoint_service_id,\n                        endpoint_name,\n                        client_auth_private_key,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientHandshakeCompleted {\n                            handle,\n                            identity_service_id,\n                            endpoint_service_id,\n                            endpoint_name,\n                            client_auth_private_key,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::IdentityClientHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the ident server handshakes\n        self.identity_servers\n            .retain(|handle, identity_server| -\u003e bool {\n                let handle = *handle;\n                match identity_server.update() {\n                    Ok(Some(IdentityServerEvent::EndpointRequestReceived {\n                        client_service_id,\n                        requested_endpoint,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerEndpointRequestReceived {\n                            handle,\n                            client_service_id,\n                            requested_endpoint: requested_endpoint.to_string(),\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityServerEvent::ChallengeResponseReceived {\n                        challenge_response,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerChallengeResponseReceived {\n                            handle,\n                            challenge_response,\n                        });\n                        true\n                    }\n                    Ok(Some(IdentityServerEvent::HandshakeCompleted {\n                        endpoint_private_key,\n                        endpoint_name,\n                        client_service_id,\n                        client_auth_public_key,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeCompleted {\n                            handle,\n                            endpoint_private_key,\n                            endpoint_name: endpoint_name.to_string(),\n                            client_service_id,\n                            client_auth_public_key,\n                        });\n                        false\n                    }\n                    Ok(Some(IdentityServerEvent::HandshakeRejected {\n                        client_allowed,\n                        client_requested_endpoint_valid,\n                        client_proof_signature_valid,\n                        client_auth_signature_valid,\n                        challenge_response_valid,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeRejected {\n                            handle,\n                            client_allowed,\n                            client_requested_endpoint_valid,\n                            client_proof_signature_valid,\n                            client_auth_signature_valid,\n                            challenge_response_valid,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::IdentityServerHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the endpoint client handshakes\n        self.endpoint_clients\n            .retain(|handle, endpoint_client| -\u003e bool {\n                let handle = *handle;\n                match endpoint_client.update() {\n                    Ok(Some(EndpointClientEvent::HandshakeCompleted { stream })) =\u003e {\n                        events.push_back(ContextEvent::EndpointClientHandshakeCompleted {\n                            handle,\n                            endpoint_service_id: endpoint_client.server_service_id.clone(),\n                            channel_name: endpoint_client.requested_channel.to_string(),\n                            stream,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::EndpointClientHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        // update the endpoint server handshakes\n        self.endpoint_servers\n            .retain(|handle, endpoint_server| -\u003e bool {\n                let handle = *handle;\n                match endpoint_server.update() {\n                    Ok(Some(EndpointServerEvent::ChannelRequestReceived {\n                        requested_channel,\n                        client_service_id,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerChannelRequestReceived {\n                            handle,\n                            client_service_id,\n                            requested_channel: requested_channel.to_string(),\n                        });\n                        true\n                    }\n                    Ok(Some(EndpointServerEvent::HandshakeCompleted {\n                        client_service_id,\n                        channel_name,\n                        stream,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeCompleted {\n                            handle,\n                            endpoint_service_id: endpoint_server.server_identity.clone(),\n                            client_service_id,\n                            channel_name: channel_name.to_string(),\n                            stream,\n                        });\n                        false\n                    }\n                    Ok(Some(EndpointServerEvent::HandshakeRejected {\n                        client_allowed,\n                        client_requested_channel_valid,\n                        client_proof_signature_valid,\n                    })) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeRejected {\n                            handle,\n                            client_allowed,\n                            client_requested_channel_valid,\n                            client_proof_signature_valid,\n                        });\n                        false\n                    }\n                    Err(err) =\u003e {\n                        events.push_back(ContextEvent::EndpointServerHandshakeFailed {\n                            handle,\n                            reason: err.into(),\n                        });\n                        false\n                    }\n                    Ok(None) =\u003e true,\n                }\n            });\n\n        Ok(events)\n    }\n}\n","traces":[{"line":362,"address":[1927359,1926128,1927318],"length":1,"stats":{"Line":1}},{"line":371,"address":[1926275],"length":1,"stats":{"Line":1}},{"line":373,"address":[1926836],"length":1,"stats":{"Line":1}},{"line":374,"address":[1926348],"length":1,"stats":{"Line":1}},{"line":380,"address":[1926382],"length":1,"stats":{"Line":1}},{"line":381,"address":[1926432],"length":1,"stats":{"Line":1}},{"line":382,"address":[1926407],"length":1,"stats":{"Line":0}},{"line":386,"address":[1926517],"length":1,"stats":{"Line":1}},{"line":387,"address":[1926536],"length":1,"stats":{"Line":1}},{"line":388,"address":[1926596],"length":1,"stats":{"Line":1}},{"line":389,"address":[1926656],"length":1,"stats":{"Line":1}},{"line":391,"address":[1926716],"length":1,"stats":{"Line":1}},{"line":393,"address":[1926727],"length":1,"stats":{"Line":1}},{"line":395,"address":[1926795],"length":1,"stats":{"Line":1}},{"line":401,"address":[1927392],"length":1,"stats":{"Line":1}},{"line":402,"address":[1927498,1927412],"length":1,"stats":{"Line":1}},{"line":403,"address":[1927489],"length":1,"stats":{"Line":1}},{"line":413,"address":[1930247,1927568,1929988],"length":1,"stats":{"Line":1}},{"line":418,"address":[1927646],"length":1,"stats":{"Line":1}},{"line":419,"address":[1927726],"length":1,"stats":{"Line":1}},{"line":421,"address":[1930322],"length":1,"stats":{"Line":0}},{"line":422,"address":[1927843],"length":1,"stats":{"Line":0}},{"line":427,"address":[1927878],"length":1,"stats":{"Line":1}},{"line":428,"address":[1927954],"length":1,"stats":{"Line":0}},{"line":432,"address":[1928496,1927996,1930216,1928188],"length":1,"stats":{"Line":2}},{"line":435,"address":[1928053,1928022],"length":1,"stats":{"Line":2}},{"line":436,"address":[1928176],"length":1,"stats":{"Line":1}},{"line":439,"address":[1930160,1928544,1928716,1928619],"length":1,"stats":{"Line":2}},{"line":440,"address":[1928758,1928677],"length":1,"stats":{"Line":2}},{"line":441,"address":[1928766],"length":1,"stats":{"Line":1}},{"line":442,"address":[1928837,1929069,1927638,1930095],"length":1,"stats":{"Line":2}},{"line":445,"address":[1928936],"length":1,"stats":{"Line":1}},{"line":447,"address":[1928987],"length":1,"stats":{"Line":1}},{"line":448,"address":[1929251,1929035],"length":1,"stats":{"Line":2}},{"line":449,"address":[1929259],"length":1,"stats":{"Line":1}},{"line":452,"address":[1929534],"length":1,"stats":{"Line":1}},{"line":453,"address":[1929824,1929551,1929734],"length":1,"stats":{"Line":2}},{"line":454,"address":[1929881,1929738],"length":1,"stats":{"Line":2}},{"line":456,"address":[1929910],"length":1,"stats":{"Line":1}},{"line":463,"address":[1930464],"length":1,"stats":{"Line":0}},{"line":467,"address":[1930494],"length":1,"stats":{"Line":0}},{"line":468,"address":[1930589],"length":1,"stats":{"Line":0}},{"line":470,"address":[1930617],"length":1,"stats":{"Line":0}},{"line":479,"address":[1930736,1931344,1931316],"length":1,"stats":{"Line":1}},{"line":484,"address":[1931068,1930783,1930870,1931141],"length":1,"stats":{"Line":3}},{"line":485,"address":[1930918,1930770,1931073,1931151,1931289],"length":1,"stats":{"Line":3}},{"line":486,"address":[1931134],"length":1,"stats":{"Line":1}},{"line":488,"address":[1931025],"length":1,"stats":{"Line":0}},{"line":493,"address":[1932518,1931360,1932550],"length":1,"stats":{"Line":1}},{"line":494,"address":[1931390],"length":1,"stats":{"Line":1}},{"line":495,"address":[1931412],"length":1,"stats":{"Line":0}},{"line":497,"address":[1931443],"length":1,"stats":{"Line":1}},{"line":498,"address":[1931636],"length":1,"stats":{"Line":0}},{"line":499,"address":[1931606],"length":1,"stats":{"Line":0}},{"line":503,"address":[1931983,1931484,1931719,1931521],"length":1,"stats":{"Line":3}},{"line":505,"address":[1931948,1931492],"length":1,"stats":{"Line":1}},{"line":506,"address":[1932055,1932345,1931382,1931919],"length":1,"stats":{"Line":3}},{"line":508,"address":[1932122,1932384],"length":1,"stats":{"Line":1}},{"line":509,"address":[1932471],"length":1,"stats":{"Line":1}},{"line":513,"address":[1932560,1933087],"length":1,"stats":{"Line":0}},{"line":514,"address":[1932596],"length":1,"stats":{"Line":0}},{"line":515,"address":[1932679],"length":1,"stats":{"Line":0}},{"line":516,"address":[1932649],"length":1,"stats":{"Line":0}},{"line":521,"address":[1932751,1932617],"length":1,"stats":{"Line":0}},{"line":523,"address":[1932897],"length":1,"stats":{"Line":0}},{"line":525,"address":[1932904],"length":1,"stats":{"Line":0}},{"line":526,"address":[1933067],"length":1,"stats":{"Line":0}},{"line":536,"address":[1933744,1933773,1933104],"length":1,"stats":{"Line":1}},{"line":543,"address":[1933565,1933492,1933182,1933269],"length":1,"stats":{"Line":3}},{"line":544,"address":[1933409,1933678,1933716,1933150,1933497],"length":1,"stats":{"Line":3}},{"line":547,"address":[1933330],"length":1,"stats":{"Line":1}},{"line":550,"address":[1933449],"length":1,"stats":{"Line":0}},{"line":561,"address":[1933792],"length":1,"stats":{"Line":1}},{"line":566,"address":[1933848,1934034,1934048],"length":1,"stats":{"Line":2}},{"line":567,"address":[1934041,1933914,1933826,1934050],"length":1,"stats":{"Line":3}},{"line":569,"address":[1933991],"length":1,"stats":{"Line":0}},{"line":579,"address":[1936821,1934112,1936402],"length":1,"stats":{"Line":1}},{"line":585,"address":[1934180,1934284],"length":1,"stats":{"Line":2}},{"line":586,"address":[1934295],"length":1,"stats":{"Line":1}},{"line":588,"address":[1936684],"length":1,"stats":{"Line":0}},{"line":589,"address":[1934412],"length":1,"stats":{"Line":0}},{"line":594,"address":[1934447],"length":1,"stats":{"Line":1}},{"line":595,"address":[1934523],"length":1,"stats":{"Line":0}},{"line":598,"address":[1934616,1934570,1936586,1934774],"length":1,"stats":{"Line":2}},{"line":599,"address":[1934726],"length":1,"stats":{"Line":0}},{"line":600,"address":[1936584,1934943,1934688,1935251],"length":1,"stats":{"Line":2}},{"line":603,"address":[1934808,1934714],"length":1,"stats":{"Line":2}},{"line":604,"address":[1934931],"length":1,"stats":{"Line":1}},{"line":607,"address":[1935374,1935471,1936528,1935299],"length":1,"stats":{"Line":2}},{"line":609,"address":[1935432,1935513],"length":1,"stats":{"Line":2}},{"line":610,"address":[1935521],"length":1,"stats":{"Line":1}},{"line":611,"address":[1934172,1935588,1935819],"length":1,"stats":{"Line":2}},{"line":614,"address":[1935686],"length":1,"stats":{"Line":1}},{"line":616,"address":[1935737],"length":1,"stats":{"Line":1}},{"line":617,"address":[1935785],"length":1,"stats":{"Line":1}},{"line":620,"address":[1936090],"length":1,"stats":{"Line":1}},{"line":621,"address":[1936227,1936107],"length":1,"stats":{"Line":1}},{"line":622,"address":[1936208,1936139],"length":1,"stats":{"Line":2}},{"line":623,"address":[1936150,1936284],"length":1,"stats":{"Line":2}},{"line":624,"address":[1936318],"length":1,"stats":{"Line":1}},{"line":631,"address":[1936848],"length":1,"stats":{"Line":0}},{"line":635,"address":[1936878],"length":1,"stats":{"Line":0}},{"line":636,"address":[1936976],"length":1,"stats":{"Line":0}},{"line":638,"address":[1937004],"length":1,"stats":{"Line":0}},{"line":649,"address":[1937120,1938861,1938604],"length":1,"stats":{"Line":1}},{"line":656,"address":[1937170],"length":1,"stats":{"Line":1}},{"line":657,"address":[1937208],"length":1,"stats":{"Line":0}},{"line":660,"address":[1937239],"length":1,"stats":{"Line":1}},{"line":661,"address":[1937318],"length":1,"stats":{"Line":1}},{"line":663,"address":[1937350],"length":1,"stats":{"Line":1}},{"line":664,"address":[1938708],"length":1,"stats":{"Line":0}},{"line":665,"address":[1937418],"length":1,"stats":{"Line":0}},{"line":669,"address":[1937452,1937391],"length":1,"stats":{"Line":2}},{"line":670,"address":[1938620],"length":1,"stats":{"Line":0}},{"line":671,"address":[1937571],"length":1,"stats":{"Line":0}},{"line":675,"address":[1937601,1937539,1937939,1938613,1937473],"length":1,"stats":{"Line":3}},{"line":678,"address":[1937488],"length":1,"stats":{"Line":1}},{"line":680,"address":[1937857,1937162,1938014,1938453],"length":1,"stats":{"Line":3}},{"line":682,"address":[1938091,1938413],"length":1,"stats":{"Line":2}},{"line":684,"address":[1938095],"length":1,"stats":{"Line":1}},{"line":686,"address":[1938516],"length":1,"stats":{"Line":1}},{"line":694,"address":[1938880],"length":1,"stats":{"Line":1}},{"line":699,"address":[1939122,1939136,1938936],"length":1,"stats":{"Line":2}},{"line":700,"address":[1938914,1939002,1939129,1939138],"length":1,"stats":{"Line":3}},{"line":702,"address":[1939079],"length":1,"stats":{"Line":0}},{"line":710,"address":[1939878,1939200,1939846],"length":1,"stats":{"Line":0}},{"line":714,"address":[1939235],"length":1,"stats":{"Line":0}},{"line":715,"address":[1939257],"length":1,"stats":{"Line":0}},{"line":718,"address":[1939293,1939369],"length":1,"stats":{"Line":0}},{"line":719,"address":[1939420],"length":1,"stats":{"Line":0}},{"line":721,"address":[1939636],"length":1,"stats":{"Line":0}},{"line":728,"address":[1941204,1939888,1941286],"length":1,"stats":{"Line":1}},{"line":734,"address":[1939978,1940421],"length":1,"stats":{"Line":2}},{"line":735,"address":[1940318],"length":1,"stats":{"Line":1}},{"line":736,"address":[1940472,1940357],"length":1,"stats":{"Line":2}},{"line":737,"address":[1941218],"length":1,"stats":{"Line":0}},{"line":740,"address":[1940595],"length":1,"stats":{"Line":1}},{"line":741,"address":[1940646],"length":1,"stats":{"Line":1}},{"line":742,"address":[1940710,1939939,1940831],"length":1,"stats":{"Line":2}},{"line":743,"address":[1940804],"length":1,"stats":{"Line":1}},{"line":744,"address":[1940972],"length":1,"stats":{"Line":1}},{"line":746,"address":[1941043],"length":1,"stats":{"Line":1}},{"line":748,"address":[1940391],"length":1,"stats":{"Line":1}},{"line":752,"address":[1941376,1942734,1942877],"length":1,"stats":{"Line":1}},{"line":758,"address":[1941902,1941451],"length":1,"stats":{"Line":2}},{"line":759,"address":[1941799],"length":1,"stats":{"Line":1}},{"line":760,"address":[1941838,1941953],"length":1,"stats":{"Line":2}},{"line":761,"address":[1942809],"length":1,"stats":{"Line":0}},{"line":764,"address":[1942076],"length":1,"stats":{"Line":1}},{"line":765,"address":[1942127],"length":1,"stats":{"Line":1}},{"line":766,"address":[1942355,1941412,1942187],"length":1,"stats":{"Line":2}},{"line":769,"address":[1942281],"length":1,"stats":{"Line":1}},{"line":770,"address":[1942340],"length":1,"stats":{"Line":1}},{"line":771,"address":[1942550],"length":1,"stats":{"Line":1}},{"line":774,"address":[1942612],"length":1,"stats":{"Line":1}},{"line":776,"address":[1941872],"length":1,"stats":{"Line":1}},{"line":781,"address":[1942960],"length":1,"stats":{"Line":0}},{"line":786,"address":[1943126,1943003],"length":1,"stats":{"Line":0}},{"line":790,"address":[1943200],"length":1,"stats":{"Line":0}},{"line":791,"address":[1943208],"length":1,"stats":{"Line":0}},{"line":795,"address":[1943232],"length":1,"stats":{"Line":0}},{"line":796,"address":[1943249],"length":1,"stats":{"Line":0}},{"line":800,"address":[1943280,1944075,1945942],"length":1,"stats":{"Line":1}},{"line":802,"address":[1943325],"length":1,"stats":{"Line":1}},{"line":805,"address":[1944194,1943349],"length":1,"stats":{"Line":2}},{"line":806,"address":[1943576,1943434,1945048],"length":1,"stats":{"Line":2}},{"line":808,"address":[1943405],"length":1,"stats":{"Line":1}},{"line":809,"address":[1943412],"length":1,"stats":{"Line":1}},{"line":810,"address":[1943419],"length":1,"stats":{"Line":1}},{"line":812,"address":[1943702],"length":1,"stats":{"Line":1}},{"line":813,"address":[1943741],"length":1,"stats":{"Line":1}},{"line":814,"address":[1943876,1943758],"length":1,"stats":{"Line":1}},{"line":815,"address":[1943934,1943790],"length":1,"stats":{"Line":2}},{"line":816,"address":[1943958],"length":1,"stats":{"Line":1}},{"line":821,"address":[1944089,1943635],"length":1,"stats":{"Line":0}},{"line":826,"address":[1943449,1943513],"length":1,"stats":{"Line":2}},{"line":827,"address":[1943456],"length":1,"stats":{"Line":3}},{"line":828,"address":[1974173],"length":1,"stats":{"Line":1}},{"line":830,"address":[1974164],"length":1,"stats":{"Line":1}},{"line":834,"address":[1974245],"length":1,"stats":{"Line":1}},{"line":835,"address":[1974281],"length":1,"stats":{"Line":1}},{"line":836,"address":[1974372,1974465,1974301],"length":1,"stats":{"Line":2}},{"line":837,"address":[1974379,1974523],"length":1,"stats":{"Line":2}},{"line":838,"address":[1974552],"length":1,"stats":{"Line":1}},{"line":839,"address":[1974601],"length":1,"stats":{"Line":1}},{"line":841,"address":[1974238],"length":1,"stats":{"Line":1}},{"line":844,"address":[1974231],"length":1,"stats":{"Line":0}},{"line":858,"address":[1944653,1944226,1944529,1944697],"length":1,"stats":{"Line":4}},{"line":859,"address":[1944761],"length":1,"stats":{"Line":1}},{"line":860,"address":[1945096],"length":1,"stats":{"Line":1}},{"line":865,"address":[1945128,1945490],"length":1,"stats":{"Line":2}},{"line":871,"address":[1945507],"length":1,"stats":{"Line":1}},{"line":872,"address":[1945254],"length":1,"stats":{"Line":1}},{"line":873,"address":[1945500],"length":1,"stats":{"Line":1}},{"line":875,"address":[1945289],"length":1,"stats":{"Line":1}},{"line":876,"address":[1945321,1945512],"length":1,"stats":{"Line":2}},{"line":878,"address":[1945400],"length":1,"stats":{"Line":1}},{"line":879,"address":[1945464,1945521],"length":1,"stats":{"Line":2}},{"line":880,"address":[1945921,1945565],"length":1,"stats":{"Line":2}},{"line":881,"address":[1945877],"length":1,"stats":{"Line":1}},{"line":882,"address":[1945914],"length":1,"stats":{"Line":1}},{"line":884,"address":[1945588,1945532],"length":1,"stats":{"Line":2}},{"line":888,"address":[1945680,1945862],"length":1,"stats":{"Line":2}},{"line":889,"address":[1945716],"length":1,"stats":{"Line":1}},{"line":891,"address":[1945697],"length":1,"stats":{"Line":1}},{"line":893,"address":[1945859],"length":1,"stats":{"Line":1}},{"line":901,"address":[1944819],"length":1,"stats":{"Line":1}},{"line":902,"address":[1974736],"length":1,"stats":{"Line":1}},{"line":903,"address":[1974785],"length":1,"stats":{"Line":1}},{"line":904,"address":[1974809,1975063],"length":1,"stats":{"Line":2}},{"line":905,"address":[1975141],"length":1,"stats":{"Line":1}},{"line":906,"address":[1975178],"length":1,"stats":{"Line":1}},{"line":910,"address":[1975261],"length":1,"stats":{"Line":1}},{"line":913,"address":[1975271],"length":1,"stats":{"Line":1}},{"line":914,"address":[1975298],"length":1,"stats":{"Line":1}},{"line":915,"address":[1975335],"length":1,"stats":{"Line":1}},{"line":916,"address":[1975374],"length":1,"stats":{"Line":1}},{"line":918,"address":[1975438],"length":1,"stats":{"Line":1}},{"line":925,"address":[1975661],"length":1,"stats":{"Line":1}},{"line":927,"address":[1974900],"length":1,"stats":{"Line":0}},{"line":928,"address":[1974974,1974932],"length":1,"stats":{"Line":0}},{"line":930,"address":[1974940],"length":1,"stats":{"Line":0}},{"line":932,"address":[1975049],"length":1,"stats":{"Line":0}},{"line":934,"address":[1975056],"length":1,"stats":{"Line":1}},{"line":939,"address":[1944844],"length":1,"stats":{"Line":1}},{"line":940,"address":[1975760,1977101],"length":1,"stats":{"Line":1}},{"line":941,"address":[1975809],"length":1,"stats":{"Line":1}},{"line":942,"address":[1975833,1976087,1976188],"length":1,"stats":{"Line":2}},{"line":944,"address":[1976195],"length":1,"stats":{"Line":1}},{"line":945,"address":[1976259],"length":1,"stats":{"Line":1}},{"line":947,"address":[1976285,1976936],"length":1,"stats":{"Line":2}},{"line":950,"address":[1976293],"length":1,"stats":{"Line":1}},{"line":952,"address":[1977077],"length":1,"stats":{"Line":1}},{"line":955,"address":[1976323],"length":1,"stats":{"Line":1}},{"line":957,"address":[1976360],"length":1,"stats":{"Line":1}},{"line":961,"address":[1976443],"length":1,"stats":{"Line":1}},{"line":964,"address":[1976453],"length":1,"stats":{"Line":1}},{"line":965,"address":[1976513],"length":1,"stats":{"Line":1}},{"line":966,"address":[1976539],"length":1,"stats":{"Line":1}},{"line":967,"address":[1976603],"length":1,"stats":{"Line":1}},{"line":969,"address":[1977172,1976635],"length":1,"stats":{"Line":2}},{"line":971,"address":[1976651],"length":1,"stats":{"Line":1}},{"line":972,"address":[1976653],"length":1,"stats":{"Line":1}},{"line":976,"address":[1977406],"length":1,"stats":{"Line":1}},{"line":979,"address":[1976693],"length":1,"stats":{"Line":0}},{"line":980,"address":[1976710],"length":1,"stats":{"Line":0}},{"line":981,"address":[1976727],"length":1,"stats":{"Line":0}},{"line":982,"address":[1976742],"length":1,"stats":{"Line":0}},{"line":983,"address":[1976757],"length":1,"stats":{"Line":0}},{"line":985,"address":[1976776],"length":1,"stats":{"Line":0}},{"line":993,"address":[1976872],"length":1,"stats":{"Line":0}},{"line":995,"address":[1975924],"length":1,"stats":{"Line":0}},{"line":996,"address":[1975956,1975998],"length":1,"stats":{"Line":0}},{"line":998,"address":[1975964],"length":1,"stats":{"Line":0}},{"line":1000,"address":[1976073],"length":1,"stats":{"Line":0}},{"line":1002,"address":[1976080],"length":1,"stats":{"Line":1}},{"line":1007,"address":[1944869],"length":1,"stats":{"Line":1}},{"line":1008,"address":[1978241,1977520,1978209],"length":1,"stats":{"Line":1}},{"line":1009,"address":[1977574],"length":1,"stats":{"Line":1}},{"line":1010,"address":[1977606],"length":1,"stats":{"Line":1}},{"line":1011,"address":[1977856],"length":1,"stats":{"Line":1}},{"line":1012,"address":[1977875,1978043],"length":1,"stats":{"Line":2}},{"line":1014,"address":[1977883],"length":1,"stats":{"Line":1}},{"line":1015,"address":[1977992],"length":1,"stats":{"Line":1}},{"line":1016,"address":[1978028],"length":1,"stats":{"Line":1}},{"line":1018,"address":[1978191],"length":1,"stats":{"Line":1}},{"line":1020,"address":[1977687],"length":1,"stats":{"Line":0}},{"line":1021,"address":[1977715,1977757],"length":1,"stats":{"Line":0}},{"line":1023,"address":[1977723],"length":1,"stats":{"Line":0}},{"line":1025,"address":[1977832],"length":1,"stats":{"Line":0}},{"line":1027,"address":[1977839],"length":1,"stats":{"Line":1}},{"line":1032,"address":[1944897],"length":1,"stats":{"Line":1}},{"line":1033,"address":[1979425,1978336],"length":1,"stats":{"Line":1}},{"line":1034,"address":[1978390],"length":1,"stats":{"Line":1}},{"line":1035,"address":[1978672,1978422,1978781],"length":1,"stats":{"Line":2}},{"line":1037,"address":[1978788],"length":1,"stats":{"Line":1}},{"line":1038,"address":[1978814],"length":1,"stats":{"Line":1}},{"line":1040,"address":[1978875,1979260],"length":1,"stats":{"Line":2}},{"line":1043,"address":[1978883],"length":1,"stats":{"Line":1}},{"line":1045,"address":[1979401],"length":1,"stats":{"Line":1}},{"line":1048,"address":[1978923],"length":1,"stats":{"Line":1}},{"line":1049,"address":[1978984],"length":1,"stats":{"Line":1}},{"line":1050,"address":[1979010],"length":1,"stats":{"Line":1}},{"line":1052,"address":[1979540,1979032],"length":1,"stats":{"Line":2}},{"line":1054,"address":[1979040],"length":1,"stats":{"Line":1}},{"line":1056,"address":[1979488],"length":1,"stats":{"Line":1}},{"line":1057,"address":[1979525],"length":1,"stats":{"Line":1}},{"line":1059,"address":[1979752],"length":1,"stats":{"Line":1}},{"line":1062,"address":[1979075],"length":1,"stats":{"Line":0}},{"line":1063,"address":[1979090],"length":1,"stats":{"Line":0}},{"line":1064,"address":[1979105],"length":1,"stats":{"Line":0}},{"line":1066,"address":[1979124],"length":1,"stats":{"Line":0}},{"line":1072,"address":[1979196],"length":1,"stats":{"Line":0}},{"line":1074,"address":[1978513],"length":1,"stats":{"Line":0}},{"line":1075,"address":[1978541,1978583],"length":1,"stats":{"Line":0}},{"line":1077,"address":[1978549],"length":1,"stats":{"Line":0}},{"line":1079,"address":[1978658],"length":1,"stats":{"Line":0}},{"line":1081,"address":[1978665],"length":1,"stats":{"Line":1}},{"line":1085,"address":[1944925],"length":1,"stats":{"Line":1}}],"covered":219,"coverable":299},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","endpoint_client.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{RequestCookie, Response, Session};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Endpoint Client\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"client received unexpected response: {0}\")]\n    UnexpectedResponseReceived(String),\n\n    #[error(\"client is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n}\n\npub(crate) enum EndpointClientEvent {\n    HandshakeCompleted { stream: TcpStream },\n}\n\n#[derive(Debug, PartialEq)]\nenum EndpointClientState {\n    BeginHandshake,\n    WaitingForServerCookie,\n    WaitingForProofVerification,\n    HandshakeComplete,\n}\n\npub(crate) struct EndpointClient {\n    // session data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    pub server_service_id: V3OnionServiceId,\n    pub requested_channel: AsciiString,\n    client_service_id: V3OnionServiceId,\n    client_ed25519_private: Ed25519PrivateKey,\n\n    // state machine data\n    state: EndpointClientState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n}\n\nimpl EndpointClient {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, send_response_request_cookie: {:?} }}\", self.state, self.begin_handshake_request_cookie, self.send_response_request_cookie)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        server_service_id: V3OnionServiceId,\n        requested_channel: AsciiString,\n        client_ed25519_private: Ed25519PrivateKey,\n    ) -\u003e Self {\n        Self {\n            rpc: Some(rpc),\n            server_service_id,\n            requested_channel,\n            client_service_id: V3OnionServiceId::from_private_key(\u0026client_ed25519_private),\n            client_ed25519_private,\n\n            state: EndpointClientState::BeginHandshake,\n            begin_handshake_request_cookie: None,\n            send_response_request_cookie: None,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cEndpointClientEvent\u003e, Error\u003e {\n        if self.state == EndpointClientState::HandshakeComplete {\n            return Err(Error::IncorrectUsage(\"update() may not be called after HandshakeComplete has been returned from previous update() call\".to_string()));\n        }\n\n        // update our rpc session\n        if let Some(rpc) = self.rpc.as_mut() {\n            rpc.update(None)?;\n\n            // client state machine\n            match (\n                \u0026self.state,\n                self.begin_handshake_request_cookie,\n                self.send_response_request_cookie,\n            ) {\n                (\u0026EndpointClientState::BeginHandshake, None, None) =\u003e {\n                    self.begin_handshake_request_cookie = Some(rpc.client_call(\n                        \"gosling_endpoint\",\n                        \"begin_handshake\",\n                        0,\n                        doc! {\n                            \"version\" : bson::Bson::String(GOSLING_PROTOCOL_VERSION.to_string()),\n                            \"client_identity\" : bson::Bson::String(self.client_service_id.to_string()),\n                            \"channel\" : bson::Bson::String(self.requested_channel.to_string()),\n                        },\n                    ).unwrap());\n                    self.state = EndpointClientState::WaitingForServerCookie;\n                    Ok(None)\n                }\n                (\n                    \u0026EndpointClientState::WaitingForServerCookie,\n                    Some(begin_handshake_request_cookie),\n                    None, // send_response_request_cookie\n                ) =\u003e {\n                    if let Some(response) = rpc.client_next_response() {\n                        let result = match response {\n                            Response::Pending { cookie } =\u003e {\n                                if cookie == begin_handshake_request_cookie {\n                                    return Ok(None);\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected pending response\".to_string(),\n                                    ));\n                                }\n                            }\n                            Response::Error { cookie, error_code } =\u003e {\n                                if cookie != begin_handshake_request_cookie {\n                                    return Err(Error::UnexpectedResponseReceived(format!(\n                                        \"received unexpected error response; rpc error_code: {}\",\n                                        error_code\n                                    )));\n                                }\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            Response::Success { cookie, result } =\u003e {\n                                if cookie == begin_handshake_request_cookie {\n                                    result\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected success response\".to_string(),\n                                    ));\n                                }\n                            }\n                        };\n\n                        if let Some(bson::Bson::Document(result)) = result {\n                            if let Some(Bson::Binary(Binary {\n                                subtype: BinarySubtype::Generic,\n                                bytes: server_cookie,\n                            })) = result.get(\"server_cookie\")\n                            {\n                                // build arguments for send_response()\n\n                                // client_cookie\n                                let mut client_cookie: ClientCookie = Default::default();\n                                OsRng.fill_bytes(\u0026mut client_cookie);\n\n                                // client_identity_proof_signature\n                                let server_cookie: ServerCookie =\n                                    match server_cookie.clone().try_into() {\n                                        Ok(server_cookie) =\u003e server_cookie,\n                                        Err(_) =\u003e {\n                                            return Err(Error::UnexpectedResponseReceived(format!(\n                                                \"unable to convert '{:?}' to server cookie\",\n                                                server_cookie\n                                            )))\n                                        }\n                                    };\n                                let client_identity_proof = build_client_proof(\n                                    DomainSeparator::GoslingEndpoint,\n                                    \u0026self.requested_channel,\n                                    \u0026self.client_service_id,\n                                    \u0026self.server_service_id,\n                                    \u0026client_cookie,\n                                    \u0026server_cookie,\n                                );\n                                let client_identity_proof_signature = self\n                                    .client_ed25519_private\n                                    .sign_message(\u0026client_identity_proof);\n\n                                // build our args object for rpc call\n                                let args = doc! {\n                                    \"client_cookie\" : Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_cookie.to_vec()}),\n                                    \"client_identity_proof_signature\" : Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}),\n                                };\n\n                                // make rpc call\n                                self.send_response_request_cookie = Some(\n                                    rpc.client_call(\"gosling_endpoint\", \"send_response\", 0, args)\n                                        .unwrap(),\n                                );\n\n                                self.state = EndpointClientState::WaitingForProofVerification;\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"begin_handshake() returned unexpected value: {}\",\n                                    result\n                                )));\n                            }\n                        } else {\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"begin_handshake() returned unexpected value: {:?}\",\n                                result\n                            )));\n                        }\n                    }\n                    Ok(None)\n                }\n                (\n                    \u0026EndpointClientState::WaitingForProofVerification,\n                    Some(_begin_handshake_request_cookie),\n                    Some(send_response_request_cookie),\n                ) =\u003e {\n                    if let Some(response) = rpc.client_next_response() {\n                        let result = match response {\n                            Response::Pending { cookie } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    return Ok(None);\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected pending response\".to_string(),\n                                    ));\n                                }\n                            }\n                            Response::Error { cookie, error_code } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    return Err(Error::UnexpectedResponseReceived(format!(\n                                        \"received unexpected error response; rpc error_code: {}\",\n                                        error_code\n                                    )));\n                                }\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            Response::Success { cookie, result } =\u003e {\n                                if cookie == send_response_request_cookie {\n                                    result\n                                } else {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"received unexpected success response\".to_string(),\n                                    ));\n                                }\n                            }\n                        };\n\n                        if let Some(Bson::Document(result)) = result {\n                            if result.is_empty() {\n                                self.state = EndpointClientState::HandshakeComplete;\n                                let stream = std::mem::take(\u0026mut self.rpc).unwrap().into_stream();\n                                return Ok(Some(EndpointClientEvent::HandshakeCompleted {\n                                    stream,\n                                }));\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected data from send_response(): {:?}\",\n                                    result\n                                )));\n                            }\n                        } else {\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"received unexpected data from send_response(): {:?}\",\n                                result\n                            )));\n                        }\n                    }\n                    Ok(None)\n                }\n                _ =\u003e Err(Error::InvalidState(self.get_state())),\n            }\n        } else {\n            Err(Error::InvalidState(self.get_state()))\n        }\n    }\n}\n","traces":[{"line":65,"address":[2022736],"length":1,"stats":{"Line":0}},{"line":66,"address":[2022919,2023001,2022760],"length":1,"stats":{"Line":0}},{"line":69,"address":[2023572,2023613,2023136],"length":1,"stats":{"Line":2}},{"line":76,"address":[2023185],"length":1,"stats":{"Line":2}},{"line":79,"address":[2023220],"length":1,"stats":{"Line":2}},{"line":88,"address":[2025651,2023632],"length":1,"stats":{"Line":2}},{"line":89,"address":[2023712],"length":1,"stats":{"Line":2}},{"line":90,"address":[2023819],"length":1,"stats":{"Line":0}},{"line":94,"address":[2023767,2023941,2024182],"length":1,"stats":{"Line":4}},{"line":95,"address":[2023704,2023965,2024303],"length":1,"stats":{"Line":4}},{"line":98,"address":[2024220,2025681,2024532,2030580,2024365],"length":1,"stats":{"Line":10}},{"line":99,"address":[2024195],"length":1,"stats":{"Line":2}},{"line":100,"address":[2024205],"length":1,"stats":{"Line":2}},{"line":101,"address":[2024212],"length":1,"stats":{"Line":2}},{"line":104,"address":[2025187,2025537],"length":1,"stats":{"Line":4}},{"line":108,"address":[2024869,2025053,2024591,2024685,2024547],"length":1,"stats":{"Line":8}},{"line":109,"address":[2024564,2024635],"length":1,"stats":{"Line":4}},{"line":110,"address":[2024793],"length":1,"stats":{"Line":2}},{"line":111,"address":[2024977],"length":1,"stats":{"Line":2}},{"line":114,"address":[2025580],"length":1,"stats":{"Line":2}},{"line":115,"address":[2025601],"length":1,"stats":{"Line":2}},{"line":117,"address":[2025704],"length":1,"stats":{"Line":2}},{"line":122,"address":[2025728,2029053],"length":1,"stats":{"Line":4}},{"line":123,"address":[2025925],"length":1,"stats":{"Line":2}},{"line":124,"address":[2026044],"length":1,"stats":{"Line":2}},{"line":125,"address":[2026060],"length":1,"stats":{"Line":2}},{"line":126,"address":[2026341],"length":1,"stats":{"Line":2}},{"line":128,"address":[2026247],"length":1,"stats":{"Line":0}},{"line":129,"address":[2026214],"length":1,"stats":{"Line":0}},{"line":133,"address":[2026156],"length":1,"stats":{"Line":0}},{"line":134,"address":[2026200],"length":1,"stats":{"Line":0}},{"line":135,"address":[2030320],"length":1,"stats":{"Line":0}},{"line":140,"address":[2030047],"length":1,"stats":{"Line":0}},{"line":145,"address":[2026074],"length":1,"stats":{"Line":2}},{"line":146,"address":[2026134],"length":1,"stats":{"Line":2}},{"line":147,"address":[2026423],"length":1,"stats":{"Line":2}},{"line":149,"address":[2026553],"length":1,"stats":{"Line":0}},{"line":150,"address":[2026396],"length":1,"stats":{"Line":0}},{"line":156,"address":[2026457,2026795,2026656],"length":1,"stats":{"Line":6}},{"line":157,"address":[2027163,2026992],"length":1,"stats":{"Line":4}},{"line":159,"address":[2027181],"length":1,"stats":{"Line":2}},{"line":165,"address":[2027201],"length":1,"stats":{"Line":2}},{"line":166,"address":[2027220],"length":1,"stats":{"Line":2}},{"line":169,"address":[2027252],"length":1,"stats":{"Line":2}},{"line":171,"address":[2027324],"length":1,"stats":{"Line":2}},{"line":173,"address":[2029118],"length":1,"stats":{"Line":0}},{"line":180,"address":[2027514],"length":1,"stats":{"Line":2}},{"line":181,"address":[2027522],"length":1,"stats":{"Line":2}},{"line":182,"address":[2027532],"length":1,"stats":{"Line":2}},{"line":183,"address":[2027542],"length":1,"stats":{"Line":2}},{"line":187,"address":[2027605,2027724],"length":1,"stats":{"Line":4}},{"line":189,"address":[2027616],"length":1,"stats":{"Line":2}},{"line":192,"address":[2028233,2027802,2027956,2027743],"length":1,"stats":{"Line":6}},{"line":193,"address":[2027762,2027846],"length":1,"stats":{"Line":4}},{"line":194,"address":[2028056],"length":1,"stats":{"Line":2}},{"line":198,"address":[2028801],"length":1,"stats":{"Line":2}},{"line":199,"address":[2028437],"length":1,"stats":{"Line":2}},{"line":203,"address":[2028845],"length":1,"stats":{"Line":2}},{"line":205,"address":[2029373],"length":1,"stats":{"Line":0}},{"line":211,"address":[2029587],"length":1,"stats":{"Line":0}},{"line":217,"address":[2030525],"length":1,"stats":{"Line":2}},{"line":219,"address":[2030603],"length":1,"stats":{"Line":2}},{"line":224,"address":[2030640],"length":1,"stats":{"Line":2}},{"line":225,"address":[2030821],"length":1,"stats":{"Line":2}},{"line":226,"address":[2030954],"length":1,"stats":{"Line":0}},{"line":227,"address":[2030970],"length":1,"stats":{"Line":0}},{"line":228,"address":[2031245],"length":1,"stats":{"Line":0}},{"line":230,"address":[2031151],"length":1,"stats":{"Line":0}},{"line":231,"address":[2031118],"length":1,"stats":{"Line":0}},{"line":235,"address":[2031060],"length":1,"stats":{"Line":1}},{"line":236,"address":[2031104],"length":1,"stats":{"Line":1}},{"line":237,"address":[2033208],"length":1,"stats":{"Line":1}},{"line":242,"address":[2032935],"length":1,"stats":{"Line":0}},{"line":247,"address":[2030984],"length":1,"stats":{"Line":2}},{"line":248,"address":[2031041],"length":1,"stats":{"Line":2}},{"line":249,"address":[2031319],"length":1,"stats":{"Line":2}},{"line":251,"address":[2031449],"length":1,"stats":{"Line":0}},{"line":252,"address":[2031292],"length":1,"stats":{"Line":0}},{"line":258,"address":[2031552,2031691,2031353],"length":1,"stats":{"Line":6}},{"line":259,"address":[2031866,2031795],"length":1,"stats":{"Line":4}},{"line":260,"address":[2031976],"length":1,"stats":{"Line":2}},{"line":261,"address":[2031997,2032274],"length":1,"stats":{"Line":4}},{"line":262,"address":[2032316],"length":1,"stats":{"Line":2}},{"line":266,"address":[2032023],"length":1,"stats":{"Line":0}},{"line":272,"address":[2032475],"length":1,"stats":{"Line":0}},{"line":278,"address":[2030910],"length":1,"stats":{"Line":2}},{"line":280,"address":[2024422],"length":1,"stats":{"Line":0}},{"line":283,"address":[2024077],"length":1,"stats":{"Line":0}}],"covered":62,"coverable":88},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","endpoint_server.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{ApiSet, ErrorCode, RequestCookie, Session};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Endpoint Server\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"server is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"client sent invalid request\")]\n    BadClient,\n}\n\npub(crate) enum EndpointServerEvent {\n    ChannelRequestReceived {\n        client_service_id: V3OnionServiceId,\n        requested_channel: AsciiString,\n    },\n    // endpoint server has acepted incoming channel request from identity client\n    HandshakeCompleted {\n        client_service_id: V3OnionServiceId,\n        channel_name: AsciiString,\n        stream: TcpStream,\n    },\n    // endpoint server has reject an incoming channel request\n    HandshakeRejected {\n        client_allowed: bool,\n        client_requested_channel_valid: bool,\n        client_proof_signature_valid: bool,\n    },\n}\n\n#[derive(Debug, PartialEq)]\nenum EndpointServerState {\n    // valid/expected states\n    WaitingForBeginHandshake,\n    ValidatingChannelRequest,\n    ChannelRequestValidated,\n    WaitingForSendResponse,\n    HandledSendResponse,\n    HandshakeComplete,\n    // failure state\n    HandshakeFailed,\n}\n\npub(crate) struct EndpointServer {\n    // Session Data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    pub server_identity: V3OnionServiceId,\n    allowed_client_identity: V3OnionServiceId,\n\n    // State Machine Data\n    state: EndpointServerState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    client_identity: Option\u003cV3OnionServiceId\u003e,\n    requested_channel: Option\u003cAsciiString\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    handshake_succeeded: Option\u003cbool\u003e,\n\n    // Verification flags\n\n    // Client not on the block-list\n    client_allowed: bool,\n    // The requested endpoint is valid\n    client_requested_channel_valid: bool,\n    // The client proof is valid and signed with client's public key\n    client_proof_signature_valid: bool,\n}\n\nimpl EndpointServer {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, client_identity: {:?}, requested_channel: {:?}, server_cookie: {:?}, handshake_succeeded:{:?} }}\", self.state, self.begin_handshake_request_cookie, self.client_identity, self.requested_channel, self.server_cookie, self.handshake_succeeded)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        client_identity: V3OnionServiceId,\n        server_identity: V3OnionServiceId,\n    ) -\u003e Self {\n        // generate server cookie\n        let mut server_cookie: ServerCookie = Default::default();\n        OsRng.fill_bytes(\u0026mut server_cookie);\n\n        EndpointServer {\n            rpc: Some(rpc),\n            server_identity,\n            allowed_client_identity: client_identity,\n            state: EndpointServerState::WaitingForBeginHandshake,\n            begin_handshake_request_cookie: None,\n            requested_channel: None,\n            client_identity: None,\n            server_cookie: None,\n            handshake_succeeded: None,\n            client_allowed: false,\n            // TODO: hookup this to event and callback\n            client_requested_channel_valid: true,\n            client_proof_signature_valid: false,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cEndpointServerEvent\u003e, Error\u003e {\n        if let Some(mut rpc) = std::mem::take(\u0026mut self.rpc) {\n            match rpc.update(Some(\u0026mut [self])) {\n                Ok(()) =\u003e {\n                    self.rpc = Some(rpc);\n                }\n                Err(err) =\u003e {\n                    self.rpc = Some(rpc);\n                    return Err(err.into());\n                }\n            }\n        }\n\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_channel.as_ref(),\n              self.server_cookie.as_ref(),\n              self.handshake_succeeded) {\n            (\u0026EndpointServerState::WaitingForBeginHandshake,\n             None, // begin_handshake_request_cookie\n             None, // client_identity\n             None, // requested_channel\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::WaitingForBeginHandshake,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {\n                self.state = EndpointServerState::ValidatingChannelRequest;\n                return Ok(\n                        Some(\n                            EndpointServerEvent::ChannelRequestReceived\n                            {\n                                client_service_id: client_identity.clone(),\n                                requested_channel: requested_channel.clone()\n                            }));\n            },\n            (\u0026EndpointServerState::ValidatingChannelRequest,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::ChannelRequestValidated,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             Some(_server_cookie),\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_channel),\n             Some(_server_cookie),\n             None) // handshake_succeeded\n            =\u003e {},\n            (\u0026EndpointServerState::HandledSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_channel),\n             Some(_server_cookie),\n             Some(handshake_succeeded))\n            =\u003e {\n                self.state = EndpointServerState::HandshakeComplete;\n                if handshake_succeeded {\n                    let stream = std::mem::take(\u0026mut self.rpc).unwrap().into_stream();\n                    return Ok(Some(EndpointServerEvent::HandshakeCompleted{\n                        client_service_id: client_identity.clone(),\n                        channel_name: requested_channel.clone(),\n                        stream}));\n                } else {\n                    return Ok(Some(EndpointServerEvent::HandshakeRejected{\n                        client_allowed: self.client_allowed,\n                        client_requested_channel_valid: self.client_requested_channel_valid,\n                        client_proof_signature_valid: self.client_proof_signature_valid}));\n                }\n            },\n            _ =\u003e {\n                if self.state == EndpointServerState::HandshakeFailed {\n                    return Err(Error::BadClient);\n                } else {\n                    return Err(Error::InvalidState(self.get_state()));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    pub fn handle_channel_request_received(\n        \u0026mut self,\n        client_requested_channel_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_channel.as_ref(),\n              self.server_cookie.as_ref(),\n              self.handshake_succeeded) {\n            (\u0026EndpointServerState::ValidatingChannelRequest,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(_requested_channel),\n             None, // server_cookie\n             None) // handshake_succeeded\n            =\u003e {\n                let mut server_cookie: ServerCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut server_cookie);\n                self.server_cookie = Some(server_cookie);\n                self.client_allowed = *client_identity == self.allowed_client_identity;\n                self.client_requested_channel_valid = client_requested_channel_valid;\n                self.state = EndpointServerState::ChannelRequestValidated;\n                Ok(())\n            },\n            _ =\u003e Err(Error::IncorrectUsage(\"handle_channel_request_received() may only be called after ChannelRequestReceived has been returned from update(), and it may only be called once\".to_string()))\n        }\n    }\n}\n\nimpl ApiSet for EndpointServer {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"gosling_endpoint\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        let request_cookie = match request_cookie {\n            Some(request_cookie) =\u003e request_cookie,\n            None =\u003e {\n                return Some(Err(ErrorCode::Runtime(\n                    RpcError::RequestCookieRequired as i32,\n                )))\n            }\n        };\n\n        match\n            (name, version,\n             \u0026self.state,\n             self.client_identity.as_ref(),\n             self.requested_channel.as_ref(),\n             self.server_cookie.as_ref()) {\n            // handle begin_handshake call\n            (\"begin_handshake\", 0,\n            \u0026EndpointServerState::WaitingForBeginHandshake,\n            None, // client_identity\n            None, // requested_channel\n            None) // server_cookie\n            =\u003e {\n                let valid_version = match args.remove(\"version\") {\n                    Some(Bson::String(value)) =\u003e value == GOSLING_PROTOCOL_VERSION,\n                    _ =\u003e false,\n                };\n                if !valid_version {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    return Some(Err(ErrorCode::Runtime(RpcError::BadVersion as i32)));\n                }\n\n                if let (\n                    Some(Bson::String(client_identity)),\n                    Some(Bson::String(channel_name))\n                ) = (\n                    args.remove(\"client_identity\"),\n                    args.remove(\"channel\")\n                ) {\n                    // client_identiity\n                    self.client_identity = match V3OnionServiceId::from_string(\u0026client_identity) {\n                        Ok(client_identity) =\u003e Some(client_identity),\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n\n                    let channel_name = match AsciiString::new(channel_name) {\n                        Ok(channel_name) =\u003e channel_name,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n\n                    // save cookie\n                    self.begin_handshake_request_cookie = Some(request_cookie);\n\n                    // save channel name\n                    self.requested_channel = Some(channel_name);\n\n                    None\n                } else {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)))\n                }\n            },\n            (\"send_response\", 0,\n            \u0026EndpointServerState::WaitingForSendResponse,\n            Some(client_identity),\n            Some(requested_channel),\n            Some(server_cookie))\n            =\u003e {\n                if let (Some(Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: client_cookie})),\n                        Some(Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature}))) =\n                       (args.remove(\"client_cookie\"),\n                        args.remove(\"client_identity_proof_signature\")) {\n                    // client_cookie\n                    let client_cookie : ClientCookie = match client_cookie.try_into() {\n                        Ok(client_cookie) =\u003e client_cookie,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n\n                    // client_identity_proof_signature\n                    let client_identity_proof_signature : [u8; ED25519_SIGNATURE_SIZE] = match client_identity_proof_signature.try_into() {\n                        Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n                    let client_identity_proof_signature = match Ed25519Signature::from_raw(\u0026client_identity_proof_signature) {\n                        Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n\n                    // convert client_identity to client's public ed25519 key\n                    let client_identity_key = match Ed25519PublicKey::from_service_id(client_identity) {\n                        Ok(client_identity_key) =\u003e client_identity_key,\n                        Err(_) =\u003e {\n                            self.state = EndpointServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n\n                    // construct + verify client proof\n                    let client_proof = build_client_proof(\n                        DomainSeparator::GoslingEndpoint,\n                        requested_channel,\n                        client_identity,\n                        \u0026self.server_identity,\n                        \u0026client_cookie,\n                        server_cookie,\n                    );\n                    self.client_proof_signature_valid =\n                        client_identity_proof_signature.verify(\u0026client_proof, \u0026client_identity_key);\n\n                    if self.client_allowed\n                        \u0026\u0026 self.client_requested_channel_valid\n                        \u0026\u0026 self.client_proof_signature_valid\n                    {\n                        self.handshake_succeeded = Some(true);\n                        self.state = EndpointServerState::HandledSendResponse;\n                        // success, return empty doc\n                        Some(Ok(Some(Bson::Document(doc! {}))))\n                    } else {\n                        self.handshake_succeeded = Some(false);\n                        self.state = EndpointServerState::HandledSendResponse;\n                        Some(Err(ErrorCode::Runtime(RpcError::Failure as i32)))\n                    }\n                } else {\n                    self.state = EndpointServerState::HandshakeFailed;\n                    Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)))\n                }\n            },\n            _ =\u003e {\n                self.state = EndpointServerState::HandshakeFailed;\n                Some(Err(ErrorCode::Runtime(RpcError::Failure as i32)))\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e)\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie.as_ref(),\n        ) {\n            (\n                \u0026EndpointServerState::ChannelRequestValidated,\n                Some(begin_handshake_request_cookie),\n                Some(server_cookie),\n            ) =\u003e {\n                self.state = EndpointServerState::WaitingForSendResponse;\n                Some((\n                    begin_handshake_request_cookie,\n                    Ok(Some(Bson::Document(doc! {\n                        \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                    }))),\n                ))\n            }\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":95,"address":[2496240],"length":1,"stats":{"Line":0}},{"line":96,"address":[2496690,2496775,2496429,2496516,2496603,2496264],"length":1,"stats":{"Line":0}},{"line":99,"address":[2497008,2497502],"length":1,"stats":{"Line":2}},{"line":105,"address":[2497040],"length":1,"stats":{"Line":2}},{"line":106,"address":[2497097],"length":1,"stats":{"Line":2}},{"line":109,"address":[2497128],"length":1,"stats":{"Line":2}},{"line":125,"address":[2498744,2497536],"length":1,"stats":{"Line":2}},{"line":126,"address":[2497587],"length":1,"stats":{"Line":2}},{"line":127,"address":[2497899,2497737],"length":1,"stats":{"Line":4}},{"line":129,"address":[2497934,2498282],"length":1,"stats":{"Line":2}},{"line":131,"address":[2498050],"length":1,"stats":{"Line":0}},{"line":132,"address":[2498170,2498382],"length":1,"stats":{"Line":0}},{"line":133,"address":[2498465,2498664],"length":1,"stats":{"Line":0}},{"line":138,"address":[2499441,2500008,2499827,2498815,2500402,2498962,2499119,2500205],"length":1,"stats":{"Line":12}},{"line":139,"address":[2498829],"length":1,"stats":{"Line":2}},{"line":140,"address":[2498846],"length":1,"stats":{"Line":2}},{"line":141,"address":[2498875],"length":1,"stats":{"Line":2}},{"line":142,"address":[2498904],"length":1,"stats":{"Line":2}},{"line":143,"address":[2498956],"length":1,"stats":{"Line":2}},{"line":151,"address":[2499576],"length":1,"stats":{"Line":2}},{"line":158,"address":[2499597],"length":1,"stats":{"Line":2}},{"line":159,"address":[2499779],"length":1,"stats":{"Line":2}},{"line":160,"address":[2499745],"length":1,"stats":{"Line":2}},{"line":161,"address":[2499649],"length":1,"stats":{"Line":2}},{"line":163,"address":[2499618],"length":1,"stats":{"Line":2}},{"line":164,"address":[2499636],"length":1,"stats":{"Line":2}},{"line":167,"address":[2499955],"length":1,"stats":{"Line":0}},{"line":173,"address":[2500003],"length":1,"stats":{"Line":0}},{"line":174,"address":[2500136],"length":1,"stats":{"Line":0}},{"line":180,"address":[2500200],"length":1,"stats":{"Line":0}},{"line":181,"address":[2500365],"length":1,"stats":{"Line":2}},{"line":187,"address":[2500397],"length":1,"stats":{"Line":2}},{"line":188,"address":[2500612],"length":1,"stats":{"Line":2}},{"line":195,"address":[2500631],"length":1,"stats":{"Line":2}},{"line":196,"address":[2500652],"length":1,"stats":{"Line":2}},{"line":197,"address":[2500915,2500823],"length":1,"stats":{"Line":4}},{"line":198,"address":[2501026],"length":1,"stats":{"Line":2}},{"line":199,"address":[2500944],"length":1,"stats":{"Line":2}},{"line":200,"address":[2501008],"length":1,"stats":{"Line":2}},{"line":201,"address":[2501015],"length":1,"stats":{"Line":2}},{"line":203,"address":[2500686],"length":1,"stats":{"Line":1}},{"line":204,"address":[2500668],"length":1,"stats":{"Line":1}},{"line":205,"address":[2500674],"length":1,"stats":{"Line":1}},{"line":206,"address":[2500680],"length":1,"stats":{"Line":1}},{"line":210,"address":[2499087],"length":1,"stats":{"Line":0}},{"line":211,"address":[2501323],"length":1,"stats":{"Line":0}},{"line":213,"address":[2501205],"length":1,"stats":{"Line":0}},{"line":218,"address":[2499375],"length":1,"stats":{"Line":2}},{"line":221,"address":[2501376],"length":1,"stats":{"Line":2}},{"line":225,"address":[2501740,2501559,2501429],"length":1,"stats":{"Line":6}},{"line":226,"address":[2501444],"length":1,"stats":{"Line":2}},{"line":227,"address":[2501461],"length":1,"stats":{"Line":2}},{"line":228,"address":[2501484],"length":1,"stats":{"Line":2}},{"line":229,"address":[2501507],"length":1,"stats":{"Line":2}},{"line":230,"address":[2501553],"length":1,"stats":{"Line":2}},{"line":231,"address":[2501893],"length":1,"stats":{"Line":2}},{"line":238,"address":[2501906],"length":1,"stats":{"Line":2}},{"line":239,"address":[2501920],"length":1,"stats":{"Line":2}},{"line":240,"address":[2501952],"length":1,"stats":{"Line":2}},{"line":241,"address":[2502123],"length":1,"stats":{"Line":2}},{"line":242,"address":[2502163],"length":1,"stats":{"Line":2}},{"line":243,"address":[2502172],"length":1,"stats":{"Line":2}},{"line":244,"address":[2502193],"length":1,"stats":{"Line":2}},{"line":246,"address":[2501621],"length":1,"stats":{"Line":0}},{"line":252,"address":[2502224],"length":1,"stats":{"Line":2}},{"line":256,"address":[2502256,2511005,2506059],"length":1,"stats":{"Line":2}},{"line":263,"address":[2502398],"length":1,"stats":{"Line":2}},{"line":264,"address":[2502577],"length":1,"stats":{"Line":2}},{"line":266,"address":[2502481],"length":1,"stats":{"Line":0}},{"line":272,"address":[2507216,2503141,2502958,2503116,2507249,2507282,2503240,2503207,2503174,2507183],"length":1,"stats":{"Line":20}},{"line":273,"address":[2503130,2502815,2507226,2503217,2503151,2507259,2503184,2507172,2507193],"length":1,"stats":{"Line":18}},{"line":274,"address":[2502598],"length":1,"stats":{"Line":2}},{"line":275,"address":[2502615],"length":1,"stats":{"Line":2}},{"line":276,"address":[2502712],"length":1,"stats":{"Line":2}},{"line":277,"address":[2502743],"length":1,"stats":{"Line":2}},{"line":279,"address":[2502870],"length":1,"stats":{"Line":2}},{"line":285,"address":[2507300],"length":1,"stats":{"Line":2}},{"line":286,"address":[2507427],"length":1,"stats":{"Line":2}},{"line":287,"address":[2507414],"length":1,"stats":{"Line":0}},{"line":289,"address":[2507781],"length":1,"stats":{"Line":2}},{"line":290,"address":[2507863],"length":1,"stats":{"Line":0}},{"line":291,"address":[2507884],"length":1,"stats":{"Line":0}},{"line":294,"address":[2508097],"length":1,"stats":{"Line":2}},{"line":295,"address":[2508459],"length":1,"stats":{"Line":2}},{"line":296,"address":[2508499],"length":1,"stats":{"Line":2}},{"line":298,"address":[2507983],"length":1,"stats":{"Line":2}},{"line":299,"address":[2508022],"length":1,"stats":{"Line":2}},{"line":302,"address":[2508555,2508623,2508808],"length":1,"stats":{"Line":6}},{"line":303,"address":[2508672],"length":1,"stats":{"Line":2}},{"line":305,"address":[2508906],"length":1,"stats":{"Line":0}},{"line":306,"address":[2508927],"length":1,"stats":{"Line":0}},{"line":310,"address":[2509040],"length":1,"stats":{"Line":2}},{"line":311,"address":[2509114],"length":1,"stats":{"Line":2}},{"line":313,"address":[2509254],"length":1,"stats":{"Line":0}},{"line":314,"address":[2509275],"length":1,"stats":{"Line":0}},{"line":319,"address":[2509394],"length":1,"stats":{"Line":2}},{"line":322,"address":[2509437,2509601],"length":1,"stats":{"Line":2}},{"line":324,"address":[2509726],"length":1,"stats":{"Line":2}},{"line":326,"address":[2508259],"length":1,"stats":{"Line":0}},{"line":327,"address":[2508280],"length":1,"stats":{"Line":0}},{"line":330,"address":[2503258],"length":1,"stats":{"Line":2}},{"line":336,"address":[2503435,2503321],"length":1,"stats":{"Line":4}},{"line":339,"address":[2503360],"length":1,"stats":{"Line":2}},{"line":341,"address":[2503989,2503921],"length":1,"stats":{"Line":4}},{"line":342,"address":[2504007],"length":1,"stats":{"Line":2}},{"line":344,"address":[2504109],"length":1,"stats":{"Line":0}},{"line":345,"address":[2504130],"length":1,"stats":{"Line":0}},{"line":350,"address":[2504303],"length":1,"stats":{"Line":2}},{"line":351,"address":[2504392],"length":1,"stats":{"Line":2}},{"line":353,"address":[2504558],"length":1,"stats":{"Line":0}},{"line":354,"address":[2504579],"length":1,"stats":{"Line":0}},{"line":357,"address":[2504752],"length":1,"stats":{"Line":2}},{"line":358,"address":[2504801],"length":1,"stats":{"Line":2}},{"line":360,"address":[2504967],"length":1,"stats":{"Line":0}},{"line":361,"address":[2504988],"length":1,"stats":{"Line":0}},{"line":366,"address":[2505106],"length":1,"stats":{"Line":2}},{"line":367,"address":[2505136],"length":1,"stats":{"Line":2}},{"line":369,"address":[2505244],"length":1,"stats":{"Line":0}},{"line":370,"address":[2505265],"length":1,"stats":{"Line":0}},{"line":376,"address":[2505394],"length":1,"stats":{"Line":2}},{"line":379,"address":[2505402],"length":1,"stats":{"Line":2}},{"line":383,"address":[2505575],"length":1,"stats":{"Line":2}},{"line":384,"address":[2505532,2505449],"length":1,"stats":{"Line":4}},{"line":386,"address":[2506002,2505741,2505584],"length":1,"stats":{"Line":5}},{"line":387,"address":[2505751],"length":1,"stats":{"Line":2}},{"line":388,"address":[2505772],"length":1,"stats":{"Line":2}},{"line":390,"address":[2505793],"length":1,"stats":{"Line":2}},{"line":391,"address":[2505814],"length":1,"stats":{"Line":2}},{"line":393,"address":[2505835,2505876],"length":1,"stats":{"Line":4}},{"line":395,"address":[2505613],"length":1,"stats":{"Line":1}},{"line":396,"address":[2505634],"length":1,"stats":{"Line":1}},{"line":397,"address":[2505655],"length":1,"stats":{"Line":1}},{"line":400,"address":[2503597],"length":1,"stats":{"Line":0}},{"line":401,"address":[2503618],"length":1,"stats":{"Line":0}},{"line":405,"address":[2503004],"length":1,"stats":{"Line":0}},{"line":406,"address":[2503025],"length":1,"stats":{"Line":0}},{"line":411,"address":[2511024,2511772],"length":1,"stats":{"Line":2}},{"line":412,"address":[2511188,2511122],"length":1,"stats":{"Line":4}},{"line":413,"address":[2511062],"length":1,"stats":{"Line":2}},{"line":414,"address":[2511077],"length":1,"stats":{"Line":2}},{"line":415,"address":[2511094],"length":1,"stats":{"Line":2}},{"line":417,"address":[2511236],"length":1,"stats":{"Line":2}},{"line":422,"address":[2511254],"length":1,"stats":{"Line":2}},{"line":423,"address":[2511707],"length":1,"stats":{"Line":2}},{"line":425,"address":[2511477,2511269,2511323],"length":1,"stats":{"Line":4}},{"line":426,"address":[2511291,2511367],"length":1,"stats":{"Line":4}},{"line":430,"address":[2511169],"length":1,"stats":{"Line":2}}],"covered":112,"coverable":147},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","gosling.rs"],"content":"// standard\n#[cfg(test)]\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// extern crates\n#[cfg(test)]\nuse bson::doc;\nuse data_encoding::HEXLOWER;\n#[cfg(test)]\nuse honk_rpc::honk_rpc::Session;\nuse num_enum::TryFromPrimitive;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\n#[cfg(test)]\nuse crate::endpoint_client::*;\n#[cfg(test)]\nuse crate::endpoint_server::*;\n#[cfg(test)]\nuse crate::identity_client::*;\n#[cfg(test)]\nuse crate::identity_server::*;\n\n#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]\n#[repr(i32)]\n/// cbindgen:ignore\npub(crate) enum RpcError {\n    // bad gosling version\n    BadVersion,\n    // cookie required\n    RequestCookieRequired,\n    // invalid or missing arguments\n    InvalidArg,\n    // generic runtime error\n    Failure,\n}\n\npub(crate) const GOSLING_PROTOCOL_VERSION: \u0026str = \"0.1.0\";\n\npub(crate) const CLIENT_COOKIE_SIZE: usize = 32usize;\npub(crate) const SERVER_COOKIE_SIZE: usize = 32usize;\n\npub(crate) type ClientCookie = [u8; CLIENT_COOKIE_SIZE];\npub(crate) type ServerCookie = [u8; SERVER_COOKIE_SIZE];\npub(crate) type ClientProof = Vec\u003cu8\u003e;\n\npub(crate) enum DomainSeparator {\n    GoslingIdentity,\n    GoslingEndpoint,\n}\n\nimpl From\u003cDomainSeparator\u003e for \u0026[u8] {\n    fn from(sep: DomainSeparator) -\u003e \u0026'static [u8] {\n        match sep {\n            DomainSeparator::GoslingIdentity =\u003e b\"gosling-identity\",\n            DomainSeparator::GoslingEndpoint =\u003e b\"gosling-endpoint\",\n        }\n    }\n}\n\npub(crate) fn build_client_proof(\n    domain_separator: DomainSeparator,\n    request: \u0026AsciiString,\n    client_service_id: \u0026V3OnionServiceId,\n    server_service_id: \u0026V3OnionServiceId,\n    client_cookie: \u0026ClientCookie,\n    server_cookie: \u0026ServerCookie,\n) -\u003e ClientProof {\n    let mut client_proof: ClientProof = Default::default();\n\n    client_proof.extend_from_slice(domain_separator.into());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(request.as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(client_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(server_service_id.to_string().as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(client_cookie).as_bytes());\n    client_proof.push(0u8);\n    client_proof.extend_from_slice(HEXLOWER.encode(server_cookie).as_bytes());\n\n    client_proof\n}\n\n//\n// Tests\n//\n\n#[cfg(test)]\nfn identity_test(\n    client_blocked: bool,\n    client_requested_endpoint: \u0026str,\n    client_requested_endpoint_valid: bool,\n    server_challenge: bson::document::Document,\n    client_response: bson::document::Document,\n    server_expected_response: bson::document::Document,\n    should_fail: bool,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // test sockets\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    // client setup\n    let client_ed25519_private = Ed25519PrivateKey::generate();\n\n    // server setup\n    let server_ed25519_private = Ed25519PrivateKey::generate();\n    let server_ed25519_public = Ed25519PublicKey::from_private_key(\u0026server_ed25519_private);\n    let server_service_id = V3OnionServiceId::from_public_key(\u0026server_ed25519_public);\n\n    let client_requested_endpoint = match AsciiString::new(client_requested_endpoint.to_string()) {\n        Ok(ascii) =\u003e ascii,\n        Err(_) =\u003e {\n            assert!(should_fail);\n            return Ok(());\n        }\n    };\n\n    // rpc setup\n    let client_rpc = Session::new(stream1);\n    let mut ident_client = IdentityClient::new(\n        client_rpc,\n        server_service_id.clone(),\n        client_requested_endpoint.clone(),\n        client_ed25519_private,\n        X25519PrivateKey::generate(),\n    )\n    .unwrap();\n\n    let server_rpc = Session::new(stream2);\n    let mut ident_server = IdentityServer::new(server_rpc, server_service_id.clone());\n\n    let mut failure_ocurred = false;\n    let mut server_complete = false;\n    let mut client_complete = false;\n    while !server_complete \u0026\u0026 !client_complete {\n        if !server_complete {\n            match ident_server.update() {\n                Ok(Some(IdentityServerEvent::EndpointRequestReceived {\n                    client_service_id,\n                    requested_endpoint,\n                })) =\u003e {\n                    println!(\n                        \"server challenge send: client_service_id {}, requested_endpoint: {}\",\n                        client_service_id.to_string(),\n                        requested_endpoint\n                    );\n                    let client_allowed = !client_blocked;\n                    ident_server.handle_endpoint_request_received(\n                        client_allowed,\n                        client_requested_endpoint_valid,\n                        server_challenge.clone(),\n                    )?;\n                }\n                Ok(Some(IdentityServerEvent::ChallengeResponseReceived { challenge_response })) =\u003e {\n                    println!(\"server challenge repsonse received\");\n                    ident_server.handle_challenge_response_received(\n                        challenge_response == server_expected_response,\n                    )?;\n                }\n                Ok(Some(IdentityServerEvent::HandshakeCompleted {\n                    endpoint_private_key: _,\n                    endpoint_name,\n                    client_service_id,\n                    client_auth_public_key: _,\n                })) =\u003e {\n                    assert!(endpoint_name == client_requested_endpoint);\n                    println!(\n                        \"server complete! client_service_id : {}\",\n                        client_service_id.to_string()\n                    );\n                    server_complete = true;\n                }\n                Ok(Some(IdentityServerEvent::HandshakeRejected {\n                    client_allowed,\n                    client_requested_endpoint_valid,\n                    client_proof_signature_valid,\n                    client_auth_signature_valid,\n                    challenge_response_valid,\n                })) =\u003e {\n                    println!(\"server complete! client request rejected\");\n                    println!(\" client_allowed: {}\", client_allowed);\n                    println!(\n                        \" client_requested_endpoint_valid: {}\",\n                        client_requested_endpoint_valid\n                    );\n                    println!(\n                        \" client_proof_signature_valid: {}\",\n                        client_proof_signature_valid\n                    );\n                    println!(\n                        \" client_auth_signature_valid: {}\",\n                        client_auth_signature_valid\n                    );\n                    println!(\" client_response_valid: {}\", challenge_response_valid);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"server failure: {:?}\", err);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n\n        if !client_complete {\n            match ident_client.update() {\n                Ok(Some(IdentityClientEvent::ChallengeReceived { endpoint_challenge })) =\u003e {\n                    println!(\n                        \"client challenge request received: endpoint_challenge: {}\",\n                        endpoint_challenge\n                    );\n                    ident_client.send_response(client_response.clone())?;\n                }\n                Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                    identity_service_id,\n                    endpoint_service_id,\n                    endpoint_name,\n                    client_auth_private_key: _,\n                })) =\u003e {\n                    assert!(identity_service_id == server_service_id);\n                    assert!(endpoint_name == client_requested_endpoint.clone().to_string());\n                    println!(\n                        \"client complete! endpoint_server : {}\",\n                        endpoint_service_id.to_string()\n                    );\n                    client_complete = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"client failure: {:?}\", err);\n                    client_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n    }\n\n    assert!(failure_ocurred == should_fail);\n    Ok(())\n}\n\n#[test]\nfn test_identity_handshake() -\u003e anyhow::Result\u003c()\u003e {\n    println!(\"Sucessful ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = false;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Bad Endpoint ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = false;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Bad Challenge Response ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Friend?\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Blocked Client ---\");\n    {\n        let client_blocked: bool = true;\n        let client_requested_endpoint: \u0026str = \"endpoint\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    println!(\"Non-ASCII endpoint ---\");\n    {\n        let client_blocked: bool = false;\n        let client_requested_endpoint: \u0026str = \"\";\n        let client_requested_endpoint_valid: bool = true;\n        let server_challenge: bson::document::Document = doc!(\"msg\": \"Speak friend and enter\");\n        let client_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let server_expected_response: bson::document::Document = doc!(\"msg\": \"Mellon\");\n        let should_fail: bool = true;\n        identity_test(\n            client_blocked,\n            client_requested_endpoint,\n            client_requested_endpoint_valid,\n            server_challenge,\n            client_response,\n            server_expected_response,\n            should_fail,\n        )?;\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nfn endpoint_test(\n    should_fail: bool,\n    client_allowed: bool,\n    channel: \u0026str,\n    channel_allowed: bool,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // test sockets\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    // server+client setup\n    let server_ed25519_private = Ed25519PrivateKey::generate();\n    let server_ed25519_public = Ed25519PublicKey::from_private_key(\u0026server_ed25519_private);\n    let server_service_id = V3OnionServiceId::from_public_key(\u0026server_ed25519_public);\n\n    let client_ed25519_private = Ed25519PrivateKey::generate();\n    let client_ed25519_public = Ed25519PublicKey::from_private_key(\u0026client_ed25519_private);\n    let client_service_id = V3OnionServiceId::from_public_key(\u0026client_ed25519_public);\n\n    // ensure our client is in the allow list\n    let allowed_client = if client_allowed {\n        client_service_id.clone()\n    } else {\n        let ed25519_private = Ed25519PrivateKey::generate();\n        let ed25519_public = Ed25519PublicKey::from_private_key(\u0026ed25519_private);\n        V3OnionServiceId::from_public_key(\u0026ed25519_public)\n    };\n\n    let server_rpc = Session::new(stream1);\n\n    let mut endpoint_server = EndpointServer::new(\n        server_rpc,\n        allowed_client.clone(),\n        server_service_id.clone(),\n    );\n\n    let client_rpc = Session::new(stream2);\n\n    let channel = match AsciiString::new(channel.to_string()) {\n        Ok(channel) =\u003e channel,\n        Err(_) =\u003e {\n            assert!(should_fail);\n            return Ok(());\n        }\n    };\n\n    let mut endpoint_client = EndpointClient::new(\n        client_rpc,\n        server_service_id.clone(),\n        channel.clone(),\n        client_ed25519_private,\n    );\n\n    let mut failure_ocurred = false;\n    let mut server_complete = false;\n    let mut client_complete = false;\n    while !server_complete \u0026\u0026 !client_complete {\n        if !server_complete {\n            match endpoint_server.update() {\n                Ok(Some(EndpointServerEvent::ChannelRequestReceived {\n                    client_service_id: ret_client_service_id,\n                    requested_channel,\n                })) =\u003e {\n                    assert_eq!(ret_client_service_id, client_service_id);\n                    assert!(requested_channel == channel);\n                    endpoint_server.handle_channel_request_received(channel_allowed)?;\n                }\n                Ok(Some(EndpointServerEvent::HandshakeCompleted {\n                    client_service_id: ret_client_service_id,\n                    channel_name: ret_channel,\n                    stream: _,\n                })) =\u003e {\n                    assert!(ret_client_service_id == client_service_id);\n                    assert!(ret_channel == channel);\n                    server_complete = true;\n                }\n                Ok(Some(EndpointServerEvent::HandshakeRejected {\n                    client_allowed,\n                    client_requested_channel_valid,\n                    client_proof_signature_valid,\n                })) =\u003e {\n                    println!(\"handshake rejected: client_allowed: {}, client_requested_channel_valid: {}, client_proof_signature_valid: {}\", client_allowed, client_requested_channel_valid, client_proof_signature_valid);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"server failure: {:?}\", err);\n                    server_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n\n        if !client_complete {\n            match endpoint_client.update() {\n                Ok(Some(EndpointClientEvent::HandshakeCompleted { stream: _ })) =\u003e {\n                    client_complete = true;\n                }\n                Ok(None) =\u003e {}\n                Err(err) =\u003e {\n                    println!(\"client failure: {:?}\", err);\n                    client_complete = true;\n                    failure_ocurred = true;\n                }\n            }\n        }\n    }\n\n    println!(\"server_complete: {}\", server_complete);\n    println!(\"client_complete: {}\", client_complete);\n\n    assert!(should_fail == failure_ocurred);\n\n    Ok(())\n}\n\n#[test]\nfn test_endpoint_handshake() -\u003e anyhow::Result\u003c()\u003e {\n    println!(\"Success ---\");\n    {\n        let should_fail = false;\n        let client_allowed = true;\n        let channel = \"channel\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Client Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = false;\n        let channel = \"channel\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Channel Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = true;\n        let channel = \"channel\";\n        let channel_allowed = false;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Client and Channel Not Allowed ---\");\n    {\n        let should_fail = true;\n        let client_allowed = false;\n        let channel = \"channel\";\n        let channel_allowed = false;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n    println!(\"Non-Ascii Channel ---\");\n    {\n        let should_fail = true;\n        let client_allowed = true;\n        let channel = \"\";\n        let channel_allowed = true;\n        endpoint_test(should_fail, client_allowed, channel, channel_allowed)?;\n    }\n\n    Ok(())\n}\n","traces":[{"line":54,"address":[2906544],"length":1,"stats":{"Line":2}},{"line":55,"address":[2906612,2906553],"length":1,"stats":{"Line":4}},{"line":56,"address":[2235000],"length":1,"stats":{"Line":2}},{"line":57,"address":[2235023],"length":1,"stats":{"Line":2}},{"line":62,"address":[2235056,2236310],"length":1,"stats":{"Line":2}},{"line":70,"address":[2235166],"length":1,"stats":{"Line":2}},{"line":72,"address":[2906758,2906858],"length":1,"stats":{"Line":4}},{"line":73,"address":[2906877],"length":1,"stats":{"Line":2}},{"line":74,"address":[2906903],"length":1,"stats":{"Line":2}},{"line":75,"address":[2906970],"length":1,"stats":{"Line":2}},{"line":76,"address":[2906996],"length":1,"stats":{"Line":2}},{"line":77,"address":[2907132],"length":1,"stats":{"Line":2}},{"line":78,"address":[2907158],"length":1,"stats":{"Line":2}},{"line":79,"address":[2907294],"length":1,"stats":{"Line":2}},{"line":80,"address":[2907320],"length":1,"stats":{"Line":2}},{"line":81,"address":[2907559],"length":1,"stats":{"Line":2}},{"line":82,"address":[2907588],"length":1,"stats":{"Line":2}},{"line":84,"address":[2907843],"length":1,"stats":{"Line":2}},{"line":92,"address":[2240982,2236336,2246578],"length":1,"stats":{"Line":1}},{"line":102,"address":[2236497],"length":1,"stats":{"Line":1}},{"line":103,"address":[2236900,2239664,2246530,2236757],"length":1,"stats":{"Line":1}},{"line":104,"address":[2237129,2236985,2246493,2236873],"length":1,"stats":{"Line":2}},{"line":106,"address":[2237170,2237271,2237070,2246456],"length":1,"stats":{"Line":2}},{"line":107,"address":[2237239,2237452,2237361,2246387],"length":1,"stats":{"Line":2}},{"line":108,"address":[2237509,2237662,2246369,2237425],"length":1,"stats":{"Line":2}},{"line":109,"address":[2246291,2237633,2237746,2237823],"length":1,"stats":{"Line":2}},{"line":112,"address":[2237804],"length":1,"stats":{"Line":1}},{"line":115,"address":[2237861],"length":1,"stats":{"Line":1}},{"line":116,"address":[2237929],"length":1,"stats":{"Line":1}},{"line":117,"address":[2237997],"length":1,"stats":{"Line":1}},{"line":119,"address":[2238048],"length":1,"stats":{"Line":1}},{"line":120,"address":[2238089],"length":1,"stats":{"Line":1}},{"line":122,"address":[2246076,2238205],"length":1,"stats":{"Line":1}},{"line":123,"address":[2246109],"length":1,"stats":{"Line":1}},{"line":128,"address":[2238218],"length":1,"stats":{"Line":1}},{"line":130,"address":[2238323],"length":1,"stats":{"Line":1}},{"line":131,"address":[2238377],"length":1,"stats":{"Line":1}},{"line":132,"address":[2238441],"length":1,"stats":{"Line":1}},{"line":133,"address":[2238456],"length":1,"stats":{"Line":1}},{"line":134,"address":[2238502],"length":1,"stats":{"Line":1}},{"line":138,"address":[2238953],"length":1,"stats":{"Line":1}},{"line":139,"address":[2239023,2245996],"length":1,"stats":{"Line":1}},{"line":141,"address":[2239169],"length":1,"stats":{"Line":1}},{"line":142,"address":[2239177],"length":1,"stats":{"Line":1}},{"line":143,"address":[2239185],"length":1,"stats":{"Line":1}},{"line":144,"address":[2239193],"length":1,"stats":{"Line":1}},{"line":145,"address":[2242934,2239245],"length":1,"stats":{"Line":2}},{"line":146,"address":[2239271,2239333,2239601],"length":1,"stats":{"Line":3}},{"line":147,"address":[2239666],"length":1,"stats":{"Line":1}},{"line":151,"address":[2240288,2240426],"length":1,"stats":{"Line":1}},{"line":156,"address":[2240545],"length":1,"stats":{"Line":1}},{"line":157,"address":[2240817,2240915,2240586],"length":1,"stats":{"Line":1}},{"line":160,"address":[2240568],"length":1,"stats":{"Line":1}},{"line":163,"address":[2239792],"length":1,"stats":{"Line":1}},{"line":164,"address":[2241035,2239888],"length":1,"stats":{"Line":2}},{"line":165,"address":[2241085,2241306],"length":1,"stats":{"Line":1}},{"line":166,"address":[2241070],"length":1,"stats":{"Line":1}},{"line":169,"address":[2239949],"length":1,"stats":{"Line":1}},{"line":175,"address":[2241589,2240029],"length":1,"stats":{"Line":2}},{"line":176,"address":[2241625],"length":1,"stats":{"Line":1}},{"line":180,"address":[2241882],"length":1,"stats":{"Line":1}},{"line":182,"address":[2240091],"length":1,"stats":{"Line":1}},{"line":189,"address":[2241908,2240123],"length":1,"stats":{"Line":2}},{"line":190,"address":[2242021],"length":1,"stats":{"Line":1}},{"line":191,"address":[2242184],"length":1,"stats":{"Line":1}},{"line":195,"address":[2242347],"length":1,"stats":{"Line":1}},{"line":199,"address":[2242510],"length":1,"stats":{"Line":1}},{"line":203,"address":[2242673],"length":1,"stats":{"Line":1}},{"line":204,"address":[2242742],"length":1,"stats":{"Line":1}},{"line":205,"address":[2242750],"length":1,"stats":{"Line":1}},{"line":208,"address":[2239428],"length":1,"stats":{"Line":0}},{"line":209,"address":[2242803],"length":1,"stats":{"Line":0}},{"line":210,"address":[2242872],"length":1,"stats":{"Line":0}},{"line":211,"address":[2242880],"length":1,"stats":{"Line":0}},{"line":216,"address":[2239278,2245407],"length":1,"stats":{"Line":2}},{"line":217,"address":[2243536,2243261],"length":1,"stats":{"Line":2}},{"line":218,"address":[2243575],"length":1,"stats":{"Line":1}},{"line":219,"address":[2243938],"length":1,"stats":{"Line":1}},{"line":223,"address":[2236450,2244141,2244023,2244351],"length":1,"stats":{"Line":2}},{"line":225,"address":[2243832],"length":1,"stats":{"Line":0}},{"line":231,"address":[2244647,2243880],"length":1,"stats":{"Line":0}},{"line":232,"address":[2244702],"length":1,"stats":{"Line":0}},{"line":233,"address":[2245074],"length":1,"stats":{"Line":0}},{"line":237,"address":[2245206],"length":1,"stats":{"Line":0}},{"line":240,"address":[2243363],"length":1,"stats":{"Line":0}},{"line":241,"address":[2245276],"length":1,"stats":{"Line":0}},{"line":242,"address":[2245345],"length":1,"stats":{"Line":0}},{"line":243,"address":[2245353],"length":1,"stats":{"Line":0}},{"line":249,"address":[2239220,2245683],"length":1,"stats":{"Line":1}},{"line":250,"address":[2245716],"length":1,"stats":{"Line":1}},{"line":354,"address":[2253400,2248428,2246592],"length":1,"stats":{"Line":1}},{"line":361,"address":[2246705],"length":1,"stats":{"Line":1}},{"line":362,"address":[2249787,2247063,2246895],"length":1,"stats":{"Line":1}},{"line":363,"address":[2247036,2247148,2247292,2253390],"length":1,"stats":{"Line":2}},{"line":365,"address":[2247233,2247330,2253356,2247428],"length":1,"stats":{"Line":2}},{"line":366,"address":[2253290,2247597,2247512,2247399],"length":1,"stats":{"Line":2}},{"line":367,"address":[2247804,2247651,2247570,2253275],"length":1,"stats":{"Line":2}},{"line":368,"address":[2253197,2247888,2247775,2247965],"length":1,"stats":{"Line":2}},{"line":371,"address":[2247946],"length":1,"stats":{"Line":1}},{"line":372,"address":[2248003],"length":1,"stats":{"Line":1}},{"line":373,"address":[2248074],"length":1,"stats":{"Line":1}},{"line":375,"address":[2248101],"length":1,"stats":{"Line":1}},{"line":376,"address":[2248120],"length":1,"stats":{"Line":1}},{"line":377,"address":[2248196],"length":1,"stats":{"Line":1}},{"line":380,"address":[2248230],"length":1,"stats":{"Line":1}},{"line":381,"address":[2248271,2248437],"length":1,"stats":{"Line":2}},{"line":383,"address":[2248236],"length":1,"stats":{"Line":1}},{"line":384,"address":[2248281],"length":1,"stats":{"Line":1}},{"line":385,"address":[2248352],"length":1,"stats":{"Line":1}},{"line":388,"address":[2248398],"length":1,"stats":{"Line":1}},{"line":391,"address":[2248439],"length":1,"stats":{"Line":1}},{"line":392,"address":[2248493],"length":1,"stats":{"Line":1}},{"line":393,"address":[2248557],"length":1,"stats":{"Line":1}},{"line":396,"address":[2248705,2248619],"length":1,"stats":{"Line":2}},{"line":398,"address":[2248721,2248782],"length":1,"stats":{"Line":2}},{"line":399,"address":[2248800],"length":1,"stats":{"Line":1}},{"line":401,"address":[2248916,2252891],"length":1,"stats":{"Line":1}},{"line":402,"address":[2252924],"length":1,"stats":{"Line":1}},{"line":407,"address":[2248929],"length":1,"stats":{"Line":1}},{"line":408,"address":[2248991],"length":1,"stats":{"Line":1}},{"line":409,"address":[2249107],"length":1,"stats":{"Line":1}},{"line":410,"address":[2249114],"length":1,"stats":{"Line":1}},{"line":413,"address":[2249217],"length":1,"stats":{"Line":1}},{"line":414,"address":[2249225],"length":1,"stats":{"Line":1}},{"line":415,"address":[2249233],"length":1,"stats":{"Line":1}},{"line":416,"address":[2249241],"length":1,"stats":{"Line":1}},{"line":417,"address":[2249360,2251634],"length":1,"stats":{"Line":2}},{"line":418,"address":[2249452,2249716,2249386],"length":1,"stats":{"Line":3}},{"line":419,"address":[2249789],"length":1,"stats":{"Line":1}},{"line":423,"address":[2249893,2250248],"length":1,"stats":{"Line":2}},{"line":424,"address":[2250336],"length":1,"stats":{"Line":1}},{"line":425,"address":[2250711,2246656,2250396,2250501],"length":1,"stats":{"Line":2}},{"line":427,"address":[2249931],"length":1,"stats":{"Line":1}},{"line":432,"address":[2251018,2250043],"length":1,"stats":{"Line":2}},{"line":433,"address":[2251073],"length":1,"stats":{"Line":1}},{"line":434,"address":[2251127],"length":1,"stats":{"Line":1}},{"line":436,"address":[2250057],"length":1,"stats":{"Line":1}},{"line":441,"address":[2251341],"length":1,"stats":{"Line":1}},{"line":442,"address":[2251442],"length":1,"stats":{"Line":1}},{"line":443,"address":[2251450],"length":1,"stats":{"Line":1}},{"line":446,"address":[2249547],"length":1,"stats":{"Line":0}},{"line":447,"address":[2251503],"length":1,"stats":{"Line":0}},{"line":448,"address":[2251572],"length":1,"stats":{"Line":0}},{"line":449,"address":[2251580],"length":1,"stats":{"Line":0}},{"line":454,"address":[2249393],"length":1,"stats":{"Line":1}},{"line":455,"address":[2251958],"length":1,"stats":{"Line":1}},{"line":456,"address":[2252204],"length":1,"stats":{"Line":1}},{"line":457,"address":[2252196],"length":1,"stats":{"Line":1}},{"line":460,"address":[2252030],"length":1,"stats":{"Line":1}},{"line":461,"address":[2252243],"length":1,"stats":{"Line":1}},{"line":462,"address":[2252312],"length":1,"stats":{"Line":1}},{"line":463,"address":[2252320],"length":1,"stats":{"Line":1}},{"line":469,"address":[2252445],"length":1,"stats":{"Line":1}},{"line":470,"address":[2252608],"length":1,"stats":{"Line":1}},{"line":472,"address":[2252684],"length":1,"stats":{"Line":1}},{"line":474,"address":[2252735],"length":1,"stats":{"Line":1}}],"covered":139,"coverable":156},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","identity_client.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{\n    get_message_overhead, get_request_section_size, RequestCookie, Response, Session,\n};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Identity Client\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to convert x25519 private key to ed25519 private key\")]\n    ClientCreationFailed(#[source] tor_interface::tor_crypto::Error),\n\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"client received unexpected response: {0}\")]\n    UnexpectedResponseReceived(String),\n\n    #[error(\"client is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"provided endpoint challenge response too large; encoded size would be {0} but session's maximum honk-rpc message size is {1}\")]\n    EndpointChallengeResponseTooLarge(usize, usize),\n}\n\npub(crate) enum IdentityClientEvent {\n    ChallengeReceived {\n        endpoint_challenge: bson::document::Document,\n    },\n    HandshakeCompleted {\n        identity_service_id: V3OnionServiceId,\n        endpoint_service_id: V3OnionServiceId,\n        endpoint_name: String,\n        client_auth_private_key: X25519PrivateKey,\n    },\n}\n\n#[derive(Debug, PartialEq)]\npub(crate) enum IdentityClientState {\n    BeginHandshake,\n    WaitingForChallenge,\n    WaitingForChallengeResponse,\n    WaitingForChallengeVerification,\n    HandshakeComplete,\n}\n\n//\n// An identity client object used for connecting\n// to an identity server\n//\npub(crate) struct IdentityClient {\n    // session data\n    rpc: Session\u003cTcpStream\u003e,\n    server_service_id: V3OnionServiceId,\n    requested_endpoint: AsciiString,\n    client_service_id: V3OnionServiceId,\n    client_identity_ed25519_private: Ed25519PrivateKey,\n    client_authorization_key_private: X25519PrivateKey,\n    client_authorization_signing_key_private: (Ed25519PrivateKey, SignBit),\n\n    // state machine data\n    state: IdentityClientState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    endpoint_challenge_response: Option\u003cbson::document::Document\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n}\n\nimpl IdentityClient {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?},  begin_handshake_request_cookie: {:?},  server_cookie: {:?}, endpoint_challenge_response: {:?},  send_response_request_cookie: {:?} }}\", self.state,  self.begin_handshake_request_cookie, self.server_cookie, self.endpoint_challenge_response, self.send_response_request_cookie)\n    }\n\n    pub fn new(\n        rpc: Session\u003cTcpStream\u003e,\n        server_service_id: V3OnionServiceId,\n        requested_endpoint: AsciiString,\n        client_identity_ed25519_private: Ed25519PrivateKey,\n        client_authorization_key_private: X25519PrivateKey,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(Self {\n            rpc,\n            server_service_id,\n            requested_endpoint,\n            client_service_id: V3OnionServiceId::from_private_key(\u0026client_identity_ed25519_private),\n            client_identity_ed25519_private,\n            client_authorization_signing_key_private: Ed25519PrivateKey::from_private_x25519(\n                \u0026client_authorization_key_private,\n            )\n            .map_err(Error::ClientCreationFailed)?,\n            client_authorization_key_private,\n\n            state: IdentityClientState::BeginHandshake,\n            begin_handshake_request_cookie: None,\n            server_cookie: None,\n            send_response_request_cookie: None,\n            endpoint_challenge_response: None,\n        })\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cIdentityClientEvent\u003e, Error\u003e {\n        if self.state == IdentityClientState::HandshakeComplete {\n            return Err(Error::IncorrectUsage(\"update() may not be called after HandshakeComplete has been returned from previous update() call\".to_string()));\n        }\n\n        // update our rpc session\n        self.rpc.update(None)?;\n\n        // client state machine\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie,\n            self.endpoint_challenge_response.take(),\n            self.send_response_request_cookie,\n        ) {\n            // send initial handshake request\n            (\n                \u0026IdentityClientState::BeginHandshake,\n                None, // begin_handshake_request_cookie\n                None, // server_cookie\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                self.begin_handshake_request_cookie = Some(self.rpc.client_call(\n                    \"gosling_identity\",\n                    \"begin_handshake\",\n                    0,\n                    doc! {\n                        \"version\" : bson::Bson::String(GOSLING_PROTOCOL_VERSION.to_string()),\n                        \"client_identity\" : bson::Bson::String(self.client_service_id.to_string()),\n                        \"endpoint\" : bson::Bson::String(self.requested_endpoint.clone().to_string()),\n                    },\n                )?);\n                self.state = IdentityClientState::WaitingForChallenge;\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallenge,\n                Some(begin_handshake_request_cookie),\n                None, // server_cookie\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                if let Some(response) = self.rpc.client_next_response() {\n                    // check for response for the begin_handshake() call\n                    let mut response = match response {\n                        Response::Pending { cookie } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected pending response\".to_string(),\n                                ));\n                            }\n                            return Ok(None);\n                        }\n                        Response::Error { cookie, error_code } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected error response; rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                            return Err(Error::UnexpectedResponseReceived(format!(\n                                \"received unexpected rpc error_code: {}\",\n                                error_code\n                            )));\n                        }\n                        Response::Success { cookie, result } =\u003e {\n                            if cookie != begin_handshake_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected success response\".to_string(),\n                                ));\n                            }\n                            match result {\n                                Some(Bson::Document(result)) =\u003e result,\n                                _ =\u003e {\n                                    return Err(Error::UnexpectedResponseReceived(\n                                        \"begin_handshake() response is unexpected bson type\"\n                                            .to_string(),\n                                    ))\n                                }\n                            }\n                        }\n                    };\n\n                    // save off the server cookie\n                    self.server_cookie = match response.get(\"server_cookie\") {\n                        Some(Bson::Binary(Binary {\n                            subtype: BinarySubtype::Generic,\n                            bytes: server_cookie,\n                        })) =\u003e match server_cookie.clone().try_into() {\n                            Ok(server_cookie) =\u003e Some(server_cookie),\n                            Err(_) =\u003e {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"unable to convert '{:?}' to server cookie\",\n                                    server_cookie\n                                )))\n                            }\n                        },\n                        Some(_) =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"server_cookie is unxpected bson type\".to_string(),\n                            ))\n                        }\n                        None =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"missing server_cookie\".to_string(),\n                            ))\n                        }\n                    };\n\n                    // get the endpoint challenge\n                    let endpoint_challenge = match response.get_mut(\"endpoint_challenge\") {\n                        Some(Bson::Document(endpoint_challenge)) =\u003e {\n                            std::mem::take(endpoint_challenge)\n                        }\n                        Some(_) =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"endpoint challenge is unexpected bson type\".to_string(),\n                            ))\n                        }\n                        None =\u003e {\n                            return Err(Error::UnexpectedResponseReceived(\n                                \"missing endpoint_challenge\".to_string(),\n                            ))\n                        }\n                    };\n\n                    self.state = IdentityClientState::WaitingForChallengeResponse;\n                    return Ok(Some(IdentityClientEvent::ChallengeReceived {\n                        endpoint_challenge,\n                    }));\n                }\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(_server_cookie),\n                None, // endpoint_challenge_response\n                None, // send_response_request_cookie\n            ) =\u003e {\n                // no-op, waiting for response for challenge response from caller\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(server_cookie),\n                Some(endpoint_challenge_response),\n                None,\n            ) =\u003e {\n                // client_cookie\n                let mut client_cookie: ClientCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut client_cookie);\n                let client_cookie = client_cookie;\n\n                // client_identity_proof_signature\n                let client_identity_proof = build_client_proof(\n                    DomainSeparator::GoslingIdentity,\n                    \u0026self.requested_endpoint,\n                    \u0026self.client_service_id,\n                    \u0026self.server_service_id,\n                    \u0026client_cookie,\n                    \u0026server_cookie,\n                );\n                let client_identity_proof_signature = self\n                    .client_identity_ed25519_private\n                    .sign_message(\u0026client_identity_proof);\n\n                // client_authorization_key\n                let client_authorization_key =\n                    X25519PublicKey::from_private_key(\u0026self.client_authorization_key_private);\n\n                // client_authorization_signature\n                let client_identity = self.client_service_id.to_string();\n                let (client_authorization_signature, signbit) = (\n                    self.client_authorization_signing_key_private\n                        .0\n                        .sign_message(client_identity.as_bytes()),\n                    self.client_authorization_signing_key_private.1,\n                );\n\n                // build our args object for rpc call\n                let args = doc! {\n                    \"client_cookie\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_cookie.to_vec()}),\n                    \"client_identity_proof_signature\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_identity_proof_signature.to_bytes().to_vec()}),\n                    \"client_authorization_key\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_key.as_bytes().to_vec()}),\n                    \"client_authorization_key_signbit\" : bson::Bson::Boolean(signbit.into()),\n                    \"client_authorization_signature\" : bson::Bson::Binary(bson::Binary{subtype: BinarySubtype::Generic, bytes: client_authorization_signature.to_bytes().to_vec()}),\n                    \"challenge_response\" : endpoint_challenge_response,\n                };\n\n                // make rpc call\n                self.send_response_request_cookie =\n                    Some(\n                        self.rpc\n                            .client_call(\"gosling_identity\", \"send_response\", 0, args)?,\n                    );\n                self.state = IdentityClientState::WaitingForChallengeVerification;\n            }\n            (\n                \u0026IdentityClientState::WaitingForChallengeVerification,\n                Some(_begin_handshake_request_cookie),\n                Some(_server_cookie),\n                None, // endpoint_challenge_response\n                Some(send_response_request_cookie),\n            ) =\u003e {\n                if let Some(response) = self.rpc.client_next_response() {\n                    let endpoint_service_id = match response {\n                        Response::Pending { cookie } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                return Ok(None);\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpectd pending response\".to_string(),\n                                ));\n                            }\n                        }\n                        Response::Error { cookie, error_code } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected error response; rpc error_code: {}\",\n                                    error_code\n                                )));\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(format!(\n                                    \"received unexpected rpc error_code: {}\",\n                                    error_code\n                                )));\n                            }\n                        }\n                        Response::Success { cookie, result } =\u003e {\n                            if cookie == send_response_request_cookie {\n                                match result {\n                                    Some(Bson::String(endpoint_service_id)) =\u003e {\n                                        match V3OnionServiceId::from_string(\u0026endpoint_service_id) {\n                                            Ok(endpoint_service_id) =\u003e endpoint_service_id,\n                                            Err(_) =\u003e return Err(Error::UnexpectedResponseReceived(format!(\"unable to parse received endpoint service id '{}' as v3 onion service id\", endpoint_service_id))),\n                                        }\n                                    }\n                                    _ =\u003e {\n                                        return Err(Error::UnexpectedResponseReceived(\n                                            \"endpoint service id is unexpected bson type\".to_string(),\n                                        ))\n                                    }\n                                }\n                            } else {\n                                return Err(Error::UnexpectedResponseReceived(\n                                    \"received unexpected success response\".to_string(),\n                                ));\n                            }\n                        }\n                    };\n                    self.state = IdentityClientState::HandshakeComplete;\n                    return Ok(Some(IdentityClientEvent::HandshakeCompleted {\n                        identity_service_id: self.server_service_id.clone(),\n                        endpoint_service_id,\n                        endpoint_name: self.requested_endpoint.clone().to_string(),\n                        client_auth_private_key: self.client_authorization_key_private.clone(),\n                    }));\n                }\n            }\n            _ =\u003e {\n                return Err(Error::InvalidState(self.get_state()));\n            }\n        }\n        Ok(None)\n    }\n\n    pub fn send_response(\n        \u0026mut self,\n        challenge_response: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.server_cookie,\n            self.endpoint_challenge_response.as_ref(),\n            self.send_response_request_cookie,\n        ) {\n            (\u0026IdentityClientState::WaitingForChallengeResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_server_cookie),\n             None, // endpoint_challenge_response\n             None  // end_response_request_cookie\n            ) =\u003e {\n                // calculate required size of request message and ensure it fits our\n                // specified message size budget\n                let arguments = doc!{\n                    \"client_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; CLIENT_COOKIE_SIZE].to_vec()}),\n                    \"client_identity_proof_signature\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; ED25519_SIGNATURE_SIZE].to_vec()}),\n                    \"client_authorization_key\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; X25519_PUBLIC_KEY_SIZE].to_vec()}),\n                    \"client_authorization_key_signbit\" : Bson::Boolean(false),\n                    \"client_authorization_signature\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: [0u8; ED25519_SIGNATURE_SIZE].to_vec()}),\n                    \"challenge_response\" : challenge_response.clone(),\n                };\n                let request_section_size = get_request_section_size(Some(0i64), Some(\"gosling_identity\".to_string()), \"send_response\".to_string(), Some(0i32), Some(arguments))?;\n                let message_size = get_message_overhead()? + request_section_size;\n                let max_message_size = self.rpc.get_max_message_size();\n                if message_size \u003e max_message_size {\n                    Err(Error::EndpointChallengeResponseTooLarge(message_size, max_message_size))\n                } else {\n                    self.endpoint_challenge_response = Some(challenge_response);\n                    Ok(())\n                }\n            }\n            _ =\u003e Err(Error::IncorrectUsage(\"send_response() may only be called after ChallengeReceived event has been returned from update(), and it may only be called once\".to_string()))\n        }\n    }\n}\n","traces":[{"line":90,"address":[2523456],"length":1,"stats":{"Line":0}},{"line":91,"address":[2523913,2523654,2523567,2523480,2523741,2523828],"length":1,"stats":{"Line":0}},{"line":94,"address":[2524112,2525503,2525460],"length":1,"stats":{"Line":2}},{"line":101,"address":[2524623,2524148],"length":1,"stats":{"Line":4}},{"line":102,"address":[2524200],"length":1,"stats":{"Line":2}},{"line":104,"address":[2524212],"length":1,"stats":{"Line":2}},{"line":105,"address":[2524235],"length":1,"stats":{"Line":2}},{"line":106,"address":[2524303],"length":1,"stats":{"Line":2}},{"line":107,"address":[2524397,2524337,2525155],"length":1,"stats":{"Line":4}},{"line":110,"address":[2525043],"length":1,"stats":{"Line":0}},{"line":111,"address":[2524510],"length":1,"stats":{"Line":2}},{"line":113,"address":[2524565],"length":1,"stats":{"Line":2}},{"line":114,"address":[2524573],"length":1,"stats":{"Line":2}},{"line":115,"address":[2524585],"length":1,"stats":{"Line":2}},{"line":116,"address":[2524593],"length":1,"stats":{"Line":2}},{"line":117,"address":[2524605],"length":1,"stats":{"Line":2}},{"line":121,"address":[2538301,2527878,2525536],"length":1,"stats":{"Line":2}},{"line":122,"address":[2525616],"length":1,"stats":{"Line":2}},{"line":123,"address":[2525779],"length":1,"stats":{"Line":0}},{"line":127,"address":[2525608,2525671,2526327],"length":1,"stats":{"Line":4}},{"line":130,"address":[2531584,2534742,2526477,2526094,2526389,2527887],"length":1,"stats":{"Line":12}},{"line":131,"address":[2525934],"length":1,"stats":{"Line":2}},{"line":132,"address":[2525951],"length":1,"stats":{"Line":2}},{"line":133,"address":[2525981],"length":1,"stats":{"Line":2}},{"line":134,"address":[2526024],"length":1,"stats":{"Line":2}},{"line":135,"address":[2526080],"length":1,"stats":{"Line":2}},{"line":138,"address":[2527624],"length":1,"stats":{"Line":2}},{"line":145,"address":[2527749,2527402,2527832],"length":1,"stats":{"Line":2}},{"line":149,"address":[2526541,2527179,2526928,2526744,2526653,2527085],"length":1,"stats":{"Line":8}},{"line":150,"address":[2526694,2526626],"length":1,"stats":{"Line":4}},{"line":151,"address":[2526852],"length":1,"stats":{"Line":2}},{"line":152,"address":[2527036,2527129],"length":1,"stats":{"Line":4}},{"line":155,"address":[2527603],"length":1,"stats":{"Line":2}},{"line":157,"address":[2527971],"length":1,"stats":{"Line":2}},{"line":164,"address":[2527995],"length":1,"stats":{"Line":2}},{"line":166,"address":[2528181],"length":1,"stats":{"Line":2}},{"line":167,"address":[2528284],"length":1,"stats":{"Line":2}},{"line":168,"address":[2528300],"length":1,"stats":{"Line":2}},{"line":169,"address":[2528544],"length":1,"stats":{"Line":0}},{"line":170,"address":[2528509],"length":1,"stats":{"Line":0}},{"line":173,"address":[2528468],"length":1,"stats":{"Line":2}},{"line":175,"address":[2528402],"length":1,"stats":{"Line":0}},{"line":176,"address":[2528446],"length":1,"stats":{"Line":0}},{"line":177,"address":[2531389],"length":1,"stats":{"Line":0}},{"line":182,"address":[2531194],"length":1,"stats":{"Line":0}},{"line":187,"address":[2528314],"length":1,"stats":{"Line":2}},{"line":188,"address":[2528380],"length":1,"stats":{"Line":2}},{"line":189,"address":[2530885],"length":1,"stats":{"Line":0}},{"line":190,"address":[2528695],"length":1,"stats":{"Line":0}},{"line":193,"address":[2528658,2528725],"length":1,"stats":{"Line":4}},{"line":194,"address":[2528795],"length":1,"stats":{"Line":2}},{"line":196,"address":[2530746],"length":1,"stats":{"Line":0}},{"line":197,"address":[2528765],"length":1,"stats":{"Line":0}},{"line":206,"address":[2529291,2529036,2529629,2528926,2529100],"length":1,"stats":{"Line":10}},{"line":209,"address":[2529339],"length":1,"stats":{"Line":2}},{"line":210,"address":[2529359],"length":1,"stats":{"Line":2}},{"line":211,"address":[2529431],"length":1,"stats":{"Line":2}},{"line":213,"address":[2530322],"length":1,"stats":{"Line":0}},{"line":220,"address":[2530580],"length":1,"stats":{"Line":0}},{"line":221,"address":[2529309],"length":1,"stats":{"Line":0}},{"line":225,"address":[2529160],"length":1,"stats":{"Line":0}},{"line":226,"address":[2529073],"length":1,"stats":{"Line":0}},{"line":232,"address":[2529672,2529783],"length":1,"stats":{"Line":4}},{"line":233,"address":[2529953],"length":1,"stats":{"Line":2}},{"line":234,"address":[2529973],"length":1,"stats":{"Line":2}},{"line":237,"address":[2530164],"length":1,"stats":{"Line":0}},{"line":238,"address":[2529992],"length":1,"stats":{"Line":0}},{"line":242,"address":[2529839],"length":1,"stats":{"Line":0}},{"line":243,"address":[2529756],"length":1,"stats":{"Line":0}},{"line":248,"address":[2530030],"length":1,"stats":{"Line":2}},{"line":249,"address":[2530051],"length":1,"stats":{"Line":2}},{"line":254,"address":[2531673],"length":1,"stats":{"Line":0}},{"line":263,"address":[2531758],"length":1,"stats":{"Line":2}},{"line":271,"address":[2531918],"length":1,"stats":{"Line":2}},{"line":272,"address":[2531978],"length":1,"stats":{"Line":2}},{"line":273,"address":[2532018],"length":1,"stats":{"Line":2}},{"line":277,"address":[2532050],"length":1,"stats":{"Line":2}},{"line":278,"address":[2532058],"length":1,"stats":{"Line":2}},{"line":279,"address":[2532068],"length":1,"stats":{"Line":2}},{"line":280,"address":[2532078],"length":1,"stats":{"Line":2}},{"line":284,"address":[2532141,2532258],"length":1,"stats":{"Line":4}},{"line":286,"address":[2532155],"length":1,"stats":{"Line":2}},{"line":289,"address":[2532285],"length":1,"stats":{"Line":2}},{"line":293,"address":[2532319],"length":1,"stats":{"Line":2}},{"line":294,"address":[2532481],"length":1,"stats":{"Line":2}},{"line":295,"address":[2532353,2532448],"length":1,"stats":{"Line":4}},{"line":297,"address":[2532372],"length":1,"stats":{"Line":2}},{"line":298,"address":[2532475],"length":1,"stats":{"Line":2}},{"line":302,"address":[2533128,2533839,2532638,2533562,2533399,2532851,2534043,2532697],"length":1,"stats":{"Line":14}},{"line":303,"address":[2532741,2532657],"length":1,"stats":{"Line":4}},{"line":304,"address":[2532951],"length":1,"stats":{"Line":2}},{"line":305,"address":[2533228],"length":1,"stats":{"Line":2}},{"line":306,"address":[2533503],"length":1,"stats":{"Line":2}},{"line":307,"address":[2533662],"length":1,"stats":{"Line":2}},{"line":308,"address":[2533939],"length":1,"stats":{"Line":2}},{"line":312,"address":[2534418],"length":1,"stats":{"Line":2}},{"line":313,"address":[2534398],"length":1,"stats":{"Line":2}},{"line":314,"address":[2534247,2534611],"length":1,"stats":{"Line":2}},{"line":315,"address":[2534499],"length":1,"stats":{"Line":0}},{"line":317,"address":[2534448],"length":1,"stats":{"Line":2}},{"line":319,"address":[2534874],"length":1,"stats":{"Line":2}},{"line":326,"address":[2534895],"length":1,"stats":{"Line":2}},{"line":327,"address":[2535081],"length":1,"stats":{"Line":2}},{"line":328,"address":[2535175],"length":1,"stats":{"Line":2}},{"line":329,"address":[2535191],"length":1,"stats":{"Line":2}},{"line":330,"address":[2535382],"length":1,"stats":{"Line":2}},{"line":332,"address":[2535431],"length":1,"stats":{"Line":0}},{"line":333,"address":[2535347],"length":1,"stats":{"Line":0}},{"line":337,"address":[2535289],"length":1,"stats":{"Line":0}},{"line":338,"address":[2535333],"length":1,"stats":{"Line":0}},{"line":339,"address":[2537915],"length":1,"stats":{"Line":0}},{"line":344,"address":[2537720],"length":1,"stats":{"Line":0}},{"line":350,"address":[2535205],"length":1,"stats":{"Line":1}},{"line":351,"address":[2535270],"length":1,"stats":{"Line":1}},{"line":352,"address":[2535572,2535843],"length":1,"stats":{"Line":2}},{"line":353,"address":[2535913],"length":1,"stats":{"Line":1}},{"line":354,"address":[2535961,2536032],"length":1,"stats":{"Line":2}},{"line":355,"address":[2536069],"length":1,"stats":{"Line":1}},{"line":356,"address":[2536928],"length":1,"stats":{"Line":0}},{"line":360,"address":[2537207],"length":1,"stats":{"Line":0}},{"line":361,"address":[2535883],"length":1,"stats":{"Line":0}},{"line":366,"address":[2535690],"length":1,"stats":{"Line":0}},{"line":367,"address":[2535545],"length":1,"stats":{"Line":0}},{"line":372,"address":[2536361],"length":1,"stats":{"Line":1}},{"line":373,"address":[2536595],"length":1,"stats":{"Line":1}},{"line":374,"address":[2536382],"length":1,"stats":{"Line":1}},{"line":376,"address":[2536431],"length":1,"stats":{"Line":1}},{"line":377,"address":[2536532],"length":1,"stats":{"Line":1}},{"line":382,"address":[2538134,2526467],"length":1,"stats":{"Line":0}},{"line":385,"address":[2527791],"length":1,"stats":{"Line":2}},{"line":388,"address":[2538336,2541832,2541973],"length":1,"stats":{"Line":2}},{"line":392,"address":[2538391,2538613,2538755],"length":1,"stats":{"Line":6}},{"line":393,"address":[2538423],"length":1,"stats":{"Line":2}},{"line":394,"address":[2538438],"length":1,"stats":{"Line":2}},{"line":395,"address":[2538462],"length":1,"stats":{"Line":2}},{"line":396,"address":[2538505],"length":1,"stats":{"Line":2}},{"line":397,"address":[2538589],"length":1,"stats":{"Line":2}},{"line":399,"address":[2538813],"length":1,"stats":{"Line":2}},{"line":407,"address":[2539073,2539571,2538919,2539697,2540066,2539322,2539946,2538861],"length":1,"stats":{"Line":14}},{"line":408,"address":[2538880,2538963],"length":1,"stats":{"Line":4}},{"line":409,"address":[2539173],"length":1,"stats":{"Line":2}},{"line":410,"address":[2539422],"length":1,"stats":{"Line":2}},{"line":411,"address":[2539671],"length":1,"stats":{"Line":2}},{"line":412,"address":[2539797],"length":1,"stats":{"Line":2}},{"line":413,"address":[2540059],"length":1,"stats":{"Line":2}},{"line":415,"address":[2540270,2540362,2541795,2540898,2541810],"length":1,"stats":{"Line":4}},{"line":416,"address":[2540871,2541772,2541324,2541039],"length":1,"stats":{"Line":4}},{"line":417,"address":[2541354,2541308],"length":1,"stats":{"Line":4}},{"line":418,"address":[2541362,2541641],"length":1,"stats":{"Line":2}},{"line":419,"address":[2541589],"length":1,"stats":{"Line":0}},{"line":421,"address":[2541381,2541648],"length":1,"stats":{"Line":2}},{"line":422,"address":[2541735],"length":1,"stats":{"Line":2}},{"line":425,"address":[2541868,2538725],"length":1,"stats":{"Line":0}}],"covered":114,"coverable":153},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","identity_server.rs"],"content":"// standard\nuse std::clone::Clone;\nuse std::convert::TryInto;\nuse std::net::TcpStream;\n\n// extern crates\nuse bson::doc;\nuse bson::spec::BinarySubtype;\nuse bson::{Binary, Bson};\nuse honk_rpc::honk_rpc::{\n    get_message_overhead, get_response_section_size, ApiSet, ErrorCode, RequestCookie, Session,\n};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse tor_interface::tor_crypto::*;\n\n// internal crates\nuse crate::ascii_string::*;\nuse crate::gosling::*;\n\n//\n// Identity Server\n//\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"HonkRPC method failed: {0}\")]\n    HonkRPCFailure(#[from] honk_rpc::honk_rpc::Error),\n\n    #[error(\"server is in invalid state: {0}\")]\n    InvalidState(String),\n\n    #[error(\"incorrect usage: {0}\")]\n    IncorrectUsage(String),\n\n    #[error(\"client sent invalid request\")]\n    BadClient,\n\n    #[error(\"provided endpoint challenge too large; encoded size would be {0} but session's maximum honk-rpc message size is {1}\")]\n    EndpointChallengeTooLarge(usize, usize),\n}\n\npub(crate) enum IdentityServerEvent {\n    EndpointRequestReceived {\n        client_service_id: V3OnionServiceId,\n        requested_endpoint: AsciiString,\n    },\n\n    ChallengeResponseReceived {\n        challenge_response: bson::document::Document,\n    },\n\n    HandshakeCompleted {\n        endpoint_private_key: Ed25519PrivateKey,\n        endpoint_name: AsciiString,\n        client_service_id: V3OnionServiceId,\n        client_auth_public_key: X25519PublicKey,\n    },\n\n    HandshakeRejected {\n        // Client not on the block-list\n        client_allowed: bool,\n        // The requested endpoint is valid\n        client_requested_endpoint_valid: bool,\n        // The client proof is valid and signed with client's public key\n        client_proof_signature_valid: bool,\n        // The client authorization signature is valid\n        client_auth_signature_valid: bool,\n        // The challenge response is valid\n        challenge_response_valid: bool,\n    },\n}\n\n#[derive(Debug, PartialEq)]\nenum IdentityServerState {\n    // valid/expected states\n    WaitingForBeginHandshake,\n    GettingChallenge,\n    ChallengeReady,\n    WaitingForSendResponse,\n    GettingChallengeVerification,\n    ChallengeVerificationReady,\n    ChallengeVerificationResponseSent,\n    HandshakeComplete,\n    // failure state\n    HandshakeFailed,\n}\n\npub(crate) struct IdentityServer {\n    // Session Data\n    rpc: Option\u003cSession\u003cTcpStream\u003e\u003e,\n    server_identity: V3OnionServiceId,\n\n    // State Machine Data\n    state: IdentityServerState,\n    begin_handshake_request_cookie: Option\u003cRequestCookie\u003e,\n    client_identity: Option\u003cV3OnionServiceId\u003e,\n    requested_endpoint: Option\u003cAsciiString\u003e,\n    server_cookie: Option\u003cServerCookie\u003e,\n    endpoint_challenge: Option\u003cbson::document::Document\u003e,\n    send_response_request_cookie: Option\u003cRequestCookie\u003e,\n    client_auth_key: Option\u003cX25519PublicKey\u003e,\n    challenge_response: Option\u003cbson::document::Document\u003e,\n    endpoint_private_key: Option\u003cEd25519PrivateKey\u003e,\n\n    // Verification flags\n\n    // Client not on the block-list\n    client_allowed: bool,\n    // The requested endpoint is valid\n    client_requested_endpoint_valid: bool,\n    // The client proof is valid and signed with client's public key\n    client_proof_signature_valid: bool,\n    // The client authorization signature is valid\n    client_auth_signature_valid: bool,\n    // The challenge response is valid\n    challenge_response_valid: bool,\n}\n\nimpl IdentityServer {\n    fn get_state(\u0026self) -\u003e String {\n        format!(\"{{ state: {:?}, begin_handshake_request_cookie: {:?}, client_identity: {:?}, requested_endpoint: {:?}, server_cookie: {:?}, endpoint_challenge: {:?}, send_response_request_cookie: {:?}, client_auth_key: {:?}, challenge_response: {:?}, endpoint_private_key: {:?} }}\", self.state, self.begin_handshake_request_cookie, self.client_identity, self.requested_endpoint, self.server_cookie, self.endpoint_challenge, self.send_response_request_cookie, self.client_auth_key, self.challenge_response, self.endpoint_private_key)\n    }\n\n    pub fn new(rpc: Session\u003cTcpStream\u003e, server_identity: V3OnionServiceId) -\u003e Self {\n        IdentityServer {\n            // Session Data\n            rpc: Some(rpc),\n            server_identity,\n\n            // State Machine Data\n            state: IdentityServerState::WaitingForBeginHandshake,\n            begin_handshake_request_cookie: None,\n            client_identity: None,\n            requested_endpoint: None,\n            server_cookie: None,\n            endpoint_challenge: None,\n            send_response_request_cookie: None,\n            client_auth_key: None,\n            challenge_response: None,\n            endpoint_private_key: None,\n\n            // Verification Flags\n            client_allowed: false,\n            client_requested_endpoint_valid: false,\n            client_proof_signature_valid: false,\n            client_auth_signature_valid: false,\n            challenge_response_valid: false,\n        }\n    }\n\n    pub fn update(\u0026mut self) -\u003e Result\u003cOption\u003cIdentityServerEvent\u003e, Error\u003e {\n        // need to remove ownership of the HonkRPC session from Self\n        // before being able to pass self into the session update method\n        if let Some(mut rpc) = std::mem::take(\u0026mut self.rpc) {\n            match rpc.update(Some(\u0026mut [self])) {\n                Ok(()) =\u003e {\n                    self.rpc = Some(rpc);\n                }\n                Err(err) =\u003e {\n                    self.rpc = Some(rpc);\n                    return Err(err.into());\n                }\n            }\n        }\n\n        match(\u0026self.state,\n              self.begin_handshake_request_cookie,\n              self.client_identity.as_ref(),\n              self.requested_endpoint.as_ref(),\n              self.server_cookie.as_ref(),\n              self.endpoint_challenge.as_ref(),\n              self.send_response_request_cookie,\n              self.client_auth_key.as_ref(),\n              self.challenge_response.as_mut(),\n              self.endpoint_private_key.as_ref()) {\n            (\u0026IdentityServerState::WaitingForBeginHandshake,\n             None, // begin_handshake_request_cookie\n             None, // client_identity\n             None, // requested_endpoint\n             None, // server_cookie\n             None, // endpoint_challenge\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                // no-op, waiting for client to connect and begin handshake\n            },\n            (\u0026IdentityServerState::WaitingForBeginHandshake,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_endpoint),\n             None, // server_cookie\n             None, // endpoint_challenge\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::GettingChallenge;\n                return Ok(Some(IdentityServerEvent::EndpointRequestReceived{client_service_id: client_identity.clone(), requested_endpoint: requested_endpoint.clone()}));\n            },\n            (\u0026IdentityServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             None, // send_response_request_cookie\n             None, // client_auth_key\n             None, // challenge_response\n             None) // endpoint_private_key\n            =\u003e {\n                // no-op, waiting for client to send challenge response\n            },\n            (\u0026IdentityServerState::WaitingForSendResponse,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(_client_auth_key),\n             Some(challenge_response),\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::GettingChallengeVerification;\n                return Ok(Some(IdentityServerEvent::ChallengeResponseReceived{\n                    challenge_response: std::mem::take(challenge_response),\n                }));\n            },\n            (\u0026IdentityServerState::ChallengeVerificationResponseSent,\n             Some(_begin_handshake_request_cookie),\n             Some(client_identity),\n             Some(requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(client_auth_key),\n             Some(_challenge_response),\n             Some(endpoint_private_key))\n            =\u003e {\n                self.state = IdentityServerState::HandshakeComplete;\n                return Ok(Some(IdentityServerEvent::HandshakeCompleted{\n                    endpoint_private_key: endpoint_private_key.clone(),\n                    endpoint_name: requested_endpoint.clone(),\n                    client_service_id: client_identity.clone(),\n                    client_auth_public_key: client_auth_key.clone(),\n                }));\n            },\n            (\u0026IdentityServerState::ChallengeVerificationResponseSent,\n             Some(_begin_handshake_request_cookie),\n             Some(_client_identity),\n             Some(_requested_endpoint),\n             Some(_server_cookie),\n             Some(_endpoint_challenge),\n             Some(_send_response_request_cookie),\n             Some(_client_auth_key),\n             Some(_challenge_response),\n             None) // endpoint_private_key\n            =\u003e {\n                self.state = IdentityServerState::HandshakeComplete;\n                return Ok(Some(IdentityServerEvent::HandshakeRejected{\n                    client_allowed: self.client_allowed,\n                    client_requested_endpoint_valid: self.client_requested_endpoint_valid,\n                    client_proof_signature_valid: self.client_proof_signature_valid,\n                    client_auth_signature_valid: self.client_auth_signature_valid,\n                    challenge_response_valid: self.challenge_response_valid,\n                }));\n            },\n             _ =\u003e {\n                if self.state == IdentityServerState::HandshakeFailed {\n                    return Err(Error::BadClient);\n                } else {\n                    return Err(Error::InvalidState(self.get_state()));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    pub fn handle_endpoint_request_received(\n        \u0026mut self,\n        client_allowed: bool,\n        endpoint_valid: bool,\n        endpoint_challenge: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.rpc.as_ref(),\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            (\n                \u0026IdentityServerState::GettingChallenge,\n                Some(rpc),\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_endpoint_name),\n                None, // server_cookie\n                None, // endpoint_challenge\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                let mut server_cookie: ServerCookie = Default::default();\n                OsRng.fill_bytes(\u0026mut server_cookie);\n\n                // calculate required size of response message and ensure if fits our\n                // specified message size budget\n                let result = doc!{\n                    \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                    \"endpoint_challenge\" : endpoint_challenge.clone(),\n                };\n                let response_section_size = get_response_section_size(Some(Bson::Document(result)))?;\n                let message_size = get_message_overhead()? + response_section_size;\n                let max_message_size = rpc.get_max_message_size();\n                if message_size \u003e max_message_size {\n                    Err(Error::EndpointChallengeTooLarge(message_size, max_message_size))\n                } else {\n                    self.server_cookie = Some(server_cookie);\n                    self.endpoint_challenge = Some(endpoint_challenge);\n                    self.client_allowed = client_allowed;\n                    self.client_requested_endpoint_valid = endpoint_valid;\n                    self.state = IdentityServerState::ChallengeReady;\n                    Ok(())\n                }\n            }\n            _ =\u003e {\n                Err(Error::IncorrectUsage(\"handle_endpoint_request_received() may only be called after EndpointRequestReceived has been returned from update(), and it may only be called once\".to_string()))\n            }\n        }\n    }\n\n    pub fn handle_challenge_response_received(\n        \u0026mut self,\n        challenge_response_valid: bool,\n    ) -\u003e Result\u003c(), Error\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            (\n                \u0026IdentityServerState::GettingChallengeVerification,\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(_server_cookie),\n                Some(_endpoint_challenge),\n                Some(_client_auth_key),\n                Some(_challenge_response),\n                None,\n            ) =\u003e\n            // endpoint_private_key\n            {\n                self.challenge_response_valid = challenge_response_valid;\n                self.state = IdentityServerState::ChallengeVerificationReady;\n                Ok(())\n            }\n            _ =\u003e {\n                Err(Error::IncorrectUsage(\"handle_challenge_response_received() may only be called after ChallengeResponseReceived event has been returned from update(), and it may only be called once\".to_string()))\n            }\n        }\n    }\n}\n\nimpl ApiSet for IdentityServer {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"gosling_identity\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        let request_cookie = match request_cookie {\n            Some(request_cookie) =\u003e request_cookie,\n            None =\u003e {\n                return Some(Err(ErrorCode::Runtime(\n                    RpcError::RequestCookieRequired as i32,\n                )))\n            }\n        };\n\n        match (\n            name,\n            version,\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_ref(),\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n            self.endpoint_private_key.as_ref(),\n        ) {\n            // handle begin_handshake call\n            (\n                \"begin_handshake\",\n                0,\n                \u0026IdentityServerState::WaitingForBeginHandshake,\n                None, // begin_handshake_request_cookie\n                None, // client_identity\n                None, // requested_endpoint\n                None, // server_cookie\n                None, // endpoint_challenge\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                let valid_version = match args.remove(\"version\") {\n                    Some(Bson::String(value)) =\u003e value == GOSLING_PROTOCOL_VERSION,\n                    _ =\u003e false,\n                };\n                if !valid_version {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    return Some(Err(ErrorCode::Runtime(RpcError::BadVersion as i32)));\n                }\n\n                if let (Some(Bson::String(client_identity)), Some(Bson::String(endpoint_name))) =\n                    (args.remove(\"client_identity\"), args.remove(\"endpoint\"))\n                {\n                    // client_identiity\n                    let client_identity = match V3OnionServiceId::from_string(\u0026client_identity) {\n                        Ok(client_identity) =\u003e client_identity,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n\n                    // endpoint name\n                    let endpoint_name = match AsciiString::new(endpoint_name) {\n                        Ok(endpoint_name) =\u003e endpoint_name,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n\n                    // save cookie\n                    self.begin_handshake_request_cookie = Some(request_cookie);\n\n                    // save results\n                    self.client_identity = Some(client_identity);\n                    self.requested_endpoint = Some(endpoint_name);\n                    None\n                } else {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)))\n                }\n            }\n            // handle send_response call\n            (\n                \"send_response\",\n                0,\n                \u0026IdentityServerState::WaitingForSendResponse,\n                Some(_begin_handshake_request_cookie),\n                Some(client_identity),\n                Some(requested_endpoint),\n                Some(server_cookie),\n                Some(_endpoint_challenge),\n                None, // client_auth_key\n                None, // challenge_response\n                None, // endpoint_private_key\n            ) =\u003e {\n                // arg validation\n                if let (\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_cookie,\n                    })),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_identity_proof_signature,\n                    })),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_authorization_key,\n                    })),\n                    Some(Bson::Boolean(client_authorization_key_signbit)),\n                    Some(Bson::Binary(Binary {\n                        subtype: BinarySubtype::Generic,\n                        bytes: client_authorization_signature,\n                    })),\n                    Some(Bson::Document(challenge_response)),\n                ) = (\n                    args.remove(\"client_cookie\"),\n                    args.remove(\"client_identity_proof_signature\"),\n                    args.remove(\"client_authorization_key\"),\n                    args.remove(\"client_authorization_key_signbit\"),\n                    args.remove(\"client_authorization_signature\"),\n                    args.remove(\"challenge_response\"),\n                ) {\n                    // client_cookie\n                    let client_cookie: ClientCookie = match client_cookie.try_into() {\n                        Ok(client_cookie) =\u003e client_cookie,\n                        Err(_) =\u003e {\n                            self.state = IdentityServerState::HandshakeFailed;\n                            return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                        }\n                    };\n\n                    // client_identity_proof_signature\n                    let client_identity_proof_signature: [u8; ED25519_SIGNATURE_SIZE] =\n                        match client_identity_proof_signature.try_into() {\n                            Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                            }\n                        };\n                    let client_identity_proof_signature =\n                        match Ed25519Signature::from_raw(\u0026client_identity_proof_signature) {\n                            Ok(client_identity_proof_signature) =\u003e client_identity_proof_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                            }\n                        };\n\n                    // client_authorization_key\n                    let client_authorization_key: [u8; X25519_PUBLIC_KEY_SIZE] =\n                        match client_authorization_key.try_into() {\n                            Ok(client_authorization_key) =\u003e client_authorization_key,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                            }\n                        };\n                    let client_authorization_key =\n                        X25519PublicKey::from_raw(\u0026client_authorization_key);\n\n                    // client_authorization_key_signbit\n                    let client_authorization_key_signbit: SignBit =\n                        client_authorization_key_signbit.into();\n\n                    // client_authorization_signature\n                    let client_authorization_signature: [u8; ED25519_SIGNATURE_SIZE] =\n                        match client_authorization_signature.try_into() {\n                            Ok(client_authorization_signature) =\u003e client_authorization_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                            }\n                        };\n                    let client_authorization_signature =\n                        match Ed25519Signature::from_raw(\u0026client_authorization_signature) {\n                            Ok(client_authorization_signature) =\u003e client_authorization_signature,\n                            Err(_) =\u003e {\n                                self.state = IdentityServerState::HandshakeFailed;\n                                return Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)));\n                            }\n                        };\n\n                    // save  cookie\n                    self.send_response_request_cookie = Some(request_cookie);\n\n                    // convert client_identity to client's public ed25519 key\n                    if let Ok(client_identity_key) =\n                        Ed25519PublicKey::from_service_id(client_identity)\n                    {\n                        // construct + verify client proof\n                        let client_proof = build_client_proof(\n                            DomainSeparator::GoslingIdentity,\n                            requested_endpoint,\n                            client_identity,\n                            \u0026self.server_identity,\n                            \u0026client_cookie,\n                            server_cookie,\n                        );\n                        self.client_proof_signature_valid = client_identity_proof_signature\n                            .verify(\u0026client_proof, \u0026client_identity_key);\n                    }\n\n                    // evaluate the client authorization signature\n                    self.client_auth_signature_valid = client_authorization_signature\n                        .verify_x25519(\n                            client_identity.as_bytes(),\n                            \u0026client_authorization_key,\n                            client_authorization_key_signbit,\n                        );\n\n                    // save off client auth key for future endpoint generation\n                    self.client_auth_key = Some(client_authorization_key);\n\n                    // safe off challenge response for verification\n                    self.challenge_response = Some(challenge_response);\n\n                    None\n                } else {\n                    self.state = IdentityServerState::HandshakeFailed;\n                    Some(Err(ErrorCode::Runtime(RpcError::InvalidArg as i32)))\n                }\n            }\n            _ =\u003e {\n                self.state = IdentityServerState::HandshakeFailed;\n                Some(Err(ErrorCode::Runtime(RpcError::Failure as i32)))\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e)\u003e {\n        match (\n            \u0026self.state,\n            self.begin_handshake_request_cookie,\n            self.client_identity.as_ref(),\n            self.requested_endpoint.as_ref(),\n            self.server_cookie.as_ref(),\n            self.endpoint_challenge.as_mut(),\n            self.send_response_request_cookie,\n            self.client_auth_key.as_ref(),\n            self.challenge_response.as_ref(),\n        ) {\n            // return challenge from begin_handshake\n            (\n                \u0026IdentityServerState::ChallengeReady,\n                Some(begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(server_cookie),\n                Some(endpoint_challenge),\n                None, // send_response_request_cookie\n                None, // client_auth_key\n                None,\n            ) =\u003e\n            // challenge_response\n            {\n                self.state = IdentityServerState::WaitingForSendResponse;\n                Some((\n                    begin_handshake_request_cookie,\n                    Ok(Some(Bson::Document(doc! {\n                        \"server_cookie\" : Bson::Binary(Binary{subtype: BinarySubtype::Generic, bytes: server_cookie.to_vec()}),\n                        \"endpoint_challenge\" : std::mem::take(endpoint_challenge),\n                    }))),\n                ))\n            }\n            (\u0026IdentityServerState::ChallengeReady, _, _, _, _, _, _, _, _) =\u003e unreachable!(),\n            (\n                \u0026IdentityServerState::ChallengeVerificationReady,\n                Some(_begin_handshake_request_cookie),\n                Some(_client_identity),\n                Some(_requested_endpoint),\n                Some(_server_cookie),\n                Some(_endpoint_challenge),\n                Some(send_response_request_cookie),\n                Some(_client_auth_key),\n                Some(_challenge_response),\n            ) =\u003e {\n                let mut success = true;\n                success \u0026= self.client_allowed;\n                success \u0026= self.client_requested_endpoint_valid;\n                success \u0026= self.client_proof_signature_valid;\n                success \u0026= self.client_auth_signature_valid;\n                success \u0026= self.challenge_response_valid;\n\n                self.state = IdentityServerState::ChallengeVerificationResponseSent;\n                if success {\n                    let endpoint_private_key = Ed25519PrivateKey::generate();\n                    let endpoint_service_id =\n                        V3OnionServiceId::from_private_key(\u0026endpoint_private_key);\n                    self.endpoint_private_key = Some(endpoint_private_key);\n                    Some((\n                        send_response_request_cookie,\n                        Ok(Some(Bson::String(endpoint_service_id.to_string()))),\n                    ))\n                } else {\n                    Some((\n                        send_response_request_cookie,\n                        Err(ErrorCode::Runtime(RpcError::Failure as i32)),\n                    ))\n                }\n            }\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":121,"address":[2466256],"length":1,"stats":{"Line":0}},{"line":122,"address":[2466280,2466619,2466793,2467134,2466445,2466878,2466965,2467052,2466532,2466706],"length":1,"stats":{"Line":0}},{"line":125,"address":[2467488],"length":1,"stats":{"Line":2}},{"line":128,"address":[2467510],"length":1,"stats":{"Line":2}},{"line":152,"address":[2468048,2469327],"length":1,"stats":{"Line":2}},{"line":155,"address":[2468107],"length":1,"stats":{"Line":2}},{"line":156,"address":[2468260,2468422],"length":1,"stats":{"Line":4}},{"line":158,"address":[2468457,2468823],"length":1,"stats":{"Line":2}},{"line":160,"address":[2468582],"length":1,"stats":{"Line":0}},{"line":161,"address":[2468929,2468702],"length":1,"stats":{"Line":0}},{"line":162,"address":[2469217,2469018],"length":1,"stats":{"Line":0}},{"line":167,"address":[2470721,2471087,2471429,2469398,2469660,2469864,2470242],"length":1,"stats":{"Line":14}},{"line":168,"address":[2469408],"length":1,"stats":{"Line":2}},{"line":169,"address":[2469415],"length":1,"stats":{"Line":2}},{"line":170,"address":[2469444],"length":1,"stats":{"Line":2}},{"line":171,"address":[2469473],"length":1,"stats":{"Line":2}},{"line":172,"address":[2469502],"length":1,"stats":{"Line":2}},{"line":173,"address":[2469531],"length":1,"stats":{"Line":2}},{"line":174,"address":[2469549],"length":1,"stats":{"Line":2}},{"line":175,"address":[2469578],"length":1,"stats":{"Line":2}},{"line":176,"address":[2469607],"length":1,"stats":{"Line":2}},{"line":190,"address":[2470479],"length":1,"stats":{"Line":2}},{"line":201,"address":[2470516],"length":1,"stats":{"Line":2}},{"line":202,"address":[2470537],"length":1,"stats":{"Line":2}},{"line":204,"address":[2471050],"length":1,"stats":{"Line":2}},{"line":217,"address":[2471241],"length":1,"stats":{"Line":2}},{"line":228,"address":[2471289],"length":1,"stats":{"Line":2}},{"line":229,"address":[2471324],"length":1,"stats":{"Line":2}},{"line":230,"address":[2471310],"length":1,"stats":{"Line":2}},{"line":233,"address":[2472037],"length":1,"stats":{"Line":2}},{"line":244,"address":[2472159],"length":1,"stats":{"Line":2}},{"line":245,"address":[2472342],"length":1,"stats":{"Line":2}},{"line":246,"address":[2472180],"length":1,"stats":{"Line":2}},{"line":247,"address":[2472210],"length":1,"stats":{"Line":2}},{"line":248,"address":[2472274],"length":1,"stats":{"Line":2}},{"line":249,"address":[2472335],"length":1,"stats":{"Line":2}},{"line":252,"address":[2471779],"length":1,"stats":{"Line":1}},{"line":263,"address":[2471811],"length":1,"stats":{"Line":1}},{"line":264,"address":[2471864],"length":1,"stats":{"Line":1}},{"line":265,"address":[2471832],"length":1,"stats":{"Line":1}},{"line":266,"address":[2471839],"length":1,"stats":{"Line":1}},{"line":267,"address":[2471846],"length":1,"stats":{"Line":1}},{"line":268,"address":[2471852],"length":1,"stats":{"Line":1}},{"line":269,"address":[2471858],"length":1,"stats":{"Line":1}},{"line":273,"address":[2469832],"length":1,"stats":{"Line":0}},{"line":274,"address":[2472725],"length":1,"stats":{"Line":0}},{"line":276,"address":[2472582],"length":1,"stats":{"Line":0}},{"line":281,"address":[2470201],"length":1,"stats":{"Line":2}},{"line":284,"address":[2472800,2475745,2475864],"length":1,"stats":{"Line":2}},{"line":290,"address":[2473258,2473422,2472886],"length":1,"stats":{"Line":6}},{"line":291,"address":[2472902],"length":1,"stats":{"Line":2}},{"line":292,"address":[2472920],"length":1,"stats":{"Line":2}},{"line":293,"address":[2472992],"length":1,"stats":{"Line":2}},{"line":294,"address":[2473009],"length":1,"stats":{"Line":2}},{"line":295,"address":[2473037],"length":1,"stats":{"Line":2}},{"line":296,"address":[2473065],"length":1,"stats":{"Line":2}},{"line":297,"address":[2473093],"length":1,"stats":{"Line":2}},{"line":298,"address":[2473121],"length":1,"stats":{"Line":2}},{"line":299,"address":[2473149],"length":1,"stats":{"Line":2}},{"line":300,"address":[2473177],"length":1,"stats":{"Line":2}},{"line":302,"address":[2473652],"length":1,"stats":{"Line":2}},{"line":314,"address":[2473721],"length":1,"stats":{"Line":2}},{"line":315,"address":[2473740],"length":1,"stats":{"Line":2}},{"line":319,"address":[2473831,2473985,2474105,2473772],"length":1,"stats":{"Line":6}},{"line":320,"address":[2473875,2473791],"length":1,"stats":{"Line":4}},{"line":321,"address":[2474098],"length":1,"stats":{"Line":2}},{"line":323,"address":[2474664,2474301,2475724],"length":1,"stats":{"Line":2}},{"line":324,"address":[2475709,2474637,2475089,2474805],"length":1,"stats":{"Line":4}},{"line":325,"address":[2475118,2475074],"length":1,"stats":{"Line":4}},{"line":326,"address":[2475126,2475522],"length":1,"stats":{"Line":2}},{"line":327,"address":[2475470],"length":1,"stats":{"Line":0}},{"line":329,"address":[2475145],"length":1,"stats":{"Line":2}},{"line":330,"address":[2475260,2475532],"length":1,"stats":{"Line":2}},{"line":331,"address":[2475639],"length":1,"stats":{"Line":2}},{"line":332,"address":[2475650],"length":1,"stats":{"Line":2}},{"line":333,"address":[2475659],"length":1,"stats":{"Line":2}},{"line":334,"address":[2475680],"length":1,"stats":{"Line":2}},{"line":338,"address":[2475759,2473392],"length":1,"stats":{"Line":0}},{"line":343,"address":[2475904],"length":1,"stats":{"Line":2}},{"line":347,"address":[2476173,2476385],"length":1,"stats":{"Line":4}},{"line":348,"address":[2475958],"length":1,"stats":{"Line":2}},{"line":349,"address":[2475968],"length":1,"stats":{"Line":2}},{"line":350,"address":[2475985],"length":1,"stats":{"Line":2}},{"line":351,"address":[2476008],"length":1,"stats":{"Line":2}},{"line":352,"address":[2476031],"length":1,"stats":{"Line":2}},{"line":353,"address":[2476054],"length":1,"stats":{"Line":2}},{"line":354,"address":[2476077],"length":1,"stats":{"Line":2}},{"line":355,"address":[2476100],"length":1,"stats":{"Line":2}},{"line":356,"address":[2476123],"length":1,"stats":{"Line":2}},{"line":358,"address":[2476630],"length":1,"stats":{"Line":2}},{"line":371,"address":[2476739],"length":1,"stats":{"Line":2}},{"line":372,"address":[2476748],"length":1,"stats":{"Line":2}},{"line":373,"address":[2476769],"length":1,"stats":{"Line":2}},{"line":376,"address":[2476266],"length":1,"stats":{"Line":0}},{"line":383,"address":[2476800],"length":1,"stats":{"Line":2}},{"line":387,"address":[2490895,2482905,2476832],"length":1,"stats":{"Line":2}},{"line":394,"address":[2476980],"length":1,"stats":{"Line":2}},{"line":395,"address":[2477207],"length":1,"stats":{"Line":2}},{"line":397,"address":[2477111],"length":1,"stats":{"Line":0}},{"line":403,"address":[2477837,2477995,2477646,2486918],"length":1,"stats":{"Line":8}},{"line":406,"address":[2477231],"length":1,"stats":{"Line":2}},{"line":407,"address":[2477248],"length":1,"stats":{"Line":2}},{"line":408,"address":[2477271],"length":1,"stats":{"Line":2}},{"line":409,"address":[2477368],"length":1,"stats":{"Line":2}},{"line":410,"address":[2477402],"length":1,"stats":{"Line":2}},{"line":411,"address":[2477436],"length":1,"stats":{"Line":2}},{"line":412,"address":[2477470],"length":1,"stats":{"Line":2}},{"line":413,"address":[2477501],"length":1,"stats":{"Line":2}},{"line":414,"address":[2477532],"length":1,"stats":{"Line":2}},{"line":417,"address":[2477749],"length":1,"stats":{"Line":2}},{"line":430,"address":[2487193],"length":1,"stats":{"Line":2}},{"line":431,"address":[2487320],"length":1,"stats":{"Line":2}},{"line":432,"address":[2487307],"length":1,"stats":{"Line":0}},{"line":434,"address":[2487674],"length":1,"stats":{"Line":2}},{"line":435,"address":[2487756],"length":1,"stats":{"Line":0}},{"line":436,"address":[2487777],"length":1,"stats":{"Line":0}},{"line":439,"address":[2487876],"length":1,"stats":{"Line":2}},{"line":443,"address":[2488448,2488516],"length":1,"stats":{"Line":4}},{"line":444,"address":[2488553],"length":1,"stats":{"Line":2}},{"line":446,"address":[2488655],"length":1,"stats":{"Line":0}},{"line":447,"address":[2488676],"length":1,"stats":{"Line":0}},{"line":452,"address":[2488789],"length":1,"stats":{"Line":2}},{"line":453,"address":[2488863],"length":1,"stats":{"Line":2}},{"line":455,"address":[2489003],"length":1,"stats":{"Line":0}},{"line":456,"address":[2489024],"length":1,"stats":{"Line":0}},{"line":461,"address":[2489146],"length":1,"stats":{"Line":2}},{"line":464,"address":[2489189],"length":1,"stats":{"Line":2}},{"line":465,"address":[2489321,2489485],"length":1,"stats":{"Line":2}},{"line":466,"address":[2489610],"length":1,"stats":{"Line":2}},{"line":468,"address":[2488152],"length":1,"stats":{"Line":0}},{"line":469,"address":[2488173],"length":1,"stats":{"Line":0}},{"line":473,"address":[2478284],"length":1,"stats":{"Line":2}},{"line":487,"address":[2479238,2479041],"length":1,"stats":{"Line":2}},{"line":490,"address":[2479735],"length":1,"stats":{"Line":2}},{"line":494,"address":[2479775],"length":1,"stats":{"Line":2}},{"line":498,"address":[2479823],"length":1,"stats":{"Line":2}},{"line":500,"address":[2479871],"length":1,"stats":{"Line":2}},{"line":503,"address":[2479891],"length":1,"stats":{"Line":2}},{"line":505,"address":[2479939],"length":1,"stats":{"Line":2}},{"line":507,"address":[2478379],"length":1,"stats":{"Line":2}},{"line":508,"address":[2478418],"length":1,"stats":{"Line":2}},{"line":509,"address":[2478501],"length":1,"stats":{"Line":2}},{"line":510,"address":[2478581],"length":1,"stats":{"Line":2}},{"line":511,"address":[2478661],"length":1,"stats":{"Line":2}},{"line":512,"address":[2478741],"length":1,"stats":{"Line":2}},{"line":515,"address":[2480119,2480051],"length":1,"stats":{"Line":4}},{"line":516,"address":[2480137],"length":1,"stats":{"Line":2}},{"line":518,"address":[2480239],"length":1,"stats":{"Line":0}},{"line":519,"address":[2480260],"length":1,"stats":{"Line":0}},{"line":524,"address":[2480433],"length":1,"stats":{"Line":2}},{"line":526,"address":[2480522],"length":1,"stats":{"Line":2}},{"line":528,"address":[2480688],"length":1,"stats":{"Line":0}},{"line":529,"address":[2480709],"length":1,"stats":{"Line":0}},{"line":532,"address":[2480882],"length":1,"stats":{"Line":2}},{"line":534,"address":[2480931],"length":1,"stats":{"Line":2}},{"line":536,"address":[2481097],"length":1,"stats":{"Line":0}},{"line":537,"address":[2481118],"length":1,"stats":{"Line":0}},{"line":542,"address":[2481231],"length":1,"stats":{"Line":2}},{"line":544,"address":[2481316],"length":1,"stats":{"Line":2}},{"line":546,"address":[2481418],"length":1,"stats":{"Line":0}},{"line":547,"address":[2481439],"length":1,"stats":{"Line":0}},{"line":550,"address":[2481612],"length":1,"stats":{"Line":2}},{"line":554,"address":[2481643],"length":1,"stats":{"Line":2}},{"line":558,"address":[2481684],"length":1,"stats":{"Line":2}},{"line":560,"address":[2481773],"length":1,"stats":{"Line":2}},{"line":562,"address":[2481939],"length":1,"stats":{"Line":0}},{"line":563,"address":[2481960],"length":1,"stats":{"Line":0}},{"line":566,"address":[2482133],"length":1,"stats":{"Line":2}},{"line":568,"address":[2482182],"length":1,"stats":{"Line":2}},{"line":570,"address":[2482348],"length":1,"stats":{"Line":0}},{"line":571,"address":[2482369],"length":1,"stats":{"Line":0}},{"line":576,"address":[2482503],"length":1,"stats":{"Line":2}},{"line":579,"address":[2482547],"length":1,"stats":{"Line":2}},{"line":584,"address":[2482630],"length":1,"stats":{"Line":2}},{"line":587,"address":[2482638],"length":1,"stats":{"Line":2}},{"line":591,"address":[2482831],"length":1,"stats":{"Line":2}},{"line":592,"address":[2482751],"length":1,"stats":{"Line":2}},{"line":596,"address":[2482944],"length":1,"stats":{"Line":2}},{"line":598,"address":[2482919],"length":1,"stats":{"Line":2}},{"line":604,"address":[2483008],"length":1,"stats":{"Line":2}},{"line":607,"address":[2483091],"length":1,"stats":{"Line":2}},{"line":609,"address":[2483410],"length":1,"stats":{"Line":2}},{"line":611,"address":[2479131],"length":1,"stats":{"Line":0}},{"line":612,"address":[2479152],"length":1,"stats":{"Line":0}},{"line":616,"address":[2477883],"length":1,"stats":{"Line":0}},{"line":617,"address":[2477904],"length":1,"stats":{"Line":0}},{"line":622,"address":[2490912,2492378],"length":1,"stats":{"Line":2}},{"line":623,"address":[2491453,2492400,2491211,2490953,2491366],"length":1,"stats":{"Line":10}},{"line":624,"address":[2490961],"length":1,"stats":{"Line":2}},{"line":625,"address":[2490971],"length":1,"stats":{"Line":2}},{"line":626,"address":[2490983],"length":1,"stats":{"Line":2}},{"line":627,"address":[2491009],"length":1,"stats":{"Line":2}},{"line":628,"address":[2491035],"length":1,"stats":{"Line":2}},{"line":629,"address":[2491061],"length":1,"stats":{"Line":2}},{"line":630,"address":[2491090],"length":1,"stats":{"Line":2}},{"line":631,"address":[2491114],"length":1,"stats":{"Line":2}},{"line":632,"address":[2491143],"length":1,"stats":{"Line":2}},{"line":635,"address":[2491622],"length":1,"stats":{"Line":2}},{"line":648,"address":[2491717],"length":1,"stats":{"Line":2}},{"line":649,"address":[2492301],"length":1,"stats":{"Line":2}},{"line":651,"address":[2491946,2491738,2491792,2492070],"length":1,"stats":{"Line":6}},{"line":652,"address":[2491760,2491836],"length":1,"stats":{"Line":4}},{"line":653,"address":[2492051],"length":1,"stats":{"Line":2}},{"line":658,"address":[2492650],"length":1,"stats":{"Line":2}},{"line":669,"address":[2492751],"length":1,"stats":{"Line":2}},{"line":670,"address":[2492759],"length":1,"stats":{"Line":2}},{"line":671,"address":[2492784],"length":1,"stats":{"Line":2}},{"line":672,"address":[2492809],"length":1,"stats":{"Line":2}},{"line":673,"address":[2492834],"length":1,"stats":{"Line":2}},{"line":674,"address":[2492859],"length":1,"stats":{"Line":2}},{"line":676,"address":[2492884],"length":1,"stats":{"Line":2}},{"line":677,"address":[2493053,2493567,2492905],"length":1,"stats":{"Line":5}},{"line":678,"address":[2493058],"length":1,"stats":{"Line":2}},{"line":679,"address":[2493093],"length":1,"stats":{"Line":2}},{"line":681,"address":[2493153],"length":1,"stats":{"Line":2}},{"line":682,"address":[2493498],"length":1,"stats":{"Line":2}},{"line":684,"address":[2493348],"length":1,"stats":{"Line":2}},{"line":687,"address":[2492992],"length":1,"stats":{"Line":1}},{"line":689,"address":[2492924],"length":1,"stats":{"Line":1}},{"line":693,"address":[2491347],"length":1,"stats":{"Line":2}}],"covered":183,"coverable":220},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\n\n// some internal functions take a lot of args but thats ok\n#![allow(clippy::too_many_arguments)]\n\nmod ascii_string;\n/// Implementation of the Gosling protocol\npub mod context;\n#[cfg(fuzzing)]\npub mod endpoint_client;\n#[cfg(not(fuzzing))]\nmod endpoint_client;\n#[cfg(fuzzing)]\npub mod endpoint_server;\n#[cfg(not(fuzzing))]\nmod endpoint_server;\npub(crate) mod gosling;\n#[cfg(fuzzing)]\npub mod identity_client;\n#[cfg(not(fuzzing))]\nmod identity_client;\n#[cfg(fuzzing)]\npub mod identity_server;\n#[cfg(not(fuzzing))]\nmod identity_server;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","gosling","tests","context.rs"],"content":"// standard\nuse std::io::{BufRead, BufReader, Write};\nuse std::net::TcpStream;\n\n// extern crates\nuse anyhow::bail;\nuse bson::doc;\nuse serial_test::serial;\n#[cfg(feature = \"tor-interface/legacy-tor-provider\")]\nuse tor_interface::legacy_tor_client::*;\n#[cfg(feature = \"tor-interface/mock-tor-provider\")]\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\n// internal crates\nuse gosling::context::*;\n\nconst INVALID_HANDSHAKE_HANDLE: HandshakeHandle = !0usize;\n\n#[test]\n#[cfg(feature = \"tor-interface/mock-tor-provider\")]\nfn test_mock_client_gosling_context() -\u003e anyhow::Result\u003c()\u003e {\n    let alice_tor_client = Box::new(MockTorClient::new());\n    let pat_tor_client = Box::new(MockTorClient::new());\n    gosling_context_test(alice_tor_client, pat_tor_client)\n}\n\n#[test]\n#[serial]\n#[cfg(feature = \"tor-interface/legacy-tor-provider\")]\nfn test_legacy_client_gosling_context() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(\"tor\")?;\n\n    let mut alice_path = std::env::temp_dir();\n    alice_path.push(\"test_legacy_client_gosling_context_alice\");\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path.clone(),\n        data_directory: alice_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n    let alice_tor_client = Box::new(LegacyTorClient::new(tor_config)?);\n\n    let mut pat_path = std::env::temp_dir();\n    pat_path.push(\"test_legacy_client_gosling_context_pat\");\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path,\n        data_directory: pat_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n    let pat_tor_client = Box::new(LegacyTorClient::new(tor_config)?);\n\n    gosling_context_test(alice_tor_client, pat_tor_client)\n}\n\n#[cfg(test)]\nfn gosling_context_test(\n    alice_tor_client: Box\u003cdyn TorProvider\u003e,\n    pat_tor_client: Box\u003cdyn TorProvider\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    // Bootstrap Alice\n    let alice_private_key = Ed25519PrivateKey::generate();\n    let alice_service_id = V3OnionServiceId::from_private_key(\u0026alice_private_key);\n\n    println!(\n        \"Starting Alice gosling context ({})\",\n        alice_service_id.to_string()\n    );\n\n    let mut alice = Context::new(\n        alice_tor_client,\n        420,\n        420,\n        std::time::Duration::from_secs(60),\n        4096,\n        None,\n        alice_private_key,\n    )?;\n    alice.bootstrap()?;\n\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in alice.update()?.drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Alice BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    println!(\"Alice Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived { line } =\u003e {\n                    println!(\"--- ALICE --- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // Bootstrap Pat\n    let pat_private_key = Ed25519PrivateKey::generate();\n    let pat_service_id = V3OnionServiceId::from_private_key(\u0026pat_private_key);\n\n    println!(\n        \"Starting Pat gosling context ({})\",\n        pat_service_id.to_string()\n    );\n    let mut pat = Context::new(\n        pat_tor_client,\n        420,\n        420,\n        std::time::Duration::from_secs(60),\n        4096,\n        None,\n        pat_private_key,\n    )?;\n    pat.bootstrap()?;\n\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in pat.update()?.drain(..) {\n            match event {\n                ContextEvent::TorBootstrapStatusReceived {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Pat BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                ContextEvent::TorBootstrapCompleted =\u003e {\n                    println!(\"Pat Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                ContextEvent::TorLogReceived { line } =\u003e {\n                    println!(\"--- PAT --- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // Start the Alice identity server\n    println!(\"Alice identity server starting\");\n    alice.identity_server_start()?;\n    let mut alice_identity_published: bool = false;\n\n    while !alice_identity_published {\n        for event in alice.update()?.drain(..) {\n            match event {\n                ContextEvent::IdentityServerPublished =\u003e {\n                    alice_identity_published = true;\n                    println!(\"Alice identity server published\");\n                }\n                ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n            }\n        }\n    }\n\n    // Pat begins client handshake\n    println!(\"Pat identity client handshake begin\");\n    let mut pat_identity_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    {\n        let mut pat_identity_handshake_tries_remaining = 3;\n        while pat_identity_handshake_tries_remaining \u003e 0\n            \u0026\u0026 pat_identity_handshake_handle == INVALID_HANDSHAKE_HANDLE\n        {\n            match pat.identity_client_begin_handshake(\n                alice_service_id.clone(),\n                \"test_endpoint\".to_string(),\n            ) {\n                Ok(handle) =\u003e {\n                    pat_identity_handshake_handle = handle;\n                }\n                Err(err) =\u003e {\n                    println!(\n                        \"Pat connecting to Alice's identity server failed with: {:?}\",\n                        err\n                    );\n                    pat_identity_handshake_tries_remaining -= 1;\n                }\n            }\n        }\n\n        if pat_identity_handshake_tries_remaining == 0 {\n            bail!(\"pat.identity_client_handshake() failed no more retries remain\");\n        }\n    }\n\n    // Alice waits for handshake start\n    let mut alice_identity_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    println!(\"Alice waits for identity handshake start\");\n    {\n        let mut alice_identity_server_endpoint_request_received: bool = false;\n        while !alice_identity_server_endpoint_request_received {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerHandshakeStarted { handle } =\u003e {\n                        alice_identity_handshake_handle = handle;\n                        println!(\"Pat has connected to Alice identity server\");\n                    }\n                    ContextEvent::IdentityServerEndpointRequestReceived {\n                        handle,\n                        client_service_id,\n                        requested_endpoint,\n                    } =\u003e {\n                        assert_eq!(alice_identity_handshake_handle, handle);\n                        assert_eq!(pat_service_id, client_service_id);\n                        assert_eq!(requested_endpoint, \"test_endpoint\");\n                        alice_identity_server_endpoint_request_received = true;\n                        println!(\"Alice receives initial identity handshake request\");\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n    }\n\n    // Alice sends challenge\n    println!(\"Alice sends identity server challenge\");\n    alice.identity_server_handle_endpoint_request_received(\n        alice_identity_handshake_handle,\n        true,\n        true,\n        doc! {},\n    )?;\n\n    // Pat responds to challenge\n    println!(\"Pat waits for server challenge\");\n    {\n        let mut pat_identity_client_challenge: Option\u003cbson::document::Document\u003e = None;\n        while pat_identity_client_challenge.is_none() {\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityClientChallengeReceived {\n                        handle,\n                        endpoint_challenge,\n                    } =\u003e {\n                        assert_eq!(handle, pat_identity_handshake_handle);\n                        pat_identity_client_challenge = Some(endpoint_challenge);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        println!(\"Pat responds to challenge\");\n        if let Some(challenge) = pat_identity_client_challenge {\n            assert_eq!(challenge, doc! {});\n            // send empty doc in response\n            pat.identity_client_handle_challenge_received(pat_identity_handshake_handle, doc! {})?;\n        } else {\n            bail!(\"missing pat_identity_client_challenge\");\n        }\n    }\n\n    // Alice evaluate challenge response\n    println!(\"Alice awaits challenge response\");\n    {\n        let mut alice_identity_server_challenge_response: Option\u003cbson::document::Document\u003e = None;\n        while alice_identity_server_challenge_response.is_none() {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerChallengeResponseReceived {\n                        handle,\n                        challenge_response,\n                    } =\u003e {\n                        assert_eq!(handle, alice_identity_handshake_handle);\n                        alice_identity_server_challenge_response = Some(challenge_response);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n        println!(\"Alice evaluates challenge response\");\n        if let Some(challenge_response) = alice_identity_server_challenge_response {\n            assert_eq!(challenge_response, doc! {});\n            println!(\"Alice accepts challenge response\");\n            alice.identity_server_handle_challenge_response_received(\n                alice_identity_handshake_handle,\n                true,\n            )?;\n        } else {\n            bail!(\"missing challenge response\");\n        }\n    }\n\n    // Alice and Pat awaits handshake results\n    println!(\"Identity handshake completing\");\n    let (\n        alice_endpoint_private_key,\n        alice_endpoint_service_id,\n        pat_auth_private_key,\n        pat_auth_public_key,\n    ) = {\n        let mut alice_endpoint_private_key: Option\u003cEd25519PrivateKey\u003e = None;\n        let mut alice_endpoint_service_id: Option\u003cV3OnionServiceId\u003e = None;\n        let mut pat_auth_private_key: Option\u003cX25519PrivateKey\u003e = None;\n        let mut pat_auth_public_key: Option\u003cX25519PublicKey\u003e = None;\n\n        let mut pat_identity_client_handshake_completed: bool = false;\n        let mut alice_identity_server_hanshake_completed: bool = false;\n        while !pat_identity_client_handshake_completed || !alice_identity_server_hanshake_completed\n        {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityServerHandshakeCompleted {\n                        handle,\n                        endpoint_private_key,\n                        endpoint_name,\n                        client_service_id,\n                        client_auth_public_key,\n                    } =\u003e {\n                        assert_eq!(handle, alice_identity_handshake_handle);\n                        alice_endpoint_private_key = Some(endpoint_private_key);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        assert_eq!(client_service_id, pat_service_id);\n                        pat_auth_public_key = Some(client_auth_public_key);\n                        alice_identity_server_hanshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::IdentityClientHandshakeCompleted {\n                        handle,\n                        identity_service_id,\n                        endpoint_service_id,\n                        endpoint_name,\n                        client_auth_private_key,\n                    } =\u003e {\n                        assert_eq!(handle, pat_identity_handshake_handle);\n                        assert_eq!(identity_service_id, alice_service_id);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        alice_endpoint_service_id = Some(endpoint_service_id);\n                        pat_auth_private_key = Some(client_auth_private_key);\n                        pat_identity_client_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        // verify the private key returned by alice matches service id returned by pat\n        assert_eq!(\n            V3OnionServiceId::from_private_key(alice_endpoint_private_key.as_ref().unwrap()),\n            *alice_endpoint_service_id.as_ref().unwrap()\n        );\n\n        (\n            alice_endpoint_private_key.unwrap(),\n            alice_endpoint_service_id.unwrap(),\n            pat_auth_private_key.unwrap(),\n            pat_auth_public_key.unwrap(),\n        )\n    };\n\n    // Alice starts endpoint server\n    println!(\"Alice endpoint server starting\");\n    alice.endpoint_server_start(\n        alice_endpoint_private_key,\n        \"test_endpoint\".to_string(),\n        pat_service_id.clone(),\n        pat_auth_public_key.clone(),\n    )?;\n    {\n        let mut alice_endpoint_server_published: bool = false;\n        while !alice_endpoint_server_published {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerPublished {\n                        endpoint_service_id,\n                        endpoint_name,\n                    } =\u003e {\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(endpoint_name, \"test_endpoint\");\n                        println!(\"Alice endpoint server published\");\n                        alice_endpoint_server_published = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n    }\n\n    // Pat begins client handshake\n    println!(\"Pat endpoint client handshake begin\");\n    let mut pat_endpoint_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    {\n        let mut pat_endpoint_handshake_tries_remaining = 3;\n        while pat_endpoint_handshake_tries_remaining \u003e 0\n            \u0026\u0026 pat_endpoint_handshake_handle == INVALID_HANDSHAKE_HANDLE\n        {\n            match pat.endpoint_client_begin_handshake(\n                alice_endpoint_service_id.clone(),\n                pat_auth_private_key.clone(),\n                \"test_channel\".to_string(),\n            ) {\n                Ok(handle) =\u003e {\n                    pat_endpoint_handshake_handle = handle;\n                }\n                Err(err) =\u003e {\n                    println!(\n                        \"Pat connecting to Alice's identity server failed with:\\n{:?}\",\n                        err\n                    );\n                    pat_endpoint_handshake_tries_remaining -= 1;\n                }\n            }\n        }\n\n        if pat_endpoint_handshake_tries_remaining == 0 {\n            bail!(\"pat.endpoint_client_begin_handshake() failed no more retries remain\");\n        }\n    }\n\n    // Alice waits for handshake start\n    let mut alice_endpoint_server_handshake_handle: HandshakeHandle = INVALID_HANDSHAKE_HANDLE;\n    println!(\"Alice waits for endpoint handshake to start\");\n    {\n        let mut alice_endpoint_server_request_recieved: bool = false;\n        while !alice_endpoint_server_request_recieved {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerHandshakeStarted { handle } =\u003e {\n                        alice_endpoint_server_handshake_handle = handle;\n                        println!(\"Pat has connected to Alice endpoint server\")\n                    }\n                    ContextEvent::EndpointServerChannelRequestReceived {\n                        handle,\n                        client_service_id,\n                        requested_channel,\n                    } =\u003e {\n                        assert_eq!(handle, alice_endpoint_server_handshake_handle);\n                        assert_eq!(client_service_id, pat_service_id);\n                        assert_eq!(requested_channel, \"test_channel\");\n                        alice_endpoint_server_request_recieved = true;\n                        println!(\"Pat requesting '{0}' endpoint channel\", requested_channel);\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"alice.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    evt =\u003e bail!(\"pat.update() returned unexpected event: {:?}\", evt),\n                }\n            }\n        }\n\n        // Alice sends handshake response\n        println!(\"Alice sends endpoint handshake response\");\n        alice.endpoint_server_handle_channel_request_received(\n            alice_endpoint_server_handshake_handle,\n            true,\n        )?;\n    }\n\n    // Alice and Pat await hndshake result\n    println!(\"Endpoint handshake completing\");\n    let (alice_server_stream, mut pat_client_stream) = {\n        let mut alice_server_stream: Option\u003cTcpStream\u003e = None;\n        let mut pat_client_stream: Option\u003cTcpStream\u003e = None;\n\n        let mut pat_endpoint_client_handshake_completed: bool = false;\n        let mut alice_endpoint_server_handshake_completed: bool = false;\n\n        while !pat_endpoint_client_handshake_completed || !alice_endpoint_server_handshake_completed\n        {\n            for event in alice.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointServerHandshakeCompleted {\n                        handle,\n                        endpoint_service_id,\n                        client_service_id,\n                        channel_name,\n                        stream,\n                    } =\u003e {\n                        assert_eq!(handle, alice_endpoint_server_handshake_handle);\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(client_service_id, pat_service_id);\n                        assert_eq!(channel_name, \"test_channel\");\n                        alice_server_stream = Some(stream);\n                        alice_endpoint_server_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    event =\u003e bail!(\"alice.update() returned unexepcted event: {:?}\", event),\n                }\n            }\n            for event in pat.update()?.drain(..) {\n                match event {\n                    ContextEvent::EndpointClientHandshakeCompleted {\n                        handle,\n                        endpoint_service_id,\n                        channel_name,\n                        stream,\n                    } =\u003e {\n                        assert_eq!(handle, pat_endpoint_handshake_handle);\n                        assert_eq!(endpoint_service_id, alice_endpoint_service_id);\n                        assert_eq!(channel_name, \"test_channel\");\n                        pat_client_stream = Some(stream);\n                        pat_endpoint_client_handshake_completed = true;\n                    }\n                    ContextEvent::TorLogReceived { line: _ } =\u003e (),\n                    event =\u003e bail!(\"pat.update() returned unexepcted event: {:?}\", event),\n                }\n            }\n        }\n        (alice_server_stream.unwrap(), pat_client_stream.unwrap())\n    };\n\n    println!(\"Endpoint handshake complete, TcpStreams returned\");\n\n    pat_client_stream.write(b\"Hello World!\\n\")?;\n    pat_client_stream.flush()?;\n\n    alice_server_stream.set_nonblocking(false)?;\n    let mut alice_reader = BufReader::new(alice_server_stream);\n\n    let mut response: String = Default::default();\n    alice_reader.read_line(\u0026mut response)?;\n\n    assert_eq!(response, \"Hello World!\\n\");\n\n    println!(\"TcpStream communication succesful\");\n\n    Ok(())\n}\n","traces":[{"line":63,"address":[1604128,1643976,1607533],"length":1,"stats":{"Line":0}},{"line":68,"address":[1604197],"length":1,"stats":{"Line":0}},{"line":69,"address":[1604585],"length":1,"stats":{"Line":0}},{"line":71,"address":[1604781],"length":1,"stats":{"Line":0}},{"line":77,"address":[1604913],"length":1,"stats":{"Line":0}},{"line":80,"address":[1604966],"length":1,"stats":{"Line":0}},{"line":82,"address":[1605029],"length":1,"stats":{"Line":0}},{"line":83,"address":[1605040],"length":1,"stats":{"Line":0}},{"line":85,"address":[1605607,1605653,1605364,1643803],"length":1,"stats":{"Line":0}},{"line":87,"address":[1605640],"length":1,"stats":{"Line":0}},{"line":88,"address":[1605648,1605814],"length":1,"stats":{"Line":0}},{"line":89,"address":[1605889,1607943,1606382,1605824,1606329,1606233,1607870],"length":1,"stats":{"Line":0}},{"line":90,"address":[1606436],"length":1,"stats":{"Line":0}},{"line":91,"address":[1606703],"length":1,"stats":{"Line":0}},{"line":99,"address":[1607569],"length":1,"stats":{"Line":0}},{"line":100,"address":[1606858,1607542],"length":1,"stats":{"Line":0}},{"line":101,"address":[1607561],"length":1,"stats":{"Line":0}},{"line":103,"address":[1606887],"length":1,"stats":{"Line":0}},{"line":104,"address":[1607618],"length":1,"stats":{"Line":0}},{"line":112,"address":[1605851],"length":1,"stats":{"Line":0}},{"line":113,"address":[1607973],"length":1,"stats":{"Line":0}},{"line":115,"address":[1608172],"length":1,"stats":{"Line":0}},{"line":120,"address":[1608304],"length":1,"stats":{"Line":0}},{"line":123,"address":[1608357],"length":1,"stats":{"Line":0}},{"line":125,"address":[1608420],"length":1,"stats":{"Line":0}},{"line":126,"address":[1608431],"length":1,"stats":{"Line":0}},{"line":128,"address":[1609044,1608755,1643707,1608998],"length":1,"stats":{"Line":0}},{"line":130,"address":[1609031],"length":1,"stats":{"Line":0}},{"line":131,"address":[1609205,1609039],"length":1,"stats":{"Line":0}},{"line":132,"address":[1609215,1609727,1611256,1611329,1609287,1609631,1609780],"length":1,"stats":{"Line":0}},{"line":133,"address":[1609834],"length":1,"stats":{"Line":0}},{"line":134,"address":[1610031],"length":1,"stats":{"Line":0}},{"line":142,"address":[1610958],"length":1,"stats":{"Line":0}},{"line":143,"address":[1610931,1610256],"length":1,"stats":{"Line":0}},{"line":144,"address":[1610950],"length":1,"stats":{"Line":0}},{"line":146,"address":[1610285],"length":1,"stats":{"Line":0}},{"line":147,"address":[1611004],"length":1,"stats":{"Line":0}},{"line":155,"address":[1609242,1611359],"length":1,"stats":{"Line":0}},{"line":156,"address":[1611378,1611467,1643686],"length":1,"stats":{"Line":0}},{"line":157,"address":[1611454],"length":1,"stats":{"Line":0}},{"line":159,"address":[1611628,1611462],"length":1,"stats":{"Line":0}},{"line":160,"address":[1612593,1612849,1612054,1611638,1611710,1612150,1612200],"length":1,"stats":{"Line":0}},{"line":161,"address":[1612238],"length":1,"stats":{"Line":0}},{"line":163,"address":[1612489],"length":1,"stats":{"Line":0}},{"line":164,"address":[1612497,1612564],"length":1,"stats":{"Line":0}},{"line":167,"address":[1612337,1612598],"length":1,"stats":{"Line":0}},{"line":173,"address":[1611665,1612862],"length":1,"stats":{"Line":0}},{"line":174,"address":[1612881],"length":1,"stats":{"Line":0}},{"line":176,"address":[1612893],"length":1,"stats":{"Line":0}},{"line":177,"address":[1612904],"length":1,"stats":{"Line":0}},{"line":178,"address":[1612926],"length":1,"stats":{"Line":0}},{"line":180,"address":[1643273],"length":1,"stats":{"Line":0}},{"line":181,"address":[1612953],"length":1,"stats":{"Line":0}},{"line":182,"address":[1643246],"length":1,"stats":{"Line":0}},{"line":184,"address":[1643342],"length":1,"stats":{"Line":0}},{"line":185,"address":[1643358],"length":1,"stats":{"Line":0}},{"line":187,"address":[1643371],"length":1,"stats":{"Line":0}},{"line":188,"address":[1643537],"length":1,"stats":{"Line":0}},{"line":192,"address":[1643657,1643606],"length":1,"stats":{"Line":0}},{"line":197,"address":[1612914],"length":1,"stats":{"Line":0}},{"line":198,"address":[1612963,1613035],"length":1,"stats":{"Line":0}},{"line":203,"address":[1612989],"length":1,"stats":{"Line":0}},{"line":204,"address":[1613001,1613079],"length":1,"stats":{"Line":0}},{"line":206,"address":[1613098],"length":1,"stats":{"Line":0}},{"line":207,"address":[1613106],"length":1,"stats":{"Line":0}},{"line":208,"address":[1613188,1613116,1613532,1615750,1616072,1613681,1613628],"length":1,"stats":{"Line":0}},{"line":209,"address":[1613719],"length":1,"stats":{"Line":0}},{"line":210,"address":[1615024],"length":1,"stats":{"Line":0}},{"line":211,"address":[1615040],"length":1,"stats":{"Line":0}},{"line":212,"address":[1615048,1615268],"length":1,"stats":{"Line":0}},{"line":214,"address":[1615123],"length":1,"stats":{"Line":0}},{"line":219,"address":[1615171,1615292],"length":1,"stats":{"Line":0}},{"line":220,"address":[1615370,1615461],"length":1,"stats":{"Line":0}},{"line":221,"address":[1615541],"length":1,"stats":{"Line":0}},{"line":222,"address":[1615659],"length":1,"stats":{"Line":0}},{"line":223,"address":[1615667],"length":1,"stats":{"Line":0}},{"line":226,"address":[1614842,1615774],"length":1,"stats":{"Line":0}},{"line":229,"address":[1613838,1614371,1614829,1614225,1614321],"length":1,"stats":{"Line":0}},{"line":230,"address":[1614397],"length":1,"stats":{"Line":0}},{"line":232,"address":[1614483,1614605],"length":1,"stats":{"Line":0}},{"line":239,"address":[1613143,1616085],"length":1,"stats":{"Line":0}},{"line":240,"address":[1616147,1643233,1616397],"length":1,"stats":{"Line":0}},{"line":241,"address":[1616104],"length":1,"stats":{"Line":0}},{"line":244,"address":[1616120],"length":1,"stats":{"Line":0}},{"line":248,"address":[1616430,1616240],"length":1,"stats":{"Line":0}},{"line":250,"address":[1616449],"length":1,"stats":{"Line":0}},{"line":251,"address":[1616570,1616483],"length":1,"stats":{"Line":0}},{"line":252,"address":[1640848,1616602,1640411,1642761,1643134,1640752,1640898],"length":1,"stats":{"Line":0}},{"line":253,"address":[1640936],"length":1,"stats":{"Line":0}},{"line":254,"address":[1642203],"length":1,"stats":{"Line":0}},{"line":258,"address":[1642257],"length":1,"stats":{"Line":0}},{"line":259,"address":[1642640,1642380],"length":1,"stats":{"Line":0}},{"line":262,"address":[1642021,1642823],"length":1,"stats":{"Line":0}},{"line":265,"address":[1641413,1642008,1641029,1641559,1641509],"length":1,"stats":{"Line":0}},{"line":266,"address":[1641585],"length":1,"stats":{"Line":0}},{"line":268,"address":[1641793,1641671],"length":1,"stats":{"Line":0}},{"line":273,"address":[1616632,1616576],"length":1,"stats":{"Line":0}},{"line":274,"address":[1616651],"length":1,"stats":{"Line":0}},{"line":275,"address":[1616790,1616890],"length":1,"stats":{"Line":0}},{"line":277,"address":[1617219,1640281,1617070],"length":1,"stats":{"Line":0}},{"line":279,"address":[1640360,1616809],"length":1,"stats":{"Line":0}},{"line":284,"address":[1617388],"length":1,"stats":{"Line":0}},{"line":286,"address":[1617433],"length":1,"stats":{"Line":0}},{"line":287,"address":[1617467,1617554],"length":1,"stats":{"Line":0}},{"line":288,"address":[1637893,1640182,1637797,1617586,1637453,1637943,1639806],"length":1,"stats":{"Line":0}},{"line":289,"address":[1637981],"length":1,"stats":{"Line":0}},{"line":290,"address":[1639264],"length":1,"stats":{"Line":0}},{"line":294,"address":[1639302],"length":1,"stats":{"Line":0}},{"line":295,"address":[1639685,1639425],"length":1,"stats":{"Line":0}},{"line":298,"address":[1639868,1639066],"length":1,"stats":{"Line":0}},{"line":301,"address":[1639053,1638074,1638554,1638604,1638458],"length":1,"stats":{"Line":0}},{"line":302,"address":[1638630],"length":1,"stats":{"Line":0}},{"line":304,"address":[1638716,1638838],"length":1,"stats":{"Line":0}},{"line":308,"address":[1617616,1617560],"length":1,"stats":{"Line":0}},{"line":309,"address":[1617635],"length":1,"stats":{"Line":0}},{"line":310,"address":[1617774,1617874],"length":1,"stats":{"Line":0}},{"line":311,"address":[1618054],"length":1,"stats":{"Line":0}},{"line":312,"address":[1618338,1637317,1618107],"length":1,"stats":{"Line":0}},{"line":313,"address":[1618099],"length":1,"stats":{"Line":0}},{"line":317,"address":[1637396,1617793],"length":1,"stats":{"Line":0}},{"line":322,"address":[1618379],"length":1,"stats":{"Line":0}},{"line":324,"address":[1624333],"length":1,"stats":{"Line":0}},{"line":325,"address":[1624351],"length":1,"stats":{"Line":0}},{"line":326,"address":[1624415],"length":1,"stats":{"Line":0}},{"line":327,"address":[1624447],"length":1,"stats":{"Line":0}},{"line":329,"address":[1618424],"length":1,"stats":{"Line":0}},{"line":330,"address":[1618444],"length":1,"stats":{"Line":0}},{"line":331,"address":[1618452],"length":1,"stats":{"Line":0}},{"line":332,"address":[1618468],"length":1,"stats":{"Line":0}},{"line":334,"address":[1618476],"length":1,"stats":{"Line":0}},{"line":335,"address":[1618484],"length":1,"stats":{"Line":0}},{"line":336,"address":[1618529,1618492],"length":1,"stats":{"Line":0}},{"line":338,"address":[1618626,1618502,1618970,1622746,1623128,1619116,1619066],"length":1,"stats":{"Line":0}},{"line":339,"address":[1619154],"length":1,"stats":{"Line":0}},{"line":340,"address":[1621727],"length":1,"stats":{"Line":0}},{"line":347,"address":[1621926],"length":1,"stats":{"Line":0}},{"line":348,"address":[1622049,1622220],"length":1,"stats":{"Line":0}},{"line":349,"address":[1622324],"length":1,"stats":{"Line":0}},{"line":350,"address":[1622450],"length":1,"stats":{"Line":0}},{"line":351,"address":[1622570],"length":1,"stats":{"Line":0}},{"line":352,"address":[1622656],"length":1,"stats":{"Line":0}},{"line":355,"address":[1622808,1621545],"length":1,"stats":{"Line":0}},{"line":358,"address":[1621535,1619640,1619253,1619786,1619736,1621160],"length":1,"stats":{"Line":0}},{"line":359,"address":[1619824],"length":1,"stats":{"Line":0}},{"line":360,"address":[1620229],"length":1,"stats":{"Line":0}},{"line":367,"address":[1620301],"length":1,"stats":{"Line":0}},{"line":368,"address":[1620432,1620518],"length":1,"stats":{"Line":0}},{"line":369,"address":[1620601],"length":1,"stats":{"Line":0}},{"line":370,"address":[1620719],"length":1,"stats":{"Line":0}},{"line":371,"address":[1620855],"length":1,"stats":{"Line":0}},{"line":372,"address":[1621065],"length":1,"stats":{"Line":0}},{"line":375,"address":[1621222,1619923],"length":1,"stats":{"Line":0}},{"line":381,"address":[1623330],"length":1,"stats":{"Line":0}},{"line":387,"address":[1623566],"length":1,"stats":{"Line":0}},{"line":388,"address":[1623661],"length":1,"stats":{"Line":0}},{"line":389,"address":[1623801],"length":1,"stats":{"Line":0}},{"line":390,"address":[1623937],"length":1,"stats":{"Line":0}},{"line":395,"address":[1624479,1624549],"length":1,"stats":{"Line":0}},{"line":396,"address":[1637177,1624774,1624881,1625055],"length":1,"stats":{"Line":0}},{"line":397,"address":[1624568],"length":1,"stats":{"Line":0}},{"line":398,"address":[1624682,1624614],"length":1,"stats":{"Line":0}},{"line":399,"address":[1624706],"length":1,"stats":{"Line":0}},{"line":400,"address":[1624767],"length":1,"stats":{"Line":0}},{"line":403,"address":[1624914],"length":1,"stats":{"Line":0}},{"line":404,"address":[1624922,1625088],"length":1,"stats":{"Line":0}},{"line":405,"address":[1626505,1626843,1625514,1625098,1625610,1625660,1625170],"length":1,"stats":{"Line":0}},{"line":406,"address":[1625698],"length":1,"stats":{"Line":0}},{"line":407,"address":[1626043],"length":1,"stats":{"Line":0}},{"line":411,"address":[1626083,1626172],"length":1,"stats":{"Line":0}},{"line":412,"address":[1626255],"length":1,"stats":{"Line":0}},{"line":413,"address":[1626373],"length":1,"stats":{"Line":0}},{"line":414,"address":[1626418],"length":1,"stats":{"Line":0}},{"line":417,"address":[1626529,1625797],"length":1,"stats":{"Line":0}},{"line":424,"address":[1626853,1625125],"length":1,"stats":{"Line":0}},{"line":425,"address":[1626872],"length":1,"stats":{"Line":0}},{"line":427,"address":[1626884],"length":1,"stats":{"Line":0}},{"line":428,"address":[1626895],"length":1,"stats":{"Line":0}},{"line":429,"address":[1626917],"length":1,"stats":{"Line":0}},{"line":431,"address":[1636779,1636712],"length":1,"stats":{"Line":0}},{"line":432,"address":[1626944],"length":1,"stats":{"Line":0}},{"line":433,"address":[1636629],"length":1,"stats":{"Line":0}},{"line":434,"address":[1636644],"length":1,"stats":{"Line":0}},{"line":436,"address":[1636805],"length":1,"stats":{"Line":0}},{"line":437,"address":[1636821],"length":1,"stats":{"Line":0}},{"line":439,"address":[1636834],"length":1,"stats":{"Line":0}},{"line":440,"address":[1637000],"length":1,"stats":{"Line":0}},{"line":444,"address":[1637069,1637126],"length":1,"stats":{"Line":0}},{"line":449,"address":[1626905],"length":1,"stats":{"Line":0}},{"line":450,"address":[1627026,1626954],"length":1,"stats":{"Line":0}},{"line":455,"address":[1626980],"length":1,"stats":{"Line":0}},{"line":456,"address":[1627070,1626992],"length":1,"stats":{"Line":0}},{"line":458,"address":[1627089],"length":1,"stats":{"Line":0}},{"line":459,"address":[1627097],"length":1,"stats":{"Line":0}},{"line":460,"address":[1629863,1627619,1627179,1627107,1627672,1630185,1627523],"length":1,"stats":{"Line":0}},{"line":461,"address":[1627710],"length":1,"stats":{"Line":0}},{"line":462,"address":[1629015],"length":1,"stats":{"Line":0}},{"line":463,"address":[1629031],"length":1,"stats":{"Line":0}},{"line":464,"address":[1629259,1629039],"length":1,"stats":{"Line":0}},{"line":466,"address":[1629114],"length":1,"stats":{"Line":0}},{"line":471,"address":[1629162,1629283],"length":1,"stats":{"Line":0}},{"line":472,"address":[1629453,1629364],"length":1,"stats":{"Line":0}},{"line":473,"address":[1629536],"length":1,"stats":{"Line":0}},{"line":474,"address":[1629654],"length":1,"stats":{"Line":0}},{"line":475,"address":[1629756],"length":1,"stats":{"Line":0}},{"line":478,"address":[1629887,1628833],"length":1,"stats":{"Line":0}},{"line":481,"address":[1627829,1628362,1628312,1628216,1628820],"length":1,"stats":{"Line":0}},{"line":482,"address":[1628388],"length":1,"stats":{"Line":0}},{"line":484,"address":[1628474,1628596],"length":1,"stats":{"Line":0}},{"line":490,"address":[1627134,1630198],"length":1,"stats":{"Line":0}},{"line":491,"address":[1636600,1630463,1630225],"length":1,"stats":{"Line":0}},{"line":492,"address":[1630217],"length":1,"stats":{"Line":0}},{"line":498,"address":[1630306,1630496],"length":1,"stats":{"Line":0}},{"line":499,"address":[1635059],"length":1,"stats":{"Line":0}},{"line":500,"address":[1630515],"length":1,"stats":{"Line":0}},{"line":501,"address":[1630534],"length":1,"stats":{"Line":0}},{"line":503,"address":[1630553],"length":1,"stats":{"Line":0}},{"line":504,"address":[1630561],"length":1,"stats":{"Line":0}},{"line":506,"address":[1630569,1630609],"length":1,"stats":{"Line":0}},{"line":508,"address":[1630761,1631105,1634439,1630579,1631201,1631251,1634799],"length":1,"stats":{"Line":0}},{"line":509,"address":[1631289],"length":1,"stats":{"Line":0}},{"line":510,"address":[1633668],"length":1,"stats":{"Line":0}},{"line":517,"address":[1633690],"length":1,"stats":{"Line":0}},{"line":518,"address":[1633907,1633821],"length":1,"stats":{"Line":0}},{"line":519,"address":[1633990],"length":1,"stats":{"Line":0}},{"line":520,"address":[1634118],"length":1,"stats":{"Line":0}},{"line":521,"address":[1634236],"length":1,"stats":{"Line":0}},{"line":522,"address":[1634344],"length":1,"stats":{"Line":0}},{"line":525,"address":[1634501,1633362],"length":1,"stats":{"Line":0}},{"line":528,"address":[1631388,1633352,1631921,1632977,1631871,1631775],"length":1,"stats":{"Line":0}},{"line":529,"address":[1631959],"length":1,"stats":{"Line":0}},{"line":530,"address":[1632334],"length":1,"stats":{"Line":0}},{"line":536,"address":[1632356],"length":1,"stats":{"Line":0}},{"line":537,"address":[1632487,1632573],"length":1,"stats":{"Line":0}},{"line":538,"address":[1632656],"length":1,"stats":{"Line":0}},{"line":539,"address":[1632774],"length":1,"stats":{"Line":0}},{"line":540,"address":[1632882],"length":1,"stats":{"Line":0}},{"line":543,"address":[1633039,1632058],"length":1,"stats":{"Line":0}},{"line":547,"address":[1634985,1630619,1634896],"length":1,"stats":{"Line":0}},{"line":550,"address":[1635081,1635151],"length":1,"stats":{"Line":0}},{"line":552,"address":[1635342,1636482,1635170],"length":1,"stats":{"Line":0}},{"line":553,"address":[1636464,1635484,1635391,1635327],"length":1,"stats":{"Line":0}},{"line":555,"address":[1635455,1636446,1604165,1635627,1635533],"length":1,"stats":{"Line":0}},{"line":556,"address":[1635597],"length":1,"stats":{"Line":0}},{"line":558,"address":[1635676],"length":1,"stats":{"Line":0}},{"line":559,"address":[1635819,1636377,1635950,1635739],"length":1,"stats":{"Line":0}},{"line":561,"address":[1635913,1635998],"length":1,"stats":{"Line":0}},{"line":563,"address":[1636072],"length":1,"stats":{"Line":0}},{"line":565,"address":[1636117],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":248},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","fuzz","fuzz_targets","fuzz_session.rs"],"content":"#![no_main]\n\n// std\nuse std::collections::{BTreeSet, VecDeque};\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// honk_rpc\nuse honk_rpc::honk_rpc::{ApiSet, Error, ErrorCode, RequestCookie, Response, Session};\n\n// extern\nuse bson::Bson;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\n#[derive(Arbitrary, Debug)]\nenum SessionMethod {\n    Update,\n    ClientCallSync,\n    ClientCallAsync {\n        // the number of update calls the ApiSet should wait before returning\n        wait_count: u8,\n    },\n    ClientCallInvalid{\n        namespace: Option\u003cString\u003e,\n        function: Option\u003cString\u003e,\n        version: Option\u003ci32\u003e,\n        // arguments: Option\u003cbson::document::Document\u003e,\n    },\n    ClientDrainResponses,\n}\n\n\n#[derive(Default)]\nstruct TestApiSet {\n    pending_async_calls: Vec\u003c(u8, RequestCookie)\u003e,\n    complete_async_calls: VecDeque\u003cRequestCookie\u003e,\n}\n\n// impl ApiSet\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"fuzzing\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        mut args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        match (name, version) {\n            (\"sync_call\", 0) =\u003e Some(Ok(Some(bson::Bson::Null))),\n            (\"sync_call\", _) =\u003e Some(Err(ErrorCode::RequestVersionInvalid)),\n            (\"async_call\", 0) =\u003e {\n                if let Some(request_cookie) = request_cookie {\n                    if let Some(bson::Bson::Int32(val)) = args.get_mut(\"wait_count\") {\n                        let \u0026mut val = val;\n                        let wait_count = val.clamp(0, 255) as u8;\n                        self.pending_async_calls.push((wait_count, request_cookie));\n                    }\n                }\n                None\n            },\n            (\"async_call\", _) =\u003e Some(Err(ErrorCode::RequestVersionInvalid)),\n            _ =\u003e Some(Err(ErrorCode::RequestFunctionInvalid)),\n        }\n    }\n\n    fn update(\u0026mut self) -\u003e () {\n        self.pending_async_calls.retain_mut(|record| -\u003e bool {\n            if record.0 == 0 {\n                self.complete_async_calls.push_back(record.1);\n                false\n            } else {\n                record.0 -= 1;\n                true\n            }\n        });\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e)\u003e {\n        match self.complete_async_calls.pop_front() {\n            Some(cookie) =\u003e Some((cookie, Ok(Some(bson::Bson::Null)))),\n            None =\u003e None\n        }\n    }\n}\n\n\nstruct Context {\n    session: Session\u003cTcpStream\u003e,\n    apiset: TestApiSet,\n    pending_successes: BTreeSet\u003cRequestCookie\u003e,\n    pending_failures: BTreeSet\u003cRequestCookie\u003e,\n}\n\nimpl Context {\n    fn new(session: Session\u003cTcpStream\u003e) -\u003e Context {\n        Context{session, apiset: Default::default(), pending_successes: Default::default(), pending_failures: Default::default()}\n    }\n}\n\nfuzz_target!(|methods: Vec\u003cSessionMethod\u003e| {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr).unwrap();\n    let socket_addr = listener.local_addr().unwrap();\n\n    let alice_stream = TcpStream::connect(socket_addr).unwrap();\n    alice_stream.set_nonblocking(true).unwrap();\n\n    let (pat_stream, _socket_addr) = listener.accept().unwrap();\n    pat_stream.set_nonblocking(true).unwrap();\n\n    let alice = Session::new(alice_stream);\n    let pat = Session::new(pat_stream);\n\n    let mut current = \u0026mut Context::new(alice);\n    let mut next = \u0026mut Context::new(pat);\n\n    // run the methods on our pair of HonkRpc Sessions\n    for method in methods {\n        match method {\n            SessionMethod::Update =\u003e match current.session.update(Some(\u0026mut [\u0026mut current.apiset])) {\n                Ok(()) =\u003e {},\n                Err(Error::MessageConversionFailed(ErrorCode::RequestFunctionInvalid)) =\u003e {},\n                Err(error) =\u003e panic!(\"{:?}\", error),\n            },\n            SessionMethod::ClientCallSync =\u003e {\n                let cookie = current.session.client_call(\"fuzzing\", \"sync_call\", 0, bson::doc!{}).unwrap();\n                assert!(current.pending_successes.insert(cookie));\n            }\n            SessionMethod::ClientCallAsync{wait_count} =\u003e {\n                let cookie = current.session.client_call(\"fuzzing\", \"async_call\", 0, bson::doc!{\"wait_count\" : Bson::Int32(wait_count as i32)}).unwrap();\n                assert!(current.pending_successes.insert(cookie));\n            }\n            SessionMethod::ClientCallInvalid{namespace,function,version} =\u003e {\n                // ensure invalid namespace\n                let namespace = match namespace {\n                    Some(namespace) =\u003e namespace,\n                    None =\u003e \"invalid\".to_string(),\n                };\n                let namespace = match namespace.as_str() {\n                    \"fuzzing\" =\u003e \"invalid\",\n                    namespace =\u003e namespace,\n                };\n\n                // ensure invalid function name\n                let function = match function {\n                    Some(function) =\u003e function,\n                    None =\u003e \"invalid\".to_string(),\n                };\n                let function = match function.as_str() {\n                    \"sync_call\" =\u003e \"invalid\",\n                    \"async_call\" =\u003e \"invalid\",\n                    function =\u003e function,\n                };\n\n                // ensure invalid function version\n                let version = match version {\n                    Some(0) =\u003e 1,\n                    Some(version) =\u003e version,\n                    None =\u003e 1,\n                };\n\n                let cookie = current.session.client_call(namespace, function, version, bson::doc!{}).unwrap();\n                assert!(current.pending_failures.insert(cookie));\n            }\n            SessionMethod::ClientDrainResponses =\u003e {\n                for response in current.session.client_drain_responses() {\n                    match response {\n                        Response::Pending{cookie} =\u003e assert!(current.pending_successes.contains(\u0026cookie) || current.pending_failures.contains(\u0026cookie)),\n                        Response::Success{cookie, result: _} =\u003e assert!(current.pending_successes.remove(\u0026cookie)),\n                        Response::Error{cookie, error_code} =\u003e {\n                            assert!(current.pending_failures.remove(\u0026cookie));\n                            assert!(error_code == ErrorCode::RequestNamespaceInvalid ||\n                                    error_code == ErrorCode::RequestFunctionInvalid ||\n                                    error_code == ErrorCode::RequestVersionInvalid);\n                        }\n                    }\n                }\n            },\n        }\n        std::mem::swap(\u0026mut current, \u0026mut next);\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","byte_counter.rs"],"content":"use std::io::Write;\n\n#[derive(Default)]\npub(crate) struct ByteCounter {\n    bytes: usize,\n}\n\nimpl ByteCounter {\n    pub fn bytes(\u0026self) -\u003e usize {\n        self.bytes\n    }\n}\n\nimpl Write for ByteCounter {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.bytes += buf.len();\n        Ok(buf.len())\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), std::io::Error\u003e {\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[14529472],"length":1,"stats":{"Line":5}},{"line":10,"address":[544021],"length":1,"stats":{"Line":5}},{"line":15,"address":[16360704],"length":1,"stats":{"Line":5}},{"line":16,"address":[544061,544121],"length":1,"stats":{"Line":5}},{"line":17,"address":[16360764],"length":1,"stats":{"Line":5}},{"line":20,"address":[1684336],"length":1,"stats":{"Line":0}},{"line":21,"address":[1684341],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":7},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","honk_rpc.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::fmt::Debug;\nuse std::io::{Cursor, ErrorKind};\n#[cfg(test)]\nuse std::net::{SocketAddr, TcpListener, TcpStream};\nuse std::option::Option;\n\n// extern crates\nuse bson::doc;\nuse bson::document::ValueAccessError;\n\nuse crate::byte_counter::ByteCounter;\n\n/// Represents various error codes that can be present in a Honk-RPC `error_section`\n#[derive(Debug, Eq, PartialEq)]\npub enum ErrorCode {\n    /// Failure to parse a received BSON document.\n    BsonParseFailed,\n    /// Received message document was too big; the default maximum message size\n    /// is 4096 bytes, but can be adjusted.\n    MessageTooBig,\n    /// Received message document missing required fields.\n    MessageParseFailed,\n    /// Received message contained version the receiver cannot handle.\n    MessageVersionIncompatible,\n    /// Section in received message contains unknown id.\n    SectionIdUnknown,\n    /// Section in received message missing required field, or provided\n    /// field is wrong datatype.\n    SectionParseFailed,\n    /// Provided request cookie is already in use.\n    RequestCookieInvalid,\n    /// Provided request namespace does not exist.\n    RequestNamespaceInvalid,\n    /// Provided request function does not exist within the provided namespace.\n    RequestFunctionInvalid,\n    /// Provided request version does not exist.\n    RequestVersionInvalid,\n    /// Provided response cookie is not recognized.\n    ResponseCookieInvalid,\n    /// Provided response state is not valid.\n    ResponseStateInvalid,\n    /// Represents an application-specific runtime error with a specific error code.\n    Runtime(i32),\n    /// Represents an unknown error with a specific error code.\n    Unknown(i32),\n}\n\n/// The error type for the `Session` type.\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    /// Failed to read data from read stream due to `std::io::Error`\n    #[error(\"failed to read data from read stream\")]\n    ReaderReadFailed(#[source] std::io::Error),\n\n    /// Bson documents need to be at least 4 bytes long\n    #[error(\"received invalid bson document size header value of {0}, must be at least 4\")]\n    BsonDocumentSizeTooSmall(i32),\n\n    /// Received Bson document header is larger than Session supports\n    #[error(\"received invalid bson document size header value of {0}, must be less than {1}\")]\n    BsonDocumentSizeTooLarge(i32, i32),\n\n    /// Too much time has elapsed without receiving a message\n    #[error(\"waited longer than {} seconds for read\", .0.as_secs_f32())]\n    MessageReadTimedOut(std::time::Duration),\n\n    /// Failed to parse bson message\n    #[error(\"failed to parse bson Message document\")]\n    BsonDocumentParseFailed(#[source] bson::de::Error),\n\n    /// Failed to convert bson document to Honk-RPC message\n    #[error(\"failed to convert bson document to Message\")]\n    MessageConversionFailed(#[source] crate::honk_rpc::ErrorCode),\n\n    /// Failed to serialise bson document\n    #[error(\"failed to serialize bson document\")]\n    BsonWriteFailed(#[source] bson::ser::Error),\n\n    /// Failed to write data to write stream due to `std::io::Error`\n    #[error(\"failed to write data to write stream\")]\n    WriterWriteFailed(#[source] std::io::Error),\n\n    /// Failed to flush data to write stream due to `std::io::Error`\n    #[error(\"failed to flush message to write stream\")]\n    WriterFlushFailed(#[source] std::io::Error),\n\n    /// Received a Honk-RPC `error_section` without an associated request cookie\n    #[error(\"recieved error section without cookie\")]\n    UnknownErrorSectionReceived(#[source] crate::honk_rpc::ErrorCode),\n\n    /// Attempted to define invalid maximum message size\n    #[error(\n        \"tried to set invalid max message size; must be \u003e=5 bytes and \u003c= i32::MAX (2147483647)\"\n    )]\n    InvalidMaxMesageSize(),\n\n    /// Attempted to send a Honk-RPC `section` that is too large to fit in a message\n    #[error(\"queued message section is too large to write; calculated size is {0} but must be less than {1}\")]\n    SectionTooLarge(usize, usize),\n}\n\nimpl From\u003ci32\u003e for ErrorCode {\n    fn from(value: i32) -\u003e ErrorCode {\n        match value {\n            -1i32 =\u003e ErrorCode::BsonParseFailed,\n            -2i32 =\u003e ErrorCode::MessageTooBig,\n            -3i32 =\u003e ErrorCode::MessageParseFailed,\n            -4i32 =\u003e ErrorCode::MessageVersionIncompatible,\n            -5i32 =\u003e ErrorCode::SectionIdUnknown,\n            -6i32 =\u003e ErrorCode::SectionParseFailed,\n            -7i32 =\u003e ErrorCode::RequestCookieInvalid,\n            -8i32 =\u003e ErrorCode::RequestNamespaceInvalid,\n            -9i32 =\u003e ErrorCode::RequestFunctionInvalid,\n            -10i32 =\u003e ErrorCode::RequestVersionInvalid,\n            -11i32 =\u003e ErrorCode::ResponseCookieInvalid,\n            -12i32 =\u003e ErrorCode::ResponseStateInvalid,\n            value =\u003e {\n                if value \u003e 0 {\n                    ErrorCode::Runtime(value)\n                } else {\n                    ErrorCode::Unknown(value)\n                }\n            }\n        }\n    }\n}\n\nimpl From\u003cErrorCode\u003e for i32 {\n    fn from(err: ErrorCode) -\u003e Self {\n        match err {\n            ErrorCode::BsonParseFailed =\u003e -1i32,\n            ErrorCode::MessageTooBig =\u003e -2i32,\n            ErrorCode::MessageParseFailed =\u003e -3i32,\n            ErrorCode::MessageVersionIncompatible =\u003e -4i32,\n            ErrorCode::SectionIdUnknown =\u003e -5i32,\n            ErrorCode::SectionParseFailed =\u003e -6i32,\n            ErrorCode::RequestCookieInvalid =\u003e -7i32,\n            ErrorCode::RequestNamespaceInvalid =\u003e -8i32,\n            ErrorCode::RequestFunctionInvalid =\u003e -9i32,\n            ErrorCode::RequestVersionInvalid =\u003e -10i32,\n            ErrorCode::ResponseCookieInvalid =\u003e -11i32,\n            ErrorCode::ResponseStateInvalid =\u003e -12i32,\n            ErrorCode::Runtime(val) =\u003e val,\n            ErrorCode::Unknown(val) =\u003e val,\n        }\n    }\n}\n\nimpl std::fmt::Display for ErrorCode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            ErrorCode::BsonParseFailed =\u003e write!(f, \"ProtocolError: failed to parse BSON object\"),\n            ErrorCode::MessageTooBig =\u003e write!(f, \"ProtocolError: received document too large\"),\n            ErrorCode::MessageParseFailed =\u003e {\n                write!(f, \"ProtocolError: received message has invalid schema\")\n            }\n            ErrorCode::MessageVersionIncompatible =\u003e write!(\n                f,\n                \"ProtocolError: received message has incompatible version\"\n            ),\n            ErrorCode::SectionIdUnknown =\u003e write!(\n                f,\n                \"ProtocolError: received message contains section of unknown type\"\n            ),\n            ErrorCode::SectionParseFailed =\u003e write!(\n                f,\n                \"ProtocolError: received message contains section with invalid schema\"\n            ),\n            ErrorCode::RequestCookieInvalid =\u003e {\n                write!(f, \"ProtocolError: request cookie already in use\")\n            }\n            ErrorCode::RequestNamespaceInvalid =\u003e write!(\n                f,\n                \"ProtocolError: request function does not exist in requested namespace\"\n            ),\n            ErrorCode::RequestFunctionInvalid =\u003e {\n                write!(f, \"ProtocolError: request function does not exist\")\n            }\n            ErrorCode::RequestVersionInvalid =\u003e {\n                write!(f, \"ProtocolError: request function version does not exist\")\n            }\n            ErrorCode::ResponseCookieInvalid =\u003e {\n                write!(f, \"ProtocolError: response cookie is not recognized\")\n            }\n            ErrorCode::ResponseStateInvalid =\u003e write!(f, \"ProtocolError: response state not valid\"),\n            ErrorCode::Runtime(code) =\u003e write!(f, \"RuntimeError: runtime error {}\", code),\n            ErrorCode::Unknown(code) =\u003e write!(f, \"UnknownError: unknown error code {}\", code),\n        }\n    }\n}\n\nimpl std::error::Error for ErrorCode {}\n\n// Honk-RPC semver is packed into an i32\nconst fn semver_to_i32(major: u8, minor: u8, patch: u8) -\u003e i32 {\n    let major = major as i32;\n    let minor = minor as i32;\n    let patch = patch as i32;\n    (major \u003c\u003c 16) | (minor \u003c\u003c 8) | patch\n}\n\nconst fn i32_to_semver(ver: i32) -\u003e Option\u003c(u8, u8, u8)\u003e {\n    if ver \u003e= 0 \u0026\u0026 ver \u003c= 0xffffff {\n        let major = (ver \u0026 0xff0000) \u003e\u003e 16;\n        let minor = (ver \u0026 0xff00) \u003e\u003e 8;\n        let patch = ver \u0026 0xff;\n        Some((major as u8, minor as u8, patch as u8))\n    } else {\n        None\n    }\n}\n\n// Honk-RPC version 0.1.0\nconst HONK_RPC_VERSION: i32 = semver_to_i32(0, 1, 0);\n\nstruct Message {\n    honk_rpc: i32,\n    sections: Vec\u003cSection\u003e,\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for Message {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        // verify version\n        let honk_rpc = match value.get_i32(\"honk_rpc\") {\n            Ok(HONK_RPC_VERSION) =\u003e HONK_RPC_VERSION,\n            Ok(honk_rpc) =\u003e {\n                return if let Some(_version) = i32_to_semver(honk_rpc) {\n                    // some other semver we cannot handle\n                    Err(ErrorCode::MessageVersionIncompatible)\n                } else {\n                    // an invalid semver\n                    Err(ErrorCode::MessageParseFailed)\n                };\n            }\n            Err(_err) =\u003e return Err(ErrorCode::MessageParseFailed),\n        };\n\n        if let Ok(sections) = value.get_array_mut(\"sections\") {\n            // messages must have at least one section\n            if sections.is_empty() {\n                return Err(ErrorCode::MessageParseFailed);\n            }\n\n            let mut message = Message {\n                honk_rpc,\n                sections: Default::default(),\n            };\n\n            for section in sections.iter_mut() {\n                if let bson::Bson::Document(section) = std::mem::take(section) {\n                    message.sections.push(Section::try_from(section)?);\n                } else {\n                    return Err(ErrorCode::SectionParseFailed);\n                }\n            }\n            Ok(message)\n        } else {\n            Err(ErrorCode::MessageParseFailed)\n        }\n    }\n}\n\nimpl From\u003cMessage\u003e for bson::document::Document {\n    fn from(value: Message) -\u003e bson::document::Document {\n        let mut value = value;\n        let mut message = bson::document::Document::new();\n        message.insert(\"honk_rpc\", value.honk_rpc);\n\n        let mut sections = bson::Array::new();\n        for section in value.sections.drain(0..) {\n            sections.push(bson::Bson::Document(bson::document::Document::from(\n                section,\n            )));\n        }\n        message.insert(\"sections\", sections);\n\n        message\n    }\n}\n\n/// A type alias for the cookie used to track client requests.\npub type RequestCookie = i64;\n\nconst ERROR_SECTION_ID: i32 = 0i32;\nconst REQUEST_SECTION_ID: i32 = 1i32;\nconst RESPONSE_SECTION_ID: i32 = 2i32;\n\nenum Section {\n    Error(ErrorSection),\n    Request(RequestSection),\n    Response(ResponseSection),\n}\n\nstruct ErrorSection {\n    cookie: Option\u003cRequestCookie\u003e,\n    code: ErrorCode,\n    message: Option\u003cString\u003e,\n    data: Option\u003cbson::Bson\u003e,\n}\n\nstruct RequestSection {\n    cookie: Option\u003cRequestCookie\u003e,\n    namespace: String,\n    function: String,\n    version: i32,\n    arguments: bson::document::Document,\n}\n\n#[repr(i32)]\n#[derive(Debug, PartialEq)]\nenum RequestState {\n    Pending = 0i32,\n    Complete = 1i32,\n}\n\nstruct ResponseSection {\n    cookie: RequestCookie,\n    state: RequestState,\n    result: Option\u003cbson::Bson\u003e,\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for Section {\n    type Error = ErrorCode;\n\n    fn try_from(\n        value: bson::document::Document,\n    ) -\u003e Result\u003cSelf, \u003cSelf as TryFrom\u003cbson::document::Document\u003e\u003e::Error\u003e {\n        match value.get_i32(\"id\") {\n            Ok(ERROR_SECTION_ID) =\u003e Ok(Section::Error(ErrorSection::try_from(value)?)),\n            Ok(REQUEST_SECTION_ID) =\u003e Ok(Section::Request(RequestSection::try_from(value)?)),\n            Ok(RESPONSE_SECTION_ID) =\u003e Ok(Section::Response(ResponseSection::try_from(value)?)),\n            Ok(_) =\u003e Err(ErrorCode::SectionIdUnknown),\n            Err(_) =\u003e Err(ErrorCode::SectionParseFailed),\n        }\n    }\n}\n\nimpl From\u003cSection\u003e for bson::document::Document {\n    fn from(value: Section) -\u003e bson::document::Document {\n        match value {\n            Section::Error(section) =\u003e bson::document::Document::from(section),\n            Section::Request(section) =\u003e bson::document::Document::from(section),\n            Section::Response(section) =\u003e bson::document::Document::from(section),\n        }\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for ErrorSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e Some(cookie),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let code = match value.get_i32(\"code\") {\n            Ok(code) =\u003e ErrorCode::from(code),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let message = match value.get_str(\"message\") {\n            Ok(message) =\u003e Some(message.to_string()),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let data = value.get_mut(\"data\").map(std::mem::take);\n\n        Ok(ErrorSection {\n            cookie,\n            code,\n            message,\n            data,\n        })\n    }\n}\n\nimpl From\u003cErrorSection\u003e for bson::document::Document {\n    fn from(value: ErrorSection) -\u003e bson::document::Document {\n        let mut error_section = bson::document::Document::new();\n        error_section.insert(\"id\", ERROR_SECTION_ID);\n\n        if let Some(cookie) = value.cookie {\n            error_section.insert(\"cookie\", cookie);\n        }\n\n        error_section.insert(\"code\", Into::\u003ci32\u003e::into(value.code));\n\n        if let Some(message) = value.message {\n            error_section.insert(\"message\", message);\n        }\n\n        if let Some(data) = value.data {\n            error_section.insert(\"data\", data);\n        }\n\n        error_section\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for RequestSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e Some(cookie),\n            Err(ValueAccessError::NotPresent) =\u003e None,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let namespace = match value.get_str(\"namespace\") {\n            Ok(namespace) =\u003e namespace.to_string(),\n            Err(ValueAccessError::NotPresent) =\u003e String::default(),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let function = match value.get_str(\"function\") {\n            Ok(function) =\u003e {\n                if function.is_empty() {\n                    return Err(ErrorCode::RequestFunctionInvalid);\n                } else {\n                    function.to_string()\n                }\n            }\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let version = match value.get_i32(\"version\") {\n            Ok(version) =\u003e version,\n            Err(ValueAccessError::NotPresent) =\u003e 0i32,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let arguments = match value.get_document_mut(\"arguments\") {\n            Ok(arguments) =\u003e std::mem::take(arguments),\n            Err(ValueAccessError::NotPresent) =\u003e bson::document::Document::new(),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        Ok(RequestSection {\n            cookie,\n            namespace,\n            function,\n            version,\n            arguments,\n        })\n    }\n}\n\nimpl From\u003cRequestSection\u003e for bson::document::Document {\n    fn from(value: RequestSection) -\u003e bson::document::Document {\n        let mut request_section = bson::document::Document::new();\n        request_section.insert(\"id\", REQUEST_SECTION_ID);\n\n        if let Some(cookie) = value.cookie {\n            request_section.insert(\"cookie\", cookie);\n        }\n\n        if !value.namespace.is_empty() {\n            request_section.insert(\"namespace\", value.namespace);\n        }\n\n        request_section.insert(\"function\", value.function);\n\n        if value.version != 0i32 {\n            request_section.insert(\"version\", value.version);\n        }\n\n        request_section.insert(\"arguments\", value.arguments);\n\n        request_section\n    }\n}\n\nimpl TryFrom\u003cbson::document::Document\u003e for ResponseSection {\n    type Error = ErrorCode;\n\n    fn try_from(value: bson::document::Document) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut value = value;\n        let cookie = match value.get_i64(\"cookie\") {\n            Ok(cookie) =\u003e cookie,\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let state = match value.get_i32(\"state\") {\n            Ok(0i32) =\u003e RequestState::Pending,\n            Ok(1i32) =\u003e RequestState::Complete,\n            Ok(_) =\u003e return Err(ErrorCode::ResponseStateInvalid),\n            Err(_) =\u003e return Err(ErrorCode::SectionParseFailed),\n        };\n\n        let result = value.get_mut(\"result\").map(std::mem::take);\n\n        // if pending there should be no result\n        if state == RequestState::Pending \u0026\u0026 result.is_some() {\n            return Err(ErrorCode::SectionParseFailed);\n        }\n\n        Ok(ResponseSection {\n            cookie,\n            state,\n            result,\n        })\n    }\n}\n\nimpl From\u003cResponseSection\u003e for bson::document::Document {\n    fn from(value: ResponseSection) -\u003e bson::document::Document {\n        let mut response_section = bson::document::Document::new();\n        response_section.insert(\"id\", RESPONSE_SECTION_ID);\n\n        response_section.insert(\"cookie\", value.cookie);\n        response_section.insert(\"state\", value.state as i32);\n\n        if let Some(result) = value.result {\n            response_section.insert(\"result\", result);\n        }\n\n        response_section\n    }\n}\n\n/// The `ApiSet` trait represents a set of APIs that can be remotely invoked by a connecting Honk-RPC client.\n/// # Example\n/// This exampe `ApiSet` implements two methods, `example::println()` and `example::async_println()`. The\n/// `println()` method immediatley prints, whereas `async_println()` queues request and\n/// prints the messagge at a later date via `update()`\n///\n/// ```rust\n/// # use honk_rpc::honk_rpc::*;\n/// # use std::collections::VecDeque;\n///\n/// const RUNTIME_ERROR_INVALID_ARG: ErrorCode = ErrorCode::Runtime(1i32);\n///\n/// struct PrintlnApiSet {\n///     // queued print reuests\n///     async_println_work: Vec\u003c(Option\u003cRequestCookie\u003e, String)\u003e,\n///     // successful async requests\n///     async_println_cookies: VecDeque\u003cRequestCookie\u003e,\n/// }\n///\n/// impl PrintlnApiSet {\n///   // prints message immediately\n///   fn println_0(\n///       \u0026mut self,\n///       mut args: bson::document::Document,\n///   ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n///     if let Some(bson::Bson::String(val)) = args.get_mut(\"val\") {\n///         println!(\"example::echo_0(val): '{}'\", val);\n///         Some(Ok(Some(bson::Bson::String(std::mem::take(val)))))\n///     } else {\n///         Some(Err(RUNTIME_ERROR_INVALID_ARG))\n///     }\n///   }\n///\n///   // queues message up for printing later\n///   fn async_println_0(\n///       \u0026mut self,\n///       request_cookie: Option\u003cRequestCookie\u003e,\n///       mut args: bson::document::Document,\n///   ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e{\n///     if let Some(bson::Bson::String(val)) = args.get_mut(\"val\") {\n///         self.async_println_work.push((request_cookie, std::mem::take(val)));\n///         None\n///     } else {\n///         Some(Err(RUNTIME_ERROR_INVALID_ARG))\n///     }\n///   }\n/// }\n///\n/// impl ApiSet for PrintlnApiSet {\n///     fn namespace(\u0026self) -\u003e \u0026str {\n///         \"example\"\n///     }\n///\n///     // handles and routes requests for `println` and `async_println`\n///     fn exec_function(\n///         \u0026mut self,\n///         name: \u0026str,\n///         version: i32,\n///         args: bson::document::Document,\n///         request_cookie: Option\u003cRequestCookie\u003e,\n///     ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n///         match (name, version) {\n///             (\"println\", 0) =\u003e self.println_0(args),\n///             (\"async_println\", 0) =\u003e self.async_println_0(request_cookie, args),\n///             (name, version) =\u003e {\n///                 println!(\"received {{ name: '{}', version: {} }}\", name, version);\n///                 Some(Err(ErrorCode::RequestFunctionInvalid))\n///             }\n///         }\n///     }\n///\n///     // handles queued `async_println` requests\n///     fn update(\u0026mut self) {\n///         for ((cookie, val)) in self.async_println_work.drain(..) {\n///             println!(\"{}\", val);\n///             if let Some(cookie) = cookie {\n///                 self.async_println_cookies.push_back(cookie);\n///             }\n///         }\n///     }\n///\n///     // finally return queued async results\n///     fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e)\u003e {\n///         if let Some(cookie) = self.async_println_cookies.pop_front() {\n///             Some((cookie, Ok(None)))\n///         } else {\n///             None\n///         }\n///     }\n/// }\n///```\n\npub trait ApiSet {\n    /// Returns the namespace of this `ApiSet`.\n    fn namespace(\u0026self) -\u003e \u0026str;\n\n    /// Schedules the execution of the requested remote procedure call. Calls to this\n    /// function map directly to a received Honk-RPC request. Each request has the\n    /// following parameters:\n    /// - `name`: The name of the function to execute.\n    /// - `version`: The version of the function to execute.\n    /// - `args`: The arguments to pass to the function.\n    /// - `request_cookie`: An optional cookie to track the request.\n    ///\n    /// This function handles both synchronous and asynchronous requests. The possible\n    /// return values for each are:\n    /// - Synchronous requests may execute and signal success by returning `Some(Ok(..))`.\n    /// - Synchronous requests may execute and signal failure by returning `Some(Err(..))`.\n    /// - Asynchronous requests must defer execution by returning `None`.\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e;\n\n    /// Updates any internal state required to make forward progress on any requested\n    /// remote procedure calls. Implementation of this method is optional and not needed\n    /// if the implementor does not have any async functions. If left unimplemented, this\n    /// function is a no-op.\n    fn update(\u0026mut self) {}\n\n    /// Returns the result of any in-flight asynchronous requests.\n    /// - Asynchronous requests may signal success by returning `Some((cookie, Ok(..)))`\n    /// - Asynchronous requests may signal failure by returning `Some((cookie, Err(..)))`\n    /// - returns None if no asynchronous results are available\n    ///\n    /// This method is optional and not needed if the implementor does not have any async\n    /// functions, in which case the default implementation will return `None`.\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e)\u003e {\n        None\n    }\n}\n\n/// Represents the response to a client request.\npub enum Response {\n    /// A pending response, indicating that the request is still being processed.\n    Pending {\n        /// The cookie associated with the request.\n        cookie: RequestCookie,\n    },\n    /// A successful response, containing the result of the request.\n    Success {\n        /// The cookie associated with the request.\n        cookie: RequestCookie,\n        /// The result of the request.\n        result: Option\u003cbson::Bson\u003e,\n    },\n    /// An error response, containing the error code.\n    Error {\n        /// The cookie associated with the request.\n        cookie: RequestCookie,\n        /// The error code indicating the type of error that occurred.\n        error_code: ErrorCode,\n    },\n}\n\n// 4 kilobytes per specification\n/// The default maximum allowed Honk-RPC message (4096 bytes)\npub const DEFAULT_MAX_MESSAGE_SIZE: usize = 4 * 1024;\n/// The default maximum allowed duration between Honk-RPC (60 seconds)\npub const DEFAULT_MAX_WAIT_TIME: std::time::Duration = std::time::Duration::from_secs(60);\n\n// Base Message Bson Format\n// document size             4 (sizeof i32 )\nconst HEADER_SIZE: usize = 4usize;\n// \"honk_rpc\" : i32          1 (0x10) + 8 (strlen \"honk_rpc\") + 1 (null) + 4 (sizeof i32)\nconst HONK_RPC_SIZE: usize = 14usize;\n// \"sections\" : {\"0\": Null}  1 (0x04) + 8 (strlen \"sections\") + 1 (null) + 4 (sizeof i32) + 1 (0x0a) + 1 (strlen \"0\") + 1 (null) + 1 (0x00)\nconst SECTIONS_SIZE: usize = 18usize;\n// footer                    1 (0x00)\nconst FOOTER_SIZE: usize = 1usize;\n\n// The honk-rpc message overhead before the content of a single section is added\nconst MIN_MESSAGE_SIZE: usize = HEADER_SIZE + HONK_RPC_SIZE + SECTIONS_SIZE + FOOTER_SIZE;\n\n/// Computes the overhead of the Honk-RPC message type. This method in conjunction with\n/// the other `get_*_section_size(..)` functions can be used to compute the size of a\n/// Honk-RPC message with exactly one section.\npub fn get_message_overhead() -\u003e Result\u003cusize, Error\u003e {\n    // construct an example empty message; the size of a real message with\n    // one section can be calculated as the sizeof(message) + sizeof(section)\n    let message = doc! {\n        \"honk_rpc\" : HONK_RPC_VERSION,\n        \"sections\" : [\n            bson::Bson::Null\n        ]\n    };\n\n    let mut counter: ByteCounter = Default::default();\n    message\n        .to_writer(\u0026mut counter)\n        .map_err(Error::BsonWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\n/// Computes the required size of a Honk-RPC error section in bytes.\n///\n/// Returns the size of the BSON-encoded error section. If BSON encoding fails,\n/// an `Error::BsonWriteFailed` is returned.\npub fn get_error_section_size(\n    cookie: Option\u003cRequestCookie\u003e,\n    message: Option\u003cString\u003e,\n    data: Option\u003cbson::Bson\u003e,\n) -\u003e Result\u003cusize, Error\u003e {\n    let mut error_section = doc! {\n        \"id\": ERROR_SECTION_ID,\n        \"code\": Into::\u003ci32\u003e::into(ErrorCode::Unknown(0)),\n    };\n\n    if let Some(cookie) = cookie {\n        error_section.insert(\"cookie\", bson::Bson::Int64(cookie));\n    }\n\n    if let Some(message) = message {\n        error_section.insert(\"message\", bson::Bson::String(message));\n    }\n\n    if let Some(data) = data {\n        error_section.insert(\"data\", data);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    error_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::BsonWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\n/// Computes the required size of a Honk-RPC requests section in bytes.\n///\n/// Returns the size of the BSON-encoded request section. If BSON encoding fails,\n/// an `Error::BsonWriteFailed` is returned.\npub fn get_request_section_size(\n    cookie: Option\u003cRequestCookie\u003e,\n    namespace: Option\u003cString\u003e,\n    function: String,\n    version: Option\u003ci32\u003e,\n    arguments: Option\u003cbson::Document\u003e,\n) -\u003e Result\u003cusize, Error\u003e {\n    let mut request_section = doc! {\n        \"id\": REQUEST_SECTION_ID,\n        \"function\": bson::Bson::String(function),\n    };\n\n    if let Some(cookie) = cookie {\n        request_section.insert(\"cookie\", bson::Bson::Int64(cookie));\n    }\n\n    if let Some(namespace) = namespace {\n        request_section.insert(\"namespace\", bson::Bson::String(namespace));\n    }\n\n    if let Some(version) = version {\n        request_section.insert(\"version\", bson::Bson::Int32(version));\n    }\n\n    if let Some(arguments) = arguments {\n        request_section.insert(\"arguments\", arguments);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    request_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::BsonWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\n/// Computes the required size of a Honk-RPC response section in bytes.\n///\n/// Returns the size of the BSON-encoded response section. If BSON encoding fails,\n/// an `Error::BsonWriteFailed` is returned.\npub fn get_response_section_size(result: Option\u003cbson::Bson\u003e) -\u003e Result\u003cusize, Error\u003e {\n    let mut response_section = doc! {\n        \"id\": RESPONSE_SECTION_ID,\n        \"cookie\": bson::Bson::Int64(0),\n        \"state\": bson::Bson::Int32(0),\n    };\n\n    if let Some(result) = result {\n        response_section.insert(\"result\", result);\n    }\n\n    let mut counter: ByteCounter = Default::default();\n    response_section\n        .to_writer(\u0026mut counter)\n        .map_err(Error::BsonWriteFailed)?;\n\n    Ok(counter.bytes())\n}\n\n/// The object that handles the communication between two endpoints  using the\n/// Honk-RPC protocol. Provides methods for setting and getting configuration\n/// parameters, reading and processing message documents, and handling API\n/// requests and responses.\npub struct Session\u003cRW\u003e {\n    // read-write stream\n    stream: RW,\n    // we write outgoing data to an intermediate buffer to handle writer blocking\n    message_write_buffer: VecDeque\u003cu8\u003e,\n\n    // message read data\n\n    // remaining number of bytes to read for current message\n    // if None, no message read is in progress\n    remaining_byte_count: Option\u003cusize\u003e,\n    // data we've read but not yet a full Message object\n    message_read_buffer: Vec\u003cu8\u003e,\n    // received sections to be handled\n    pending_sections: VecDeque\u003cSection\u003e,\n    // remote client's inbound remote procedure calls to local server\n    inbound_requests: Vec\u003cRequestSection\u003e,\n    // remote server's responses to local client's remote procedure calls\n    inbound_responses: VecDeque\u003cResponse\u003e,\n\n    // message write data\n\n    // we serialize outgoing messages to this buffer first to verify size limitations\n    message_serialization_buffer: VecDeque\u003cu8\u003e,\n    // the next request cookie to use when making a remote prodedure call\n    next_cookie: RequestCookie,\n    // sections to be sent to the remote server\n    outbound_sections: Vec\u003cbson::Document\u003e,\n\n    // the maximum size of a message we've agreed to allow in the session\n    max_message_size: usize,\n    // the maximum amount of time the session is willing to wait to receive a message\n    // before terminating the session\n    max_wait_time: std::time::Duration,\n    // last time a new message read began\n    read_timestamp: std::time::Instant,\n}\n\n#[allow(dead_code)]\nimpl\u003cRW\u003e Session\u003cRW\u003e\nwhere\n    RW: std::io::Read + std::io::Write + Send,\n{\n    /// Sets the maximum message size this `Session` is willing to read from from the underlying `RW`. Attempted reads  will abort if the next bson document's `i32` size field is greater than the `max_message_size` defined in this function.\n    pub fn set_max_message_size(\u0026mut self, max_message_size: i32) -\u003e Result\u003c(), Error\u003e {\n        if max_message_size \u003c MIN_MESSAGE_SIZE as i32 {\n            // base size of a honk-rpc mssage\n            Err(Error::InvalidMaxMesageSize())\n        } else {\n            self.max_message_size = max_message_size as usize;\n            Ok(())\n        }\n    }\n\n    /// Gets the maximum allowed message size this `Session` is willing to read from the underlying `RW`. The default value is 4096 bytes.\n    pub fn get_max_message_size(\u0026self) -\u003e usize {\n        self.max_message_size\n    }\n\n    /// Sets the maximum amount of time this `Session` is willing to wait for a new Honk-RPC message on the underlying `RW`. `Session` updates will fil after `max_wait_time` has elapsed without receiving any new Honk-RPC message documents.\n    pub fn set_max_wait_time(\u0026mut self, max_wait_time: std::time::Duration) {\n        self.max_wait_time = max_wait_time;\n    }\n\n    /// Gets the maximum amount this `Session` is willing to wait for a new Honk-RPC message. The default value is 60 seconds.\n    pub fn get_max_wait_time(\u0026self) -\u003e std::time::Duration {\n        self.max_wait_time\n    }\n\n    /// Creates a new `Session` using the given `stream`.\n    pub fn new(stream: RW) -\u003e Self {\n        let mut message_write_buffer: VecDeque\u003cu8\u003e = Default::default();\n        message_write_buffer.reserve(DEFAULT_MAX_MESSAGE_SIZE);\n\n        let mut message_serialization_buffer: VecDeque\u003cu8\u003e = Default::default();\n        message_serialization_buffer.reserve(DEFAULT_MAX_MESSAGE_SIZE);\n\n        Session {\n            stream,\n            message_write_buffer,\n            remaining_byte_count: None,\n            message_read_buffer: Default::default(),\n            pending_sections: Default::default(),\n            inbound_requests: Default::default(),\n            inbound_responses: Default::default(),\n            message_serialization_buffer,\n            next_cookie: Default::default(),\n            outbound_sections: Default::default(),\n            max_message_size: DEFAULT_MAX_MESSAGE_SIZE,\n            max_wait_time: DEFAULT_MAX_WAIT_TIME,\n            read_timestamp: std::time::Instant::now(),\n        }\n    }\n\n    /// Consumes the `Session` and returns the underlying stream.\n    pub fn into_stream(self) -\u003e RW {\n        self.stream\n    }\n\n    // read a block of bytes from the undelrying stream\n    fn stream_read(\u0026mut self, buffer: \u0026mut [u8]) -\u003e Result\u003cusize, Error\u003e {\n        match self.stream.read(buffer) {\n            Err(err) =\u003e {\n                if err.kind() == ErrorKind::WouldBlock || err.kind() == ErrorKind::TimedOut {\n                    // abort if we've gone too long without a new message\n                    if std::time::Instant::now().duration_since(self.read_timestamp)\n                        \u003e self.max_wait_time\n                    {\n                        Err(Error::MessageReadTimedOut(self.max_wait_time))\n                    } else {\n                        Ok(0)\n                    }\n                } else {\n                    Err(Error::ReaderReadFailed(err))\n                }\n            }\n            Ok(0) =\u003e Err(Error::ReaderReadFailed(std::io::Error::from(\n                ErrorKind::UnexpectedEof,\n            ))),\n            Ok(count) =\u003e {\n                // update read_timestamp\n                self.read_timestamp = std::time::Instant::now();\n                Ok(count)\n            }\n        }\n    }\n\n    // read the next block of bytes as a bson document size header\n    fn read_message_size(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        match self.remaining_byte_count {\n            // we've already read the size header\n            Some(_remaining) =\u003e Ok(()),\n            // still need to read the size header\n            None =\u003e {\n                // may have been partially read already so ensure it's the right size\n                assert!(self.message_read_buffer.len() \u003c std::mem::size_of::\u003ci32\u003e());\n                let bytes_needed = std::mem::size_of::\u003ci32\u003e() - self.message_read_buffer.len();\n                // ensure we have enough space for an entire int32\n                let mut buffer = [0u8; std::mem::size_of::\u003ci32\u003e()];\n                // but shrink view down to number of bytes remaining\n                let buffer = \u0026mut buffer[0..bytes_needed];\n                match self.stream_read(buffer) {\n                    Err(err) =\u003e Err(err),\n                    Ok(0) =\u003e Ok(()),\n                    Ok(count) =\u003e {\n                        #[cfg(test)]\n                        println!(\"\u003c\u003c\u003c read {} bytes for message header\", count);\n                        self.message_read_buffer\n                            .extend_from_slice(\u0026buffer[0..count]);\n\n                        // all bytes required for i32 message size have been read\n                        if self.message_read_buffer.len() == std::mem::size_of::\u003ci32\u003e() {\n                            let size = \u0026self.message_read_buffer.as_slice();\n                            let size: i32 = (size[0] as i32)\n                                | (size[1] as i32) \u003c\u003c 8\n                                | (size[2] as i32) \u003c\u003c 16\n                                | (size[3] as i32) \u003c\u003c 24;\n                            // size should be at least larger than the bytes required for size header\n                            if size \u003c= std::mem::size_of::\u003ci32\u003e() as i32 {\n                                return Err(Error::BsonDocumentSizeTooSmall(size));\n                            }\n                            // convert to usize type now that we know it's not negative\n                            if size as usize \u003e self.max_message_size {\n                                return Err(Error::BsonDocumentSizeTooLarge(\n                                    size,\n                                    self.max_message_size as i32,\n                                ));\n                            }\n\n                            // deduct size of i32 header and save\n                            let size = size as usize - std::mem::size_of::\u003ci32\u003e();\n\n                            self.remaining_byte_count = Some(size);\n                        }\n                        Ok(())\n                    }\n                }\n            }\n        }\n    }\n\n    // read the remainder of a bson message\n    fn read_message(\u0026mut self) -\u003e Result\u003cOption\u003cMessage\u003e, Error\u003e {\n        // update remaining bytes to read for message\n        self.read_message_size()?;\n        // read the message bytes\n        if let Some(remaining) = self.remaining_byte_count {\n            #[cfg(test)]\n            println!(\"--- message requires {} more bytes\", remaining);\n\n            let mut buffer = vec![0u8; remaining];\n            match self.stream_read(\u0026mut buffer) {\n                Err(err) =\u003e Err(err),\n                Ok(0) =\u003e Ok(None),\n                Ok(count) =\u003e {\n                    #[cfg(test)]\n                    println!(\"\u003c\u003c\u003c read {} bytes\", count);\n                    // append read bytes\n                    self.message_read_buffer\n                        .extend_from_slice(\u0026buffer[0..count]);\n                    if remaining == count {\n                        self.remaining_byte_count = None;\n\n                        let mut cursor = Cursor::new(std::mem::take(\u0026mut self.message_read_buffer));\n                        let bson = bson::document::Document::from_reader(\u0026mut cursor)\n                            .map_err(Error::BsonDocumentParseFailed)?;\n\n                        // take back our allocated vec and clear it\n                        self.message_read_buffer = cursor.into_inner();\n                        self.message_read_buffer.clear();\n\n                        #[cfg(test)]\n                        println!(\"\u003c\u003c\u003c read message: {}\", bson);\n\n                        Ok(Some(\n                            Message::try_from(bson).map_err(Error::MessageConversionFailed)?,\n                        ))\n                    } else {\n                        // update the remaining byte count\n                        self.remaining_byte_count = Some(remaining - count);\n                        Ok(None)\n                    }\n                }\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    // read and save of available sections\n    fn read_sections(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        loop {\n            match self.read_message() {\n                Ok(Some(mut message)) =\u003e {\n                    self.pending_sections.extend(message.sections.drain(..));\n                }\n                Ok(None) =\u003e return Ok(()),\n                Err(err) =\u003e {\n                    match err {\n                        // in the event of timeouts and IO errors we finish any remaining work\n                        Error::MessageReadTimedOut(_) | Error::ReaderReadFailed(_) =\u003e {\n                            // ensure no pending items to handle\n                            if self.pending_sections.is_empty() \u0026\u0026 self.inbound_responses.is_empty()\n                            {\n                                return Err(err);\n                            }\n                            return Ok(());\n                        }\n                        // all other errors we terminate\n                        _ =\u003e return Err(err),\n                    }\n                }\n            }\n        }\n    }\n\n    // route read sections to client and server buffers\n    fn process_sections(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        while let Some(section) = self.pending_sections.pop_front() {\n            match section {\n                Section::Error(error) =\u003e {\n                    if let Some(cookie) = error.cookie {\n                        // error in response to a request\n                        self.inbound_responses.push_back(Response::Error {\n                            cookie,\n                            error_code: error.code,\n                        });\n                    } else {\n                        return Err(Error::UnknownErrorSectionReceived(error.code));\n                    }\n                }\n                Section::Request(request) =\u003e {\n                    // request to route to our apisets\n                    self.inbound_requests.push(request);\n                }\n                Section::Response(response) =\u003e {\n                    // response to our client\n\n                    match (response.cookie, response.state, response.result) {\n                        (cookie, RequestState::Complete, result) =\u003e {\n                            self.inbound_responses\n                                .push_back(Response::Success { cookie, result });\n                        }\n                        (cookie, RequestState::Pending, _) =\u003e {\n                            self.inbound_responses\n                                .push_back(Response::Pending { cookie });\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    // queue outbound section for packaging into a Honk-RPC message\n    fn push_outbound_section(\u0026mut self, section: Section) -\u003e Result\u003c(), Error\u003e {\n        let max_section_size = self.max_message_size - MIN_MESSAGE_SIZE;\n\n        let mut counter: ByteCounter = Default::default();\n        let section: bson::Document = section.into();\n        section\n            .to_writer(\u0026mut counter)\n            .map_err(Error::BsonWriteFailed)?;\n        let section_size = counter.bytes();\n\n        if section_size \u003c= max_section_size {\n            self.outbound_sections.push(section);\n            Ok(())\n        } else {\n            Err(Error::SectionTooLarge(section_size, max_section_size))\n        }\n    }\n\n    // package outbound sections into a message, and serialize message to the message_write_buffer\n    fn serialize_messages(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        // if no pending sections there is nothing to do\n        if self.outbound_sections.is_empty() {\n            return Ok(());\n        }\n\n        // build message and convert to bson to send\n        let message = Message {\n            honk_rpc: HONK_RPC_VERSION,\n            sections: Default::default(),\n        };\n        let mut message = bson::document::Document::from(message);\n        message.insert(\"sections\", std::mem::take(\u0026mut self.outbound_sections));\n        self.serialize_messages_impl(message)\n    }\n\n    // pack sections into messages and serialise them to buffer\n    fn serialize_messages_impl(\n        \u0026mut self,\n        mut message: bson::document::Document,\n    ) -\u003e Result\u003c(), Error\u003e {\n        self.message_serialization_buffer.clear();\n        message\n            .to_writer(\u0026mut self.message_serialization_buffer)\n            .map_err(Error::BsonWriteFailed)?;\n\n        if self.message_serialization_buffer.len() \u003e self.max_message_size {\n            // if we can't split a message anymore then we have a problem\n            let sections = message.get_array_mut(\"sections\").unwrap();\n            assert!(sections.len() \u003e 1);\n\n            let right = doc! {\n                \"honk_rpc\" : HONK_RPC_VERSION,\n                \"sections\" : sections.split_off(sections.len() / 2),\n            };\n            let left = message;\n\n            self.serialize_messages_impl(left)?;\n            self.serialize_messages_impl(right)?;\n        } else {\n            #[cfg(test)]\n            println!(\"\u003e\u003e\u003e write message: {:?}\", message);\n            // copy the serialized message into the pending write buffer\n            self.message_write_buffer\n                .append(\u0026mut self.message_serialization_buffer);\n        }\n\n        Ok(())\n    }\n\n    // write data to stream and remove from write buffer\n    fn write_pending_data(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let bytes_written = self.write_pending_data_impl()?;\n        self.stream.flush().map_err(Error::WriterWriteFailed)?;\n        // removes the written bytes\n        self.message_write_buffer.drain(0..bytes_written);\n        // and shuffles the data so it is contiguous\n        self.message_write_buffer.make_contiguous();\n\n        Ok(())\n    }\n\n    fn write_pending_data_impl(\u0026mut self) -\u003e Result\u003cusize, Error\u003e {\n        // write pending data\n        let (mut pending_data, empty): (\u0026[u8], \u0026[u8]) = self.message_write_buffer.as_slices();\n        assert!(empty.is_empty());\n        let pending_bytes: usize = pending_data.len();\n        let mut bytes_written: usize = 0usize;\n\n        while bytes_written != pending_bytes {\n            match self.stream.write(pending_data) {\n                Err(err) =\u003e {\n                    let kind = err.kind();\n                    if kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut {\n                        // no *additional* bytes written so return bytes written so far\n                        return Ok(bytes_written);\n                    } else {\n                        return Err(Error::WriterWriteFailed(err));\n                    }\n                }\n                Ok(count) =\u003e {\n                    bytes_written += count;\n                    #[cfg(test)]\n                    println!(\"\u003e\u003e\u003e sent {} of {} bytes\", bytes_written, pending_bytes);\n                    pending_data = \u0026pending_data[count..];\n                }\n            }\n        }\n\n        Ok(bytes_written)\n    }\n\n    /// Read and process Honk-RPC message documents from connected peer, handle any new incoming Honk-RPC requests, update any in-progress async requests and write pending reponses, errors and requests to peer. This function must be called regularly for the `Session` to make forward progress.\n    pub fn update(\u0026mut self, apisets: Option\u003c\u0026mut [\u0026mut dyn ApiSet]\u003e) -\u003e Result\u003c(), Error\u003e {\n        // read sections from remote\n        self.read_sections()?;\n        // route sections to buffers\n        self.process_sections()?;\n\n        // handle incoming api calls\n        let apisets = apisets.unwrap_or(\u0026mut []);\n        self.handle_requests(apisets)?;\n\n        // serialize pending responses\n        self.serialize_messages()?;\n\n        // write pendng data to writer\n        self.write_pending_data()?;\n\n        Ok(())\n    }\n\n    // apisets : a slice of mutable ApiSet references sorted by their namespaces\n    fn handle_requests(\u0026mut self, apisets: \u0026mut [\u0026mut dyn ApiSet]) -\u003e Result\u003c(), Error\u003e {\n        // first handle all of our inbound requests\n        let mut inbound_requests = std::mem::take(\u0026mut self.inbound_requests);\n        for mut request in inbound_requests.drain(..) {\n            if let Ok(idx) =\n                apisets.binary_search_by(|probe| probe.namespace().cmp(\u0026request.namespace))\n            {\n                let apiset = match apisets.get_mut(idx) {\n                    Some(apiset) =\u003e apiset,\n                    None =\u003e unreachable!(),\n                };\n                match apiset.exec_function(\n                    \u0026request.function,\n                    request.version,\n                    std::mem::take(\u0026mut request.arguments),\n                    request.cookie,\n                ) {\n                    // func found, invoked and succeeded\n                    Some(Ok(result)) =\u003e {\n                        if let Some(cookie) = request.cookie {\n                            self.push_outbound_section(Section::Response(ResponseSection {\n                                cookie,\n                                state: RequestState::Complete,\n                                result,\n                            }))?;\n                        }\n                    }\n                    // func found, invoked and failed\n                    Some(Err(error_code)) =\u003e {\n                        self.push_outbound_section(Section::Error(ErrorSection {\n                            cookie: request.cookie,\n                            code: error_code,\n                            message: None,\n                            data: None,\n                        }))?;\n                    }\n                    // func found, called, and result is pending\n                    None =\u003e {\n                        if let Some(cookie) = request.cookie {\n                            self.push_outbound_section(Section::Response(ResponseSection {\n                                cookie,\n                                state: RequestState::Pending,\n                                result: None,\n                            }))?;\n                        }\n                    }\n                }\n            } else {\n                // invalid namespace\n                self.push_outbound_section(Section::Error(ErrorSection {\n                    cookie: request.cookie,\n                    code: ErrorCode::RequestNamespaceInvalid,\n                    message: None,\n                    data: None,\n                }))?;\n            }\n        }\n\n        // next send out async responses from apisets\n        for apiset in apisets.iter_mut() {\n            // allow apiset to do any required repetitive work\n            apiset.update();\n            // put pending results in our message\n            while let Some((cookie, result)) = apiset.next_result() {\n                match (cookie, result) {\n                    // function completed successfully\n                    (cookie, Ok(result)) =\u003e {\n                        self.push_outbound_section(Section::Response(ResponseSection {\n                            cookie,\n                            state: RequestState::Complete,\n                            result,\n                        }))?;\n                    }\n                    // function completed with failure\n                    (cookie, Err(error_code)) =\u003e {\n                        self.push_outbound_section(Section::Error(ErrorSection {\n                            cookie: Some(cookie),\n                            code: error_code,\n                            message: None,\n                            data: None,\n                        }))?;\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Performs a client call to a remote function. Returns a `RequestCookie` to associate this client call with a future `Response`.\n    pub fn client_call(\n        \u0026mut self,\n        namespace: \u0026str,\n        function: \u0026str,\n        version: i32,\n        arguments: bson::document::Document,\n    ) -\u003e Result\u003cRequestCookie, Error\u003e {\n        // always make sure we have a new cookie\n        let cookie = self.next_cookie;\n        self.next_cookie += 1;\n\n        // add request to outgoing buffer\n        self.push_outbound_section(Section::Request(RequestSection {\n            cookie: Some(cookie),\n            namespace: namespace.to_string(),\n            function: function.to_string(),\n            version,\n            arguments,\n        }))?;\n\n        Ok(cookie)\n    }\n\n    /// Drains all `Response` objects resulting from prevoius invocations of `Session::client_call()`\n    pub fn client_drain_responses(\u0026mut self) -\u003e std::collections::vec_deque::Drain\u003cResponse\u003e {\n        self.inbound_responses.drain(..)\n    }\n\n    /// Retrieves the next `Response` object from previous invocations of `Session::client_call()`\n    pub fn client_next_response(\u0026mut self) -\u003e Option\u003cResponse\u003e {\n        self.inbound_responses.pop_front()\n    }\n}\n\n#[test]\nfn test_honk_client_read_write() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    let mut alice = Session::new(stream1);\n    let mut pat = Session::new(stream2);\n\n    println!(\"--- pat reads message, but none has been sent\");\n\n    // no message sent yet\n    assert!(pat.read_message()?.is_none());\n\n    println!(\"--- alice sends no message, but no pending sections so no message sent\");\n\n    // send an empty message\n    alice.serialize_messages()?;\n    alice.write_pending_data()?;\n\n    println!(\"--- pat reads message, but none has been sent\");\n\n    // ensure no mesage as actually sent\n    match pat.read_message() {\n        Ok(Some(msg)) =\u003e panic!(\n            \"message should not have been sent: {}\",\n            bson::document::Document::from(msg)\n        ),\n        Ok(None) =\u003e {}\n        Err(err) =\u003e panic!(\"{:?}\", err),\n    }\n\n    println!(\"--- pat sends an error message\");\n\n    const CUSTOM_ERROR: \u0026str = \"Custom Error!\";\n\n    pat.push_outbound_section(Section::Error(ErrorSection {\n        cookie: Some(42069),\n        code: ErrorCode::Runtime(1),\n        message: Some(CUSTOM_ERROR.to_string()),\n        data: None,\n    }))?;\n\n    pat.serialize_messages()?;\n    pat.write_pending_data()?;\n\n    println!(\"--- alice reads and verifies message\");\n\n    // wait for alice to receive message\n    let mut alice_read_message: bool = false;\n    while !alice_read_message {\n        // println!(\"reading...\");\n        if let Some(mut msg) = alice.read_message()? {\n            assert_eq!(msg.sections.len(), 1);\n            match msg.sections.pop() {\n                Some(Section::Error(section)) =\u003e {\n                    match (section.cookie, section.code, section.message) {\n                        (Some(42069), ErrorCode::Runtime(1), Some(message)) =\u003e {\n                            assert_eq!(message, CUSTOM_ERROR);\n                            alice_read_message = true;\n                        }\n                        (cookie, code, message) =\u003e panic!(\n                            \"unexpected error section: cookie: {:?}, code: {:?}, message: {:?}\",\n                            cookie, code, message\n                        ),\n                    };\n                }\n                Some(_) =\u003e panic!(\"was expecting an Error section\"),\n                None =\u003e panic!(\"we should have a message\"),\n            }\n        }\n    }\n\n    println!(\"--- alice sends multi-section message\");\n\n    alice.push_outbound_section(Section::Error(ErrorSection {\n        cookie: Some(42069),\n        code: ErrorCode::Runtime(2),\n        message: Some(CUSTOM_ERROR.to_string()),\n        data: None,\n    }))?;\n    alice.push_outbound_section(Section::Request(RequestSection {\n        cookie: None,\n        namespace: \"std\".to_string(),\n        function: \"print\".to_string(),\n        version: 0,\n        arguments: doc! {\"message\": \"hello!\"},\n    }))?;\n    alice.push_outbound_section(Section::Response(ResponseSection {\n        cookie: 123456,\n        state: RequestState::Pending,\n        result: None,\n    }))?;\n\n    // send a multi-section mesage\n    alice.serialize_messages()?;\n    alice.write_pending_data()?;\n\n    println!(\"--- pat reads and verifies multi-section message\");\n\n    // read sections sent to pat\n    let mut pat_read_message: bool = false;\n    while !pat_read_message {\n        if let Some(msg) = pat.read_message()? {\n            assert_eq!(msg.sections.len(), 3);\n            for section in msg.sections.iter() {\n                match section {\n                    Section::Error(section) =\u003e {\n                        assert_eq!(section.cookie, Some(42069));\n                        assert_eq!(section.code, ErrorCode::Runtime(2));\n                        assert_eq!(section.message, Some(CUSTOM_ERROR.to_string()));\n                        assert_eq!(section.data, None);\n                    }\n                    Section::Request(section) =\u003e {\n                        assert_eq!(section.cookie, None);\n                        assert_eq!(section.namespace, \"std\");\n                        assert_eq!(section.function, \"print\");\n                        assert_eq!(section.version, 0i32);\n                    }\n                    Section::Response(section) =\u003e {\n                        assert_eq!(section.cookie, 123456);\n                        assert_eq!(section.state, RequestState::Pending);\n                        assert_eq!(section.result, None);\n                    }\n                }\n            }\n            pat_read_message = true;\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nstruct TestApiSet {\n    call_count: usize,\n}\n\n#[cfg(test)]\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"namespace\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        _args: bson::document::Document,\n        _request_section: Option\u003cRequestCookie\u003e,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        match (name, version) {\n            (\"function\", 0) =\u003e {\n                println!(\"--- namespace::function_0() called\");\n                self.call_count += 1;\n            }\n            _ =\u003e (),\n        }\n        Some(Ok(None))\n    }\n}\n\n#[test]\nfn test_honk_timeout() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let alice_stream = TcpStream::connect(socket_addr)?;\n    alice_stream.set_nonblocking(true)?;\n    alice_stream.set_nodelay(true)?;\n    println!(\"--- alice peer_addr: {}\", alice_stream.peer_addr()?);\n    let (pat_stream, _socket_addr) = listener.accept()?;\n    pat_stream.set_nonblocking(true)?;\n    pat_stream.set_nodelay(true)?;\n\n    let mut alice = Session::new(alice_stream);\n    let mut alice_apiset = TestApiSet { call_count: 0usize };\n    let mut pat = Session::new(pat_stream);\n\n    let start = std::time::Instant::now();\n\n    println!(\n        \"--- {:?} alice set max_wait_time to 3 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    alice.update(None)?;\n    alice.set_max_wait_time(std::time::Duration::from_secs(3));\n    alice.update(None)?;\n\n    // a read will happen so time should reset\n    println!(\n        \"--- {:?} sleep 2 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(2));\n\n    println!(\n        \"--- {:?} pat calls namespace::function_0()\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.client_call(\"namespace\", \"function\", 0, doc! {})?;\n    while alice_apiset.call_count != 1 {\n        pat.update(None)?;\n        alice.update(Some(\u0026mut [\u0026mut alice_apiset]))?;\n    }\n\n    // a read will happen so time should reset\n    println!(\n        \"--- {:?} sleep 2 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(2));\n    pat.update(None)?;\n    alice.update(None)?;\n\n    println!(\n        \"--- {:?} pat calls namespace::function_0()\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.client_call(\"namespace\", \"function\", 0, doc! {})?;\n    while alice_apiset.call_count != 2 {\n        pat.update(None)?;\n        alice.update(Some(\u0026mut [\u0026mut alice_apiset]))?;\n    }\n\n    // on reads occur so alice should timeout\n    println!(\n        \"--- {:?} sleep 4 seconds\",\n        std::time::Instant::now().duration_since(start)\n    );\n    std::thread::sleep(std::time::Duration::from_secs(4));\n\n    println!(\n        \"--- {:?} pat+alice update\",\n        std::time::Instant::now().duration_since(start)\n    );\n    pat.update(None)?;\n    match alice.update(None) {\n        Ok(()) =\u003e panic!(\"should have timed out\"),\n        Err(Error::MessageReadTimedOut(duration)) =\u003e {\n            println!(\"--- expected time out after {:?}\", duration)\n        }\n        Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n    }\n    Ok(())\n}\n","traces":[{"line":105,"address":[1660288],"length":1,"stats":{"Line":3}},{"line":106,"address":[1660298],"length":1,"stats":{"Line":3}},{"line":107,"address":[1660349],"length":1,"stats":{"Line":0}},{"line":108,"address":[1660359],"length":1,"stats":{"Line":0}},{"line":109,"address":[1660369],"length":1,"stats":{"Line":0}},{"line":110,"address":[1660379],"length":1,"stats":{"Line":0}},{"line":111,"address":[1660389],"length":1,"stats":{"Line":0}},{"line":112,"address":[1660399],"length":1,"stats":{"Line":0}},{"line":113,"address":[1660409],"length":1,"stats":{"Line":0}},{"line":114,"address":[1660419],"length":1,"stats":{"Line":0}},{"line":115,"address":[1660429],"length":1,"stats":{"Line":0}},{"line":116,"address":[1660439],"length":1,"stats":{"Line":0}},{"line":117,"address":[1660449],"length":1,"stats":{"Line":0}},{"line":118,"address":[1660459],"length":1,"stats":{"Line":0}},{"line":120,"address":[1660510,1660338,1660492],"length":1,"stats":{"Line":6}},{"line":121,"address":[1660498],"length":1,"stats":{"Line":3}},{"line":123,"address":[1660480],"length":1,"stats":{"Line":0}},{"line":131,"address":[1660512],"length":1,"stats":{"Line":3}},{"line":132,"address":[1660520],"length":1,"stats":{"Line":3}},{"line":133,"address":[1660552],"length":1,"stats":{"Line":0}},{"line":134,"address":[1660565],"length":1,"stats":{"Line":0}},{"line":135,"address":[1660575],"length":1,"stats":{"Line":0}},{"line":136,"address":[1660585],"length":1,"stats":{"Line":0}},{"line":137,"address":[1660595],"length":1,"stats":{"Line":0}},{"line":138,"address":[1660605],"length":1,"stats":{"Line":0}},{"line":139,"address":[1660615],"length":1,"stats":{"Line":0}},{"line":140,"address":[1660625],"length":1,"stats":{"Line":0}},{"line":141,"address":[1660635],"length":1,"stats":{"Line":0}},{"line":142,"address":[1660645],"length":1,"stats":{"Line":0}},{"line":143,"address":[1660655],"length":1,"stats":{"Line":0}},{"line":144,"address":[1660665],"length":1,"stats":{"Line":0}},{"line":145,"address":[1660675],"length":1,"stats":{"Line":3}},{"line":146,"address":[1660689],"length":1,"stats":{"Line":0}},{"line":152,"address":[1660720],"length":1,"stats":{"Line":1}},{"line":153,"address":[1660753],"length":1,"stats":{"Line":1}},{"line":154,"address":[1660783],"length":1,"stats":{"Line":0}},{"line":155,"address":[1660827],"length":1,"stats":{"Line":0}},{"line":157,"address":[1660871],"length":1,"stats":{"Line":0}},{"line":159,"address":[1660921],"length":1,"stats":{"Line":0}},{"line":163,"address":[1660971],"length":1,"stats":{"Line":0}},{"line":167,"address":[1661021],"length":1,"stats":{"Line":0}},{"line":172,"address":[1661071],"length":1,"stats":{"Line":0}},{"line":174,"address":[1661121],"length":1,"stats":{"Line":0}},{"line":179,"address":[1661171],"length":1,"stats":{"Line":0}},{"line":182,"address":[1661221],"length":1,"stats":{"Line":0}},{"line":185,"address":[1661271],"length":1,"stats":{"Line":0}},{"line":187,"address":[1661321],"length":1,"stats":{"Line":0}},{"line":188,"address":[1661482,1661376],"length":1,"stats":{"Line":2}},{"line":189,"address":[1661577,1661683],"length":1,"stats":{"Line":0}},{"line":197,"address":[1661792],"length":1,"stats":{"Line":0}},{"line":198,"address":[1661812],"length":1,"stats":{"Line":0}},{"line":199,"address":[1661819],"length":1,"stats":{"Line":0}},{"line":200,"address":[1661826],"length":1,"stats":{"Line":0}},{"line":201,"address":[1661833],"length":1,"stats":{"Line":0}},{"line":204,"address":[1661856],"length":1,"stats":{"Line":0}},{"line":205,"address":[1661864,1661874],"length":1,"stats":{"Line":0}},{"line":206,"address":[1661891],"length":1,"stats":{"Line":0}},{"line":207,"address":[1661906],"length":1,"stats":{"Line":0}},{"line":208,"address":[1661921],"length":1,"stats":{"Line":0}},{"line":209,"address":[1661930],"length":1,"stats":{"Line":0}},{"line":211,"address":[1661869],"length":1,"stats":{"Line":0}},{"line":226,"address":[1663590,1661984,1663889],"length":1,"stats":{"Line":5}},{"line":227,"address":[1662009],"length":1,"stats":{"Line":5}},{"line":230,"address":[1662001,1662085,1662164],"length":1,"stats":{"Line":15}},{"line":232,"address":[1662328],"length":1,"stats":{"Line":0}},{"line":233,"address":[1662342,1663704,1663822],"length":1,"stats":{"Line":0}},{"line":235,"address":[1663778],"length":1,"stats":{"Line":0}},{"line":238,"address":[1663829],"length":1,"stats":{"Line":0}},{"line":241,"address":[1662226],"length":1,"stats":{"Line":0}},{"line":244,"address":[1662930,1662292,1662356,1662459],"length":1,"stats":{"Line":15}},{"line":246,"address":[1662395,1662468],"length":1,"stats":{"Line":10}},{"line":247,"address":[1662498],"length":1,"stats":{"Line":0}},{"line":252,"address":[1662474],"length":1,"stats":{"Line":5}},{"line":255,"address":[1662595,1662670,1662932,1663500],"length":1,"stats":{"Line":20}},{"line":256,"address":[1662948,1662983],"length":1,"stats":{"Line":10}},{"line":257,"address":[1663139,1663291,1663524],"length":1,"stats":{"Line":10}},{"line":259,"address":[1663171],"length":1,"stats":{"Line":0}},{"line":262,"address":[1662819],"length":1,"stats":{"Line":5}},{"line":264,"address":[1662415],"length":1,"stats":{"Line":0}},{"line":270,"address":[1685862,1685893,1685040],"length":1,"stats":{"Line":5}},{"line":271,"address":[1685057],"length":1,"stats":{"Line":5}},{"line":272,"address":[1685082],"length":1,"stats":{"Line":5}},{"line":273,"address":[1685139,1685218],"length":1,"stats":{"Line":10}},{"line":275,"address":[1685237],"length":1,"stats":{"Line":5}},{"line":276,"address":[1685330,1685454,1685532,1685256],"length":1,"stats":{"Line":15}},{"line":277,"address":[1685539,1685716],"length":1,"stats":{"Line":0}},{"line":281,"address":[1685561],"length":1,"stats":{"Line":5}},{"line":283,"address":[1685669],"length":1,"stats":{"Line":5}},{"line":331,"address":[1665200,1665229,1663904],"length":1,"stats":{"Line":5}},{"line":334,"address":[1664024,1663934],"length":1,"stats":{"Line":10}},{"line":335,"address":[1664750,1664209,1664546],"length":1,"stats":{"Line":6}},{"line":336,"address":[1664323,1664765],"length":1,"stats":{"Line":10}},{"line":337,"address":[1664437,1664970],"length":1,"stats":{"Line":8}},{"line":338,"address":[1664161],"length":1,"stats":{"Line":0}},{"line":339,"address":[1664113],"length":1,"stats":{"Line":0}},{"line":345,"address":[1685920],"length":1,"stats":{"Line":5}},{"line":346,"address":[1685942],"length":1,"stats":{"Line":5}},{"line":347,"address":[1685979],"length":1,"stats":{"Line":3}},{"line":348,"address":[1686021],"length":1,"stats":{"Line":5}},{"line":349,"address":[1686069],"length":1,"stats":{"Line":5}},{"line":357,"address":[1665248,1666305,1666327],"length":1,"stats":{"Line":3}},{"line":358,"address":[1665265],"length":1,"stats":{"Line":3}},{"line":360,"address":[1665454,1665321,1665398],"length":1,"stats":{"Line":6}},{"line":361,"address":[1665416],"length":1,"stats":{"Line":3}},{"line":362,"address":[1665507],"length":1,"stats":{"Line":0}},{"line":363,"address":[1665526],"length":1,"stats":{"Line":0}},{"line":366,"address":[1665474,1665574],"length":1,"stats":{"Line":6}},{"line":367,"address":[1665616,1665705],"length":1,"stats":{"Line":6}},{"line":368,"address":[1665654],"length":1,"stats":{"Line":0}},{"line":371,"address":[1665843,1665731],"length":1,"stats":{"Line":5}},{"line":372,"address":[1665796,1665863],"length":1,"stats":{"Line":2}},{"line":373,"address":[1665943],"length":1,"stats":{"Line":2}},{"line":374,"address":[1665968],"length":1,"stats":{"Line":0}},{"line":377,"address":[1665911,1666059],"length":1,"stats":{"Line":6}},{"line":379,"address":[1666150],"length":1,"stats":{"Line":3}},{"line":380,"address":[1666086],"length":1,"stats":{"Line":3}},{"line":382,"address":[1666102],"length":1,"stats":{"Line":3}},{"line":389,"address":[1686128,1687086,1687119],"length":1,"stats":{"Line":3}},{"line":390,"address":[1686150],"length":1,"stats":{"Line":3}},{"line":391,"address":[1686342,1686265],"length":1,"stats":{"Line":6}},{"line":393,"address":[1686366],"length":1,"stats":{"Line":3}},{"line":394,"address":[1686464,1686389],"length":1,"stats":{"Line":6}},{"line":397,"address":[1686488,1686430],"length":1,"stats":{"Line":6}},{"line":399,"address":[1686548],"length":1,"stats":{"Line":3}},{"line":400,"address":[1686616,1686701],"length":1,"stats":{"Line":2}},{"line":403,"address":[1686725,1686665],"length":1,"stats":{"Line":3}},{"line":404,"address":[1686922,1686820],"length":1,"stats":{"Line":0}},{"line":407,"address":[1686869],"length":1,"stats":{"Line":3}},{"line":414,"address":[1666352,1667962,1667984],"length":1,"stats":{"Line":5}},{"line":415,"address":[1666369],"length":1,"stats":{"Line":5}},{"line":417,"address":[1666564,1666431,1666508],"length":1,"stats":{"Line":11}},{"line":418,"address":[1666526],"length":1,"stats":{"Line":5}},{"line":419,"address":[1666620],"length":1,"stats":{"Line":1}},{"line":420,"address":[1666639],"length":1,"stats":{"Line":0}},{"line":423,"address":[1666682,1666584,1666758],"length":1,"stats":{"Line":10}},{"line":424,"address":[1666711,1666778],"length":1,"stats":{"Line":10}},{"line":425,"address":[1666879,1666824],"length":1,"stats":{"Line":0}},{"line":426,"address":[1666836],"length":1,"stats":{"Line":0}},{"line":429,"address":[1666780,1666925],"length":1,"stats":{"Line":10}},{"line":430,"address":[1666954],"length":1,"stats":{"Line":5}},{"line":431,"address":[1666996,1667059],"length":1,"stats":{"Line":10}},{"line":432,"address":[1667095],"length":1,"stats":{"Line":0}},{"line":434,"address":[1667083],"length":1,"stats":{"Line":5}},{"line":437,"address":[1667012],"length":1,"stats":{"Line":0}},{"line":440,"address":[1667220,1667285,1667138],"length":1,"stats":{"Line":15}},{"line":441,"address":[1667262],"length":1,"stats":{"Line":1}},{"line":442,"address":[1667341],"length":1,"stats":{"Line":5}},{"line":443,"address":[1667359],"length":1,"stats":{"Line":0}},{"line":446,"address":[1667305,1667455,1667402],"length":1,"stats":{"Line":10}},{"line":447,"address":[1667482,1667420],"length":1,"stats":{"Line":10}},{"line":448,"address":[1667842,1667906],"length":1,"stats":{"Line":0}},{"line":449,"address":[1667866],"length":1,"stats":{"Line":0}},{"line":452,"address":[1667657],"length":1,"stats":{"Line":5}},{"line":453,"address":[1667484],"length":1,"stats":{"Line":5}},{"line":454,"address":[1667510],"length":1,"stats":{"Line":5}},{"line":455,"address":[1667558],"length":1,"stats":{"Line":5}},{"line":456,"address":[1667606],"length":1,"stats":{"Line":5}},{"line":457,"address":[1667617],"length":1,"stats":{"Line":5}},{"line":463,"address":[1688194,1688121,1687280],"length":1,"stats":{"Line":5}},{"line":464,"address":[1687302],"length":1,"stats":{"Line":5}},{"line":465,"address":[1687487,1687407],"length":1,"stats":{"Line":10}},{"line":467,"address":[1687511],"length":1,"stats":{"Line":5}},{"line":468,"address":[1687534,1687590],"length":1,"stats":{"Line":10}},{"line":471,"address":[1687575,1687613],"length":1,"stats":{"Line":10}},{"line":472,"address":[1687624,1687781],"length":1,"stats":{"Line":10}},{"line":475,"address":[1687705,1687800],"length":1,"stats":{"Line":10}},{"line":477,"address":[1687824],"length":1,"stats":{"Line":5}},{"line":478,"address":[1687977],"length":1,"stats":{"Line":1}},{"line":481,"address":[1687842,1688042],"length":1,"stats":{"Line":10}},{"line":483,"address":[1688066],"length":1,"stats":{"Line":5}},{"line":490,"address":[1668876,1668000],"length":1,"stats":{"Line":4}},{"line":491,"address":[1668017],"length":1,"stats":{"Line":4}},{"line":492,"address":[1668076,1668153],"length":1,"stats":{"Line":8}},{"line":493,"address":[1668171],"length":1,"stats":{"Line":4}},{"line":494,"address":[1668230],"length":1,"stats":{"Line":0}},{"line":497,"address":[1668192,1668284],"length":1,"stats":{"Line":8}},{"line":498,"address":[1668462],"length":1,"stats":{"Line":4}},{"line":499,"address":[1668475],"length":1,"stats":{"Line":4}},{"line":500,"address":[1668413],"length":1,"stats":{"Line":0}},{"line":501,"address":[1668359],"length":1,"stats":{"Line":0}},{"line":504,"address":[1668486],"length":1,"stats":{"Line":4}},{"line":507,"address":[1668543,1668746,1668617],"length":1,"stats":{"Line":12}},{"line":508,"address":[1668787],"length":1,"stats":{"Line":0}},{"line":511,"address":[1668669],"length":1,"stats":{"Line":4}},{"line":513,"address":[1668623],"length":1,"stats":{"Line":4}},{"line":514,"address":[1668634],"length":1,"stats":{"Line":4}},{"line":520,"address":[1688886,1688905,1688240],"length":1,"stats":{"Line":5}},{"line":521,"address":[1688262],"length":1,"stats":{"Line":5}},{"line":522,"address":[1688360,1688437],"length":1,"stats":{"Line":10}},{"line":524,"address":[1688458],"length":1,"stats":{"Line":5}},{"line":525,"address":[1688522],"length":1,"stats":{"Line":5}},{"line":527,"address":[1688600],"length":1,"stats":{"Line":5}},{"line":528,"address":[1688831,1688730],"length":1,"stats":{"Line":6}},{"line":531,"address":[1688779],"length":1,"stats":{"Line":5}},{"line":656,"address":[1291808,1291813],"length":1,"stats":{"Line":12}},{"line":665,"address":[],"length":0,"stats":{"Line":1}},{"line":666,"address":[],"length":0,"stats":{"Line":1}},{"line":715,"address":[1670008,1668912],"length":1,"stats":{"Line":2}},{"line":718,"address":[1669140,1670030,1668929],"length":1,"stats":{"Line":4}},{"line":721,"address":[1669132],"length":1,"stats":{"Line":2}},{"line":725,"address":[1669645,1669587],"length":1,"stats":{"Line":4}},{"line":726,"address":[1669918,1669653],"length":1,"stats":{"Line":2}},{"line":728,"address":[1669806],"length":1,"stats":{"Line":0}},{"line":730,"address":[1669774,1669954],"length":1,"stats":{"Line":4}},{"line":737,"address":[1671811,1670048,1671759],"length":1,"stats":{"Line":0}},{"line":742,"address":[1670085,1670202,1670399],"length":1,"stats":{"Line":0}},{"line":744,"address":[1670337],"length":1,"stats":{"Line":0}},{"line":747,"address":[1670514],"length":1,"stats":{"Line":0}},{"line":748,"address":[1670535,1670686],"length":1,"stats":{"Line":0}},{"line":751,"address":[1670610,1670710],"length":1,"stats":{"Line":0}},{"line":752,"address":[1670741,1670875],"length":1,"stats":{"Line":0}},{"line":755,"address":[1670899,1670840],"length":1,"stats":{"Line":0}},{"line":756,"address":[1670990,1671046],"length":1,"stats":{"Line":0}},{"line":759,"address":[1671070,1671034],"length":1,"stats":{"Line":0}},{"line":760,"address":[1671343,1670075,1671078],"length":1,"stats":{"Line":0}},{"line":762,"address":[1671231],"length":1,"stats":{"Line":0}},{"line":764,"address":[1671199,1671382],"length":1,"stats":{"Line":0}},{"line":771,"address":[1673810,1673705,1671840],"length":1,"stats":{"Line":2}},{"line":778,"address":[1672263,1671906,1672039],"length":1,"stats":{"Line":6}},{"line":780,"address":[1672182],"length":1,"stats":{"Line":2}},{"line":783,"address":[1672386],"length":1,"stats":{"Line":2}},{"line":784,"address":[1672558,1672407],"length":1,"stats":{"Line":4}},{"line":787,"address":[1672582,1672482],"length":1,"stats":{"Line":4}},{"line":788,"address":[1672613,1672719],"length":1,"stats":{"Line":4}},{"line":791,"address":[1672738,1672707],"length":1,"stats":{"Line":4}},{"line":792,"address":[1672749,1672858],"length":1,"stats":{"Line":4}},{"line":795,"address":[1672882,1672823],"length":1,"stats":{"Line":4}},{"line":796,"address":[1672961,1673017],"length":1,"stats":{"Line":4}},{"line":799,"address":[1673005,1673041],"length":1,"stats":{"Line":4}},{"line":800,"address":[1673049,1671887,1673314],"length":1,"stats":{"Line":4}},{"line":802,"address":[1673202],"length":1,"stats":{"Line":0}},{"line":804,"address":[1673170,1673353],"length":1,"stats":{"Line":4}},{"line":811,"address":[1675124,1673840,1675143],"length":1,"stats":{"Line":2}},{"line":812,"address":[1673963,1674131,1673862,1674260],"length":1,"stats":{"Line":8}},{"line":814,"address":[1674101],"length":1,"stats":{"Line":2}},{"line":815,"address":[1674231],"length":1,"stats":{"Line":2}},{"line":818,"address":[1674388],"length":1,"stats":{"Line":2}},{"line":819,"address":[1674615,1674518],"length":1,"stats":{"Line":4}},{"line":822,"address":[1674562,1674639],"length":1,"stats":{"Line":4}},{"line":823,"address":[1674911,1674647],"length":1,"stats":{"Line":2}},{"line":825,"address":[1674799],"length":1,"stats":{"Line":0}},{"line":827,"address":[1674768,1674946],"length":1,"stats":{"Line":4}},{"line":878,"address":[],"length":0,"stats":{"Line":1}},{"line":879,"address":[],"length":0,"stats":{"Line":2}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":1}},{"line":884,"address":[],"length":0,"stats":{"Line":1}},{"line":889,"address":[],"length":0,"stats":{"Line":2}},{"line":890,"address":[],"length":0,"stats":{"Line":2}},{"line":894,"address":[],"length":0,"stats":{"Line":2}},{"line":895,"address":[],"length":0,"stats":{"Line":2}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[1044224,1045376,1045448],"length":1,"stats":{"Line":5}},{"line":905,"address":[1044245],"length":1,"stats":{"Line":5}},{"line":906,"address":[1044330],"length":1,"stats":{"Line":5}},{"line":908,"address":[1044398],"length":1,"stats":{"Line":5}},{"line":909,"address":[1044405],"length":1,"stats":{"Line":6}},{"line":915,"address":[1044527],"length":1,"stats":{"Line":6}},{"line":916,"address":[1044591],"length":1,"stats":{"Line":6}},{"line":917,"address":[1044647],"length":1,"stats":{"Line":6}},{"line":918,"address":[1044699],"length":1,"stats":{"Line":6}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[1044853],"length":1,"stats":{"Line":6}},{"line":924,"address":[1044860],"length":1,"stats":{"Line":6}},{"line":929,"address":[],"length":0,"stats":{"Line":2}},{"line":930,"address":[],"length":0,"stats":{"Line":2}},{"line":934,"address":[1027424,1028260],"length":1,"stats":{"Line":5}},{"line":935,"address":[1027504],"length":1,"stats":{"Line":6}},{"line":936,"address":[1027553],"length":1,"stats":{"Line":6}},{"line":937,"address":[1027794,1027576,1027871],"length":1,"stats":{"Line":12}},{"line":939,"address":[1028150,1028229,1028003,1028103,1027847],"length":1,"stats":{"Line":25}},{"line":940,"address":[1028088],"length":1,"stats":{"Line":6}},{"line":942,"address":[1028165],"length":1,"stats":{"Line":1}},{"line":944,"address":[1028129],"length":1,"stats":{"Line":6}},{"line":947,"address":[1027913],"length":1,"stats":{"Line":0}},{"line":950,"address":[1027598],"length":1,"stats":{"Line":2}},{"line":951,"address":[1027590],"length":1,"stats":{"Line":2}},{"line":953,"address":[1027662],"length":1,"stats":{"Line":4}},{"line":955,"address":[1027680],"length":1,"stats":{"Line":5}},{"line":956,"address":[1027719],"length":1,"stats":{"Line":5}},{"line":962,"address":[1038208],"length":1,"stats":{"Line":4}},{"line":963,"address":[1038241],"length":1,"stats":{"Line":4}},{"line":965,"address":[1038280],"length":1,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[1038252,1038310],"length":1,"stats":{"Line":4}},{"line":970,"address":[1038343,1038534],"length":1,"stats":{"Line":4}},{"line":972,"address":[1038396],"length":1,"stats":{"Line":5}},{"line":974,"address":[1038421],"length":1,"stats":{"Line":5}},{"line":975,"address":[1038484,1038550],"length":1,"stats":{"Line":11}},{"line":976,"address":[1038563],"length":1,"stats":{"Line":3}},{"line":977,"address":[1038622],"length":1,"stats":{"Line":6}},{"line":978,"address":[1038655],"length":1,"stats":{"Line":5}},{"line":981,"address":[1038821,1038676],"length":1,"stats":{"Line":10}},{"line":982,"address":[],"length":0,"stats":{"Line":1}},{"line":985,"address":[1039485,1038832],"length":1,"stats":{"Line":10}},{"line":986,"address":[1038891],"length":1,"stats":{"Line":5}},{"line":987,"address":[1038998,1039189,1038933,1039113,1039037],"length":1,"stats":{"Line":20}},{"line":988,"address":[1039073,1039022,1038968],"length":1,"stats":{"Line":10}},{"line":989,"address":[1039043,1039098,1039149],"length":1,"stats":{"Line":10}},{"line":990,"address":[1039174,1039218,1039119],"length":1,"stats":{"Line":10}},{"line":992,"address":[1039202],"length":1,"stats":{"Line":5}},{"line":993,"address":[1039270],"length":1,"stats":{"Line":0}},{"line":996,"address":[1039248],"length":1,"stats":{"Line":5}},{"line":997,"address":[1039369],"length":1,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[1039362],"length":1,"stats":{"Line":0}},{"line":1004,"address":[1039434,1039490,1039322],"length":1,"stats":{"Line":10}},{"line":1006,"address":[1039442],"length":1,"stats":{"Line":5}},{"line":1008,"address":[1038871],"length":1,"stats":{"Line":5}},{"line":1016,"address":[1030785,1028288,1030712],"length":1,"stats":{"Line":4}},{"line":1018,"address":[1028414,1028310],"length":1,"stats":{"Line":7}},{"line":1020,"address":[1028403,1028626,1028472],"length":1,"stats":{"Line":17}},{"line":1024,"address":[1028489],"length":1,"stats":{"Line":5}},{"line":1025,"address":[1028518,1028698],"length":1,"stats":{"Line":10}},{"line":1026,"address":[1028756],"length":1,"stats":{"Line":0}},{"line":1027,"address":[1028815],"length":1,"stats":{"Line":0}},{"line":1028,"address":[1028901],"length":1,"stats":{"Line":5}},{"line":1032,"address":[1028922,1029045],"length":1,"stats":{"Line":10}},{"line":1033,"address":[1028931],"length":1,"stats":{"Line":5}},{"line":1034,"address":[1030514,1029066,1029302],"length":1,"stats":{"Line":10}},{"line":1035,"address":[1029108],"length":1,"stats":{"Line":5}},{"line":1037,"address":[1029343,1029143],"length":1,"stats":{"Line":10}},{"line":1038,"address":[1029374,1029438,1029890],"length":1,"stats":{"Line":10}},{"line":1039,"address":[1029778],"length":1,"stats":{"Line":0}},{"line":1042,"address":[1029961,1029707],"length":1,"stats":{"Line":10}},{"line":1043,"address":[1030077],"length":1,"stats":{"Line":5}},{"line":1048,"address":[1030373],"length":1,"stats":{"Line":5}},{"line":1049,"address":[1030524,1030088],"length":1,"stats":{"Line":5}},{"line":1053,"address":[1029081,1029307,1029180],"length":1,"stats":{"Line":0}},{"line":1054,"address":[1029223],"length":1,"stats":{"Line":0}},{"line":1059,"address":[1028547],"length":1,"stats":{"Line":6}},{"line":1064,"address":[1031342,1030800],"length":1,"stats":{"Line":4}},{"line":1065,"address":[1031337,1030830],"length":1,"stats":{"Line":9}},{"line":1066,"address":[1030843],"length":1,"stats":{"Line":4}},{"line":1067,"address":[1031129],"length":1,"stats":{"Line":5}},{"line":1068,"address":[1031155,1031282],"length":1,"stats":{"Line":10}},{"line":1070,"address":[1031109],"length":1,"stats":{"Line":5}},{"line":1071,"address":[1030926],"length":1,"stats":{"Line":3}},{"line":1072,"address":[1031031],"length":1,"stats":{"Line":3}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[1031522,1031431,1031491],"length":1,"stats":{"Line":8}},{"line":1078,"address":[1031547],"length":1,"stats":{"Line":1}},{"line":1080,"address":[1031502],"length":1,"stats":{"Line":2}},{"line":1083,"address":[1031364],"length":1,"stats":{"Line":0}},{"line":1091,"address":[1037024,1037711],"length":1,"stats":{"Line":5}},{"line":1092,"address":[1037054],"length":1,"stats":{"Line":5}},{"line":1093,"address":[1037202,1037131],"length":1,"stats":{"Line":5}},{"line":1094,"address":[1037204],"length":1,"stats":{"Line":2}},{"line":1095,"address":[1037234,1037477],"length":1,"stats":{"Line":4}},{"line":1097,"address":[1037493,1037511],"length":1,"stats":{"Line":4}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[1037497],"length":1,"stats":{"Line":2}},{"line":1102,"address":[1037571],"length":1,"stats":{"Line":0}},{"line":1105,"address":[1037254],"length":1,"stats":{"Line":5}},{"line":1107,"address":[1037289],"length":1,"stats":{"Line":5}},{"line":1109,"address":[1037311],"length":1,"stats":{"Line":4}},{"line":1112,"address":[1037341],"length":1,"stats":{"Line":4}},{"line":1113,"address":[1037820],"length":1,"stats":{"Line":4}},{"line":1114,"address":[1037956,1038146,1038088],"length":1,"stats":{"Line":12}},{"line":1115,"address":[1037960],"length":1,"stats":{"Line":4}},{"line":1117,"address":[1037751],"length":1,"stats":{"Line":3}},{"line":1118,"address":[1038132,1037805,1037767],"length":1,"stats":{"Line":9}},{"line":1119,"address":[1037771],"length":1,"stats":{"Line":3}},{"line":1126,"address":[1037184],"length":1,"stats":{"Line":5}},{"line":1130,"address":[1041352,1040448],"length":1,"stats":{"Line":5}},{"line":1131,"address":[1040483,1040557],"length":1,"stats":{"Line":5}},{"line":1133,"address":[1040545,1040628],"length":1,"stats":{"Line":10}},{"line":1134,"address":[1040633],"length":1,"stats":{"Line":5}},{"line":1135,"address":[1040700,1040999,1040770,1040475],"length":1,"stats":{"Line":15}},{"line":1136,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[1040887],"length":1,"stats":{"Line":0}},{"line":1138,"address":[1041033,1040859],"length":1,"stats":{"Line":10}},{"line":1140,"address":[1041112,1041041,1041266],"length":1,"stats":{"Line":10}},{"line":1141,"address":[1041119],"length":1,"stats":{"Line":5}},{"line":1142,"address":[1041253],"length":1,"stats":{"Line":5}},{"line":1144,"address":[1041060],"length":1,"stats":{"Line":0}},{"line":1149,"address":[1039974,1039945,1039520],"length":1,"stats":{"Line":4}},{"line":1151,"address":[1039558],"length":1,"stats":{"Line":4}},{"line":1152,"address":[1039683],"length":1,"stats":{"Line":4}},{"line":1158,"address":[1039582],"length":1,"stats":{"Line":4}},{"line":1160,"address":[1039624],"length":1,"stats":{"Line":5}},{"line":1161,"address":[1039742,1039656],"length":1,"stats":{"Line":10}},{"line":1162,"address":[1039811],"length":1,"stats":{"Line":5}},{"line":1166,"address":[1041440,1043460,1043433],"length":1,"stats":{"Line":5}},{"line":1170,"address":[1041483],"length":1,"stats":{"Line":5}},{"line":1171,"address":[1041607,1041835,1043442],"length":1,"stats":{"Line":5}},{"line":1172,"address":[1041592],"length":1,"stats":{"Line":5}},{"line":1173,"address":[1041729],"length":1,"stats":{"Line":0}},{"line":1175,"address":[1041702,1043184,1041870],"length":1,"stats":{"Line":11}},{"line":1177,"address":[1041910,1042136],"length":1,"stats":{"Line":2}},{"line":1178,"address":[1042144],"length":1,"stats":{"Line":1}},{"line":1180,"address":[1042414,1042201],"length":1,"stats":{"Line":2}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[1042368],"length":1,"stats":{"Line":1}},{"line":1184,"address":[1042628],"length":1,"stats":{"Line":1}},{"line":1186,"address":[1043368,1042723,1042771,1042977],"length":1,"stats":{"Line":2}},{"line":1187,"address":[1042842,1043114,1043354,1041475,1043194],"length":1,"stats":{"Line":7}},{"line":1192,"address":[1041898,1041884,1041941],"length":1,"stats":{"Line":14}},{"line":1193,"address":[1041891],"length":1,"stats":{"Line":5}},{"line":1196,"address":[1041948],"length":1,"stats":{"Line":5}},{"line":1200,"address":[1039984],"length":1,"stats":{"Line":4}},{"line":1201,"address":[1040014,1040190],"length":1,"stats":{"Line":5}},{"line":1202,"address":[1040006,1040321,1040100],"length":1,"stats":{"Line":10}},{"line":1204,"address":[1040253],"length":1,"stats":{"Line":5}},{"line":1206,"address":[1040292],"length":1,"stats":{"Line":5}},{"line":1208,"address":[1040306],"length":1,"stats":{"Line":5}},{"line":1211,"address":[1044200,1043504],"length":1,"stats":{"Line":5}},{"line":1213,"address":[1043534],"length":1,"stats":{"Line":5}},{"line":1214,"address":[1043602],"length":1,"stats":{"Line":5}},{"line":1215,"address":[1043640],"length":1,"stats":{"Line":5}},{"line":1216,"address":[1043658],"length":1,"stats":{"Line":5}},{"line":1218,"address":[1043672,1043919],"length":1,"stats":{"Line":10}},{"line":1219,"address":[1043713],"length":1,"stats":{"Line":5}},{"line":1220,"address":[1043804],"length":1,"stats":{"Line":0}},{"line":1221,"address":[1043988,1043833],"length":1,"stats":{"Line":0}},{"line":1222,"address":[1044090,1043995],"length":1,"stats":{"Line":0}},{"line":1224,"address":[1044062],"length":1,"stats":{"Line":0}},{"line":1226,"address":[1044101],"length":1,"stats":{"Line":0}},{"line":1229,"address":[1043769],"length":1,"stats":{"Line":5}},{"line":1230,"address":[1043787,1043924,1043857],"length":1,"stats":{"Line":10}},{"line":1233,"address":[1043862,1043909],"length":1,"stats":{"Line":10}},{"line":1238,"address":[1043684],"length":1,"stats":{"Line":5}},{"line":1242,"address":[1045488],"length":1,"stats":{"Line":4}},{"line":1244,"address":[1045544,1045688],"length":1,"stats":{"Line":5}},{"line":1246,"address":[1045874,1045613],"length":1,"stats":{"Line":5}},{"line":1249,"address":[1045751],"length":1,"stats":{"Line":5}},{"line":1250,"address":[1045799,1046010],"length":1,"stats":{"Line":5}},{"line":1253,"address":[1045935,1046143],"length":1,"stats":{"Line":4}},{"line":1256,"address":[1045520,1046071,1046216],"length":1,"stats":{"Line":8}},{"line":1258,"address":[1046201],"length":1,"stats":{"Line":5}},{"line":1262,"address":[1031664,1036891],"length":1,"stats":{"Line":5}},{"line":1264,"address":[1031750],"length":1,"stats":{"Line":5}},{"line":1265,"address":[1031799,1031862,1031955,1032024],"length":1,"stats":{"Line":20}},{"line":1266,"address":[1036609,1033875],"length":1,"stats":{"Line":16}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[1033918,1034265],"length":1,"stats":{"Line":10}},{"line":1270,"address":[1034332],"length":1,"stats":{"Line":5}},{"line":1273,"address":[1034491,1034576,1034348],"length":1,"stats":{"Line":14}},{"line":1274,"address":[1034365],"length":1,"stats":{"Line":5}},{"line":1275,"address":[1034412],"length":1,"stats":{"Line":5}},{"line":1276,"address":[1034423],"length":1,"stats":{"Line":5}},{"line":1277,"address":[1034475],"length":1,"stats":{"Line":5}},{"line":1280,"address":[1035295],"length":1,"stats":{"Line":4}},{"line":1281,"address":[1035687,1035329],"length":1,"stats":{"Line":8}},{"line":1282,"address":[1036332,1035834,1036150],"length":1,"stats":{"Line":8}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[1035703],"length":1,"stats":{"Line":4}},{"line":1285,"address":[1035714],"length":1,"stats":{"Line":4}},{"line":1290,"address":[1035349],"length":1,"stats":{"Line":2}},{"line":1291,"address":[1035429,1036633,1036585,1036399],"length":1,"stats":{"Line":4}},{"line":1292,"address":[1035377],"length":1,"stats":{"Line":2}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[1035403],"length":1,"stats":{"Line":2}},{"line":1295,"address":[1035421],"length":1,"stats":{"Line":2}},{"line":1299,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[1034560,1034628],"length":1,"stats":{"Line":8}},{"line":1301,"address":[1034673,1035227,1035041],"length":1,"stats":{"Line":8}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[1034644],"length":1,"stats":{"Line":4}},{"line":1304,"address":[1034665],"length":1,"stats":{"Line":4}},{"line":1311,"address":[1033996,1036846,1036664],"length":1,"stats":{"Line":0}},{"line":1312,"address":[1033933],"length":1,"stats":{"Line":0}},{"line":1313,"address":[1033949],"length":1,"stats":{"Line":0}},{"line":1314,"address":[1033970],"length":1,"stats":{"Line":0}},{"line":1315,"address":[1033988],"length":1,"stats":{"Line":0}},{"line":1321,"address":[1032272,1032092],"length":1,"stats":{"Line":10}},{"line":1323,"address":[1032293,1032324],"length":1,"stats":{"Line":10}},{"line":1325,"address":[1032331],"length":1,"stats":{"Line":5}},{"line":1326,"address":[1032449],"length":1,"stats":{"Line":3}},{"line":1328,"address":[1032553],"length":1,"stats":{"Line":3}},{"line":1329,"address":[1033358,1033544,1032692],"length":1,"stats":{"Line":6}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[1032681],"length":1,"stats":{"Line":3}},{"line":1332,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[1032992],"length":1,"stats":{"Line":1}},{"line":1337,"address":[1031726,1033772,1033092,1033586],"length":1,"stats":{"Line":7}},{"line":1338,"address":[1033036],"length":1,"stats":{"Line":1}},{"line":1339,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[1033066],"length":1,"stats":{"Line":1}},{"line":1341,"address":[1033084],"length":1,"stats":{"Line":1}},{"line":1347,"address":[1032244],"length":1,"stats":{"Line":4}},{"line":1351,"address":[1027381,1026432],"length":1,"stats":{"Line":4}},{"line":1359,"address":[1026538],"length":1,"stats":{"Line":5}},{"line":1360,"address":[1026661,1026574],"length":1,"stats":{"Line":5}},{"line":1363,"address":[1026876,1027344,1026498,1027379],"length":1,"stats":{"Line":9}},{"line":1364,"address":[1026626],"length":1,"stats":{"Line":5}},{"line":1365,"address":[1026654],"length":1,"stats":{"Line":5}},{"line":1366,"address":[1026740],"length":1,"stats":{"Line":5}},{"line":1367,"address":[],"length":0,"stats":{"Line":0}},{"line":1368,"address":[1026797],"length":1,"stats":{"Line":5}},{"line":1371,"address":[1027211],"length":1,"stats":{"Line":5}},{"line":1375,"address":[1041392],"length":1,"stats":{"Line":1}},{"line":1376,"address":[1041409],"length":1,"stats":{"Line":1}},{"line":1380,"address":[1040400],"length":1,"stats":{"Line":4}},{"line":1381,"address":[1040417],"length":1,"stats":{"Line":4}}],"covered":357,"coverable":496},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\n\nmod byte_counter;\npub mod honk_rpc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","honk-rpc","tests","honk_rpc.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::net::{SocketAddr, TcpListener, TcpStream};\n\n// extern crates\nuse bson::doc;\nuse data_encoding::HEXLOWER;\nuse sha3::{Digest, Sha3_256};\n\n// internal crates\nuse honk_rpc::honk_rpc::*;\n\n#[derive(Default)]\nstruct TestApiSet {\n    delay_echo_results: VecDeque\u003c(RequestCookie, Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e)\u003e,\n}\n\nconst RUNTIME_ERROR_INVALID_ARG: ErrorCode = ErrorCode::Runtime(1i32);\nconst RUNTIME_ERROR_NOT_IMPLEMENTED: ErrorCode = ErrorCode::Runtime(2i32);\n\nimpl TestApiSet {\n    // returns the same string arg sent\n    fn echo_0(\n        \u0026mut self,\n        mut args: bson::document::Document,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        if let Some(bson::Bson::String(val)) = args.get_mut(\"val\") {\n            println!(\"TestApiSet::echo_0(val): val = '{}'\", val);\n            // Some((Some(bson::Bson::String(std::mem::take(val))), None))\n            Some(Ok(Some(bson::Bson::String(std::mem::take(val)))))\n        } else {\n            Some(Err(RUNTIME_ERROR_INVALID_ARG))\n        }\n    }\n\n    // second version of echo that isn't implemented\n    fn echo_1(\n        \u0026mut self,\n        _args: bson::document::Document,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        Some(Err(RUNTIME_ERROR_NOT_IMPLEMENTED))\n    }\n\n    // same as echo but takes awhile and appends ' - Delayed!' to source string before returning\n    fn delay_echo_0(\n        \u0026mut self,\n        request_cookie: Option\u003cRequestCookie\u003e,\n        mut args: bson::document::Document,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        if let Some(bson::Bson::String(val)) = args.get_mut(\"val\") {\n            println!(\"TestApiSet::delay_echo_0(val): val = '{}'\", val);\n            // only enqueue response if a request cookie is provided\n            if let Some(request_cookie) = request_cookie {\n                val.push_str(\" - Delayed!\");\n                self.delay_echo_results.push_back((\n                    request_cookie,\n                    Ok(Some(bson::Bson::String(std::mem::take(val)))),\n                ));\n            }\n            // async func so don't return result immediately\n            None\n        } else {\n            Some(Err(RUNTIME_ERROR_INVALID_ARG))\n        }\n    }\n\n    fn sha256_0(\n        \u0026mut self,\n        mut args: bson::document::Document,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        if let Some(bson::Bson::Binary(val)) = args.get_mut(\"data\") {\n            let mut sha256 = Sha3_256::new();\n            sha256.update(\u0026val.bytes);\n\n            let hash = sha256.finalize();\n\n            Some(Ok(Some(bson::Bson::String(HEXLOWER.encode(\u0026hash)))))\n        } else {\n            Some(Err(RUNTIME_ERROR_INVALID_ARG))\n        }\n    }\n}\n\nimpl ApiSet for TestApiSet {\n    fn namespace(\u0026self) -\u003e \u0026str {\n        \"test\"\n    }\n\n    fn exec_function(\n        \u0026mut self,\n        name: \u0026str,\n        version: i32,\n        args: bson::document::Document,\n        request_cookie: Option\u003cRequestCookie\u003e,\n    ) -\u003e Option\u003cResult\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e\u003e {\n        match (name, version) {\n            (\"echo\", 0) =\u003e self.echo_0(args),\n            (\"echo\", 1) =\u003e self.echo_1(args),\n            (\"delay_echo\", 0) =\u003e self.delay_echo_0(request_cookie, args),\n            (\"sha256\", 0) =\u003e self.sha256_0(args),\n            (name, version) =\u003e {\n                println!(\"received {{ name: '{}', version: {} }}\", name, version);\n                Some(Err(ErrorCode::RequestFunctionInvalid))\n            }\n        }\n    }\n\n    fn next_result(\u0026mut self) -\u003e Option\u003c(RequestCookie, Result\u003cOption\u003cbson::Bson\u003e, ErrorCode\u003e)\u003e {\n        self.delay_echo_results.pop_front()\n    }\n}\n\n#[test]\nfn test_honk_client_apiset() -\u003e anyhow::Result\u003c()\u003e {\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n    let listener = TcpListener::bind(socket_addr)?;\n    let socket_addr = listener.local_addr()?;\n\n    let stream1 = TcpStream::connect(socket_addr)?;\n    stream1.set_nonblocking(true)?;\n    let (stream2, _socket_addr) = listener.accept()?;\n    stream2.set_nonblocking(true)?;\n\n    let mut alice = Session::new(stream1);\n    let mut pat = Session::new(stream2);\n\n    let mut test_api_set: TestApiSet = Default::default();\n    let alice_apisets: \u0026mut [\u0026mut dyn ApiSet] = \u0026mut [\u0026mut test_api_set];\n\n    //\n    // Pat calls remote test::echo_0 call\n    //\n\n    println!(\"--- pat calling test::echo(val: \\\"Hello Alice!\\\")\");\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 0, doc! {\"val\" : \"Hello Alice!\"})?;\n\n    println!(\"--- pat wits for response from alice\");\n    let mut pat_sync_call_handled: bool = false;\n    while !pat_sync_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    if let Some(bson::Bson::String(result)) = result {\n                        assert_eq!(result, \"Hello Alice!\");\n                        pat_sync_call_handled = true;\n                    }\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls remote test::echo_0 call (with wrong arg)\n    //\n    println!(\"--- pat calling test::echo(string: \\\"Hello Alice!\\\"), should fail because bad arg\");\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 0, doc! {\"string\" : \"Hello Alice!\"})?;\n\n    println!(\"--- pat waits for response from alice\");\n    let mut pat_bad_call_handled: bool = false;\n    while !pat_bad_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\n                        \"received unexpected result: {:?}, cookie: {}\",\n                        result, cookie\n                    );\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    assert_eq!(error_code, RUNTIME_ERROR_INVALID_ARG);\n                    println!(\"--- pat received invlaid arg response\");\n                    pat_bad_call_handled = true;\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls v2 remote test::echo_1 call (which is not implemented)\n    //\n    println!(\n        \"--- pat calling test::echo_1(val: \\\"Hello Again!\\\"), should fail because not implemented\"\n    );\n    let sent_cookie = pat.client_call(\"test\", \"echo\", 1, doc! {\"val\" : \"Hello Again!\"})?;\n\n    println!(\"--- pat waits for response from alice\");\n    let mut pat_bad_call_handled: bool = false;\n    while !pat_bad_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\n                        \"received unexpected result: {:?}, cookie: {}\",\n                        result, cookie\n                    );\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    assert_eq!(error_code, RUNTIME_ERROR_NOT_IMPLEMENTED);\n                    println!(\"--- pat received not implemented response\");\n                    pat_bad_call_handled = true;\n                }\n            }\n        }\n    }\n\n    //\n    // Pat calls test::delay_echo_0 which goes through the async machinery\n    //\n    println!(\"--- pat calling test::delay_echo(val: \\\"Hello Delayed?\\\"), should succeed\");\n    let sent_cookie = pat.client_call(\"test\", \"delay_echo\", 0, doc! {\"val\" : \"Hello Delayed?\"})?;\n\n    println!(\"--- pat waits for ack from alice\");\n    let mut pat_async_call_acked: bool = false;\n    while !pat_async_call_acked {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    println!(\"--- pat received pending response\");\n                    pat_async_call_acked = true;\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    panic!(\n                        \"received unexpected sucess: {:?}, cookie: {}\",\n                        result, cookie\n                    );\n                }\n            }\n        }\n    }\n\n    println!(\"--- pat waits for alice response\");\n    let mut pat_async_call_handled: bool = false;\n    while !pat_async_call_handled {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        if let Some(response) = pat.client_next_response() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    assert_eq!(sent_cookie, cookie);\n                    if let Some(bson::Bson::String(result)) = result {\n                        assert_eq!(result, \"Hello Delayed? - Delayed!\");\n                        println!(\"--- pat received success response\");\n                        pat_async_call_handled = true;\n                    }\n                }\n            }\n        }\n    }\n\n    println!(\"--- pat calling test::sha256(data: [0x00..])\");\n    let mut args: bson::document::Document = Default::default();\n    let data = vec![0u8; DEFAULT_MAX_MESSAGE_SIZE / 2];\n    args.insert(\n        \"data\",\n        bson::Bson::Binary(bson::Binary {\n            subtype: bson::spec::BinarySubtype::Generic,\n            bytes: data,\n        }),\n    );\n\n    let cookie1 = pat.client_call(\"test\", \"sha256\", 0, args)?;\n\n    println!(\"--- pat calling test::sha256(data: [0xff..])\");\n    let mut args: bson::document::Document = Default::default();\n    let data = vec![0xFFu8; DEFAULT_MAX_MESSAGE_SIZE / 2];\n    args.insert(\n        \"data\",\n        bson::Bson::Binary(bson::Binary {\n            subtype: bson::spec::BinarySubtype::Generic,\n            bytes: data,\n        }),\n    );\n\n    let cookie2 = pat.client_call(\"test\", \"sha256\", 0, args)?;\n\n    println!(\"--- pat waits for alice responses\");\n    let mut pat_0x00_buffer_hashed: bool = false;\n    let mut pat_0xff_buffer_hashed: bool = false;\n\n    while !pat_0x00_buffer_hashed || !pat_0xff_buffer_hashed {\n        alice.update(Some(alice_apisets))?;\n        pat.update(None)?;\n        for response in pat.client_drain_responses() {\n            match response {\n                Response::Pending { cookie } =\u003e {\n                    panic!(\"received unexpected pending, cookie: {}\", cookie);\n                }\n                Response::Error { cookie, error_code } =\u003e {\n                    panic!(\n                        \"received unexpected error: {}, cookie: {}\",\n                        error_code, cookie\n                    );\n                }\n                Response::Success { cookie, result } =\u003e {\n                    println!(\"cookie: {}, result: {:?}\", cookie, result);\n                    if let Some(bson::Bson::String(result)) = result {\n                        if cookie == cookie1 {\n                            pat_0x00_buffer_hashed = true;\n                            assert_eq!(\n                                result,\n                                \"463c61ad03873aa9e82581205205acc3d3c8346c7037c43e4e241ee529f2dc27\"\n                            );\n                            println!(\"--- pat received 0x00 buffer hash\");\n                        } else if cookie == cookie2 {\n                            assert_eq!(\n                                result,\n                                \"9bd2dc706dd5251ae8fad858931585c71a1b4587aa7ecb30e15880e1b9dcda16\"\n                            );\n                            pat_0xff_buffer_hashed = true;\n                            println!(\"--- pat received 0xff buffer hash\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":23,"address":[1294128,1294717],"length":1,"stats":{"Line":1}},{"line":27,"address":[1294237,1294375,1294164],"length":1,"stats":{"Line":3}},{"line":28,"address":[1294479],"length":1,"stats":{"Line":1}},{"line":30,"address":[1294533],"length":1,"stats":{"Line":1}},{"line":32,"address":[1294313],"length":1,"stats":{"Line":1}},{"line":37,"address":[1294752],"length":1,"stats":{"Line":1}},{"line":41,"address":[1294779],"length":1,"stats":{"Line":1}},{"line":45,"address":[1294864,1295838],"length":1,"stats":{"Line":1}},{"line":50,"address":[1295366,1294991,1295129,1294917],"length":1,"stats":{"Line":3}},{"line":51,"address":[1295236],"length":1,"stats":{"Line":1}},{"line":53,"address":[1295299],"length":1,"stats":{"Line":1}},{"line":54,"address":[1295324],"length":1,"stats":{"Line":1}},{"line":55,"address":[1295674],"length":1,"stats":{"Line":1}},{"line":57,"address":[1295371],"length":1,"stats":{"Line":1}},{"line":61,"address":[1295353],"length":1,"stats":{"Line":1}},{"line":63,"address":[1295067],"length":1,"stats":{"Line":0}},{"line":67,"address":[1295872,1296790],"length":1,"stats":{"Line":1}},{"line":71,"address":[1296122,1295910,1295984],"length":1,"stats":{"Line":2}},{"line":72,"address":[1296154],"length":1,"stats":{"Line":1}},{"line":73,"address":[1296171],"length":1,"stats":{"Line":1}},{"line":75,"address":[1296208],"length":1,"stats":{"Line":1}},{"line":77,"address":[1296358,1296230],"length":1,"stats":{"Line":2}},{"line":79,"address":[1296060],"length":1,"stats":{"Line":0}},{"line":85,"address":[1296816],"length":1,"stats":{"Line":1}},{"line":89,"address":[1296848,1298118,1298147],"length":1,"stats":{"Line":1}},{"line":96,"address":[1297181,1297344,1297105,1296957],"length":1,"stats":{"Line":4}},{"line":97,"address":[1297624,1296988,1297066,1297818],"length":1,"stats":{"Line":4}},{"line":98,"address":[1297823,1297724],"length":1,"stats":{"Line":2}},{"line":99,"address":[1297072,1297510,1297142],"length":1,"stats":{"Line":3}},{"line":100,"address":[1297148,1297370,1297198],"length":1,"stats":{"Line":3}},{"line":101,"address":[1297208],"length":1,"stats":{"Line":0}},{"line":103,"address":[1298012],"length":1,"stats":{"Line":0}},{"line":108,"address":[1298160],"length":1,"stats":{"Line":1}},{"line":109,"address":[1298177],"length":1,"stats":{"Line":1}}],"covered":30,"coverable":34},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","fuzz","fuzz_targets","fuzz_crypto.rs"],"content":"#![no_main]\n\n// tor_interface\nuse tor_interface::tor_crypto::*;\n\n// fuzzing\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::arbitrary;\nuse libfuzzer_sys::arbitrary::Arbitrary;\n\n#[derive(Arbitrary, Debug)]\nstruct CryptoData\u003c'a\u003e {\n    ed25519_public_raw: [u8; 32],\n    onion_service_id: \u0026'a str,\n    x25519_public_raw: [u8; 32],\n    message_1: \u0026'a [u8],\n    message_2: \u0026'a [u8],\n    ed25519_private_raw_1: [u8; 64],\n    ed25519_private_raw_2: [u8; 64],\n    x25519_private_raw_1: [u8; 32],\n    x25519_private_raw_2: [u8; 32],\n}\n\nfuzz_target!(|data: CryptoData| {\n\n    //\n    // ed25519 tests\n    //\n\n    // ensure random bytes don't break ed25519public from_raw\n    let _ = Ed25519PublicKey::from_raw(\u0026data.ed25519_public_raw);\n\n    // ensure random string doesn't break v3onionserviceid from_string\n    let _ = V3OnionServiceId::from_string(data.onion_service_id);\n\n    // ensure random bytes don't break x25519public from_raw\n    let _ = X25519PublicKey::from_raw(\u0026data.x25519_public_raw);\n\n    // try to build key from raw binary blob, return early if invalid\n    if let Ok(ed25519_private_1) = Ed25519PrivateKey::from_raw(\u0026data.ed25519_private_raw_1) {\n        // ensure key round-trips through keyblob representation\n        assert_eq!(Ed25519PrivateKey::from_key_blob(ed25519_private_1.to_key_blob().as_ref()).unwrap(), ed25519_private_1);\n\n        // ensure key round-trips through raw bytes representation\n        match Ed25519PrivateKey::from_raw(\u0026ed25519_private_1.to_bytes()) {\n            Ok(ed25519_private) =\u003e assert_eq!(ed25519_private, ed25519_private_1),\n            Err(err) =\u003e panic!(\"{:?}\", err),\n        }\n\n        // derive private keys public key\n        let ed25519_public_1 = Ed25519PublicKey::from_private_key(\u0026ed25519_private_1);\n\n        // compare onion service id derivation from public vs privat ekey\n        assert_eq!(V3OnionServiceId::from_private_key(\u0026ed25519_private_1), V3OnionServiceId::from_public_key(\u0026ed25519_public_1));\n        let onion_service_id_1 = V3OnionServiceId::from_public_key(\u0026ed25519_public_1);\n        // ensure service id round-trips through string representation\n        assert_eq!(V3OnionServiceId::from_string(\u0026onion_service_id_1.to_string()).unwrap(), onion_service_id_1);\n\n        // ensure public key round-trips through service id\n        assert_eq!(ed25519_public_1, Ed25519PublicKey::from_service_id(\u0026V3OnionServiceId::from_public_key(\u0026ed25519_public_1)).unwrap());\n\n        // ensure key round-trips through raw bytes representation\n        assert_eq!(ed25519_public_1, Ed25519PublicKey::from_raw(ed25519_public_1.as_bytes()).unwrap());\n\n        // sign and verify a message\n        let ed25519_signature_1 = ed25519_private_1.sign_message(data.message_1);\n        assert!(ed25519_signature_1.verify(data.message_1, \u0026ed25519_public_1));\n        // verify signature does not work for unrelated message\n        if data.message_1 != data.message_2 {\n            assert!(!ed25519_signature_1.verify(data.message_2, \u0026ed25519_public_1));\n        }\n\n        // ensure we can't verfify another key's signature\n        if data.ed25519_private_raw_1 != data.ed25519_private_raw_2 {\n            // try to build key from raw binary blob, return early if invalid\n            if let Ok(ed25519_private_2) = Ed25519PrivateKey::from_raw(\u0026data.ed25519_private_raw_2) {\n\n                // ensure key round-trips through keyblob representation\n                assert_eq!(Ed25519PrivateKey::from_key_blob(ed25519_private_2.to_key_blob().as_ref()).unwrap(), ed25519_private_2);\n\n                // ensure key round-trips through raw bytes representation\n                match Ed25519PrivateKey::from_raw(\u0026ed25519_private_2.to_bytes()) {\n                    Ok(ed25519_private) =\u003e assert_eq!(ed25519_private, ed25519_private_2),\n                    Err(err) =\u003e panic!(\"{:?}\", err),\n                }\n\n                // derive private key's public key\n                let ed25519_public_2 = Ed25519PublicKey::from_private_key(\u0026ed25519_private_2);\n\n                // compare onion service id derivation from public vs privat ekey\n                assert_eq!(V3OnionServiceId::from_private_key(\u0026ed25519_private_2), V3OnionServiceId::from_public_key(\u0026ed25519_public_2));\n                let onion_service_id_2 = V3OnionServiceId::from_public_key(\u0026ed25519_public_2);\n                // ensure service id round-trips through string representation\n                assert_eq!(V3OnionServiceId::from_string(\u0026onion_service_id_2.to_string()).unwrap(), onion_service_id_2);\n\n                // ensure public key round-trips through service id\n                assert_eq!(ed25519_public_2, Ed25519PublicKey::from_service_id(\u0026V3OnionServiceId::from_public_key(\u0026ed25519_public_2)).unwrap());\n\n                // ensure key round-trips through raw bytes representation\n                assert_eq!(ed25519_public_2, Ed25519PublicKey::from_raw(ed25519_public_2.as_bytes()).unwrap());\n\n\n                // sign and verify a message\n                let ed25519_signature_2 = ed25519_private_2.sign_message(data.message_2);\n                assert!(ed25519_signature_2.verify(data.message_2, \u0026ed25519_public_2));\n\n                // verify signature does not work for unrelated message\n                if data.message_1 != data.message_2 {\n                    assert!(!ed25519_signature_2.verify(data.message_1, \u0026ed25519_public_2));\n                }\n\n                // verify we cannot verify signatures using the wrong public keys\n                if ed25519_public_1 != ed25519_public_2 {\n                    assert!(!ed25519_signature_1.verify(data.message_1, \u0026ed25519_public_2));\n                    assert!(!ed25519_signature_2.verify(data.message_2, \u0026ed25519_public_1));\n                }\n            }\n        }\n    }\n\n    //\n    // x25519 tests\n    //\n\n    if let Ok(x25519_private_1) = X25519PrivateKey::from_raw(\u0026data.x25519_private_raw_1) {\n        // ensure round-trips through byte representation\n        assert_eq!(x25519_private_1, X25519PrivateKey::from_raw(\u0026x25519_private_1.to_bytes()).unwrap());\n        assert_eq!(data.x25519_private_raw_1, x25519_private_1.to_bytes());\n        // ensure round-trips through base64 representation\n        assert_eq!(x25519_private_1, X25519PrivateKey::from_base64(\u0026x25519_private_1.to_base64()).unwrap());\n\n        // ensure converts to e25519 without issue\n        let _ = Ed25519PrivateKey::from_private_x25519(\u0026x25519_private_1).unwrap();\n\n        let x25519_public_1 = X25519PublicKey::from_private_key(\u0026x25519_private_1);\n        // ensure round-trips through byte representation\n        assert_eq!(x25519_public_1, X25519PublicKey::from_raw(x25519_public_1.as_bytes()));\n        // ensure round-trips through base32 representation\n        assert_eq!(x25519_public_1, X25519PublicKey::from_base32(\u0026x25519_public_1.to_base32()).unwrap());\n\n        if let Ok(x25519_private_2) = X25519PrivateKey::from_raw(\u0026data.x25519_private_raw_2) {\n            // ensure round-trips through byte representation\n            assert_eq!(x25519_private_2, X25519PrivateKey::from_raw(\u0026x25519_private_2.to_bytes()).unwrap());\n            assert_eq!(data.x25519_private_raw_2, x25519_private_2.to_bytes());\n            // ensure round-trips through base64 representation\n            assert_eq!(x25519_private_2, X25519PrivateKey::from_base64(\u0026x25519_private_2.to_base64()).unwrap());\n\n            // ensure converts to e25519 without issue\n            let _ = Ed25519PrivateKey::from_private_x25519(\u0026x25519_private_2).unwrap();\n\n            let x25519_public_2 = X25519PublicKey::from_private_key(\u0026x25519_private_2);\n            // ensure round-trips through byte representation\n            assert_eq!(x25519_public_2, X25519PublicKey::from_raw(x25519_public_2.as_bytes()));\n            // ensure round-trips through base32 representation\n            assert_eq!(x25519_public_2, X25519PublicKey::from_base32(\u0026x25519_public_2.to_base32()).unwrap());\n        }\n    }\n\n\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","arti_client_tor_client.rs"],"content":"// standard\nuse std::net::SocketAddr;\nuse std::ops::DerefMut;\nuse std::path::{Path, PathBuf};\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::{Arc, Mutex};\n\n//extern\nuse arti_client::config::{CfgPath, TorClientConfigBuilder};\nuse arti_client::{BootstrapBehavior, DangerouslyIntoTorAddr, IntoTorAddr, TorClient};\nuse fs_mistrust::Mistrust;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::{TcpListener, TcpStream};\nuse tokio::runtime;\nuse tokio_stream::StreamExt;\nuse tor_cell::relaycell::msg::Connected;\nuse tor_hscrypto::pk::HsIdKeypair;\nuse tor_hsservice::config::OnionServiceConfigBuilder;\nuse tor_hsservice::{HsIdKeypairSpecifier, HsNickname, OnionService, RunningOnionService};\nuse tor_keymgr::{ArtiEphemeralKeystore, KeyMgrBuilder, KeystoreSelector};\nuse tor_llcrypto::pk::ed25519::ExpandedKeypair;\nuse tor_persist::state_dir::StateDirectory;\nuse tor_proto::stream::IncomingStreamRequest;\nuse tor_rtcompat::PreferredRuntime;\n\n// internal crates\nuse crate::tor_crypto::*;\nuse crate::tor_provider;\nuse crate::tor_provider::*;\n\n/// [`ArtiClientTorClient`]-specific error type\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"not implemented\")]\n    NotImplemented(),\n\n    #[error(\"unable to bind TCP listener\")]\n    TcpListenerBindFailed(#[source] std::io::Error),\n\n    #[error(\"unable to get TCP listener's local address\")]\n    TcpListenerLocalAddrFailed(#[source] std::io::Error),\n\n    #[error(\"unable to accept connection on TCP Listener\")]\n    TcpListenerAcceptFailed(#[source] std::io::Error),\n\n    #[error(\"unable to connect to TCP listener\")]\n    TcpStreamConnectFailed(#[source] std::io::Error),\n\n    #[error(\"unable to convert tokio::TcpStream to std::net::TcpStream\")]\n    TcpStreamIntoFailed(#[source] std::io::Error),\n\n    #[error(\"arti-client config-builder error: {0}\")]\n    ArtiClientConfigBuilderError(#[source] arti_client::config::ConfigBuildError),\n\n    #[error(\"arti-client error: {0}\")]\n    ArtiClientError(#[source] arti_client::Error),\n\n    #[error(\"arti-client tor-addr error: {0}\")]\n    ArtiClientTorAddrError(#[source] arti_client::TorAddrError),\n\n    #[error(\"tor-keymgr error: {0}\")]\n    TorKeyMgrError(#[source] tor_keymgr::Error),\n\n    // TODO: the 'real' error (tor_keymgr::mgr::KeyMgrBuilderError) isn't\n    // actually defined anywhere from what I can tell\n    #[error(\"failed to build KeyMgr\")]\n    TorKeyMgrBuilderError(),\n\n    #[error(\"unexpected key found when inserting HsIdKeypair\")]\n    KeyMgrInsertionFailure(),\n\n    #[error(\"onion-service config-builder error: {0}\")]\n    OnionServiceConfigBuilderError(#[source] tor_config::ConfigBuildError),\n\n    #[error(\"tor-persist error: {0}\")]\n    TorPersistError(#[source] tor_persist::Error),\n\n    #[error(\"tor-hsservice startup error: {0}\")]\n    TorHsServiceStartupError(#[source] tor_hsservice::StartupError),\n}\n\nimpl From\u003cError\u003e for crate::tor_provider::Error {\n    fn from(error: Error) -\u003e Self {\n        crate::tor_provider::Error::Generic(error.to_string())\n    }\n}\n\n/// The `ArtiClientTorClient` is an in-process [`arti-client`](https://crates.io/crates/arti-client)-based [`TorProvider`].\n///\n///\npub struct ArtiClientTorClient {\n    tokio_runtime: Arc\u003cruntime::Runtime\u003e,\n    arti_client: TorClient\u003cPreferredRuntime\u003e,\n    state_dir: PathBuf,\n    fs_mistrust: Mistrust,\n    pending_events: Arc\u003cMutex\u003cVec\u003cTorEvent\u003e\u003e\u003e,\n}\n\n// used to forward traffic to/from arti to local tcp streams\nasync fn forward_stream\u003cR, W\u003e(alive: Arc\u003cAtomicBool\u003e, mut reader: R, mut writer: W) -\u003e ()\nwhere\n    R: AsyncReadExt + Unpin,\n    W: AsyncWriteExt + Unpin,\n{\n    // allow 100ms timeout on reads to verify writer is still good\n    let read_timeout = std::time::Duration::from_millis(100);\n    // allow additional retries in the event the other half of the pump\n    // dies; keep pumping data until our read times out 3 times\n    let mut remaining_retries = 3;\n    let mut buf = [0u8; 1024];\n\n    loop {\n        if !alive.load(Ordering::Relaxed) \u0026\u0026 remaining_retries == 0 {\n            break;\n        }\n\n        tokio::select! {\n            count = reader.read(\u0026mut buf) =\u003e match count {\n                // end of stream\n                Ok(0) =\u003e break,\n                // read N bytes\n                Ok(count) =\u003e {\n                    // forward traffic\n                    match writer.write_all(\u0026buf[0..count]).await {\n                        Ok(()) =\u003e (),\n                        Err(_err) =\u003e break,\n                    }\n                    match writer.flush().await {\n                        Ok(()) =\u003e (),\n                        Err(_err) =\u003e break,\n                    }\n                },\n                // read failed\n                Err(_err) =\u003e break,\n            },\n            _ = tokio::time::sleep(read_timeout.clone()) =\u003e match writer.flush().await {\n                Ok(()) =\u003e {\n                    // so long as our writer and reader are good, we should\n                    // allow a few additional data pump attempts\n                    if !alive.load(Ordering::Relaxed) {\n                        remaining_retries -= 1;\n                    }\n                },\n                Err(_err) =\u003e break,\n            }\n        }\n    }\n    // signal pump death\n    alive.store(false, Ordering::Relaxed);\n}\n\nimpl ArtiClientTorClient {\n    /// Construct a new `ArtiClientTorClient` which uses a [Tokio](https://crates.io/crates/tokio) runtime internally for all async operations.\n    pub fn new(\n        tokio_runtime: Arc\u003cruntime::Runtime\u003e,\n        root_data_directory: \u0026Path,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        // set custom config options\n        let mut config_builder: TorClientConfigBuilder = Default::default();\n\n        // manually set arti cache and data directories so we can have\n        // multiple concurrent instances and control where it writes\n        let mut cache_dir = PathBuf::from(root_data_directory);\n        cache_dir.push(\"cache\");\n        config_builder\n            .storage()\n            .cache_dir(CfgPath::new_literal(cache_dir));\n\n        let mut state_dir = PathBuf::from(root_data_directory);\n        state_dir.push(\"state\");\n        config_builder\n            .storage()\n            .state_dir(CfgPath::new_literal(state_dir.clone()));\n\n        // disable access to clearnet addresses and enable access to onion services\n        config_builder\n            .address_filter()\n            .allow_local_addrs(false)\n            .allow_onion_addrs(true);\n\n        let config = match config_builder.build() {\n            Ok(config) =\u003e config,\n            Err(err) =\u003e return Err(err).map_err(Error::ArtiClientConfigBuilderError),\n        };\n\n        let fs_mistrust = config.fs_mistrust().clone();\n\n        let arti_client = tokio_runtime.block_on(async {\n            TorClient::builder()\n                .config(config)\n                .bootstrap_behavior(BootstrapBehavior::Manual)\n                .create_unbootstrapped()\n                .map_err(Error::ArtiClientError)\n\n            // TODO: implement TorEvent::LogReceived events once upstream issue is resolved:\n            // https://gitlab.torproject.org/tpo/core/arti/-/issues/1356\n        })?;\n\n        let pending_events = std::vec![TorEvent::LogReceived {\n            line: \"Starting arti-client TorProvider\".to_string()\n        }];\n        let pending_events = Arc::new(Mutex::new(pending_events));\n\n        Ok(Self {\n            tokio_runtime,\n            arti_client,\n            state_dir,\n            fs_mistrust,\n            pending_events,\n        })\n    }\n}\n\nimpl TorProvider for ArtiClientTorClient {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, tor_provider::Error\u003e {\n        std::thread::sleep(std::time::Duration::from_millis(16));\n        match self.pending_events.lock() {\n            Ok(mut pending_events) =\u003e Ok(std::mem::take(pending_events.deref_mut())),\n            Err(_) =\u003e {\n                unreachable!(\"another thread panicked while holding this pending_events mutex\")\n            }\n        }\n    }\n\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        // save progress events\n        let mut bootstrap_events = self.arti_client.bootstrap_events();\n        let pending_events = self.pending_events.clone();\n        self.tokio_runtime.spawn(async move {\n            while let Some(evt) = bootstrap_events.next().await {\n                match pending_events.lock() {\n                    Ok(mut pending_events) =\u003e {\n                        pending_events.push(TorEvent::BootstrapStatus {\n                            progress: (evt.as_frac().clamp(0.0f32, 1.0f32) * 100f32) as u32,\n                            tag: \"no-tag\".to_string(),\n                            summary: \"no summary\".to_string(),\n                        });\n                        // TODO: properly handle evt.blocked() with a new TorEvent::Error or something\n                    }\n                    Err(_) =\u003e unreachable!(\n                        \"another thread panicked while holding this pending_events mutex\"\n                    ),\n                }\n            }\n        });\n\n        // initiate bootstrap\n        let arti_client = self.arti_client.clone();\n        let pending_events = self.pending_events.clone();\n        self.tokio_runtime.spawn(async move {\n            match arti_client.bootstrap().await {\n                Ok(()) =\u003e match pending_events.lock() {\n                    Ok(mut pending_events) =\u003e {\n                        pending_events.push(TorEvent::BootstrapComplete);\n                        return;\n                    }\n                    Err(_) =\u003e unreachable!(\n                        \"another thread panicked while holding this pending_events mutex\"\n                    ),\n                },\n                Err(_err) =\u003e {\n                    // TODO: add an error event to TorEvent\n                }\n            }\n        });\n\n        Ok(())\n    }\n\n    fn add_client_auth(\n        \u0026mut self,\n        _service_id: \u0026V3OnionServiceId,\n        _client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Err(Error::NotImplemented().into())\n    }\n\n    fn remove_client_auth(\n        \u0026mut self,\n        _service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Err(Error::NotImplemented().into())\n    }\n\n    fn connect(\n        \u0026mut self,\n        target: TargetAddr,\n        circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, tor_provider::Error\u003e {\n        // stream isolation not implemented yet\n        if circuit.is_some() {\n            return Err(Error::NotImplemented().into());\n        }\n\n        // connect to onion service\n        let arti_target = match target.clone() {\n            TargetAddr::Socket(socket_addr) =\u003e socket_addr.into_tor_addr_dangerously(),\n            TargetAddr::Domain(domain_addr) =\u003e {\n                (domain_addr.domain(), domain_addr.port()).into_tor_addr()\n            }\n            TargetAddr::OnionService(OnionAddr::V3(OnionAddrV3 {\n                service_id,\n                virt_port,\n            })) =\u003e (format!(\"{}.onion\", service_id), virt_port).into_tor_addr(),\n        }\n        .map_err(Error::ArtiClientTorAddrError)?;\n\n        let arti_client = self.arti_client.clone();\n        let data_stream = self\n            .tokio_runtime\n            .block_on(async move { arti_client.connect(arti_target).await })\n            .map_err(Error::ArtiClientError)?;\n\n        // start a task to forward traffic from returned data stream\n        // and tcp socket\n        let client_stream = self.tokio_runtime.block_on(async move {\n            let (data_reader, data_writer) = data_stream.split();\n\n            // try to bind to a local address, let OS pick our port\n            let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n            let server_listener = TcpListener::bind(socket_addr)\n                .await\n                .map_err(Error::TcpListenerBindFailed)?;\n            // await future after a client connects\n            let server_accept_future = server_listener.accept();\n            let socket_addr = server_listener\n                .local_addr()\n                .map_err(Error::TcpListenerLocalAddrFailed)?;\n\n            // client stream will ultimatley be returned from connect()\n            let client_stream = TcpStream::connect(socket_addr)\n                .await\n                .map_err(Error::TcpStreamConnectFailed)?;\n            // client has connected so now get the server's tcp stream\n            let (server_stream, _socket_addr) = server_accept_future\n                .await\n                .map_err(Error::TcpListenerAcceptFailed)?;\n            let (tcp_reader, tcp_writer) = server_stream.into_split();\n\n            // now spawn new tasks to forward traffic to/from local listener\n            let pump_alive = Arc::new(AtomicBool::new(true));\n            tokio::task::spawn({\n                let pump_alive = pump_alive.clone();\n                async move {\n                    forward_stream(pump_alive, tcp_reader, data_writer).await;\n                }\n            });\n            tokio::task::spawn(async move {\n                forward_stream(pump_alive, data_reader, tcp_writer).await;\n            });\n            Ok::\u003cTcpStream, tor_provider::Error\u003e(client_stream)\n        })?;\n\n        let stream = client_stream\n            .into_std()\n            .map_err(Error::TcpStreamIntoFailed)?;\n        Ok(OnionStream {\n            stream,\n            local_addr: None,\n            peer_addr: Some(target),\n        })\n    }\n\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, tor_provider::Error\u003e {\n        // client auth is not implemented yet\n        if authorized_clients.is_some() {\n            return Err(Error::NotImplemented().into());\n        }\n\n        // try to bind to a local address, let OS pick our port\n        let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n        // TODO: make this one async too\n        let listener =\n            std::net::TcpListener::bind(socket_addr).map_err(Error::TcpListenerBindFailed)?;\n        let socket_addr = listener\n            .local_addr()\n            .map_err(Error::TcpListenerLocalAddrFailed)?;\n\n        // create a new ephemeral store for storing our onion service keys\n        let ephemeral_store: ArtiEphemeralKeystore =\n            ArtiEphemeralKeystore::new(\"ephemeral\".to_string());\n        let keymgr = match KeyMgrBuilder::default()\n            .default_store(Box::new(ephemeral_store))\n            .build()\n        {\n            Ok(keymgr) =\u003e keymgr,\n            Err(_) =\u003e return Err(Error::TorKeyMgrBuilderError().into()),\n        };\n\n        // generate a nickname to identify this onion service\n        let service_id = V3OnionServiceId::from_private_key(private_key);\n        let hs_nickname = match HsNickname::new(service_id.to_string()) {\n            Ok(nickname) =\u003e nickname,\n            Err(_) =\u003e {\n                panic!(\"v3 onion service id string representation should be a valid HsNickname\")\n            }\n        };\n\n        let hs_id_spec = HsIdKeypairSpecifier::new(hs_nickname.clone());\n        // generate a new HsIdKeypair (from an Ed25519PrivateKey)\n        // clone() isn't implemented for ExpandedKeypair \u003e:[\n        let secret_key_bytes = private_key.inner().to_secret_key_bytes();\n        let expanded_keypair = ExpandedKeypair::from_secret_key_bytes(secret_key_bytes)\n            .unwrap()\n            .into();\n\n        // write the HsIdKeypair to keymgr\n        // TODO: for now this should return Ok(None) unless we persist the ephemeral store longer-term (ie for client auth keys in the future)\n        match keymgr.insert::\u003cHsIdKeypair\u003e(expanded_keypair, \u0026hs_id_spec, KeystoreSelector::Default)\n        {\n            Ok(None) =\u003e (), // expected\n            Ok(Some(_)) =\u003e return Err(Error::KeyMgrInsertionFailure().into()),\n            Err(err) =\u003e Err(err).map_err(Error::TorKeyMgrError)?,\n        }\n\n        // create an OnionServiceConfig with the ephemeral nickname\n        let onion_service_config = match OnionServiceConfigBuilder::default()\n            .nickname(hs_nickname)\n            .build()\n        {\n            Ok(onion_service_config) =\u003e onion_service_config,\n            Err(err) =\u003e Err(err).map_err(Error::OnionServiceConfigBuilderError)?,\n        };\n\n        // create OnionService\n        let state_dir = match StateDirectory::new(self.state_dir.as_path(), \u0026self.fs_mistrust) {\n            Ok(state_dir) =\u003e state_dir,\n            Err(err) =\u003e Err(err).map_err(Error::TorPersistError)?,\n        };\n        let onion_service = OnionService::new(onion_service_config, Arc::new(keymgr), \u0026state_dir)\n            .map_err(Error::TorHsServiceStartupError)?;\n\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id.clone(), virt_port));\n\n        // launch the OnionService and get a Stream of RendRequest\n        let runtime = self.arti_client.runtime().clone();\n        let dirmgr = self.arti_client.dirmgr().clone().upcast_arc();\n        let hs_circ_pool = self.arti_client.hs_circ_pool().clone();\n\n        let (onion_service, mut rend_requests) = onion_service\n            .launch(runtime, dirmgr, hs_circ_pool)\n            .map_err(Error::TorHsServiceStartupError)?;\n\n        // start a task to signal onion service published\n        let pending_events = self.pending_events.clone();\n        let mut status_events = onion_service.status_events();\n        self.tokio_runtime.spawn(async move {\n            while let Some(evt) = status_events.next().await {\n                match evt.state() {\n                    tor_hsservice::status::State::Running =\u003e match pending_events.lock() {\n                        Ok(mut pending_events) =\u003e {\n                            pending_events.push(TorEvent::OnionServicePublished { service_id });\n                            return;\n                        }\n                        Err(_) =\u003e unreachable!(\n                            \"another thread panicked while holding this pending_events mutex\"\n                        ),\n                    },\n                    _ =\u003e (),\n                }\n            }\n        });\n\n        // start a task which accepts every RendRequest to get a StreamRequest\n        self.tokio_runtime.spawn(async move {\n            while let Some(request) = rend_requests.next().await {\n                let mut stream_requests = match request.accept().await {\n                    Ok(stream_requests) =\u003e stream_requests,\n                    // TODO: probably not our problem?\n                    _ =\u003e return,\n                };\n                // spawn a new task to consume the stream requsts\n                tokio::task::spawn(async move {\n                    while let Some(stream_request) = stream_requests.next().await {\n                        let should_accept =\n                            if let IncomingStreamRequest::Begin(begin) = stream_request.request() {\n                                // we only accept connections on the virt port\n                                begin.port() == virt_port\n                            } else {\n                                false\n                            };\n\n                        if should_accept {\n                            let data_stream =\n                                match stream_request.accept(Connected::new_empty()).await {\n                                    Ok(data_stream) =\u003e data_stream,\n                                    // TODO: probably not our problem\n                                    _ =\u003e continue,\n                                };\n                            let (data_reader, data_writer) = data_stream.split();\n\n                            let (tcp_reader, tcp_writer) =\n                                match TcpStream::connect(socket_addr).await {\n                                    Ok(tcp_stream) =\u003e tcp_stream.into_split(),\n                                    // TODO: possibly our problem?\n                                    _ =\u003e continue,\n                                };\n                            // now spawn new tasks to forward traffic to/from the onion listener\n\n                            let pump_alive = Arc::new(AtomicBool::new(true));\n                            // read from connected client and write to local socket\n                            tokio::task::spawn({\n                                let pump_alive = pump_alive.clone();\n                                async move {\n                                    forward_stream(pump_alive, data_reader, tcp_writer).await;\n                                }\n                            });\n                            // read from local socket and write to connected client\n                            tokio::task::spawn(async move {\n                                forward_stream(pump_alive, tcp_reader, data_writer).await;\n                            });\n                        } else {\n                            // either requesting the wrong port or the wrong type of stream request\n                            let _ = stream_request.shutdown_circuit();\n                        }\n                    }\n                });\n            }\n        });\n\n        // onion-service is torn down when `onion_service` is dropped\n        Ok(OnionListener::new::\u003cArc\u003cRunningOnionService\u003e\u003e(listener, onion_addr, onion_service, |_|{}))\n    }\n\n    fn generate_token(\u0026mut self) -\u003e CircuitToken {\n        0usize\n    }\n\n    fn release_token(\u0026mut self, _token: CircuitToken) {}\n}\n","traces":[{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","censorship_circumvention.rs"],"content":"// standard\nuse std::net::SocketAddr;\nuse std::path::PathBuf;\nuse std::str::FromStr;\nuse std::sync::OnceLock;\n\n// extern crates\nuse regex::Regex;\n\n#[derive(Clone, Debug)]\n/// Configuration for a pluggable-transport\npub struct PluggableTransportConfig {\n    transports: Vec\u003cString\u003e,\n    path_to_binary: PathBuf,\n    options: Vec\u003cString\u003e,\n}\n\n#[derive(thiserror::Error, Debug)]\n/// Error returned on failure to construct a [`PluggableTransportConfig`]\npub enum PluggableTransportConfigError {\n    #[error(\"pluggable transport name '{0}' is invalid\")]\n    /// transport names must be a valid C identifier\n    TransportNameInvalid(String),\n    #[error(\"unable to use '{0}' as pluggable transport binary path, {1}\")]\n    /// configuration only allows aboslute paths to binaries\n    BinaryPathInvalid(String, String),\n}\n\n// per the PT spec: https://github.com/Pluggable-Transports/Pluggable-Transports-spec/blob/main/releases/PTSpecV1.0/pt-1_0.txt\nstatic TRANSPORT_PATTERN: OnceLock\u003cRegex\u003e = OnceLock::new();\nfn init_transport_pattern() -\u003e Regex {\n    Regex::new(r\"(?m)^[a-zA-Z_][a-zA-Z0-9_]*$\").unwrap()\n}\n\n/// Configuration struct for a pluggable-transport which conforms to the v1.0 pluggable-transport [specification](https://github.com/Pluggable-Transports/Pluggable-Transports-spec/blob/main/releases/PTSpecV1.0/pt-1_0.txt)\nimpl PluggableTransportConfig {\n    /// Construct a new `PluggableTransportConfig`. Each `transport` string must be a [valid C identifier](https://github.com/Pluggable-Transports/Pluggable-Transports-spec/blob/c92e59a9fa6ba11c181f4c5ec9d533eaa7d9d7f3/releases/PTSpecV1.0/pt-1_0.txt#L144) while `path_to_binary` must be an absolute path.\n    pub fn new(\n        transports: Vec\u003cString\u003e,\n        path_to_binary: PathBuf,\n    ) -\u003e Result\u003cSelf, PluggableTransportConfigError\u003e {\n        let transport_pattern = TRANSPORT_PATTERN.get_or_init(init_transport_pattern);\n        // validate each transport\n        for transport in \u0026transports {\n            if !transport_pattern.is_match(\u0026transport) {\n                return Err(PluggableTransportConfigError::TransportNameInvalid(\n                    transport.clone(),\n                ));\n            }\n        }\n\n        // pluggable transport path must be absolute so we can fix it up for individual\n        // TorProvider implementations\n        if !path_to_binary.is_absolute() {\n            return Err(PluggableTransportConfigError::BinaryPathInvalid(\n                format!(\"{:?}\", path_to_binary.display()),\n                \"must be an absolute path\".to_string(),\n            ));\n        }\n\n        Ok(Self {\n            transports,\n            path_to_binary,\n            options: Default::default(),\n        })\n    }\n\n    /// Get a reference to this `PluggableTransportConfig`'s list of transports.\n    pub fn transports(\u0026self) -\u003e \u0026Vec\u003cString\u003e {\n        \u0026self.transports\n    }\n\n    /// Get a reference to this `PluggableTransportConfig`'s `PathBuf` containing the absolute path to the pluggable-transport binary.\n    pub fn path_to_binary(\u0026self) -\u003e \u0026PathBuf {\n        \u0026self.path_to_binary\n    }\n\n    /// Get a reference to this `PluggableTransportConfig`'s list of command-line options\n    pub fn options(\u0026self) -\u003e \u0026Vec\u003cString\u003e {\n        \u0026self.options\n    }\n\n    /// Add a command-line option used to invoke this pluggable-transport.\n    pub fn add_option(\u0026mut self, arg: String) {\n        self.options.push(arg);\n    }\n}\n\n/// Configuration for a bridge line to be used with a pluggable-transport\n#[derive(Clone, Debug)]\npub struct BridgeLine {\n    transport: String,\n    address: SocketAddr,\n    fingerprint: String,\n    keyvalues: Vec\u003c(String, String)\u003e,\n}\n\n#[derive(thiserror::Error, Debug)]\n/// Error returned on failure to construct a [`BridgeLine`]\npub enum BridgeLineError {\n    #[error(\"bridge line '{0}' missing transport\")]\n    /// Provided bridge line missing transport\n    TransportMissing(String),\n\n    #[error(\"bridge line '{0}' missing address\")]\n    /// Provided bridge line missing address\n    AddressMissing(String),\n\n    #[error(\"bridge line '{0}' missing fingerprint\")]\n    /// Provided bridge line missing fingerprint\n    FingerprintMissing(String),\n\n    #[error(\"transport name '{0}' is invalid\")]\n    /// Invalid transport name (must be a valid C identifier)\n    TransportNameInvalid(String),\n\n    #[error(\"address '{0}' cannot be parsed as IP:PORT\")]\n    /// Provided bridge line's address not parseable\n    AddressParseFailed(String),\n\n    #[error(\"key=value '{0}' is invalid\")]\n    /// A key/value pair in invalid format\n    KeyValueInvalid(String),\n\n    #[error(\"bridge address port must not be 0\")]\n    /// Invalid bridge address port\n    AddressPortInvalid,\n\n    #[error(\"fingerprint '{0}' is invalid\")]\n    /// Fingerprint is not parseable (must be length 40 base16 string)\n    FingerprintInvalid(String),\n}\n\n/// A `BridgeLine` contains the information required to connect to a bridge through the means of a particular pluggable-transport (defined in a `PluggableTransportConfi`). For more information, see:\n/// - [https://tb-manual.torproject.org/bridges/](https://tb-manual.torproject.org/bridges/)\nimpl BridgeLine {\n    /// Construct a new `BridgeLine` from its constiuent parts. The `transport` argument must be a valid C identifier and must have an associated `transport` defined in an associated `PluggableTransportConfig`. The `address` must have a non-zero port. The `fingerprint` is a length 40 base16-encoded string. Finally, the keys in the `keyvalues` list must not contain space (` `) or equal (`=`) characters.\n    ///\n    /// In practice, bridge lines are distributed as entire strings so most consumers of these APIs are not likely to need this particular function.\n    pub fn new(\n        transport: String,\n        address: SocketAddr,\n        fingerprint: String,\n        keyvalues: Vec\u003c(String, String)\u003e,\n    ) -\u003e Result\u003cBridgeLine, BridgeLineError\u003e {\n        let transport_pattern = TRANSPORT_PATTERN.get_or_init(init_transport_pattern);\n\n        // transports have a particular pattern\n        if !transport_pattern.is_match(\u0026transport) {\n            return Err(BridgeLineError::TransportNameInvalid(transport));\n        }\n\n        // port can't be 0\n        if address.port() == 0 {\n            return Err(BridgeLineError::AddressPortInvalid);\n        }\n\n        static BRIDGE_FINGERPRINT_PATTERN: OnceLock\u003cRegex\u003e = OnceLock::new();\n        let bridge_fingerprint_pattern = BRIDGE_FINGERPRINT_PATTERN\n            .get_or_init(|| Regex::new(r\"(?m)^[0-9a-fA-F]{40}$\").unwrap());\n\n        // fingerprint should be a sha1 hash\n        if !bridge_fingerprint_pattern.is_match(\u0026fingerprint) {\n            return Err(BridgeLineError::FingerprintInvalid(fingerprint));\n        }\n\n        // validate key-values\n        for (key, value) in \u0026keyvalues {\n            if key.contains(' ') || key.contains('=') || key.len() == 0 {\n                return Err(BridgeLineError::KeyValueInvalid(format!(\"{key}={value}\")));\n            }\n        }\n\n        Ok(Self {\n            transport,\n            address,\n            fingerprint,\n            keyvalues,\n        })\n    }\n\n    /// Get a reference to this `BridgeLine`'s transport field.\n    pub fn transport(\u0026self) -\u003e \u0026String {\n        \u0026self.transport\n    }\n\n    /// Get a reference to this `BridgeLine`'s address field.\n    pub fn address(\u0026self) -\u003e \u0026SocketAddr {\n        \u0026self.address\n    }\n\n    /// Get a reference to this `BridgeLine`'s fingerprint field.\n    pub fn fingerprint(\u0026self) -\u003e \u0026String {\n        \u0026self.fingerprint\n    }\n\n    /// Get a reference to this `BridgeLine`'s key/values field.\n    pub fn keyvalues(\u0026self) -\u003e \u0026Vec\u003c(String, String)\u003e {\n        \u0026self.keyvalues\n    }\n\n    #[cfg(feature = \"legacy-tor-provider\")]\n    /// Serialise this `BridgeLine` to the value set via `SETCONF Bridge...` legacy c-tor control-port command.\n    pub fn as_legacy_tor_setconf_value(\u0026self) -\u003e String {\n        let transport = \u0026self.transport;\n        let address = self.address.to_string();\n        let fingerprint = self.fingerprint.to_string();\n        let keyvalues: Vec\u003cString\u003e = self\n            .keyvalues\n            .iter()\n            .map(|(key, value)| format!(\"{key}={value}\"))\n            .collect();\n        let keyvalues = keyvalues.join(\" \");\n\n        format!(\"{transport} {address} {fingerprint} {keyvalues}\")\n    }\n}\n\nimpl FromStr for BridgeLine {\n    type Err = BridgeLineError;\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut tokens = s.split(' ');\n        // get transport name\n        let transport = if let Some(transport) = tokens.next() {\n            transport\n        } else {\n            return Err(BridgeLineError::TransportMissing(s.to_string()));\n        };\n        // get bridge address\n        let address = if let Some(address) = tokens.next() {\n            if let Ok(address) = SocketAddr::from_str(address) {\n                address\n            } else {\n                return Err(BridgeLineError::AddressParseFailed(address.to_string()));\n            }\n        } else {\n            return Err(BridgeLineError::AddressMissing(s.to_string()));\n        };\n        // get the bridge fingerprint\n        let fingerprint = if let Some(fingerprint) = tokens.next() {\n            fingerprint\n        } else {\n            return Err(BridgeLineError::FingerprintMissing(s.to_string()));\n        };\n\n        // get the bridge options\n        static BRIDGE_OPTION_PATTERN: OnceLock\u003cRegex\u003e = OnceLock::new();\n        let bridge_option_pattern = BRIDGE_OPTION_PATTERN\n            .get_or_init(|| Regex::new(r\"(?m)^(?\u003ckey\u003e[^=]+)=(?\u003cvalue\u003e.*)$\").unwrap());\n\n        let mut keyvalues: Vec\u003c(String, String)\u003e = Default::default();\n        while let Some(keyvalue) = tokens.next() {\n            if let Some(caps) = bridge_option_pattern.captures(\u0026keyvalue) {\n                let key = caps\n                    .name(\"key\")\n                    .expect(\"missing key group\")\n                    .as_str()\n                    .to_string();\n                let value = caps\n                    .name(\"value\")\n                    .expect(\"missing value group\")\n                    .as_str()\n                    .to_string();\n                keyvalues.push((key, value));\n            } else {\n                return Err(BridgeLineError::KeyValueInvalid(keyvalue.to_string()));\n            }\n        }\n\n        BridgeLine::new(\n            transport.to_string(),\n            address,\n            fingerprint.to_string(),\n            keyvalues,\n        )\n    }\n}","traces":[{"line":31,"address":[3623552],"length":1,"stats":{"Line":0}},{"line":32,"address":[3623565],"length":1,"stats":{"Line":0}},{"line":38,"address":[3624748,3623776,3625267],"length":1,"stats":{"Line":0}},{"line":42,"address":[3623809,3623921],"length":1,"stats":{"Line":0}},{"line":44,"address":[3624064,3623929],"length":1,"stats":{"Line":0}},{"line":45,"address":[3624080,3625027],"length":1,"stats":{"Line":0}},{"line":46,"address":[3625087],"length":1,"stats":{"Line":0}},{"line":47,"address":[3625052],"length":1,"stats":{"Line":0}},{"line":54,"address":[3624118,3624047],"length":1,"stats":{"Line":0}},{"line":55,"address":[3624590],"length":1,"stats":{"Line":0}},{"line":56,"address":[3624269,3624148,3624406],"length":1,"stats":{"Line":0}},{"line":57,"address":[3624511],"length":1,"stats":{"Line":0}},{"line":61,"address":[3624809],"length":1,"stats":{"Line":0}},{"line":62,"address":[3624175],"length":1,"stats":{"Line":0}},{"line":63,"address":[3624206],"length":1,"stats":{"Line":0}},{"line":64,"address":[3624237],"length":1,"stats":{"Line":0}},{"line":69,"address":[3625296],"length":1,"stats":{"Line":0}},{"line":74,"address":[3625312],"length":1,"stats":{"Line":0}},{"line":75,"address":[3625320],"length":1,"stats":{"Line":0}},{"line":79,"address":[3625328],"length":1,"stats":{"Line":0}},{"line":80,"address":[3625336],"length":1,"stats":{"Line":0}},{"line":84,"address":[3625344],"length":1,"stats":{"Line":0}},{"line":85,"address":[3625349],"length":1,"stats":{"Line":0}},{"line":140,"address":[3625376,3627496,3627524],"length":1,"stats":{"Line":0}},{"line":146,"address":[3625549,3625431],"length":1,"stats":{"Line":0}},{"line":149,"address":[3625557],"length":1,"stats":{"Line":0}},{"line":150,"address":[3625639],"length":1,"stats":{"Line":0}},{"line":154,"address":[3625813,3625852],"length":1,"stats":{"Line":0}},{"line":155,"address":[3625866],"length":1,"stats":{"Line":0}},{"line":159,"address":[3625941],"length":1,"stats":{"Line":0}},{"line":160,"address":[3647808,3648029,3647822],"length":1,"stats":{"Line":0}},{"line":163,"address":[3625985],"length":1,"stats":{"Line":0}},{"line":164,"address":[3626058],"length":1,"stats":{"Line":0}},{"line":168,"address":[3626724,3626235],"length":1,"stats":{"Line":0}},{"line":169,"address":[3626760,3626811,3626972],"length":1,"stats":{"Line":0}},{"line":170,"address":[3627138],"length":1,"stats":{"Line":0}},{"line":174,"address":[3626513],"length":1,"stats":{"Line":0}},{"line":175,"address":[3626392],"length":1,"stats":{"Line":0}},{"line":177,"address":[3626435],"length":1,"stats":{"Line":0}},{"line":178,"address":[3626478],"length":1,"stats":{"Line":0}},{"line":183,"address":[3627568],"length":1,"stats":{"Line":0}},{"line":188,"address":[3627584],"length":1,"stats":{"Line":0}},{"line":189,"address":[3627592],"length":1,"stats":{"Line":0}},{"line":193,"address":[3627600],"length":1,"stats":{"Line":0}},{"line":194,"address":[3627608],"length":1,"stats":{"Line":0}},{"line":198,"address":[3627616],"length":1,"stats":{"Line":0}},{"line":199,"address":[3627624],"length":1,"stats":{"Line":0}},{"line":204,"address":[3627632,3628619],"length":1,"stats":{"Line":0}},{"line":205,"address":[3627662],"length":1,"stats":{"Line":0}},{"line":206,"address":[3627667],"length":1,"stats":{"Line":0}},{"line":207,"address":[3627690],"length":1,"stats":{"Line":0}},{"line":208,"address":[3627752,3627825],"length":1,"stats":{"Line":0}},{"line":211,"address":[3648268,3648048,3648081],"length":1,"stats":{"Line":0}},{"line":213,"address":[3627906,3627987],"length":1,"stats":{"Line":0}},{"line":215,"address":[3628423],"length":1,"stats":{"Line":0}},{"line":221,"address":[3630836,3628656,3631277],"length":1,"stats":{"Line":0}},{"line":222,"address":[3628702],"length":1,"stats":{"Line":0}},{"line":224,"address":[3628753],"length":1,"stats":{"Line":0}},{"line":227,"address":[3628932],"length":1,"stats":{"Line":0}},{"line":230,"address":[3629076,3628854],"length":1,"stats":{"Line":0}},{"line":231,"address":[3629118,3629321],"length":1,"stats":{"Line":0}},{"line":234,"address":[3629463],"length":1,"stats":{"Line":0}},{"line":237,"address":[3629177],"length":1,"stats":{"Line":0}},{"line":240,"address":[3629607,3629385],"length":1,"stats":{"Line":0}},{"line":243,"address":[3629712],"length":1,"stats":{"Line":0}},{"line":248,"address":[3629649],"length":1,"stats":{"Line":0}},{"line":249,"address":[3648589,3648382,3648368],"length":1,"stats":{"Line":0}},{"line":251,"address":[3629675],"length":1,"stats":{"Line":0}},{"line":252,"address":[3629936,3630809,3629856],"length":1,"stats":{"Line":0}},{"line":253,"address":[3630077,3630018],"length":1,"stats":{"Line":0}},{"line":254,"address":[3630312,3630199],"length":1,"stats":{"Line":0}},{"line":259,"address":[3630416,3630492],"length":1,"stats":{"Line":0}},{"line":264,"address":[3630586],"length":1,"stats":{"Line":0}},{"line":266,"address":[3630234,3630850],"length":1,"stats":{"Line":0}},{"line":271,"address":[3630067,3631042],"length":1,"stats":{"Line":0}},{"line":273,"address":[3631058],"length":1,"stats":{"Line":0}},{"line":274,"address":[3631111],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":77},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_client.rs"],"content":"// standard\nuse std::collections::BTreeMap;\nuse std::convert::From;\nuse std::default::Default;\nuse std::net::{SocketAddr, TcpListener};\nuse std::option::Option;\nuse std::path::PathBuf;\nuse std::string::ToString;\nuse std::sync::{atomic, Arc};\nuse std::time::Duration;\n\n// extern crates\nuse socks::Socks5Stream;\n\n// internal crates\nuse crate::censorship_circumvention::*;\nuse crate::legacy_tor_control_stream::*;\nuse crate::legacy_tor_controller::*;\nuse crate::legacy_tor_process::*;\nuse crate::legacy_tor_version::*;\nuse crate::proxy::*;\nuse crate::tor_crypto::*;\nuse crate::tor_provider;\nuse crate::tor_provider::*;\n\n/// [`LegacyTorClient`]-specific error type\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to create LegacyTorProcess object\")]\n    LegacyTorProcessCreationFailed(#[source] crate::legacy_tor_process::Error),\n\n    #[error(\"failed to create LegacyControlStream object\")]\n    LegacyControlStreamCreationFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"failed to create LegacyTorController object\")]\n    LegacyTorControllerCreationFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to authenticate with the tor process\")]\n    LegacyTorProcessAuthenticationFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to determine the tor process version\")]\n    GetInfoVersionFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"tor process version to old; found {0} but must be at least {1}\")]\n    LegacyTorProcessTooOld(String, String),\n\n    #[error(\"failed to register for STATUS_CLIENT and HS_DESC events\")]\n    SetEventsFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to delete unused onion service\")]\n    DelOnionFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed waiting for async events: {0}\")]\n    WaitAsyncEventsFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to begin bootstrap\")]\n    SetConfDisableNetwork0Failed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to setconf\")]\n    SetConfFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to add client auth for onion service\")]\n    OnionClientAuthAddFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to remove client auth from onion service\")]\n    OnionClientAuthRemoveFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"failed to get socks listener\")]\n    GetInfoNetListenersSocksFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"no socks listeners available to connect through\")]\n    NoSocksListenersFound(),\n\n    #[error(\"invalid circuit token\")]\n    CircuitTokenInvalid(),\n\n    #[error(\"unable to connect to socks listener\")]\n    Socks5ConnectionFailed(#[source] std::io::Error),\n\n    #[error(\"unable to bind TCP listener\")]\n    TcpListenerBindFailed(#[source] std::io::Error),\n\n    #[error(\"unable to get TCP listener's local address\")]\n    TcpListenerLocalAddrFailed(#[source] std::io::Error),\n\n    #[error(\"failed to create onion service\")]\n    AddOnionFailed(#[source] crate::legacy_tor_controller::Error),\n\n    #[error(\"tor not bootstrapped\")]\n    LegacyTorNotBootstrapped(),\n\n    #[error(\"{0}\")]\n    PluggableTransportConfigDirectoryCreationFailed(#[source] std::io::Error),\n\n    #[error(\"unable to create pluggable-transport directory because file with same name already exists: {0:?}\")]\n    PluggableTransportDirectoryNameCollision(PathBuf),\n\n    #[error(\"{0}\")]\n    PluggableTransportSymlinkRemovalFailed(#[source] std::io::Error),\n\n    #[error(\"{0}\")]\n    PluggableTransportSymlinkCreationFailed(#[source] std::io::Error),\n\n    #[error(\"pluggable transport binary name not representable as utf8: {0:?}\")]\n    PluggableTransportBinaryNameNotUtf8Representnable(std::ffi::OsString),\n\n    #[error(\"{0}\")]\n    PluggableTransportConfigError(#[source] crate::censorship_circumvention::PluggableTransportConfigError),\n\n    #[error(\"pluggable transport multiply defines '{0}' bridge transport type\")]\n    BridgeTransportTypeMultiplyDefined(String),\n\n    #[error(\"bridge transport '{0}' not supported by pluggable transport configuration\")]\n    BridgeTransportNotSupported(String),\n\n    #[error(\"not implemented\")]\n    NotImplemented(),\n}\n\nimpl From\u003cError\u003e for crate::tor_provider::Error {\n    fn from(error: Error) -\u003e Self {\n        crate::tor_provider::Error::Generic(error.to_string())\n    }\n}\n\n//\n// CircuitToken Implementation\n//\nstruct LegacyCircuitToken {\n    username: String,\n    password: String,\n}\n\nimpl LegacyCircuitToken {\n    fn new() -\u003e LegacyCircuitToken {\n        const CIRCUIT_TOKEN_USERNAME_LENGTH: usize = 32usize;\n        const CIRCUIT_TOKEN_PASSWORD_LENGTH: usize = 32usize;\n        let username = generate_password(CIRCUIT_TOKEN_USERNAME_LENGTH);\n        let password = generate_password(CIRCUIT_TOKEN_PASSWORD_LENGTH);\n\n        LegacyCircuitToken { username, password }\n    }\n}\n\nimpl Default for LegacyCircuitToken {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n//\n// LegacyTorClientConfig\n//\n\n#[derive(Clone, Debug)]\npub enum LegacyTorClientConfig {\n    BundledTor {\n        tor_bin_path: PathBuf,\n        data_directory: PathBuf,\n        proxy_settings: Option\u003cProxyConfig\u003e,\n        allowed_ports: Option\u003cVec\u003cu16\u003e\u003e,\n        pluggable_transports: Option\u003cVec\u003cPluggableTransportConfig\u003e\u003e,\n        bridge_lines: Option\u003cVec\u003cBridgeLine\u003e\u003e,\n    },\n    SystemTor {\n        tor_socks_addr: SocketAddr,\n        tor_control_addr: SocketAddr,\n        tor_control_passwd: String,\n    },\n}\n\n//\n// LegacyTorClient\n//\n\n/// A `LegacyTorClient` implements the [`TorProvider`] trait using a legacy c-tor daemon backend.\n///\n/// The tor process can either be launched and owned by `LegacyTorClient`, or it can use an already running tor-daemon. When using an already runnng tor-daemon, the [`TorProvider::bootstrap()`] automatically succeeds, presuming the connected tor-daemon has successfully bootstrapped.\n///\n/// The minimum supported c-tor is version 0.4.6.1.\npub struct LegacyTorClient {\n    daemon: Option\u003cLegacyTorProcess\u003e,\n    version: LegacyTorVersion,\n    controller: LegacyTorController,\n    bootstrapped: bool,\n    socks_listener: Option\u003cSocketAddr\u003e,\n    // list of open onion services and their is_active flag\n    onion_services: Vec\u003c(V3OnionServiceId, Arc\u003catomic::AtomicBool\u003e)\u003e,\n    // our list of circuit tokens for the tor daemon\n    circuit_token_counter: usize,\n    circuit_tokens: BTreeMap\u003cCircuitToken, LegacyCircuitToken\u003e,\n}\n\nimpl LegacyTorClient {\n    /// Construct a new `LegacyTorClient` from a [`LegacyTorClientConfig`].\n    pub fn new(config: LegacyTorClientConfig) -\u003e Result\u003cLegacyTorClient, Error\u003e {\n        let (daemon, mut controller, password, socks_listener) = match \u0026config {\n            LegacyTorClientConfig::BundledTor {\n                tor_bin_path,\n                data_directory,\n                ..\n            } =\u003e {\n                // launch tor\n                let daemon =\n                    LegacyTorProcess::new(tor_bin_path.as_path(), data_directory.as_path())\n                        .map_err(Error::LegacyTorProcessCreationFailed)?;\n                // open a control stream\n                let control_stream =\n                    LegacyControlStream::new(daemon.get_control_addr(), Duration::from_millis(16))\n                        .map_err(Error::LegacyControlStreamCreationFailed)?;\n\n                // create a controler\n                let controller = LegacyTorController::new(control_stream)\n                    .map_err(Error::LegacyTorControllerCreationFailed)?;\n\n                let password = daemon.get_password().to_string();\n                (Some(daemon), controller, password, None)\n            }\n            LegacyTorClientConfig::SystemTor {\n                tor_socks_addr,\n                tor_control_addr,\n                tor_control_passwd,\n            } =\u003e {\n                // open a control stream\n                let control_stream =\n                    LegacyControlStream::new(\u0026tor_control_addr, Duration::from_millis(16))\n                        .map_err(Error::LegacyControlStreamCreationFailed)?;\n\n                // create a controler\n                let controller = LegacyTorController::new(control_stream)\n                    .map_err(Error::LegacyTorControllerCreationFailed)?;\n\n                (\n                    None,\n                    controller,\n                    tor_control_passwd.clone(),\n                    Some(tor_socks_addr.clone()),\n                )\n            }\n        };\n\n        // authenticate\n        controller\n            .authenticate(\u0026password)\n            .map_err(Error::LegacyTorProcessAuthenticationFailed)?;\n\n        // min required version for v3 client auth (see control-spec.txt)\n        let min_required_version = LegacyTorVersion {\n            major: 0u32,\n            minor: 4u32,\n            micro: 6u32,\n            patch_level: 1u32,\n            status_tag: None,\n        };\n\n        // verify version is recent enough\n        let version = controller\n            .getinfo_version()\n            .map_err(Error::GetInfoVersionFailed)?;\n\n        if version \u003c min_required_version {\n            return Err(Error::LegacyTorProcessTooOld(\n                version.to_string(),\n                min_required_version.to_string(),\n            ));\n        }\n\n        // configure tor client\n        if let LegacyTorClientConfig::BundledTor {\n            data_directory,\n            proxy_settings,\n            allowed_ports,\n            pluggable_transports,\n            bridge_lines,\n            ..\n        } = config\n        {\n            // configure proxy\n            match proxy_settings {\n                Some(ProxyConfig::Socks4(Socks4ProxyConfig { address })) =\u003e {\n                    controller\n                        .setconf(\u0026[(\"Socks4Proxy\", address.to_string())])\n                        .map_err(Error::SetConfFailed)?;\n                }\n                Some(ProxyConfig::Socks5(Socks5ProxyConfig {\n                    address,\n                    username,\n                    password,\n                })) =\u003e {\n                    controller\n                        .setconf(\u0026[(\"Socks5Proxy\", address.to_string())])\n                        .map_err(Error::SetConfFailed)?;\n                    let username = username.unwrap_or(\"\".to_string());\n                    if !username.is_empty() {\n                        controller\n                            .setconf(\u0026[(\"Socks5ProxyUsername\", username.to_string())])\n                            .map_err(Error::SetConfFailed)?;\n                    }\n                    let password = password.unwrap_or(\"\".to_string());\n                    if !password.is_empty() {\n                        controller\n                            .setconf(\u0026[(\"Socks5ProxyPassword\", password.to_string())])\n                            .map_err(Error::SetConfFailed)?;\n                    }\n                }\n                Some(ProxyConfig::Https(HttpsProxyConfig {\n                    address,\n                    username,\n                    password,\n                })) =\u003e {\n                    controller\n                        .setconf(\u0026[(\"HTTPSProxy\", address.to_string())])\n                        .map_err(Error::SetConfFailed)?;\n                    let username = username.unwrap_or(\"\".to_string());\n                    let password = password.unwrap_or(\"\".to_string());\n                    if !username.is_empty() || !password.is_empty() {\n                        let authenticator = format!(\"{}:{}\", username, password);\n                        controller\n                            .setconf(\u0026[(\"HTTPSProxyAuthenticator\", authenticator)])\n                            .map_err(Error::SetConfFailed)?;\n                    }\n                }\n                None =\u003e (),\n            }\n            // configure firewall\n            if let Some(allowed_ports) = allowed_ports {\n                let allowed_addresses: Vec\u003cString\u003e = allowed_ports\n                    .iter()\n                    .map(|port| format!(\"*{{}}:{port}\"))\n                    .collect();\n                let allowed_addresses = allowed_addresses.join(\", \");\n                controller\n                    .setconf(\u0026[(\"ReachableAddresses\", allowed_addresses)])\n                    .map_err(Error::SetConfFailed)?;\n            }\n            // configure pluggable transports\n            let mut supported_transports: std::collections::BTreeSet\u003cString\u003e = Default::default();\n            if let Some(pluggable_transports) = pluggable_transports {\n                // Legacy tor daemon cannot be configured to use pluggable-transports which\n                // exist in paths containing spaces. To work around this, we create a known, safe\n                // path in the tor daemon's working directory, and soft-link the provided\n                // binary path to this safe location. Finally, we configure tor to use the soft-linked\n                // binary in the ClientTransportPlugin setconf call.\n\n                // create pluggable-transport directory\n                let mut pt_directory = data_directory.clone();\n                pt_directory.push(\"pluggable-transports\");\n                if !std::path::Path::exists(\u0026pt_directory) {\n                    // path does not exist so create it\n                    std::fs::create_dir(\u0026pt_directory)\n                        .map_err(Error::PluggableTransportConfigDirectoryCreationFailed)?;\n                } else if !std::path::Path::is_dir(\u0026pt_directory) {\n                    // path exists but it is not a directory\n                    return Err(Error::PluggableTransportDirectoryNameCollision(\n                        pt_directory,\n                    ));\n                }\n\n                // symlink all our pts and configure tor\n                let mut conf: Vec\u003c(\u0026str, String)\u003e = Default::default();\n                for pt_settings in \u0026pluggable_transports {\n                    // symlink absolute path of pt binary to pt_directory in tor's working\n                    // directory\n                    let path_to_binary = pt_settings.path_to_binary();\n                    let binary_name = path_to_binary\n                        .file_name()\n                        .expect(\"file_name should be absolute path\");\n                    let mut pt_symlink = pt_directory.clone();\n                    pt_symlink.push(binary_name);\n                    let binary_name = if let Some(binary_name) = binary_name.to_str() {\n                        binary_name\n                    } else {\n                        return Err(Error::PluggableTransportBinaryNameNotUtf8Representnable(\n                            binary_name.to_os_string(),\n                        ));\n                    };\n\n                    // remove any file that may exist with the same name\n                    if std::path::Path::exists(\u0026pt_symlink) {\n                        std::fs::remove_file(\u0026pt_symlink)\n                            .map_err(Error::PluggableTransportSymlinkRemovalFailed)?;\n                    }\n\n                    // create new symlink\n                    #[cfg(windows)]\n                    std::os::windows::fs::symlink_file(path_to_binary, \u0026pt_symlink)\n                        .map_err(Error::PluggableTransportSymlinkCreationFailed)?;\n                    #[cfg(unix)]\n                    std::os::unix::fs::symlink(path_to_binary, \u0026pt_symlink)\n                        .map_err(Error::PluggableTransportSymlinkCreationFailed)?;\n\n                    // verify a bridge-type support has not been defined for multiple pluggable-transports\n                    for transport in pt_settings.transports() {\n                        if supported_transports.contains(transport) {\n                            return Err(Error::BridgeTransportTypeMultiplyDefined(\n                                transport.to_string(),\n                            ));\n                        }\n                        supported_transports.insert(transport.to_string());\n                    }\n\n                    // finally construct our setconf value\n                    let transports = pt_settings.transports().join(\",\");\n                    use std::path::MAIN_SEPARATOR;\n                    let path_to_binary =\n                        format!(\"pluggable-transports{MAIN_SEPARATOR}{binary_name}\");\n                    let options = pt_settings.options().join(\" \");\n\n                    let value = format!(\"{transports} exec {path_to_binary} {options}\");\n                    conf.push((\"ClientTransportPlugin\", value));\n                }\n                controller\n                    .setconf(conf.as_slice())\n                    .map_err(Error::SetConfFailed)?;\n            }\n            // configure bridge lines\n            if let Some(bridge_lines) = bridge_lines {\n                let mut conf: Vec\u003c(\u0026str, String)\u003e = Default::default();\n                for bridge_line in \u0026bridge_lines {\n                    if !supported_transports.contains(bridge_line.transport()) {\n                        return Err(Error::BridgeTransportNotSupported(\n                            bridge_line.transport().to_string(),\n                        ));\n                    }\n                    let value = bridge_line.as_legacy_tor_setconf_value();\n                    conf.push((\"Bridge\", value));\n                }\n                conf.push((\"UseBridges\", \"1\".to_string()));\n                controller\n                    .setconf(conf.as_slice())\n                    .map_err(Error::SetConfFailed)?;\n            }\n        }\n\n        // register for STATUS_CLIENT async events\n        controller\n            .setevents(\u0026[\"STATUS_CLIENT\", \"HS_DESC\"])\n            .map_err(Error::SetEventsFailed)?;\n\n        Ok(LegacyTorClient {\n            daemon,\n            version,\n            controller,\n            bootstrapped: false,\n            socks_listener,\n            onion_services: Default::default(),\n            circuit_token_counter: 0usize,\n            circuit_tokens: Default::default(),\n        })\n    }\n\n    /// Get the version of the connected c-tor daemon.\n    pub fn version(\u0026mut self) -\u003e LegacyTorVersion {\n        self.version.clone()\n    }\n}\n\nimpl TorProvider for LegacyTorClient {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, tor_provider::Error\u003e {\n        let mut i = 0;\n        while i \u003c self.onion_services.len() {\n            // remove onion services with no active listeners\n            if !self.onion_services[i].1.load(atomic::Ordering::Relaxed) {\n                let entry = self.onion_services.swap_remove(i);\n                let service_id = entry.0;\n\n                self.controller\n                    .del_onion(\u0026service_id)\n                    .map_err(Error::DelOnionFailed)?;\n            } else {\n                i += 1;\n            }\n        }\n\n        let mut events: Vec\u003cTorEvent\u003e = Default::default();\n        for async_event in self\n            .controller\n            .wait_async_events()\n            .map_err(Error::WaitAsyncEventsFailed)?\n            .iter()\n        {\n            match async_event {\n                AsyncEvent::StatusClient {\n                    severity,\n                    action,\n                    arguments,\n                } =\u003e {\n                    if severity == \"NOTICE\" \u0026\u0026 action == \"BOOTSTRAP\" {\n                        let mut progress: u32 = 0;\n                        let mut tag: String = Default::default();\n                        let mut summary: String = Default::default();\n                        for (key, val) in arguments.iter() {\n                            match key.as_str() {\n                                \"PROGRESS\" =\u003e progress = val.parse().unwrap_or(0u32),\n                                \"TAG\" =\u003e tag = val.to_string(),\n                                \"SUMMARY\" =\u003e summary = val.to_string(),\n                                _ =\u003e {} // ignore unexpected arguments\n                            }\n                        }\n                        events.push(TorEvent::BootstrapStatus {\n                            progress,\n                            tag,\n                            summary,\n                        });\n                        if progress == 100u32 {\n                            events.push(TorEvent::BootstrapComplete);\n                            self.bootstrapped = true;\n                        }\n                    }\n                }\n                AsyncEvent::HsDesc { action, hs_address } =\u003e {\n                    if action == \"UPLOADED\" {\n                        events.push(TorEvent::OnionServicePublished {\n                            service_id: hs_address.clone(),\n                        });\n                    }\n                }\n                AsyncEvent::Unknown { lines } =\u003e {\n                    println!(\"Received Unknown Event:\");\n                    for line in lines.iter() {\n                        println!(\" {}\", line);\n                    }\n                }\n            }\n        }\n\n        if let Some(daemon) = \u0026mut self.daemon {\n            // bundled tor gives us log-lines\n            for log_line in daemon.wait_log_lines().iter_mut() {\n                events.push(TorEvent::LogReceived {\n                    line: std::mem::take(log_line),\n                });\n            }\n        } else if !self.bootstrapped {\n            // system tor needs to send a bootstrap complete event *once*\n            events.push(TorEvent::BootstrapComplete);\n            self.bootstrapped = true;\n        }\n\n        Ok(events)\n    }\n\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        if !self.bootstrapped {\n            self.controller\n                .setconf(\u0026[(\"DisableNetwork\", \"0\".to_string())])\n                .map_err(Error::SetConfDisableNetwork0Failed)?;\n        }\n        Ok(())\n    }\n\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Ok(self\n            .controller\n            .onion_client_auth_add(service_id, client_auth, None, \u0026Default::default())\n            .map_err(Error::OnionClientAuthAddFailed)?)\n    }\n\n    fn remove_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        Ok(self\n            .controller\n            .onion_client_auth_remove(service_id)\n            .map_err(Error::OnionClientAuthRemoveFailed)?)\n    }\n\n    // connect to an onion service and returns OnionStream\n    fn connect(\n        \u0026mut self,\n        target: TargetAddr,\n        circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, tor_provider::Error\u003e {\n        if !self.bootstrapped {\n            return Err(Error::LegacyTorNotBootstrapped().into());\n        }\n\n        if self.socks_listener.is_none() {\n            let mut listeners = self\n                .controller\n                .getinfo_net_listeners_socks()\n                .map_err(Error::GetInfoNetListenersSocksFailed)?;\n            if listeners.is_empty() {\n                return Err(Error::NoSocksListenersFound())?;\n            }\n            self.socks_listener = Some(listeners.swap_remove(0));\n        }\n\n        let socks_listener = match self.socks_listener {\n            Some(socks_listener) =\u003e socks_listener,\n            None =\u003e unreachable!(),\n        };\n\n        // our target\n        let socks_target = match target.clone() {\n            TargetAddr::Socket(socket_addr) =\u003e socks::TargetAddr::Ip(socket_addr),\n            TargetAddr::Domain(domain_addr) =\u003e {\n                socks::TargetAddr::Domain(domain_addr.domain().to_string(), domain_addr.port())\n            }\n            TargetAddr::OnionService(OnionAddr::V3(OnionAddrV3 {\n                service_id,\n                virt_port,\n            })) =\u003e socks::TargetAddr::Domain(format!(\"{}.onion\", service_id), virt_port),\n        };\n\n        // readwrite stream\n        let stream = match \u0026circuit {\n            None =\u003e Socks5Stream::connect(socks_listener, socks_target),\n            Some(circuit) =\u003e {\n                if let Some(circuit) = self.circuit_tokens.get(circuit) {\n                    Socks5Stream::connect_with_password(\n                        socks_listener,\n                        socks_target,\n                        \u0026circuit.username,\n                        \u0026circuit.password,\n                    )\n                } else {\n                    return Err(Error::CircuitTokenInvalid())?;\n                }\n            }\n        }\n        .map_err(Error::Socks5ConnectionFailed)?;\n\n        Ok(OnionStream {\n            stream: stream.into_inner(),\n            local_addr: None,\n            peer_addr: Some(target),\n        })\n    }\n\n    // stand up an onion service and return an LegacyOnionListener\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, tor_provider::Error\u003e {\n        if !self.bootstrapped {\n            return Err(Error::LegacyTorNotBootstrapped().into());\n        }\n\n        // try to bind to a local address, let OS pick our port\n        let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n        let listener = TcpListener::bind(socket_addr).map_err(Error::TcpListenerBindFailed)?;\n        let socket_addr = listener\n            .local_addr()\n            .map_err(Error::TcpListenerLocalAddrFailed)?;\n\n        let mut flags = AddOnionFlags {\n            discard_pk: true,\n            ..Default::default()\n        };\n        if authorized_clients.is_some() {\n            flags.v3_auth = true;\n        }\n\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(\n            V3OnionServiceId::from_private_key(private_key),\n            virt_port,\n        ));\n\n        // start onion service\n        let (_, service_id) = self\n            .controller\n            .add_onion(\n                Some(private_key),\n                \u0026flags,\n                None,\n                virt_port,\n                Some(socket_addr),\n                authorized_clients,\n            )\n            .map_err(Error::AddOnionFailed)?;\n\n        let is_active = Arc::new(atomic::AtomicBool::new(true));\n        self.onion_services\n            .push((service_id, Arc::clone(\u0026is_active)));\n\n        Ok(OnionListener::new(listener, onion_addr, is_active, |is_active| {\n            is_active.store(false, atomic::Ordering::Relaxed);\n        }))\n    }\n\n    fn generate_token(\u0026mut self) -\u003e CircuitToken {\n        let new_token = self.circuit_token_counter;\n        self.circuit_token_counter += 1;\n        self.circuit_tokens\n            .insert(new_token, LegacyCircuitToken::new());\n        new_token\n    }\n\n    fn release_token(\u0026mut self, circuit_token: CircuitToken) {\n        self.circuit_tokens.remove(\u0026circuit_token);\n    }\n}\n","traces":[{"line":121,"address":[3672496,3672629],"length":1,"stats":{"Line":1}},{"line":122,"address":[3672573,3672515],"length":1,"stats":{"Line":2}},{"line":135,"address":[3548629,3548448],"length":1,"stats":{"Line":0}},{"line":138,"address":[3548477],"length":1,"stats":{"Line":0}},{"line":139,"address":[3548492],"length":1,"stats":{"Line":0}},{"line":146,"address":[3548656],"length":1,"stats":{"Line":0}},{"line":147,"address":[3548664],"length":1,"stats":{"Line":0}},{"line":196,"address":[3567664,3548688,3551199],"length":1,"stats":{"Line":2}},{"line":197,"address":[3553818,3548779,3550959],"length":1,"stats":{"Line":4}},{"line":198,"address":[3549055],"length":1,"stats":{"Line":2}},{"line":204,"address":[3549077,3549768,3549315,3551299],"length":1,"stats":{"Line":4}},{"line":206,"address":[3549704],"length":1,"stats":{"Line":0}},{"line":208,"address":[3550251,3551259,3549846,3549678],"length":1,"stats":{"Line":4}},{"line":210,"address":[3550187],"length":1,"stats":{"Line":0}},{"line":213,"address":[3550127,3550321,3551208,3550596],"length":1,"stats":{"Line":4}},{"line":214,"address":[3550532],"length":1,"stats":{"Line":0}},{"line":216,"address":[3550506,3550685],"length":1,"stats":{"Line":4}},{"line":217,"address":[3550692],"length":1,"stats":{"Line":2}},{"line":219,"address":[3549134],"length":1,"stats":{"Line":1}},{"line":225,"address":[3549169,3568291,3551684,3551332],"length":1,"stats":{"Line":2}},{"line":227,"address":[3551620],"length":1,"stats":{"Line":0}},{"line":230,"address":[3551754,3552113,3551560],"length":1,"stats":{"Line":2}},{"line":231,"address":[3552049],"length":1,"stats":{"Line":0}},{"line":234,"address":[3551985],"length":1,"stats":{"Line":1}},{"line":235,"address":[3551993],"length":1,"stats":{"Line":1}},{"line":236,"address":[3552019],"length":1,"stats":{"Line":1}},{"line":237,"address":[3552202,3552250],"length":1,"stats":{"Line":2}},{"line":243,"address":[3552582,3568054,3552861],"length":1,"stats":{"Line":2}},{"line":244,"address":[3551173],"length":1,"stats":{"Line":2}},{"line":245,"address":[3552797],"length":1,"stats":{"Line":0}},{"line":257,"address":[3553231,3552779,3552934,3568033],"length":1,"stats":{"Line":4}},{"line":259,"address":[3553167],"length":1,"stats":{"Line":0}},{"line":261,"address":[3553122,3553308],"length":1,"stats":{"Line":4}},{"line":262,"address":[3567828],"length":1,"stats":{"Line":0}},{"line":263,"address":[3553348],"length":1,"stats":{"Line":0}},{"line":264,"address":[3567749],"length":1,"stats":{"Line":0}},{"line":269,"address":[3553322],"length":1,"stats":{"Line":2}},{"line":270,"address":[3553386],"length":1,"stats":{"Line":2}},{"line":271,"address":[3553439],"length":1,"stats":{"Line":2}},{"line":272,"address":[3553481],"length":1,"stats":{"Line":2}},{"line":273,"address":[3553542],"length":1,"stats":{"Line":2}},{"line":274,"address":[3553603],"length":1,"stats":{"Line":2}},{"line":279,"address":[3553664,3553774],"length":1,"stats":{"Line":2}},{"line":280,"address":[3553820],"length":1,"stats":{"Line":0}},{"line":281,"address":[3554442,3554493,3554664],"length":1,"stats":{"Line":0}},{"line":282,"address":[3553884,3554306],"length":1,"stats":{"Line":0}},{"line":283,"address":[3554778,3554573,3554449],"length":1,"stats":{"Line":0}},{"line":285,"address":[3554018],"length":1,"stats":{"Line":0}},{"line":290,"address":[3555259,3555088,3555037],"length":1,"stats":{"Line":0}},{"line":291,"address":[3554901,3554058],"length":1,"stats":{"Line":0}},{"line":292,"address":[3555044,3556818,3555168],"length":1,"stats":{"Line":0}},{"line":293,"address":[3555288,3556796],"length":1,"stats":{"Line":0}},{"line":294,"address":[3555460,3555525],"length":1,"stats":{"Line":0}},{"line":295,"address":[3555765,3555816,3555990],"length":1,"stats":{"Line":0}},{"line":296,"address":[3555629,3555547],"length":1,"stats":{"Line":0}},{"line":297,"address":[3556016,3555772,3555896],"length":1,"stats":{"Line":0}},{"line":299,"address":[3556057,3556774,3555554],"length":1,"stats":{"Line":0}},{"line":300,"address":[3556222,3556157],"length":1,"stats":{"Line":0}},{"line":301,"address":[3556409,3556460,3556634],"length":1,"stats":{"Line":0}},{"line":302,"address":[3556244,3556273],"length":1,"stats":{"Line":0}},{"line":303,"address":[3556540,3556416,3556660],"length":1,"stats":{"Line":0}},{"line":306,"address":[3554088],"length":1,"stats":{"Line":0}},{"line":311,"address":[3557450,3557279,3557228],"length":1,"stats":{"Line":0}},{"line":312,"address":[3557092,3554232],"length":1,"stats":{"Line":0}},{"line":313,"address":[3565530,3557235,3557359],"length":1,"stats":{"Line":0}},{"line":314,"address":[3557479,3565508],"length":1,"stats":{"Line":0}},{"line":315,"address":[3565486,3557643],"length":1,"stats":{"Line":0}},{"line":316,"address":[3557990,3557815,3557880],"length":1,"stats":{"Line":0}},{"line":317,"address":[3558136],"length":1,"stats":{"Line":0}},{"line":318,"address":[3558412,3558361,3558586],"length":1,"stats":{"Line":0}},{"line":319,"address":[3558225],"length":1,"stats":{"Line":0}},{"line":320,"address":[3558612,3558368,3558492],"length":1,"stats":{"Line":0}},{"line":326,"address":[3558789,3553730],"length":1,"stats":{"Line":2}},{"line":327,"address":[3558829,3558946],"length":1,"stats":{"Line":0}},{"line":329,"address":[3245088,3245191],"length":1,"stats":{"Line":0}},{"line":331,"address":[3559146,3559051],"length":1,"stats":{"Line":0}},{"line":332,"address":[3559365,3559536,3559314],"length":1,"stats":{"Line":0}},{"line":333,"address":[3559178],"length":1,"stats":{"Line":0}},{"line":334,"address":[3559603,3559321,3559445],"length":1,"stats":{"Line":0}},{"line":337,"address":[3558864],"length":1,"stats":{"Line":2}},{"line":338,"address":[3559663],"length":1,"stats":{"Line":2}},{"line":346,"address":[3559754,3559849],"length":1,"stats":{"Line":0}},{"line":347,"address":[3559857],"length":1,"stats":{"Line":0}},{"line":348,"address":[3559937],"length":1,"stats":{"Line":0}},{"line":350,"address":[3560003,3560072,3560238],"length":1,"stats":{"Line":0}},{"line":351,"address":[3560174],"length":1,"stats":{"Line":0}},{"line":352,"address":[3560301,3560038],"length":1,"stats":{"Line":0}},{"line":354,"address":[3560400],"length":1,"stats":{"Line":0}},{"line":355,"address":[3560344],"length":1,"stats":{"Line":0}},{"line":360,"address":[3560144],"length":1,"stats":{"Line":0}},{"line":361,"address":[3560508,3560603,3560726],"length":1,"stats":{"Line":0}},{"line":364,"address":[3561133,3560750],"length":1,"stats":{"Line":0}},{"line":365,"address":[3561141],"length":1,"stats":{"Line":0}},{"line":368,"address":[3561339],"length":1,"stats":{"Line":0}},{"line":369,"address":[3561362],"length":1,"stats":{"Line":0}},{"line":370,"address":[3561441],"length":1,"stats":{"Line":0}},{"line":371,"address":[3561557],"length":1,"stats":{"Line":0}},{"line":373,"address":[3563758],"length":1,"stats":{"Line":0}},{"line":374,"address":[3561628],"length":1,"stats":{"Line":0}},{"line":379,"address":[3561654,3561581],"length":1,"stats":{"Line":0}},{"line":380,"address":[3561902,3563748,3561719],"length":1,"stats":{"Line":0}},{"line":381,"address":[3561838],"length":1,"stats":{"Line":0}},{"line":389,"address":[3561939,3563746,3562110,3561689],"length":1,"stats":{"Line":0}},{"line":390,"address":[3562046],"length":1,"stats":{"Line":0}},{"line":393,"address":[3562305,3562147,3562019],"length":1,"stats":{"Line":0}},{"line":394,"address":[3562329,3563529],"length":1,"stats":{"Line":0}},{"line":395,"address":[3563621],"length":1,"stats":{"Line":0}},{"line":396,"address":[3563574],"length":1,"stats":{"Line":0}},{"line":399,"address":[3563581,3563551],"length":1,"stats":{"Line":0}},{"line":403,"address":[3562366,3562286],"length":1,"stats":{"Line":0}},{"line":405,"address":[3562667],"length":1,"stats":{"Line":0}},{"line":407,"address":[3562796,3562861],"length":1,"stats":{"Line":0}},{"line":409,"address":[3563252],"length":1,"stats":{"Line":0}},{"line":410,"address":[3563357],"length":1,"stats":{"Line":0}},{"line":412,"address":[3561101,3560982,3560804],"length":1,"stats":{"Line":0}},{"line":413,"address":[3560691],"length":1,"stats":{"Line":0}},{"line":414,"address":[3560918],"length":1,"stats":{"Line":0}},{"line":417,"address":[3559761,3563934],"length":1,"stats":{"Line":2}},{"line":418,"address":[3563974],"length":1,"stats":{"Line":0}},{"line":419,"address":[3564248,3564059,3564139],"length":1,"stats":{"Line":0}},{"line":420,"address":[3564684,3564269],"length":1,"stats":{"Line":0}},{"line":421,"address":[3564793],"length":1,"stats":{"Line":0}},{"line":422,"address":[3564722,3564778],"length":1,"stats":{"Line":0}},{"line":425,"address":[3564743],"length":1,"stats":{"Line":0}},{"line":426,"address":[3564923],"length":1,"stats":{"Line":0}},{"line":428,"address":[3564288,3564221],"length":1,"stats":{"Line":0}},{"line":429,"address":[3564429,3564607,3564655],"length":1,"stats":{"Line":0}},{"line":430,"address":[3564374],"length":1,"stats":{"Line":0}},{"line":431,"address":[3564543],"length":1,"stats":{"Line":0}},{"line":436,"address":[3566536,3567744,3566160,3553692],"length":1,"stats":{"Line":4}},{"line":438,"address":[3566472],"length":1,"stats":{"Line":0}},{"line":440,"address":[3566669],"length":1,"stats":{"Line":2}},{"line":441,"address":[3566244],"length":1,"stats":{"Line":2}},{"line":442,"address":[3566348],"length":1,"stats":{"Line":2}},{"line":443,"address":[3566404],"length":1,"stats":{"Line":2}},{"line":446,"address":[3566442],"length":1,"stats":{"Line":2}},{"line":448,"address":[3566609],"length":1,"stats":{"Line":2}},{"line":453,"address":[3569088],"length":1,"stats":{"Line":0}},{"line":454,"address":[3569105],"length":1,"stats":{"Line":0}},{"line":459,"address":[3569136,3573035,3570686],"length":1,"stats":{"Line":2}},{"line":460,"address":[3569175],"length":1,"stats":{"Line":2}},{"line":461,"address":[3569211],"length":1,"stats":{"Line":2}},{"line":463,"address":[3569307,3573487],"length":1,"stats":{"Line":4}},{"line":464,"address":[3573056],"length":1,"stats":{"Line":0}},{"line":465,"address":[3573096],"length":1,"stats":{"Line":0}},{"line":467,"address":[3570766,3569167,3573176,3573258,3573429],"length":1,"stats":{"Line":2}},{"line":469,"address":[3573365],"length":1,"stats":{"Line":0}},{"line":471,"address":[3573183,3573492,3573479],"length":1,"stats":{"Line":4}},{"line":475,"address":[3569256],"length":1,"stats":{"Line":2}},{"line":476,"address":[3569772,3569965,3569289,3569429,3569683],"length":1,"stats":{"Line":8}},{"line":479,"address":[3569619],"length":1,"stats":{"Line":0}},{"line":482,"address":[3569989],"length":1,"stats":{"Line":2}},{"line":483,"address":[3570833],"length":1,"stats":{"Line":2}},{"line":488,"address":[3571430,3572153,3570883],"length":1,"stats":{"Line":6}},{"line":489,"address":[3571488],"length":1,"stats":{"Line":2}},{"line":490,"address":[3571507],"length":1,"stats":{"Line":2}},{"line":491,"address":[3571514],"length":1,"stats":{"Line":2}},{"line":492,"address":[3571586,3571675,3572034],"length":1,"stats":{"Line":6}},{"line":493,"address":[3572075,3572185],"length":1,"stats":{"Line":4}},{"line":494,"address":[3572727,3572201,3572272],"length":1,"stats":{"Line":6}},{"line":495,"address":[3572244,3572554,3572296,3572348],"length":1,"stats":{"Line":8}},{"line":496,"address":[3572362,3572312],"length":1,"stats":{"Line":4}},{"line":500,"address":[3571928],"length":1,"stats":{"Line":2}},{"line":501,"address":[3571841],"length":1,"stats":{"Line":2}},{"line":502,"address":[3571848],"length":1,"stats":{"Line":2}},{"line":503,"address":[3571888],"length":1,"stats":{"Line":2}},{"line":505,"address":[3572173,3572092],"length":1,"stats":{"Line":4}},{"line":506,"address":[3572102],"length":1,"stats":{"Line":2}},{"line":507,"address":[3572166],"length":1,"stats":{"Line":2}},{"line":511,"address":[3570927],"length":1,"stats":{"Line":2}},{"line":512,"address":[3570955,3572880],"length":1,"stats":{"Line":4}},{"line":513,"address":[3572912],"length":1,"stats":{"Line":2}},{"line":514,"address":[3572905],"length":1,"stats":{"Line":2}},{"line":518,"address":[3570776],"length":1,"stats":{"Line":0}},{"line":519,"address":[3570796,3570991],"length":1,"stats":{"Line":0}},{"line":520,"address":[3571018],"length":1,"stats":{"Line":0}},{"line":521,"address":[3571349],"length":1,"stats":{"Line":0}},{"line":527,"address":[3570073],"length":1,"stats":{"Line":2}},{"line":529,"address":[3570276,3570469,3570148,3570181],"length":1,"stats":{"Line":8}},{"line":530,"address":[3570614],"length":1,"stats":{"Line":2}},{"line":531,"address":[3570485],"length":1,"stats":{"Line":2}},{"line":534,"address":[3570163,3570745],"length":1,"stats":{"Line":2}},{"line":536,"address":[3570695],"length":1,"stats":{"Line":1}},{"line":537,"address":[3570738],"length":1,"stats":{"Line":1}},{"line":540,"address":[3570512],"length":1,"stats":{"Line":2}},{"line":543,"address":[3573520,3573996],"length":1,"stats":{"Line":2}},{"line":544,"address":[3573550],"length":1,"stats":{"Line":2}},{"line":545,"address":[3573943,3573542,3573724,3573799],"length":1,"stats":{"Line":6}},{"line":546,"address":[3573563],"length":1,"stats":{"Line":2}},{"line":547,"address":[3573969,3573755,3573867],"length":1,"stats":{"Line":2}},{"line":549,"address":[3573736],"length":1,"stats":{"Line":2}},{"line":552,"address":[3574422,3574390,3574032],"length":1,"stats":{"Line":2}},{"line":557,"address":[3574249,3574064,3574202,3574356],"length":1,"stats":{"Line":6}},{"line":559,"address":[3574096,3574241,3574403],"length":1,"stats":{"Line":4}},{"line":560,"address":[3574328],"length":1,"stats":{"Line":0}},{"line":563,"address":[3574432],"length":1,"stats":{"Line":1}},{"line":567,"address":[3574582,3574448],"length":1,"stats":{"Line":1}},{"line":570,"address":[3574555],"length":1,"stats":{"Line":0}},{"line":574,"address":[3578253,3577746,3574624],"length":1,"stats":{"Line":2}},{"line":579,"address":[3574687],"length":1,"stats":{"Line":2}},{"line":580,"address":[3574851,3574720],"length":1,"stats":{"Line":0}},{"line":583,"address":[3574774,3574909],"length":1,"stats":{"Line":4}},{"line":584,"address":[3578248,3575685,3575225,3574973],"length":1,"stats":{"Line":2}},{"line":587,"address":[3575161],"length":1,"stats":{"Line":0}},{"line":588,"address":[3575305,3575124],"length":1,"stats":{"Line":4}},{"line":589,"address":[3575342,3578046,3578246],"length":1,"stats":{"Line":0}},{"line":591,"address":[3575466,3575311],"length":1,"stats":{"Line":4}},{"line":594,"address":[3574923],"length":1,"stats":{"Line":2}},{"line":595,"address":[3575596],"length":1,"stats":{"Line":2}},{"line":600,"address":[3575634],"length":1,"stats":{"Line":2}},{"line":601,"address":[3575687],"length":1,"stats":{"Line":0}},{"line":602,"address":[3575985],"length":1,"stats":{"Line":0}},{"line":603,"address":[3576017,3576288],"length":1,"stats":{"Line":0}},{"line":605,"address":[3576069],"length":1,"stats":{"Line":2}},{"line":612,"address":[3577152,3576049,3577467,3577755,3576658],"length":1,"stats":{"Line":8}},{"line":613,"address":[3576656,3576445],"length":1,"stats":{"Line":4}},{"line":614,"address":[3576576],"length":1,"stats":{"Line":0}},{"line":615,"address":[3576592,3576693],"length":1,"stats":{"Line":0}},{"line":618,"address":[3576751],"length":1,"stats":{"Line":0}},{"line":619,"address":[3576815],"length":1,"stats":{"Line":0}},{"line":620,"address":[3577017],"length":1,"stats":{"Line":0}},{"line":623,"address":[3576835,3577806],"length":1,"stats":{"Line":0}},{"line":627,"address":[3577403],"length":1,"stats":{"Line":1}},{"line":629,"address":[3577603],"length":1,"stats":{"Line":2}},{"line":630,"address":[3577313],"length":1,"stats":{"Line":2}},{"line":631,"address":[3577545],"length":1,"stats":{"Line":2}},{"line":632,"address":[3577555],"length":1,"stats":{"Line":2}},{"line":637,"address":[3580405,3578272,3580363],"length":1,"stats":{"Line":2}},{"line":643,"address":[3578359],"length":1,"stats":{"Line":2}},{"line":644,"address":[3578384],"length":1,"stats":{"Line":0}},{"line":648,"address":[3578475],"length":1,"stats":{"Line":2}},{"line":649,"address":[3578831,3578601,3578775],"length":1,"stats":{"Line":4}},{"line":650,"address":[3578804,3580390,3579128,3578932],"length":1,"stats":{"Line":4}},{"line":652,"address":[3579064],"length":1,"stats":{"Line":0}},{"line":658,"address":[3579282,3579347],"length":1,"stats":{"Line":4}},{"line":659,"address":[3579339],"length":1,"stats":{"Line":2}},{"line":662,"address":[3579357],"length":1,"stats":{"Line":2}},{"line":663,"address":[3579320],"length":1,"stats":{"Line":2}},{"line":668,"address":[3580372,3579522,3579926],"length":1,"stats":{"Line":2}},{"line":671,"address":[3579472],"length":1,"stats":{"Line":2}},{"line":673,"address":[3579480],"length":1,"stats":{"Line":2}},{"line":675,"address":[3579490],"length":1,"stats":{"Line":2}},{"line":678,"address":[3579843],"length":1,"stats":{"Line":2}},{"line":680,"address":[3579960],"length":1,"stats":{"Line":2}},{"line":681,"address":[3580063,3580221],"length":1,"stats":{"Line":4}},{"line":682,"address":[3580074,3580149],"length":1,"stats":{"Line":4}},{"line":684,"address":[3245371,3245264],"length":1,"stats":{"Line":4}},{"line":685,"address":[3245336,3245278],"length":1,"stats":{"Line":4}},{"line":689,"address":[3580448],"length":1,"stats":{"Line":0}},{"line":690,"address":[3580468],"length":1,"stats":{"Line":0}},{"line":691,"address":[3580597,3580488],"length":1,"stats":{"Line":0}},{"line":692,"address":[3580526,3580557],"length":1,"stats":{"Line":0}},{"line":693,"address":[3580537,3580573],"length":1,"stats":{"Line":0}},{"line":697,"address":[3580624],"length":1,"stats":{"Line":0}},{"line":698,"address":[3580644],"length":1,"stats":{"Line":0}}],"covered":124,"coverable":255},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_control_stream.rs"],"content":"// standard\nuse std::collections::VecDeque;\nuse std::default::Default;\nuse std::io::{ErrorKind, Read, Write};\nuse std::net::{SocketAddr, TcpStream};\nuse std::option::Option;\nuse std::string::ToString;\nuse std::time::Duration;\n\n// extern crates\nuse regex::Regex;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"control stream read timeout must not be zero\")]\n    ReadTimeoutZero(),\n\n    #[error(\"could not connect to control port\")]\n    CreationFailed(#[source] std::io::Error),\n\n    #[error(\"configure control port socket failed\")]\n    ConfigurationFailed(#[source] std::io::Error),\n\n    #[error(\"control port parsing regex creation failed\")]\n    ParsingRegexCreationFailed(#[source] regex::Error),\n\n    #[error(\"control port stream read failure\")]\n    ReadFailed(#[source] std::io::Error),\n\n    #[error(\"control port stream closed by remote\")]\n    ClosedByRemote(),\n\n    #[error(\"received control port response invalid utf8\")]\n    InvalidResponse(#[source] std::str::Utf8Error),\n\n    #[error(\"failed to parse control port reply: {0}\")]\n    ReplyParseFailed(String),\n\n    #[error(\"control port stream write failure\")]\n    WriteFailed(#[source] std::io::Error),\n}\n\npub(crate) struct LegacyControlStream {\n    stream: TcpStream,\n    closed_by_remote: bool,\n    pending_data: Vec\u003cu8\u003e,\n    pending_lines: VecDeque\u003cString\u003e,\n    pending_reply: Vec\u003cString\u003e,\n    reading_multiline_value: bool,\n    // regexes used to parse control port responses\n    single_line_data: Regex,\n    multi_line_data: Regex,\n    end_reply_line: Regex,\n}\n\ntype StatusCode = u32;\npub(crate) struct Reply {\n    pub status_code: StatusCode,\n    pub reply_lines: Vec\u003cString\u003e,\n}\n\nimpl LegacyControlStream {\n    pub fn new(addr: \u0026SocketAddr, read_timeout: Duration) -\u003e Result\u003cLegacyControlStream, Error\u003e {\n        if read_timeout.is_zero() {\n            return Err(Error::ReadTimeoutZero());\n        }\n\n        let stream = TcpStream::connect(addr).map_err(Error::CreationFailed)?;\n        stream\n            .set_read_timeout(Some(read_timeout))\n            .map_err(Error::ConfigurationFailed)?;\n\n        // pre-allocate a kilobyte for the read buffer\n        const READ_BUFFER_SIZE: usize = 1024;\n        let pending_data = Vec::with_capacity(READ_BUFFER_SIZE);\n\n        let single_line_data =\n            Regex::new(r\"^\\d\\d\\d-.*\").map_err(Error::ParsingRegexCreationFailed)?;\n        let multi_line_data =\n            Regex::new(r\"^\\d\\d\\d+.*\").map_err(Error::ParsingRegexCreationFailed)?;\n        let end_reply_line =\n            Regex::new(r\"^\\d\\d\\d .*\").map_err(Error::ParsingRegexCreationFailed)?;\n\n        Ok(LegacyControlStream {\n            stream,\n            closed_by_remote: false,\n            pending_data,\n            pending_lines: Default::default(),\n            pending_reply: Default::default(),\n            reading_multiline_value: false,\n            // regex\n            single_line_data,\n            multi_line_data,\n            end_reply_line,\n        })\n    }\n\n    #[cfg(test)]\n    pub(crate) fn closed_by_remote(\u0026mut self) -\u003e bool {\n        self.closed_by_remote\n    }\n\n    fn read_line(\u0026mut self) -\u003e Result\u003cOption\u003cString\u003e, Error\u003e {\n        // read pending bytes from stream until we have a line to return\n        while self.pending_lines.is_empty() {\n            let byte_count = self.pending_data.len();\n            match self.stream.read_to_end(\u0026mut self.pending_data) {\n                Err(err) =\u003e {\n                    if err.kind() == ErrorKind::WouldBlock || err.kind() == ErrorKind::TimedOut {\n                        if byte_count == self.pending_data.len() {\n                            return Ok(None);\n                        }\n                    } else {\n                        return Err(Error::ReadFailed(err));\n                    }\n                }\n                Ok(0usize) =\u003e {\n                    self.closed_by_remote = true;\n                    return Err(Error::ClosedByRemote());\n                }\n                Ok(_count) =\u003e (),\n            }\n\n            // split our read buffer into individual lines\n            let mut begin = 0;\n            for index in 1..self.pending_data.len() {\n                if self.pending_data[index - 1] == b'\\r' \u0026\u0026 self.pending_data[index] == b'\\n' {\n                    let end = index - 1;\n                    // view into byte vec of just the found line\n                    let line_view: \u0026[u8] = \u0026self.pending_data[begin..end];\n                    // convert to string\n                    let line_string =\n                        std::str::from_utf8(line_view).map_err(Error::InvalidResponse)?;\n\n                    // save in pending list\n                    self.pending_lines.push_back(line_string.to_string());\n                    // update begin (and skip over \\r\\n)\n                    begin = end + 2;\n                }\n            }\n            // leave any leftover bytes in the buffer for the next call\n            self.pending_data.drain(0..begin);\n        }\n\n        Ok(self.pending_lines.pop_front())\n    }\n\n    pub fn read_reply(\u0026mut self) -\u003e Result\u003cOption\u003cReply\u003e, Error\u003e {\n        loop {\n            let current_line = match self.read_line()? {\n                Some(line) =\u003e line,\n                None =\u003e return Ok(None),\n            };\n\n            // make sure the status code matches (if we are not in the\n            // middle of a multi-line read\n            if let Some(first_line) = self.pending_reply.first() {\n                if !self.reading_multiline_value {\n                    let first_status_code = \u0026first_line[0..3];\n                    let current_status_code = \u0026current_line[0..3];\n                    if first_status_code != current_status_code {\n                        return Err(Error::ReplyParseFailed(format!(\n                            \"mismatched status codes, {} != {}\",\n                            first_status_code, current_status_code\n                        )));\n                    }\n                }\n            }\n\n            // end of a response\n            if self.end_reply_line.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found multi-line end reply but not reading a multi-line reply\".to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n                break;\n            // single line data from getinfo and friends\n            } else if self.single_line_data.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found single-line reply but still reading a multi-line reply\".to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n            // begin of multiline data from getinfo and friends\n            } else if self.multi_line_data.is_match(\u0026current_line) {\n                if self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found multi-line start reply but still reading a multi-line reply\"\n                            .to_string(),\n                    ));\n                }\n                self.pending_reply.push(current_line);\n                self.reading_multiline_value = true;\n            // multiline data to be squashed to a single entry\n            } else {\n                if !self.reading_multiline_value {\n                    return Err(Error::ReplyParseFailed(\n                        \"found a multi-line intermediate reply but not reading a multi-line reply\"\n                            .to_string(),\n                    ));\n                }\n                // don't bother writing the end of multiline token\n                if current_line == \".\" {\n                    self.reading_multiline_value = false;\n                } else {\n                    let multiline = match self.pending_reply.last_mut() {\n                        Some(multiline) =\u003e multiline,\n                        // if our logic here is right, then\n                        // self.reading_multiline_value == !self.pending_reply.is_empty()\n                        // should always be true regardless of the data received\n                        // from the control port\n                        None =\u003e unreachable!(),\n                    };\n                    multiline.push('\\n');\n                    multiline.push_str(\u0026current_line);\n                }\n            }\n        }\n\n        // take ownership of the reply lines\n        let mut reply_lines: Vec\u003cString\u003e = Default::default();\n        std::mem::swap(\u0026mut self.pending_reply, \u0026mut reply_lines);\n\n        // parse out the response code for easier matching\n        let status_code_string = match reply_lines.first() {\n            Some(line) =\u003e line[0..3].to_string(),\n            // the lines have already been parsed+validated in the above loop\n            None =\u003e unreachable!(),\n        };\n        let status_code: u32 = match status_code_string.parse() {\n            Ok(status_code) =\u003e status_code,\n            Err(_) =\u003e {\n                return Err(Error::ReplyParseFailed(format!(\n                    \"unable to parse '{}' as status code\",\n                    status_code_string\n                )))\n            }\n        };\n\n        // strip the redundant status code from start of lines\n        for line in reply_lines.iter_mut() {\n            if line.starts_with(\u0026status_code_string) {\n                *line = line[4..].to_string();\n            }\n        }\n\n        Ok(Some(Reply {\n            status_code,\n            reply_lines,\n        }))\n    }\n\n    pub fn write(\u0026mut self, cmd: \u0026str) -\u003e Result\u003c(), Error\u003e {\n        if let Err(err) = write!(self.stream, \"{}\\r\\n\", cmd) {\n            self.closed_by_remote = true;\n            return Err(Error::WriteFailed(err));\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":63,"address":[3267408,3265184,3267577],"length":1,"stats":{"Line":3}},{"line":64,"address":[3265223],"length":1,"stats":{"Line":3}},{"line":65,"address":[3265346],"length":1,"stats":{"Line":0}},{"line":68,"address":[3265496,3265258,3265409],"length":1,"stats":{"Line":6}},{"line":69,"address":[3267562,3265456,3265206,3265752,3265619],"length":1,"stats":{"Line":9}},{"line":70,"address":[3265432],"length":1,"stats":{"Line":3}},{"line":71,"address":[3265720],"length":1,"stats":{"Line":0}},{"line":75,"address":[3265691],"length":1,"stats":{"Line":3}},{"line":77,"address":[3267517,3265861,3265789,3266026],"length":1,"stats":{"Line":4}},{"line":79,"address":[3265990,3266296,3266131,3267496],"length":1,"stats":{"Line":6}},{"line":81,"address":[3266401,3266617,3266260],"length":1,"stats":{"Line":6}},{"line":84,"address":[3266979],"length":1,"stats":{"Line":3}},{"line":85,"address":[3266534],"length":1,"stats":{"Line":3}},{"line":87,"address":[3266553],"length":1,"stats":{"Line":3}},{"line":88,"address":[3266593],"length":1,"stats":{"Line":3}},{"line":89,"address":[3266722],"length":1,"stats":{"Line":3}},{"line":92,"address":[3266787],"length":1,"stats":{"Line":3}},{"line":93,"address":[3266851],"length":1,"stats":{"Line":3}},{"line":94,"address":[3266915],"length":1,"stats":{"Line":3}},{"line":99,"address":[1691792],"length":1,"stats":{"Line":1}},{"line":100,"address":[1691797],"length":1,"stats":{"Line":1}},{"line":103,"address":[3267616,3269061],"length":1,"stats":{"Line":3}},{"line":105,"address":[3267646],"length":1,"stats":{"Line":3}},{"line":106,"address":[3267751],"length":1,"stats":{"Line":3}},{"line":107,"address":[3267824,3267775],"length":1,"stats":{"Line":4}},{"line":108,"address":[3267834],"length":1,"stats":{"Line":3}},{"line":109,"address":[3268068,3268155,3267857],"length":1,"stats":{"Line":6}},{"line":110,"address":[3268312,3268132],"length":1,"stats":{"Line":6}},{"line":111,"address":[3268346],"length":1,"stats":{"Line":3}},{"line":114,"address":[3268203],"length":1,"stats":{"Line":0}},{"line":118,"address":[3267881],"length":1,"stats":{"Line":0}},{"line":119,"address":[3267888],"length":1,"stats":{"Line":0}},{"line":121,"address":[3267952],"length":1,"stats":{"Line":1}},{"line":125,"address":[3267970],"length":1,"stats":{"Line":3}},{"line":126,"address":[3267982,3268409,3268500],"length":1,"stats":{"Line":9}},{"line":127,"address":[3268521,3269014],"length":1,"stats":{"Line":6}},{"line":128,"address":[3268625,3268791],"length":1,"stats":{"Line":3}},{"line":130,"address":[3268665],"length":1,"stats":{"Line":3}},{"line":132,"address":[3268705,3268911,3268812],"length":1,"stats":{"Line":6}},{"line":136,"address":[3268844],"length":1,"stats":{"Line":3}},{"line":138,"address":[3269019,3268890,3269006],"length":1,"stats":{"Line":6}},{"line":142,"address":[3268455],"length":1,"stats":{"Line":3}},{"line":145,"address":[3267678],"length":1,"stats":{"Line":3}},{"line":148,"address":[3269088,3273382],"length":1,"stats":{"Line":3}},{"line":149,"address":[3269127,3271657],"length":1,"stats":{"Line":6}},{"line":150,"address":[3269151],"length":1,"stats":{"Line":3}},{"line":151,"address":[3269489],"length":1,"stats":{"Line":3}},{"line":152,"address":[3269406],"length":1,"stats":{"Line":3}},{"line":157,"address":[3269561,3269662],"length":1,"stats":{"Line":6}},{"line":158,"address":[3269758],"length":1,"stats":{"Line":3}},{"line":159,"address":[3269831],"length":1,"stats":{"Line":3}},{"line":160,"address":[3269906],"length":1,"stats":{"Line":3}},{"line":161,"address":[3269989],"length":1,"stats":{"Line":3}},{"line":162,"address":[3270227],"length":1,"stats":{"Line":0}},{"line":171,"address":[3269775,3270482],"length":1,"stats":{"Line":6}},{"line":172,"address":[3270568],"length":1,"stats":{"Line":3}},{"line":173,"address":[3273431],"length":1,"stats":{"Line":0}},{"line":174,"address":[3271877],"length":1,"stats":{"Line":0}},{"line":177,"address":[3271814],"length":1,"stats":{"Line":3}},{"line":180,"address":[3270517,3270610],"length":1,"stats":{"Line":6}},{"line":181,"address":[3270696],"length":1,"stats":{"Line":3}},{"line":182,"address":[3271686],"length":1,"stats":{"Line":0}},{"line":183,"address":[3271617],"length":1,"stats":{"Line":0}},{"line":186,"address":[3271554,3271644],"length":1,"stats":{"Line":6}},{"line":188,"address":[3270738,3270645,3271413],"length":1,"stats":{"Line":3}},{"line":189,"address":[3270792],"length":1,"stats":{"Line":1}},{"line":190,"address":[3271426],"length":1,"stats":{"Line":0}},{"line":191,"address":[3271371],"length":1,"stats":{"Line":0}},{"line":195,"address":[3271308],"length":1,"stats":{"Line":1}},{"line":196,"address":[3271406],"length":1,"stats":{"Line":1}},{"line":199,"address":[3270773],"length":1,"stats":{"Line":1}},{"line":200,"address":[3270877],"length":1,"stats":{"Line":0}},{"line":201,"address":[3270810],"length":1,"stats":{"Line":0}},{"line":206,"address":[3270837,3271004,3271064],"length":1,"stats":{"Line":3}},{"line":207,"address":[3271057],"length":1,"stats":{"Line":1}},{"line":209,"address":[3271018,3271085],"length":1,"stats":{"Line":2}},{"line":210,"address":[3271179],"length":1,"stats":{"Line":1}},{"line":217,"address":[3271208],"length":1,"stats":{"Line":1}},{"line":218,"address":[3271225],"length":1,"stats":{"Line":1}},{"line":224,"address":[3271915],"length":1,"stats":{"Line":3}},{"line":225,"address":[3271964],"length":1,"stats":{"Line":3}},{"line":228,"address":[3272020],"length":1,"stats":{"Line":3}},{"line":229,"address":[3272168],"length":1,"stats":{"Line":3}},{"line":233,"address":[3272343,3272266],"length":1,"stats":{"Line":6}},{"line":234,"address":[3272406],"length":1,"stats":{"Line":3}},{"line":236,"address":[3273180],"length":1,"stats":{"Line":0}},{"line":244,"address":[3272883,3272562,3272424],"length":1,"stats":{"Line":9}},{"line":245,"address":[3272955,3273175,3272904],"length":1,"stats":{"Line":9}},{"line":246,"address":[3272996],"length":1,"stats":{"Line":3}},{"line":250,"address":[3272762],"length":1,"stats":{"Line":3}},{"line":252,"address":[3272722],"length":1,"stats":{"Line":3}},{"line":256,"address":[3273584],"length":1,"stats":{"Line":3}},{"line":257,"address":[3273623,3273720],"length":1,"stats":{"Line":6}},{"line":258,"address":[3273835],"length":1,"stats":{"Line":1}},{"line":259,"address":[3273842],"length":1,"stats":{"Line":1}},{"line":261,"address":[3273927],"length":1,"stats":{"Line":3}}],"covered":81,"coverable":96},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_controller.rs"],"content":"// standard\nuse std::default::Default;\nuse std::net::SocketAddr;\nuse std::option::Option;\n#[cfg(test)]\nuse std::path::Path;\nuse std::str::FromStr;\nuse std::string::ToString;\n#[cfg(test)]\nuse std::time::{Duration, Instant};\n\n// extern crates\nuse regex::Regex;\n#[cfg(test)]\nuse serial_test::serial;\n\n// internal crates\nuse crate::legacy_tor_control_stream::*;\n#[cfg(test)]\nuse crate::legacy_tor_process::*;\nuse crate::legacy_tor_version::*;\nuse crate::tor_crypto::*;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"response regex creation failed\")]\n    ParsingRegexCreationFailed(#[source] regex::Error),\n\n    #[error(\"control stream read reply failed\")]\n    ReadReplyFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"unexpected synchronous reply recieved\")]\n    UnexpectedSynchonousReplyReceived(),\n\n    #[error(\"control stream write command failed\")]\n    WriteCommandFailed(#[source] crate::legacy_tor_control_stream::Error),\n\n    #[error(\"invalid command arguments: {0}\")]\n    InvalidCommandArguments(String),\n\n    #[error(\"command failed: {0} {}\", .1.join(\"\\n\"))]\n    CommandFailed(u32, Vec\u003cString\u003e),\n\n    #[error(\"failed to parse command reply: {0}\")]\n    CommandReplyParseFailed(String),\n\n    #[error(\"failed to parse received tor version\")]\n    TorVersionParseFailed(#[source] crate::legacy_tor_version::Error),\n}\n\n// Per-command data\n#[derive(Default)]\npub(crate) struct AddOnionFlags {\n    pub discard_pk: bool,\n    pub detach: bool,\n    pub v3_auth: bool,\n    pub non_anonymous: bool,\n    pub max_streams_close_circuit: bool,\n}\n\n#[derive(Default)]\npub(crate) struct OnionClientAuthAddFlags {\n    pub permanent: bool,\n}\n\npub(crate) enum AsyncEvent {\n    Unknown {\n        lines: Vec\u003cString\u003e,\n    },\n    StatusClient {\n        severity: String,\n        action: String,\n        arguments: Vec\u003c(String, String)\u003e,\n    },\n    HsDesc {\n        action: String,\n        hs_address: V3OnionServiceId,\n    },\n}\n\npub(crate) struct LegacyTorController {\n    // underlying control stream\n    control_stream: LegacyControlStream,\n    // list of async replies to be handled\n    async_replies: Vec\u003cReply\u003e,\n    // regex for parsing events\n    status_event_pattern: Regex,\n    status_event_argument_pattern: Regex,\n    hs_desc_pattern: Regex,\n}\n\nfn quoted_string(string: \u0026str) -\u003e String {\n    // replace \\ with \\\\ and \" with \\\"\n    // see: https://spec.torproject.org/control-spec/message-format.html?highlight=QuotedString#description-format\n    string.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\")\n}\n\nimpl LegacyTorController {\n    pub fn new(control_stream: LegacyControlStream) -\u003e Result\u003cLegacyTorController, Error\u003e {\n        let status_event_pattern =\n            Regex::new(r#\"^STATUS_CLIENT (?P\u003cseverity\u003eNOTICE|WARN|ERR) (?P\u003caction\u003e[A-Za-z]+)\"#)\n                .map_err(Error::ParsingRegexCreationFailed)?;\n        let status_event_argument_pattern =\n            Regex::new(r#\"(?P\u003ckey\u003e[A-Z]+)=(?P\u003cvalue\u003e[A-Za-z0-9_]+|\"[^\"]+\")\"#)\n                .map_err(Error::ParsingRegexCreationFailed)?;\n        let hs_desc_pattern = Regex::new(\n            r#\"HS_DESC (?P\u003caction\u003eREQUESTED|UPLOAD|RECEIVED|UPLOADED|IGNORE|FAILED|CREATED) (?P\u003chsaddress\u003e[a-z2-7]{56})\"#\n        ).map_err(Error::ParsingRegexCreationFailed)?;\n\n        Ok(LegacyTorController {\n            control_stream,\n            async_replies: Default::default(),\n            // regex\n            status_event_pattern,\n            status_event_argument_pattern,\n            hs_desc_pattern,\n        })\n    }\n\n    // return curently available events, does not block waiting\n    // for an event\n    fn wait_async_replies(\u0026mut self) -\u003e Result\u003cVec\u003cReply\u003e, Error\u003e {\n        let mut replies: Vec\u003cReply\u003e = Default::default();\n        // take any previously received async replies\n        std::mem::swap(\u0026mut self.async_replies, \u0026mut replies);\n\n        // and keep consuming until none are available\n        loop {\n            if let Some(reply) = self\n                .control_stream\n                .read_reply()\n                .map_err(Error::ReadReplyFailed)?\n            {\n                replies.push(reply);\n            } else {\n                // no more replies immediately available so return\n                return Ok(replies);\n            }\n        }\n    }\n\n    fn reply_to_event(\u0026self, reply: \u0026mut Reply) -\u003e Result\u003cAsyncEvent, Error\u003e {\n        if reply.status_code != 650u32 {\n            return Err(Error::UnexpectedSynchonousReplyReceived());\n        }\n\n        // not sure this is what we want but yolo\n        let reply_text = reply.reply_lines.join(\" \");\n        if let Some(caps) = self.status_event_pattern.captures(\u0026reply_text) {\n            let severity = match caps.name(\"severity\") {\n                Some(severity) =\u003e severity.as_str(),\n                None =\u003e unreachable!(),\n            };\n            let action = match caps.name(\"action\") {\n                Some(action) =\u003e action.as_str(),\n                None =\u003e unreachable!(),\n            };\n\n            let mut arguments: Vec\u003c(String, String)\u003e = Default::default();\n            for caps in self\n                .status_event_argument_pattern\n                .captures_iter(\u0026reply_text)\n            {\n                let key = match caps.name(\"key\") {\n                    Some(key) =\u003e key.as_str(),\n                    None =\u003e unreachable!(),\n                };\n                let value = {\n                    let value = match caps.name(\"value\") {\n                        Some(value) =\u003e value.as_str(),\n                        None =\u003e unreachable!(),\n                    };\n                    if value.starts_with('\\\"') \u0026\u0026 value.ends_with('\\\"') {\n                        \u0026value[1..value.len() - 1]\n                    } else {\n                        value\n                    }\n                };\n                arguments.push((key.to_string(), value.to_string()));\n            }\n\n            return Ok(AsyncEvent::StatusClient {\n                severity: severity.to_string(),\n                action: action.to_string(),\n                arguments,\n            });\n        }\n\n        if let Some(caps) = self.hs_desc_pattern.captures(\u0026reply_text) {\n            let action = match caps.name(\"action\") {\n                Some(action) =\u003e action.as_str(),\n                None =\u003e unreachable!(),\n            };\n            let hs_address = match caps.name(\"hsaddress\") {\n                Some(hs_address) =\u003e hs_address.as_str(),\n                None =\u003e unreachable!(),\n            };\n\n            if let Ok(hs_address) = V3OnionServiceId::from_string(hs_address) {\n                return Ok(AsyncEvent::HsDesc {\n                    action: action.to_string(),\n                    hs_address,\n                });\n            }\n        }\n\n        // no luck parsing reply, just return full text\n        let mut reply_lines: Vec\u003cString\u003e = Default::default();\n        std::mem::swap(\u0026mut reply_lines, \u0026mut reply.reply_lines);\n\n        Ok(AsyncEvent::Unknown { lines: reply_lines })\n    }\n\n    pub fn wait_async_events(\u0026mut self) -\u003e Result\u003cVec\u003cAsyncEvent\u003e, Error\u003e {\n        let mut async_replies = self.wait_async_replies()?;\n        let mut async_events: Vec\u003cAsyncEvent\u003e = Default::default();\n\n        for reply in async_replies.iter_mut() {\n            async_events.push(self.reply_to_event(reply)?);\n        }\n\n        Ok(async_events)\n    }\n\n    // wait for a sync reply, save off async replies for later\n    fn wait_sync_reply(\u0026mut self) -\u003e Result\u003cReply, Error\u003e {\n        loop {\n            if let Some(reply) = self\n                .control_stream\n                .read_reply()\n                .map_err(Error::ReadReplyFailed)?\n            {\n                match reply.status_code {\n                    650u32 =\u003e self.async_replies.push(reply),\n                    _ =\u003e return Ok(reply),\n                }\n            }\n        }\n    }\n\n    fn write_command(\u0026mut self, text: \u0026str) -\u003e Result\u003cReply, Error\u003e {\n        self.control_stream\n            .write(text)\n            .map_err(Error::WriteCommandFailed)?;\n        self.wait_sync_reply()\n    }\n\n    //\n    // Tor Commands\n    //\n    // The section where we can find the specification in control-spec.txt\n    // for the underlying command is listed in parentheses\n    //\n    // Each of these command wrapper methods block until completion\n    //\n\n    // SETCONF (3.1)\n    fn setconf_cmd(\u0026mut self, key_values: \u0026[(\u0026str, String)]) -\u003e Result\u003cReply, Error\u003e {\n        if key_values.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"SETCONF key-value pairs list must not be empty\".to_string(),\n            ));\n        }\n        let mut command_buffer = vec![\"SETCONF\".to_string()];\n\n        for (key, value) in key_values.iter() {\n            command_buffer.push(format!(\"{}=\\\"{}\\\"\", key, quoted_string(value.trim())));\n        }\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // GETCONF (3.3)\n    #[cfg(test)]\n    fn getconf_cmd(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if keywords.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"GETCONF keywords list must not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"GETCONF {}\", keywords.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // SETEVENTS (3.4)\n    fn setevents_cmd(\u0026mut self, event_codes: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if event_codes.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"SETEVENTS event codes list mut not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"SETEVENTS {}\", event_codes.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // AUTHENTICATE (3.5)\n    fn authenticate_cmd(\u0026mut self, password: \u0026str) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"AUTHENTICATE \\\"{}\\\"\", quoted_string(password));\n\n        self.write_command(\u0026command)\n    }\n\n    // GETINFO (3.9)\n    fn getinfo_cmd(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cReply, Error\u003e {\n        if keywords.is_empty() {\n            return Err(Error::InvalidCommandArguments(\n                \"GETINFO keywords list must not be empty\".to_string(),\n            ));\n        }\n        let command = format!(\"GETINFO {}\", keywords.join(\" \"));\n\n        self.write_command(\u0026command)\n    }\n\n    // ADD_ONION (3.27)\n    fn add_onion_cmd(\n        \u0026mut self,\n        key: Option\u003c\u0026Ed25519PrivateKey\u003e,\n        flags: \u0026AddOnionFlags,\n        max_streams: Option\u003cu16\u003e,\n        virt_port: u16,\n        target: Option\u003cSocketAddr\u003e,\n        client_auth: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let mut command_buffer = vec![\"ADD_ONION\".to_string()];\n\n        // set our key or request a new one\n        if let Some(key) = key {\n            command_buffer.push(key.to_key_blob());\n        } else {\n            command_buffer.push(\"NEW:ED25519-V3\".to_string());\n        }\n\n        // set our flags\n        let mut flag_buffer: Vec\u003c\u0026str\u003e = Default::default();\n        if flags.discard_pk {\n            flag_buffer.push(\"DiscardPK\");\n        }\n        if flags.detach {\n            flag_buffer.push(\"Detach\");\n        }\n        if flags.v3_auth {\n            flag_buffer.push(\"V3Auth\");\n        }\n        if flags.non_anonymous {\n            flag_buffer.push(\"NonAnonymous\");\n        }\n        if flags.max_streams_close_circuit {\n            flag_buffer.push(\"MaxStreamsCloseCircuit\");\n        }\n\n        if !flag_buffer.is_empty() {\n            command_buffer.push(format!(\"Flags={}\", flag_buffer.join(\",\")));\n        }\n\n        // set max concurrent streams\n        if let Some(max_streams) = max_streams {\n            command_buffer.push(format!(\"MaxStreams={}\", max_streams));\n        }\n\n        // set our onion service target\n        if let Some(target) = target {\n            command_buffer.push(format!(\"Port={},{}\", virt_port, target));\n        } else {\n            command_buffer.push(format!(\"Port={}\", virt_port));\n        }\n        // setup client auth\n        if let Some(client_auth) = client_auth {\n            for key in client_auth.iter() {\n                command_buffer.push(format!(\"ClientAuthV3={}\", key.to_base32()));\n            }\n        }\n\n        // finally send the command\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // DEL_ONION (3.38)\n    fn del_onion_cmd(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"DEL_ONION {}\", service_id);\n\n        self.write_command(\u0026command)\n    }\n\n    // ONION_CLIENT_AUTH_ADD (3.30)\n    fn onion_client_auth_add_cmd(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        private_key: \u0026X25519PrivateKey,\n        client_name: Option\u003cString\u003e,\n        flags: \u0026OnionClientAuthAddFlags,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let mut command_buffer = vec![\"ONION_CLIENT_AUTH_ADD\".to_string()];\n\n        // set the onion service id\n        command_buffer.push(service_id.to_string());\n\n        // set our client's private key\n        command_buffer.push(format!(\"x25519:{}\", private_key.to_base64()));\n\n        if let Some(client_name) = client_name {\n            command_buffer.push(format!(\"ClientName={}\", client_name));\n        }\n\n        if flags.permanent {\n            command_buffer.push(\"Flags=Permanent\".to_string());\n        }\n\n        // finally send command\n        let command = command_buffer.join(\" \");\n\n        self.write_command(\u0026command)\n    }\n\n    // ONION_CLIENT_AUTH_REMOVE (3.31)\n    fn onion_client_auth_remove_cmd(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003cReply, Error\u003e {\n        let command = format!(\"ONION_CLIENT_AUTH_REMOVE {}\", service_id);\n\n        self.write_command(\u0026command)\n    }\n\n    //\n    // Public high-level typesafe command method wrappers\n    //\n\n    pub fn setconf(\u0026mut self, key_values: \u0026[(\u0026str, String)]) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.setconf_cmd(key_values)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    #[cfg(test)]\n    pub fn getconf(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cVec\u003c(String, String)\u003e, Error\u003e {\n        let reply = self.getconf_cmd(keywords)?;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                let mut key_values: Vec\u003c(String, String)\u003e = Default::default();\n                for line in reply.reply_lines {\n                    match line.find('=') {\n                        Some(index) =\u003e key_values\n                            .push((line[0..index].to_string(), line[index + 1..].to_string())),\n                        None =\u003e key_values.push((line, String::new())),\n                    }\n                }\n                Ok(key_values)\n            }\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn setevents(\u0026mut self, events: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.setevents_cmd(events)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn authenticate(\u0026mut self, password: \u0026str) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.authenticate_cmd(password)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn getinfo(\u0026mut self, keywords: \u0026[\u0026str]) -\u003e Result\u003cVec\u003c(String, String)\u003e, Error\u003e {\n        let reply = self.getinfo_cmd(keywords)?;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                let mut key_values: Vec\u003c(String, String)\u003e = Default::default();\n                for line in reply.reply_lines {\n                    match line.find('=') {\n                        Some(index) =\u003e key_values\n                            .push((line[0..index].to_string(), line[index + 1..].to_string())),\n                        None =\u003e {\n                            if line != \"OK\" {\n                                key_values.push((line, String::new()))\n                            }\n                        }\n                    }\n                }\n                Ok(key_values)\n            }\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    pub fn add_onion(\n        \u0026mut self,\n        key: Option\u003c\u0026Ed25519PrivateKey\u003e,\n        flags: \u0026AddOnionFlags,\n        max_streams: Option\u003cu16\u003e,\n        virt_port: u16,\n        target: Option\u003cSocketAddr\u003e,\n        client_auth: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003c(Option\u003cEd25519PrivateKey\u003e, V3OnionServiceId), Error\u003e {\n        let reply = self.add_onion_cmd(key, flags, max_streams, virt_port, target, client_auth)?;\n\n        let mut private_key: Option\u003cEd25519PrivateKey\u003e = None;\n        let mut service_id: Option\u003cV3OnionServiceId\u003e = None;\n\n        match reply.status_code {\n            250u32 =\u003e {\n                for line in reply.reply_lines {\n                    if let Some(mut index) = line.find(\"ServiceID=\") {\n                        if service_id.is_some() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"received duplicate ServiceID entries\".to_string(),\n                            ));\n                        }\n                        index += \"ServiceId=\".len();\n                        let service_id_string = \u0026line[index..];\n                        service_id = match V3OnionServiceId::from_string(service_id_string) {\n                            Ok(service_id) =\u003e Some(service_id),\n                            Err(_) =\u003e {\n                                return Err(Error::CommandReplyParseFailed(format!(\n                                    \"could not parse '{}' as V3OnionServiceId\",\n                                    service_id_string\n                                )))\n                            }\n                        }\n                    } else if let Some(mut index) = line.find(\"PrivateKey=\") {\n                        if private_key.is_some() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"received duplicate PrivateKey entries\".to_string(),\n                            ));\n                        }\n                        index += \"PrivateKey=\".len();\n                        let key_blob_string = \u0026line[index..];\n                        private_key = match Ed25519PrivateKey::from_key_blob_legacy(key_blob_string)\n                        {\n                            Ok(private_key) =\u003e Some(private_key),\n                            Err(_) =\u003e {\n                                return Err(Error::CommandReplyParseFailed(format!(\n                                    \"could not parse {} as Ed25519PrivateKey\",\n                                    key_blob_string\n                                )))\n                            }\n                        };\n                    } else if line.contains(\"ClientAuthV3=\") {\n                        if client_auth.unwrap_or_default().is_empty() {\n                            return Err(Error::CommandReplyParseFailed(\n                                \"recieved unexpected ClientAuthV3 keys\".to_string(),\n                            ));\n                        }\n                    } else if !line.contains(\"OK\") {\n                        return Err(Error::CommandReplyParseFailed(format!(\n                            \"received unexpected reply line '{}'\",\n                            line\n                        )));\n                    }\n                }\n            }\n            code =\u003e return Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n\n        if flags.discard_pk {\n            if private_key.is_some() {\n                return Err(Error::CommandReplyParseFailed(\n                    \"PrivateKey response should have been discard\".to_string(),\n                ));\n            }\n        } else if private_key.is_none() {\n            return Err(Error::CommandReplyParseFailed(\n                \"did not receive a PrivateKey\".to_string(),\n            ));\n        }\n\n        match service_id {\n            Some(service_id) =\u003e Ok((private_key, service_id)),\n            None =\u003e Err(Error::CommandReplyParseFailed(\n                \"did not receive a ServiceID\".to_string(),\n            )),\n        }\n    }\n\n    pub fn del_onion(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.del_onion_cmd(service_id)?;\n\n        match reply.status_code {\n            250u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    // more specific encapulsation of specific command invocations\n\n    pub fn getinfo_net_listeners_socks(\u0026mut self) -\u003e Result\u003cVec\u003cSocketAddr\u003e, Error\u003e {\n        let response = self.getinfo(\u0026[\"net/listeners/socks\"])?;\n        for (key, value) in response.iter() {\n            if key.as_str() == \"net/listeners/socks\" {\n                if value.is_empty() {\n                    return Ok(Default::default());\n                }\n                // get our list of double-quoted strings\n                let listeners: Vec\u003c\u0026str\u003e = value.split(' ').collect();\n                let mut result: Vec\u003cSocketAddr\u003e = Default::default();\n                for socket_addr in listeners.iter() {\n                    if !socket_addr.starts_with('\\\"') || !socket_addr.ends_with('\\\"') {\n                        return Err(Error::CommandReplyParseFailed(format!(\n                            \"could not parse '{}' as socket address\",\n                            socket_addr\n                        )));\n                    }\n\n                    // remove leading/trailing double quote\n                    let stripped = \u0026socket_addr[1..socket_addr.len() - 1];\n                    result.push(match SocketAddr::from_str(stripped) {\n                        Ok(result) =\u003e result,\n                        Err(_) =\u003e {\n                            return Err(Error::CommandReplyParseFailed(format!(\n                                \"could not parse '{}' as socket address\",\n                                socket_addr\n                            )))\n                        }\n                    });\n                }\n                return Ok(result);\n            }\n        }\n        Err(Error::CommandReplyParseFailed(\n            \"reply did not find a 'net/listeners/socks' key/value\".to_string(),\n        ))\n    }\n\n    pub fn getinfo_version(\u0026mut self) -\u003e Result\u003cLegacyTorVersion, Error\u003e {\n        let response = self.getinfo(\u0026[\"version\"])?;\n        for (key, value) in response.iter() {\n            if key.as_str() == \"version\" {\n                return LegacyTorVersion::from_str(value).map_err(Error::TorVersionParseFailed);\n            }\n        }\n        Err(Error::CommandReplyParseFailed(\n            \"did not find a 'version' key/value\".to_string(),\n        ))\n    }\n\n    pub fn onion_client_auth_add(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        private_key: \u0026X25519PrivateKey,\n        client_name: Option\u003cString\u003e,\n        flags: \u0026OnionClientAuthAddFlags,\n    ) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.onion_client_auth_add_cmd(service_id, private_key, client_name, flags)?;\n\n        match reply.status_code {\n            250u32..=252u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn onion_client_auth_remove(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e {\n        let reply = self.onion_client_auth_remove_cmd(service_id)?;\n\n        match reply.status_code {\n            250u32..=251u32 =\u003e Ok(()),\n            code =\u003e Err(Error::CommandFailed(code, reply.reply_lines)),\n        }\n    }\n}\n\n#[test]\n#[serial]\nfn test_tor_controller() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_tor_controller\");\n    let tor_process = LegacyTorProcess::new(\u0026tor_path, \u0026data_path)?;\n\n    // create a scope to ensure tor_controller is dropped\n    {\n        let control_stream =\n            LegacyControlStream::new(tor_process.get_control_addr(), Duration::from_millis(16))?;\n\n        // create a tor controller and send authentication command\n        let mut tor_controller = LegacyTorController::new(control_stream)?;\n        tor_controller.authenticate_cmd(tor_process.get_password())?;\n        assert!(\n            tor_controller\n                .authenticate_cmd(\"invalid password\")?\n                .status_code\n                == 515u32\n        );\n\n        // tor controller should have shutdown the connection after failed authentication\n        assert!(\n            tor_controller\n                .authenticate_cmd(tor_process.get_password())\n                .is_err(),\n            \"expected failure due to closed connection\"\n        );\n        assert!(tor_controller.control_stream.closed_by_remote());\n    }\n    // now create a second controller\n    {\n        let control_stream =\n            LegacyControlStream::new(tor_process.get_control_addr(), Duration::from_millis(16))?;\n\n        // create a tor controller and send authentication command\n        // all async events are just printed to stdout\n        let mut tor_controller = LegacyTorController::new(control_stream)?;\n        tor_controller.authenticate(tor_process.get_password())?;\n\n        // ensure everything is matching our default_torrc settings\n        let vals = tor_controller.getconf(\u0026[\"SocksPort\", \"AvoidDiskWrites\", \"DisableNetwork\"])?;\n        for (key, value) in vals.iter() {\n            let expected = match key.as_str() {\n                \"SocksPort\" =\u003e \"auto\",\n                \"AvoidDiskWrites\" =\u003e \"1\",\n                \"DisableNetwork\" =\u003e \"1\",\n                _ =\u003e panic!(\"unexpected returned key: {}\", key),\n            };\n            assert!(value == expected);\n        }\n\n        let vals = tor_controller.getinfo(\u0026[\"version\", \"config-file\", \"config-text\"])?;\n        let mut expected_torrc_path = data_path.clone();\n        expected_torrc_path.push(\"torrc\");\n        let mut expected_control_port_path = data_path.clone();\n        expected_control_port_path.push(\"control_port\");\n        for (key, value) in vals.iter() {\n            match key.as_str() {\n                \"version\" =\u003e assert!(Regex::new(r\"\\d+\\.\\d+\\.\\d+\\.\\d+\")?.is_match(\u0026value)),\n                \"config-file\" =\u003e assert!(Path::new(\u0026value) == expected_torrc_path),\n                \"config-text\" =\u003e assert!(\n                    value.to_string()\n                        == format!(\n                            \"\\nControlPort auto\\nControlPortWriteToFile {}\\nDataDirectory {}\",\n                            expected_control_port_path.display(),\n                            data_path.display()\n                        )\n                ),\n                _ =\u003e panic!(\"unexpected returned key: {}\", key),\n            }\n        }\n\n        tor_controller.setevents(\u0026[\"STATUS_CLIENT\"])?;\n        // begin bootstrap\n        tor_controller.setconf(\u0026[(\"DisableNetwork\", \"0\".to_string())])?;\n\n        // add an onoin service\n        let (private_key, service_id) =\n            match tor_controller.add_onion(None, \u0026Default::default(), None, 22, None, None)? {\n                (Some(private_key), service_id) =\u003e (private_key, service_id),\n                _ =\u003e panic!(\"add_onion did not return expected values\"),\n            };\n        println!(\"private_key: {}\", private_key.to_key_blob());\n        println!(\"service_id: {}\", service_id.to_string());\n\n        assert!(\n            tor_controller\n                .del_onion(\u0026V3OnionServiceId::from_string(\n                    \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd\"\n                )?)\n                .is_err(),\n            \"deleting unknown onion should have failed\"\n        );\n\n        // delete our new onion\n        tor_controller.del_onion(\u0026service_id)?;\n\n        println!(\"listeners: \");\n        for sock_addr in tor_controller.getinfo_net_listeners_socks()?.iter() {\n            println!(\" {}\", sock_addr);\n        }\n\n        // print our event names available to tor\n        for (key, value) in tor_controller.getinfo(\u0026[\"events/names\"])?.iter() {\n            println!(\"{} : {}\", key, value);\n        }\n\n        let stop_time = Instant::now() + std::time::Duration::from_secs(5);\n        while stop_time \u003e Instant::now() {\n            for async_event in tor_controller.wait_async_events()?.iter() {\n                match async_event {\n                    AsyncEvent::Unknown { lines } =\u003e {\n                        println!(\"Unknown: {}\", lines.join(\"\\n\"));\n                    }\n                    AsyncEvent::StatusClient {\n                        severity,\n                        action,\n                        arguments,\n                    } =\u003e {\n                        println!(\"STATUS_CLIENT severity={}, action={}\", severity, action);\n                        for (key, value) in arguments.iter() {\n                            println!(\" {}='{}'\", key, value);\n                        }\n                    }\n                    AsyncEvent::HsDesc { action, hs_address } =\u003e {\n                        println!(\n                            \"HS_DESC action={}, hsaddress={}\",\n                            action,\n                            hs_address.to_string()\n                        );\n                    }\n                }\n            }\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":92,"address":[3697360,3697564],"length":1,"stats":{"Line":3}},{"line":95,"address":[3697502,3697384],"length":1,"stats":{"Line":6}},{"line":99,"address":[3699063,3697584,3699146],"length":1,"stats":{"Line":3}},{"line":100,"address":[3697606],"length":1,"stats":{"Line":6}},{"line":102,"address":[3697849],"length":1,"stats":{"Line":0}},{"line":103,"address":[3698185,3697813,3699129,3697958],"length":1,"stats":{"Line":6}},{"line":105,"address":[3698137],"length":1,"stats":{"Line":0}},{"line":110,"address":[3698761],"length":1,"stats":{"Line":3}},{"line":111,"address":[3698406],"length":1,"stats":{"Line":3}},{"line":112,"address":[3698436],"length":1,"stats":{"Line":3}},{"line":114,"address":[3698581],"length":1,"stats":{"Line":3}},{"line":115,"address":[3698633],"length":1,"stats":{"Line":3}},{"line":116,"address":[3698697],"length":1,"stats":{"Line":3}},{"line":122,"address":[3699184,3699842,3699813],"length":1,"stats":{"Line":3}},{"line":123,"address":[3699213],"length":1,"stats":{"Line":3}},{"line":125,"address":[3699317,3699258],"length":1,"stats":{"Line":6}},{"line":129,"address":[3699597,3699332,3699777],"length":1,"stats":{"Line":3}},{"line":132,"address":[3699558],"length":1,"stats":{"Line":0}},{"line":134,"address":[3699652,3699760],"length":1,"stats":{"Line":6}},{"line":137,"address":[3699680],"length":1,"stats":{"Line":3}},{"line":142,"address":[3701583,3699856,3703887],"length":1,"stats":{"Line":3}},{"line":143,"address":[3699911],"length":1,"stats":{"Line":3}},{"line":144,"address":[3700047],"length":1,"stats":{"Line":0}},{"line":148,"address":[3699936],"length":1,"stats":{"Line":3}},{"line":149,"address":[3700002,3700182],"length":1,"stats":{"Line":6}},{"line":150,"address":[3700295,3700396],"length":1,"stats":{"Line":6}},{"line":151,"address":[3700455],"length":1,"stats":{"Line":3}},{"line":154,"address":[3700574],"length":1,"stats":{"Line":3}},{"line":155,"address":[3700671],"length":1,"stats":{"Line":3}},{"line":159,"address":[3700788],"length":1,"stats":{"Line":3}},{"line":160,"address":[3700936,3701108,3701063,3700815],"length":1,"stats":{"Line":12}},{"line":162,"address":[3700837],"length":1,"stats":{"Line":3}},{"line":164,"address":[3701188,3701636],"length":1,"stats":{"Line":6}},{"line":165,"address":[3701698],"length":1,"stats":{"Line":3}},{"line":169,"address":[3701815],"length":1,"stats":{"Line":3}},{"line":170,"address":[3701912],"length":1,"stats":{"Line":3}},{"line":173,"address":[3702026,3702091,3702313],"length":1,"stats":{"Line":9}},{"line":174,"address":[3702197,3702149],"length":1,"stats":{"Line":6}},{"line":176,"address":[3702075],"length":1,"stats":{"Line":3}},{"line":179,"address":[3702185,3702318],"length":1,"stats":{"Line":6}},{"line":182,"address":[3701372],"length":1,"stats":{"Line":3}},{"line":183,"address":[3701250],"length":1,"stats":{"Line":3}},{"line":184,"address":[3701281],"length":1,"stats":{"Line":3}},{"line":185,"address":[3701340],"length":1,"stats":{"Line":3}},{"line":189,"address":[3702514],"length":1,"stats":{"Line":2}},{"line":190,"address":[3702816,3702702],"length":1,"stats":{"Line":4}},{"line":191,"address":[3702878],"length":1,"stats":{"Line":2}},{"line":194,"address":[3702977],"length":1,"stats":{"Line":2}},{"line":195,"address":[3703074],"length":1,"stats":{"Line":2}},{"line":199,"address":[3703157],"length":1,"stats":{"Line":2}},{"line":200,"address":[3703357],"length":1,"stats":{"Line":2}},{"line":201,"address":[3703276],"length":1,"stats":{"Line":2}},{"line":208,"address":[3703619],"length":1,"stats":{"Line":0}},{"line":209,"address":[3703665],"length":1,"stats":{"Line":0}},{"line":211,"address":[3703736],"length":1,"stats":{"Line":0}},{"line":214,"address":[3703904,3704821],"length":1,"stats":{"Line":3}},{"line":215,"address":[3704062,3703934],"length":1,"stats":{"Line":3}},{"line":216,"address":[3704043],"length":1,"stats":{"Line":3}},{"line":218,"address":[3704234,3704157,3704489],"length":1,"stats":{"Line":9}},{"line":219,"address":[3704513,3704533],"length":1,"stats":{"Line":6}},{"line":222,"address":[3704381],"length":1,"stats":{"Line":3}},{"line":226,"address":[3704848],"length":1,"stats":{"Line":3}},{"line":227,"address":[3704877,3705400],"length":1,"stats":{"Line":6}},{"line":228,"address":[3704889,3705140],"length":1,"stats":{"Line":3}},{"line":231,"address":[3705112],"length":1,"stats":{"Line":0}},{"line":233,"address":[3705226],"length":1,"stats":{"Line":3}},{"line":234,"address":[3705279],"length":1,"stats":{"Line":2}},{"line":235,"address":[3705307],"length":1,"stats":{"Line":3}},{"line":241,"address":[3705424],"length":1,"stats":{"Line":3}},{"line":242,"address":[3705579,3705446],"length":1,"stats":{"Line":4}},{"line":244,"address":[3705551],"length":1,"stats":{"Line":1}},{"line":245,"address":[3705544],"length":1,"stats":{"Line":3}},{"line":258,"address":[3706607,3707046,3705616],"length":1,"stats":{"Line":3}},{"line":259,"address":[3705709],"length":1,"stats":{"Line":3}},{"line":260,"address":[3705805],"length":1,"stats":{"Line":0}},{"line":261,"address":[3705772],"length":1,"stats":{"Line":0}},{"line":264,"address":[3707059,3705729,3705887,3706054],"length":1,"stats":{"Line":3}},{"line":266,"address":[3706129,3706274,3706028],"length":1,"stats":{"Line":9}},{"line":267,"address":[3706786,3706621],"length":1,"stats":{"Line":3}},{"line":269,"address":[3706242,3706424],"length":1,"stats":{"Line":6}},{"line":271,"address":[3706464,3706551],"length":1,"stats":{"Line":6}},{"line":276,"address":[1662366,1661728],"length":1,"stats":{"Line":1}},{"line":277,"address":[1661800],"length":1,"stats":{"Line":1}},{"line":278,"address":[1661976],"length":1,"stats":{"Line":0}},{"line":279,"address":[1661949],"length":1,"stats":{"Line":0}},{"line":282,"address":[1661824,1662034],"length":1,"stats":{"Line":1}},{"line":284,"address":[1662332,1662254],"length":1,"stats":{"Line":2}},{"line":288,"address":[3707072,3707711],"length":1,"stats":{"Line":3}},{"line":289,"address":[3707144],"length":1,"stats":{"Line":3}},{"line":290,"address":[3707321],"length":1,"stats":{"Line":0}},{"line":291,"address":[3707294],"length":1,"stats":{"Line":0}},{"line":294,"address":[3707168,3707379],"length":1,"stats":{"Line":3}},{"line":296,"address":[3707599,3707677],"length":1,"stats":{"Line":6}},{"line":300,"address":[3707744,3708224],"length":1,"stats":{"Line":3}},{"line":301,"address":[3707816,3707925],"length":1,"stats":{"Line":3}},{"line":303,"address":[3708118,3708193],"length":1,"stats":{"Line":6}},{"line":307,"address":[3708256,3708895],"length":1,"stats":{"Line":3}},{"line":308,"address":[3708328],"length":1,"stats":{"Line":3}},{"line":309,"address":[3708505],"length":1,"stats":{"Line":0}},{"line":310,"address":[3708478],"length":1,"stats":{"Line":0}},{"line":313,"address":[3708563,3708352],"length":1,"stats":{"Line":3}},{"line":315,"address":[3708783,3708861],"length":1,"stats":{"Line":6}},{"line":319,"address":[3710242,3708928,3711902],"length":1,"stats":{"Line":3}},{"line":328,"address":[3709300,3711915,3709090],"length":1,"stats":{"Line":3}},{"line":331,"address":[3709264,3709321],"length":1,"stats":{"Line":5}},{"line":332,"address":[3709337,3709427],"length":1,"stats":{"Line":4}},{"line":334,"address":[3709475,3709356],"length":1,"stats":{"Line":2}},{"line":338,"address":[3709456],"length":1,"stats":{"Line":3}},{"line":339,"address":[3709509],"length":1,"stats":{"Line":3}},{"line":340,"address":[3709527,3709602],"length":1,"stats":{"Line":4}},{"line":342,"address":[3709519],"length":1,"stats":{"Line":3}},{"line":343,"address":[3709617],"length":1,"stats":{"Line":0}},{"line":345,"address":[3709609],"length":1,"stats":{"Line":3}},{"line":346,"address":[3709663],"length":1,"stats":{"Line":2}},{"line":348,"address":[3709655],"length":1,"stats":{"Line":3}},{"line":349,"address":[3709709],"length":1,"stats":{"Line":0}},{"line":351,"address":[3709701],"length":1,"stats":{"Line":3}},{"line":352,"address":[3709765],"length":1,"stats":{"Line":0}},{"line":355,"address":[3709802,3709742],"length":1,"stats":{"Line":6}},{"line":356,"address":[3709808,3709870,3709998],"length":1,"stats":{"Line":4}},{"line":360,"address":[3710251,3709837],"length":1,"stats":{"Line":3}},{"line":361,"address":[3710397],"length":1,"stats":{"Line":0}},{"line":365,"address":[3710371,3710510],"length":1,"stats":{"Line":5}},{"line":366,"address":[3710846],"length":1,"stats":{"Line":2}},{"line":368,"address":[3710998],"length":1,"stats":{"Line":1}},{"line":371,"address":[3710964,3711103],"length":1,"stats":{"Line":5}},{"line":372,"address":[3711135,3711198],"length":1,"stats":{"Line":4}},{"line":373,"address":[3711446,3711331],"length":1,"stats":{"Line":2}},{"line":378,"address":[3711700,3711156],"length":1,"stats":{"Line":6}},{"line":380,"address":[3711827,3711740],"length":1,"stats":{"Line":6}},{"line":384,"address":[3711920,3712211],"length":1,"stats":{"Line":1}},{"line":385,"address":[3712015],"length":1,"stats":{"Line":1}},{"line":387,"address":[3712105,3712180],"length":1,"stats":{"Line":2}},{"line":391,"address":[3713765,3713418,3712240],"length":1,"stats":{"Line":2}},{"line":398,"address":[3712314,3712423,3713750],"length":1,"stats":{"Line":4}},{"line":401,"address":[3712613,3712673],"length":1,"stats":{"Line":4}},{"line":404,"address":[3712702,3712817],"length":1,"stats":{"Line":2}},{"line":406,"address":[3713058],"length":1,"stats":{"Line":2}},{"line":407,"address":[3713299],"length":1,"stats":{"Line":0}},{"line":410,"address":[3713241],"length":1,"stats":{"Line":2}},{"line":411,"address":[3713453],"length":1,"stats":{"Line":0}},{"line":415,"address":[3713427,3713516],"length":1,"stats":{"Line":4}},{"line":417,"address":[3713637,3713556],"length":1,"stats":{"Line":4}},{"line":421,"address":[3714099,3713808],"length":1,"stats":{"Line":1}},{"line":425,"address":[3713903],"length":1,"stats":{"Line":1}},{"line":427,"address":[3713993,3714068],"length":1,"stats":{"Line":2}},{"line":434,"address":[3714128],"length":1,"stats":{"Line":3}},{"line":435,"address":[3714169,3714349],"length":1,"stats":{"Line":3}},{"line":437,"address":[3714337],"length":1,"stats":{"Line":3}},{"line":438,"address":[3714416],"length":1,"stats":{"Line":3}},{"line":439,"address":[3714432],"length":1,"stats":{"Line":0}},{"line":444,"address":[1671231,1671554,1669872],"length":1,"stats":{"Line":1}},{"line":445,"address":[1670128,1669913],"length":1,"stats":{"Line":1}},{"line":447,"address":[1670116],"length":1,"stats":{"Line":1}},{"line":449,"address":[1670200],"length":1,"stats":{"Line":1}},{"line":450,"address":[1670497,1670403,1670624,1671508,1670674],"length":1,"stats":{"Line":5}},{"line":451,"address":[1670901,1670722],"length":1,"stats":{"Line":2}},{"line":452,"address":[1671488,1671019],"length":1,"stats":{"Line":2}},{"line":453,"address":[1671258,1671040],"length":1,"stats":{"Line":2}},{"line":454,"address":[1670964,1671079],"length":1,"stats":{"Line":0}},{"line":457,"address":[1670747],"length":1,"stats":{"Line":1}},{"line":459,"address":[1670215],"length":1,"stats":{"Line":0}},{"line":463,"address":[3714624],"length":1,"stats":{"Line":3}},{"line":464,"address":[3714845,3714665],"length":1,"stats":{"Line":3}},{"line":466,"address":[3714833],"length":1,"stats":{"Line":3}},{"line":467,"address":[3714912],"length":1,"stats":{"Line":3}},{"line":468,"address":[3714928],"length":1,"stats":{"Line":0}},{"line":472,"address":[3715120],"length":1,"stats":{"Line":3}},{"line":473,"address":[3715341,3715161],"length":1,"stats":{"Line":3}},{"line":475,"address":[3715329],"length":1,"stats":{"Line":3}},{"line":476,"address":[3715408],"length":1,"stats":{"Line":3}},{"line":477,"address":[3715424],"length":1,"stats":{"Line":0}},{"line":481,"address":[3717064,3717397,3715616],"length":1,"stats":{"Line":3}},{"line":482,"address":[3715657,3715882],"length":1,"stats":{"Line":3}},{"line":484,"address":[3715867],"length":1,"stats":{"Line":3}},{"line":486,"address":[3715947],"length":1,"stats":{"Line":3}},{"line":487,"address":[3716273,3716168,3716408,3716462,3717351],"length":1,"stats":{"Line":15}},{"line":488,"address":[3716689,3716510],"length":1,"stats":{"Line":6}},{"line":489,"address":[3716778,3717311],"length":1,"stats":{"Line":6}},{"line":490,"address":[3716799,3717091],"length":1,"stats":{"Line":6}},{"line":492,"address":[3716752,3716844],"length":1,"stats":{"Line":6}},{"line":493,"address":[3716869],"length":1,"stats":{"Line":0}},{"line":498,"address":[3716535],"length":1,"stats":{"Line":3}},{"line":500,"address":[3715974],"length":1,"stats":{"Line":0}},{"line":504,"address":[3717440,3720545,3722530],"length":1,"stats":{"Line":3}},{"line":513,"address":[3717924,3717578],"length":1,"stats":{"Line":3}},{"line":515,"address":[3717878],"length":1,"stats":{"Line":3}},{"line":516,"address":[3717898],"length":1,"stats":{"Line":3}},{"line":518,"address":[3717906],"length":1,"stats":{"Line":3}},{"line":520,"address":[3718419,3717984,3718284,3718473],"length":1,"stats":{"Line":12}},{"line":521,"address":[3718513,3719405],"length":1,"stats":{"Line":6}},{"line":522,"address":[3719570,3719503],"length":1,"stats":{"Line":6}},{"line":523,"address":[3720562],"length":1,"stats":{"Line":0}},{"line":524,"address":[3719603],"length":1,"stats":{"Line":0}},{"line":527,"address":[3719641,3719728,3719576],"length":1,"stats":{"Line":6}},{"line":528,"address":[3719678,3719764],"length":1,"stats":{"Line":6}},{"line":529,"address":[3719812,3720037],"length":1,"stats":{"Line":6}},{"line":530,"address":[3719901],"length":1,"stats":{"Line":3}},{"line":532,"address":[3720287],"length":1,"stats":{"Line":0}},{"line":538,"address":[3720464,3720238,3720504,3720101,3720679,3719537],"length":1,"stats":{"Line":9}},{"line":539,"address":[3720777,3720844],"length":1,"stats":{"Line":2}},{"line":540,"address":[3721767],"length":1,"stats":{"Line":0}},{"line":541,"address":[3720877],"length":1,"stats":{"Line":0}},{"line":544,"address":[3720915,3720850,3720996],"length":1,"stats":{"Line":2}},{"line":545,"address":[3720952,3721027],"length":1,"stats":{"Line":2}},{"line":546,"address":[3721075,3721352,3721231,3721410],"length":1,"stats":{"Line":3}},{"line":548,"address":[3721149],"length":1,"stats":{"Line":1}},{"line":550,"address":[3721523],"length":1,"stats":{"Line":0}},{"line":556,"address":[3721884,3720811],"length":1,"stats":{"Line":6}},{"line":557,"address":[3721962,3722323],"length":1,"stats":{"Line":4}},{"line":558,"address":[3722386],"length":1,"stats":{"Line":0}},{"line":559,"address":[3722351],"length":1,"stats":{"Line":0}},{"line":562,"address":[3721929,3721996],"length":1,"stats":{"Line":6}},{"line":563,"address":[3722131],"length":1,"stats":{"Line":0}},{"line":570,"address":[3718062],"length":1,"stats":{"Line":0}},{"line":573,"address":[3718547],"length":1,"stats":{"Line":3}},{"line":574,"address":[3718807,3718578],"length":1,"stats":{"Line":4}},{"line":575,"address":[3719244],"length":1,"stats":{"Line":0}},{"line":576,"address":[3718816],"length":1,"stats":{"Line":0}},{"line":579,"address":[3718552,3718614],"length":1,"stats":{"Line":2}},{"line":580,"address":[3718682],"length":1,"stats":{"Line":0}},{"line":581,"address":[3718647],"length":1,"stats":{"Line":0}},{"line":585,"address":[3718620],"length":1,"stats":{"Line":3}},{"line":586,"address":[3718876],"length":1,"stats":{"Line":3}},{"line":587,"address":[3719035],"length":1,"stats":{"Line":0}},{"line":588,"address":[3718846],"length":1,"stats":{"Line":0}},{"line":593,"address":[3722576],"length":1,"stats":{"Line":1}},{"line":594,"address":[3722788,3722608],"length":1,"stats":{"Line":1}},{"line":596,"address":[3722776],"length":1,"stats":{"Line":1}},{"line":597,"address":[3722853],"length":1,"stats":{"Line":1}},{"line":598,"address":[3722868],"length":1,"stats":{"Line":1}},{"line":604,"address":[3723056,3725411,3725472],"length":1,"stats":{"Line":3}},{"line":605,"address":[3723266,3723087],"length":1,"stats":{"Line":3}},{"line":606,"address":[3723386,3723231,3723587],"length":1,"stats":{"Line":9}},{"line":607,"address":[3723631,3723785],"length":1,"stats":{"Line":6}},{"line":608,"address":[3723858],"length":1,"stats":{"Line":3}},{"line":609,"address":[3723913,3725428],"length":1,"stats":{"Line":0}},{"line":612,"address":[3723893,3723948],"length":1,"stats":{"Line":6}},{"line":613,"address":[3723999],"length":1,"stats":{"Line":3}},{"line":614,"address":[3724402,3724062,3724150],"length":1,"stats":{"Line":9}},{"line":615,"address":[3724476,3724578,3724418],"length":1,"stats":{"Line":9}},{"line":616,"address":[3724666],"length":1,"stats":{"Line":0}},{"line":623,"address":[3724626,3724834],"length":1,"stats":{"Line":6}},{"line":624,"address":[3725178,3724946,3725023],"length":1,"stats":{"Line":9}},{"line":625,"address":[3724991],"length":1,"stats":{"Line":3}},{"line":627,"address":[3725183],"length":1,"stats":{"Line":0}},{"line":634,"address":[3724302],"length":1,"stats":{"Line":3}},{"line":637,"address":[3723662],"length":1,"stats":{"Line":0}},{"line":638,"address":[3723560],"length":1,"stats":{"Line":0}},{"line":642,"address":[3726306,3725488],"length":1,"stats":{"Line":2}},{"line":643,"address":[3725513,3725678],"length":1,"stats":{"Line":2}},{"line":644,"address":[3725789,3725960,3725649],"length":1,"stats":{"Line":6}},{"line":645,"address":[3726001,3726153],"length":1,"stats":{"Line":4}},{"line":646,"address":[3726217],"length":1,"stats":{"Line":2}},{"line":649,"address":[3726023],"length":1,"stats":{"Line":0}},{"line":650,"address":[3725933],"length":1,"stats":{"Line":0}},{"line":654,"address":[3726336],"length":1,"stats":{"Line":2}},{"line":661,"address":[3726384,3726573],"length":1,"stats":{"Line":2}},{"line":664,"address":[3726782,3726556],"length":1,"stats":{"Line":4}},{"line":665,"address":[3726638],"length":1,"stats":{"Line":0}},{"line":670,"address":[3726864],"length":1,"stats":{"Line":1}},{"line":671,"address":[3727085,3726896],"length":1,"stats":{"Line":1}},{"line":674,"address":[3727294,3727068],"length":1,"stats":{"Line":2}},{"line":675,"address":[3727150],"length":1,"stats":{"Line":0}}],"covered":210,"coverable":264},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_process.rs"],"content":"// standard\nuse std::default::Default;\nuse std::fs;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader, Read, Write};\nuse std::net::SocketAddr;\nuse std::ops::Drop;\nuse std::path::Path;\nuse std::process;\nuse std::process::{Child, ChildStdout, Command, Stdio};\nuse std::str::FromStr;\nuse std::string::ToString;\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\n\n// extern crates\nuse data_encoding::HEXUPPER;\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse sha1::{Digest, Sha1};\n\n// internal crates\nuse crate::tor_crypto::generate_password;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"failed to read control port file\")]\n    ControlPortFileReadFailed(#[source] std::io::Error),\n\n    #[error(\"provided control port file '{0}' larger than expected ({1} bytes)\")]\n    ControlPortFileTooLarge(String, u64),\n\n    #[error(\"failed to parse '{0}' as control port file\")]\n    ControlPortFileContentsInvalid(String),\n\n    #[error(\"provided tor bin path '{0}' must be an absolute path\")]\n    TorBinPathNotAbsolute(String),\n\n    #[error(\"provided data directory '{0}' must be an absolute path\")]\n    TorDataDirectoryPathNotAbsolute(String),\n\n    #[error(\"failed to create data directory\")]\n    DataDirectoryCreationFailed(#[source] std::io::Error),\n\n    #[error(\"file exists in provided data directory path '{0}'\")]\n    DataDirectoryPathExistsAsFile(String),\n\n    #[error(\"failed to create default_torrc file\")]\n    DefaultTorrcFileCreationFailed(#[source] std::io::Error),\n\n    #[error(\"failed to write default_torrc file\")]\n    DefaultTorrcFileWriteFailed(#[source] std::io::Error),\n\n    #[error(\"failed to create torrc file\")]\n    TorrcFileCreationFailed(#[source] std::io::Error),\n\n    #[error(\"failed to remove control_port file\")]\n    ControlPortFileDeleteFailed(#[source] std::io::Error),\n\n    #[error(\"failed to start legacy tor process\")]\n    LegacyTorProcessStartFailed(#[source] std::io::Error),\n\n    #[error(\"failed to read control addr from control_file '{0}'\")]\n    ControlPortFileMissing(String),\n\n    #[error(\"unable to take legacy tor process stdout\")]\n    LegacyTorProcessStdoutTakeFailed(),\n\n    #[error(\"failed to spawn tor process stdout read thread\")]\n    StdoutReadThreadSpawnFailed(#[source] std::io::Error),\n}\n\nfn read_control_port_file(control_port_file: \u0026Path) -\u003e Result\u003cSocketAddr, Error\u003e {\n    // open file\n    let mut file = File::open(control_port_file).map_err(Error::ControlPortFileReadFailed)?;\n\n    // bail if the file is larger than expected\n    let metadata = file.metadata().map_err(Error::ControlPortFileReadFailed)?;\n    if metadata.len() \u003e= 1024 {\n        return Err(Error::ControlPortFileTooLarge(\n            format!(\"{}\", control_port_file.display()),\n            metadata.len(),\n        ));\n    }\n\n    // read contents to string\n    let mut contents = String::new();\n    file.read_to_string(\u0026mut contents)\n        .map_err(Error::ControlPortFileReadFailed)?;\n\n    if contents.starts_with(\"PORT=\") {\n        let addr_string = \u0026contents.trim_end()[\"PORT=\".len()..];\n        if let Ok(addr) = SocketAddr::from_str(addr_string) {\n            return Ok(addr);\n        }\n    }\n    Err(Error::ControlPortFileContentsInvalid(format!(\n        \"{}\",\n        control_port_file.display()\n    )))\n}\n\n// Encapsulates the tor daemon process\npub(crate) struct LegacyTorProcess {\n    control_addr: SocketAddr,\n    process: Child,\n    password: String,\n    // stdout data\n    stdout_lines: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n}\n\nimpl LegacyTorProcess {\n    const S2K_RFC2440_SPECIFIER_LEN: usize = 9;\n\n    fn hash_tor_password_with_salt(\n        salt: \u0026[u8; Self::S2K_RFC2440_SPECIFIER_LEN],\n        password: \u0026str,\n    ) -\u003e String {\n        assert_eq!(salt[Self::S2K_RFC2440_SPECIFIER_LEN - 1], 0x60);\n\n        // tor-specific rfc 2440 constants\n        const EXPBIAS: u8 = 6u8;\n        const C: u8 = 0x60; // salt[S2K_RFC2440_SPECIFIER_LEN - 1]\n        const COUNT: usize = (16usize + ((C \u0026 15u8) as usize)) \u003c\u003c ((C \u003e\u003e 4) + EXPBIAS);\n\n        // squash together our hash input\n        let mut input: Vec\u003cu8\u003e = Default::default();\n        // append salt (sans the 'C' constant')\n        input.extend_from_slice(\u0026salt[0..Self::S2K_RFC2440_SPECIFIER_LEN - 1]);\n        // append password bytes\n        input.extend_from_slice(password.as_bytes());\n\n        let input = input.as_slice();\n        let input_len = input.len();\n\n        let mut sha1 = Sha1::new();\n        let mut count = COUNT;\n        while count \u003e 0 {\n            if count \u003e input_len {\n                sha1.update(input);\n                count -= input_len;\n            } else {\n                sha1.update(\u0026input[0..count]);\n                break;\n            }\n        }\n\n        let key = sha1.finalize();\n\n        let mut hash = \"16:\".to_string();\n        HEXUPPER.encode_append(salt, \u0026mut hash);\n        HEXUPPER.encode_append(\u0026key, \u0026mut hash);\n\n        hash\n    }\n\n    fn hash_tor_password(password: \u0026str) -\u003e String {\n        let mut salt = [0x00u8; Self::S2K_RFC2440_SPECIFIER_LEN];\n        OsRng.fill_bytes(\u0026mut salt);\n        salt[Self::S2K_RFC2440_SPECIFIER_LEN - 1] = 0x60u8;\n\n        Self::hash_tor_password_with_salt(\u0026salt, password)\n    }\n\n    pub fn get_control_addr(\u0026self) -\u003e \u0026SocketAddr {\n        \u0026self.control_addr\n    }\n\n    pub fn get_password(\u0026self) -\u003e \u0026String {\n        \u0026self.password\n    }\n\n    pub fn new(tor_bin_path: \u0026Path, data_directory: \u0026Path) -\u003e Result\u003cLegacyTorProcess, Error\u003e {\n        if tor_bin_path.is_relative() {\n            return Err(Error::TorBinPathNotAbsolute(format!(\n                \"{}\",\n                tor_bin_path.display()\n            )));\n        }\n        if data_directory.is_relative() {\n            return Err(Error::TorDataDirectoryPathNotAbsolute(format!(\n                \"{}\",\n                data_directory.display()\n            )));\n        }\n\n        // create data directory if it doesn't exist\n        if !data_directory.exists() {\n            fs::create_dir_all(data_directory).map_err(Error::DataDirectoryCreationFailed)?;\n        } else if data_directory.is_file() {\n            return Err(Error::DataDirectoryPathExistsAsFile(format!(\n                \"{}\",\n                data_directory.display()\n            )));\n        }\n\n        // construct paths to torrc files\n        let default_torrc = data_directory.join(\"default_torrc\");\n        let torrc = data_directory.join(\"torrc\");\n        let control_port_file = data_directory.join(\"control_port\");\n\n        // TODO: should we nuke the existing torrc between runs? Do we want\n        // users setting custom nonsense in there?\n        // construct default torrc\n        //  - daemon determines socks port\n        //  - minimize writes to disk\n        //  - start with network disabled by default\n        if !default_torrc.exists() {\n            const DEFAULT_TORRC_CONTENT: \u0026str = \"SocksPort auto\\n\\\n            AvoidDiskWrites 1\\n\\\n            DisableNetwork 1\\n\";\n\n            let mut default_torrc_file =\n                File::create(\u0026default_torrc).map_err(Error::DefaultTorrcFileCreationFailed)?;\n            default_torrc_file\n                .write_all(DEFAULT_TORRC_CONTENT.as_bytes())\n                .map_err(Error::DefaultTorrcFileWriteFailed)?;\n        }\n\n        // create empty torrc for user\n        if !torrc.exists() {\n            let _ = File::create(\u0026torrc).map_err(Error::TorrcFileCreationFailed)?;\n        }\n\n        // remove any existing control_port_file\n        if control_port_file.exists() {\n            fs::remove_file(\u0026control_port_file).map_err(Error::ControlPortFileDeleteFailed)?;\n        }\n\n        const CONTROL_PORT_PASSWORD_LENGTH: usize = 32usize;\n        let password = generate_password(CONTROL_PORT_PASSWORD_LENGTH);\n        let password_hash = Self::hash_tor_password(\u0026password);\n\n        let mut process = Command::new(tor_bin_path.as_os_str())\n            .stdout(Stdio::piped())\n            .stdin(Stdio::null())\n            .stderr(Stdio::null())\n            // set working directory to data directory\n            .current_dir(data_directory)\n            // point to our above written torrc file\n            .arg(\"--defaults-torrc\")\n            .arg(default_torrc)\n            // location of torrc\n            .arg(\"--torrc-file\")\n            .arg(torrc)\n            // root data directory\n            .arg(\"DataDirectory\")\n            .arg(data_directory)\n            // daemon will assign us a port, and we will\n            // read it from the control port file\n            .arg(\"ControlPort\")\n            .arg(\"auto\")\n            // control port file destination\n            .arg(\"ControlPortWriteToFile\")\n            .arg(control_port_file.clone())\n            // use password authentication to prevent other apps\n            // from modifying our daemon's settings\n            .arg(\"HashedControlPassword\")\n            .arg(password_hash)\n            // tor process will shut down after this process shuts down\n            // to avoid orphaned tor daemon\n            .arg(\"__OwningControllerProcess\")\n            .arg(process::id().to_string())\n            .spawn()\n            .map_err(Error::LegacyTorProcessStartFailed)?;\n\n        let mut control_addr = None;\n        let start = Instant::now();\n\n        // try and read the control port from the control port file\n        // or abort after 5 seconds\n        // TODO: make this timeout configurable?\n        while control_addr.is_none() \u0026\u0026 start.elapsed() \u003c Duration::from_secs(5) {\n            if control_port_file.exists() {\n                control_addr = Some(read_control_port_file(control_port_file.as_path())?);\n                fs::remove_file(\u0026control_port_file).map_err(Error::ControlPortFileDeleteFailed)?;\n            }\n        }\n\n        let control_addr = match control_addr {\n            Some(control_addr) =\u003e control_addr,\n            None =\u003e {\n                return Err(Error::ControlPortFileMissing(format!(\n                    \"{}\",\n                    control_port_file.display()\n                )))\n            }\n        };\n\n        let stdout_lines: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e = Default::default();\n\n        {\n            let stdout_lines = Arc::downgrade(\u0026stdout_lines);\n            let stdout = BufReader::new(match process.stdout.take() {\n                Some(stdout) =\u003e stdout,\n                None =\u003e return Err(Error::LegacyTorProcessStdoutTakeFailed()),\n            });\n\n            std::thread::Builder::new()\n                .name(\"tor_stdout_reader\".to_string())\n                .spawn(move || {\n                    LegacyTorProcess::read_stdout_task(\u0026stdout_lines, stdout);\n                })\n                .map_err(Error::StdoutReadThreadSpawnFailed)?;\n        }\n\n        Ok(LegacyTorProcess {\n            control_addr,\n            process,\n            password,\n            stdout_lines,\n        })\n    }\n\n    fn read_stdout_task(\n        stdout_lines: \u0026std::sync::Weak\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n        mut stdout: BufReader\u003cChildStdout\u003e,\n    ) {\n        while let Some(stdout_lines) = stdout_lines.upgrade() {\n            let mut line = String::default();\n            // read line\n            if stdout.read_line(\u0026mut line).is_ok() {\n                // remove trailing '\\n'\n                line.pop();\n                // then acquire the lock on the line buffer\n                let mut stdout_lines = match stdout_lines.lock() {\n                    Ok(stdout_lines) =\u003e stdout_lines,\n                    Err(_) =\u003e unreachable!(),\n                };\n                stdout_lines.push(line);\n            }\n        }\n    }\n\n    pub fn wait_log_lines(\u0026mut self) -\u003e Vec\u003cString\u003e {\n        let mut lines = match self.stdout_lines.lock() {\n            Ok(lines) =\u003e lines,\n            Err(_) =\u003e unreachable!(),\n        };\n        std::mem::take(\u0026mut lines)\n    }\n}\n\nimpl Drop for LegacyTorProcess {\n    fn drop(\u0026mut self) {\n        let _ = self.process.kill();\n    }\n}\n\n#[test]\nfn test_password_hash() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let salt1: [u8; LegacyTorProcess::S2K_RFC2440_SPECIFIER_LEN] = [\n        0xbeu8, 0x2au8, 0x25u8, 0x1du8, 0xe6u8, 0x2cu8, 0xb2u8, 0x7au8, 0x60u8,\n    ];\n    let hash1 = LegacyTorProcess::hash_tor_password_with_salt(\u0026salt1, \"abcdefghijklmnopqrstuvwxyz\");\n    assert_eq!(\n        hash1,\n        \"16:BE2A251DE62CB27A60AC9178A937990E8ED0AB662FA82A5C7DE3EBB23A\"\n    );\n\n    let salt2: [u8; LegacyTorProcess::S2K_RFC2440_SPECIFIER_LEN] = [\n        0x36u8, 0x73u8, 0x0eu8, 0xefu8, 0xd1u8, 0x8cu8, 0x60u8, 0xd6u8, 0x60u8,\n    ];\n    let hash2 = LegacyTorProcess::hash_tor_password_with_salt(\u0026salt2, \"password\");\n    assert_eq!(\n        hash2,\n        \"16:36730EEFD18C60D66052E7EA535438761C0928D316EEA56A190C99B50A\"\n    );\n\n    // ensure same password is hashed to different things\n    assert_ne!(\n        LegacyTorProcess::hash_tor_password(\"password\"),\n        LegacyTorProcess::hash_tor_password(\"password\")\n    );\n\n    Ok(())\n}\n","traces":[{"line":73,"address":[3221392,3223164,3223601],"length":1,"stats":{"Line":3}},{"line":75,"address":[3221599,3221447],"length":1,"stats":{"Line":3}},{"line":78,"address":[3221940,3221561,3223596,3221733],"length":1,"stats":{"Line":6}},{"line":79,"address":[3221917,3222009],"length":1,"stats":{"Line":6}},{"line":80,"address":[3223481],"length":1,"stats":{"Line":0}},{"line":81,"address":[3223299,3223189,3222048],"length":1,"stats":{"Line":0}},{"line":82,"address":[3223412],"length":1,"stats":{"Line":0}},{"line":87,"address":[3222025],"length":1,"stats":{"Line":3}},{"line":88,"address":[3222177,3223143,3222339,3222074],"length":1,"stats":{"Line":6}},{"line":89,"address":[3222307],"length":1,"stats":{"Line":0}},{"line":91,"address":[3222378,3222282],"length":1,"stats":{"Line":6}},{"line":92,"address":[3222459],"length":1,"stats":{"Line":3}},{"line":93,"address":[3222616],"length":1,"stats":{"Line":3}},{"line":94,"address":[3222737],"length":1,"stats":{"Line":3}},{"line":97,"address":[3222933],"length":1,"stats":{"Line":0}},{"line":99,"address":[3222431,3222823],"length":1,"stats":{"Line":0}},{"line":115,"address":[3225046,3223616,3224970],"length":1,"stats":{"Line":3}},{"line":119,"address":[3223684],"length":1,"stats":{"Line":3}},{"line":127,"address":[3223800],"length":1,"stats":{"Line":3}},{"line":129,"address":[3223913,3223822],"length":1,"stats":{"Line":6}},{"line":131,"address":[3223981],"length":1,"stats":{"Line":3}},{"line":133,"address":[3224000],"length":1,"stats":{"Line":3}},{"line":134,"address":[3224071],"length":1,"stats":{"Line":3}},{"line":136,"address":[3224079],"length":1,"stats":{"Line":3}},{"line":137,"address":[3224098],"length":1,"stats":{"Line":3}},{"line":138,"address":[3225021,3224110],"length":1,"stats":{"Line":6}},{"line":139,"address":[3224272],"length":1,"stats":{"Line":3}},{"line":140,"address":[3224466],"length":1,"stats":{"Line":3}},{"line":141,"address":[3224984,3225026],"length":1,"stats":{"Line":3}},{"line":143,"address":[3224296,3224498],"length":1,"stats":{"Line":6}},{"line":148,"address":[3224125],"length":1,"stats":{"Line":3}},{"line":150,"address":[3224522],"length":1,"stats":{"Line":3}},{"line":151,"address":[3224557],"length":1,"stats":{"Line":3}},{"line":152,"address":[3224797,3224723],"length":1,"stats":{"Line":3}},{"line":154,"address":[3224905],"length":1,"stats":{"Line":3}},{"line":157,"address":[3225072],"length":1,"stats":{"Line":3}},{"line":158,"address":[3225106],"length":1,"stats":{"Line":3}},{"line":159,"address":[3225123],"length":1,"stats":{"Line":3}},{"line":160,"address":[3225159],"length":1,"stats":{"Line":3}},{"line":162,"address":[3225164],"length":1,"stats":{"Line":3}},{"line":165,"address":[3225184],"length":1,"stats":{"Line":3}},{"line":166,"address":[3225192],"length":1,"stats":{"Line":3}},{"line":169,"address":[3225200],"length":1,"stats":{"Line":3}},{"line":173,"address":[3225216,3227683,3232523],"length":1,"stats":{"Line":3}},{"line":174,"address":[3225325],"length":1,"stats":{"Line":3}},{"line":175,"address":[3225547],"length":1,"stats":{"Line":0}},{"line":177,"address":[3225432],"length":1,"stats":{"Line":0}},{"line":180,"address":[3225398],"length":1,"stats":{"Line":3}},{"line":181,"address":[3225934],"length":1,"stats":{"Line":0}},{"line":183,"address":[3225819],"length":1,"stats":{"Line":0}},{"line":188,"address":[3225785],"length":1,"stats":{"Line":3}},{"line":189,"address":[3226409,3226172],"length":1,"stats":{"Line":3}},{"line":190,"address":[3226273],"length":1,"stats":{"Line":0}},{"line":191,"address":[3226641],"length":1,"stats":{"Line":0}},{"line":193,"address":[3226526],"length":1,"stats":{"Line":0}},{"line":198,"address":[3226303],"length":1,"stats":{"Line":3}},{"line":199,"address":[3226373,3226920],"length":1,"stats":{"Line":6}},{"line":200,"address":[3226928],"length":1,"stats":{"Line":3}},{"line":208,"address":[3227006,3227086],"length":1,"stats":{"Line":6}},{"line":213,"address":[3227174,3227113,3227692,3227321],"length":1,"stats":{"Line":6}},{"line":215,"address":[3227433,3227616],"length":1,"stats":{"Line":3}},{"line":216,"address":[3227426],"length":1,"stats":{"Line":3}},{"line":217,"address":[3227584],"length":1,"stats":{"Line":0}},{"line":221,"address":[3227148,3227710],"length":1,"stats":{"Line":6}},{"line":222,"address":[3227737,3227798],"length":1,"stats":{"Line":6}},{"line":226,"address":[3227772,3228017],"length":1,"stats":{"Line":6}},{"line":227,"address":[3228067,3232418],"length":1,"stats":{"Line":0}},{"line":231,"address":[3228057],"length":1,"stats":{"Line":3}},{"line":232,"address":[3228355,3228264],"length":1,"stats":{"Line":6}},{"line":234,"address":[3228386,3229460,3228561,3228693,3229213,3229704,3228956,3229327,3228631,3228842,3228466],"length":1,"stats":{"Line":30}},{"line":235,"address":[3228485],"length":1,"stats":{"Line":3}},{"line":236,"address":[3228588],"length":1,"stats":{"Line":3}},{"line":237,"address":[3228650],"length":1,"stats":{"Line":3}},{"line":242,"address":[3228802],"length":1,"stats":{"Line":3}},{"line":245,"address":[3228916],"length":1,"stats":{"Line":3}},{"line":255,"address":[3229198],"length":1,"stats":{"Line":3}},{"line":259,"address":[3229287],"length":1,"stats":{"Line":3}},{"line":263,"address":[3229393],"length":1,"stats":{"Line":3}},{"line":265,"address":[3232377,3229645,3228506],"length":1,"stats":{"Line":3}},{"line":267,"address":[3229777],"length":1,"stats":{"Line":3}},{"line":268,"address":[3229787],"length":1,"stats":{"Line":3}},{"line":273,"address":[3229843,3229917],"length":1,"stats":{"Line":6}},{"line":274,"address":[3230066,3231880],"length":1,"stats":{"Line":6}},{"line":275,"address":[3231912,3232342,3232121],"length":1,"stats":{"Line":3}},{"line":276,"address":[3232090,3225293,3232186],"length":1,"stats":{"Line":9}},{"line":280,"address":[3229882],"length":1,"stats":{"Line":3}},{"line":281,"address":[3230111],"length":1,"stats":{"Line":3}},{"line":283,"address":[3230309],"length":1,"stats":{"Line":0}},{"line":285,"address":[3230172,3230094],"length":1,"stats":{"Line":0}},{"line":290,"address":[3230544,3230143],"length":1,"stats":{"Line":6}},{"line":293,"address":[3230625,3230552],"length":1,"stats":{"Line":6}},{"line":294,"address":[3230641,3230841,3230706],"length":1,"stats":{"Line":9}},{"line":295,"address":[3230827],"length":1,"stats":{"Line":3}},{"line":296,"address":[3230746],"length":1,"stats":{"Line":0}},{"line":299,"address":[3231155,3231024,3230903,3231750,3231402],"length":1,"stats":{"Line":9}},{"line":300,"address":[3231804,3231067,3230951],"length":1,"stats":{"Line":6}},{"line":301,"address":[3231075],"length":1,"stats":{"Line":6}},{"line":302,"address":[3772521],"length":1,"stats":{"Line":3}},{"line":304,"address":[3231343],"length":1,"stats":{"Line":3}},{"line":307,"address":[3231527],"length":1,"stats":{"Line":3}},{"line":309,"address":[3231455],"length":1,"stats":{"Line":3}},{"line":310,"address":[3231487],"length":1,"stats":{"Line":3}},{"line":311,"address":[3231519],"length":1,"stats":{"Line":3}},{"line":315,"address":[3233351,3233461,3232560],"length":1,"stats":{"Line":3}},{"line":319,"address":[3232585,3232660],"length":1,"stats":{"Line":6}},{"line":320,"address":[3232706],"length":1,"stats":{"Line":3}},{"line":322,"address":[3232860,3232778],"length":1,"stats":{"Line":6}},{"line":324,"address":[3232994],"length":1,"stats":{"Line":3}},{"line":326,"address":[3233001],"length":1,"stats":{"Line":3}},{"line":327,"address":[3233057],"length":1,"stats":{"Line":3}},{"line":330,"address":[3233152,3233236],"length":1,"stats":{"Line":6}},{"line":335,"address":[3233488,3233740],"length":1,"stats":{"Line":2}},{"line":336,"address":[3233520],"length":1,"stats":{"Line":2}},{"line":337,"address":[3233552],"length":1,"stats":{"Line":2}},{"line":340,"address":[3233708,3233629],"length":1,"stats":{"Line":4}},{"line":345,"address":[3219952],"length":1,"stats":{"Line":3}},{"line":346,"address":[3219961],"length":1,"stats":{"Line":3}}],"covered":99,"coverable":117},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","legacy_tor_version.rs"],"content":"// standard\nuse std::cmp::Ordering;\nuse std::option::Option;\nuse std::str::FromStr;\nuse std::string::ToString;\n\n/// `LegacyTorVersion`-specific error type\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"{}\", .0)]\n    ParseError(String),\n}\n\n/// Type representing a legacy c-tor daemon's version number. This version conforms c-tor's [version-spec](https://spec.torproject.org/version-spec.htm).\n#[derive(Clone)]\npub struct LegacyTorVersion {\n    pub(crate) major: u32,\n    pub(crate) minor: u32,\n    pub(crate) micro: u32,\n    pub(crate) patch_level: u32,\n    pub(crate) status_tag: Option\u003cString\u003e,\n}\n\nimpl LegacyTorVersion {\n    fn status_tag_pattern_is_match(status_tag: \u0026str) -\u003e bool {\n        if status_tag.is_empty() {\n            return false;\n        }\n\n        for c in status_tag.chars() {\n            if c.is_whitespace() {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// Construct a new `LegacyTorVersion` object.\n    pub fn new(\n        major: u32,\n        minor: u32,\n        micro: u32,\n        patch_level: Option\u003cu32\u003e,\n        status_tag: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cLegacyTorVersion, Error\u003e {\n        let status_tag = if let Some(status_tag) = status_tag {\n            if Self::status_tag_pattern_is_match(status_tag) {\n                Some(status_tag.to_string())\n            } else {\n                return Err(Error::ParseError(\n                    \"tor version status tag may not be empty or contain white-space\".to_string(),\n                ));\n            }\n        } else {\n            None\n        };\n\n        Ok(LegacyTorVersion {\n            major,\n            minor,\n            micro,\n            patch_level: patch_level.unwrap_or(0u32),\n            status_tag,\n        })\n    }\n}\n\nimpl FromStr for LegacyTorVersion {\n    type Err = Error;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cLegacyTorVersion, Self::Err\u003e {\n        // MAJOR.MINOR.MICRO[.PATCHLEVEL][-STATUS_TAG][ (EXTRA_INFO)]*\n        let mut tokens = s.split(' ');\n        let (major, minor, micro, patch_level, status_tag) =\n            if let Some(version_status_tag) = tokens.next() {\n                let mut tokens = version_status_tag.split('-');\n                let (major, minor, micro, patch_level) = if let Some(version) = tokens.next() {\n                    let mut tokens = version.split('.');\n                    let major: u32 = if let Some(major) = tokens.next() {\n                        match major.parse() {\n                            Ok(major) =\u003e major,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MAJOR portion of tor version\",\n                                    major\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MAJOR portion of tor version\".to_string(),\n                        ));\n                    };\n                    let minor: u32 = if let Some(minor) = tokens.next() {\n                        match minor.parse() {\n                            Ok(minor) =\u003e minor,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MINOR portion of tor version\",\n                                    minor\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MINOR portion of tor version\".to_string(),\n                        ));\n                    };\n                    let micro: u32 = if let Some(micro) = tokens.next() {\n                        match micro.parse() {\n                            Ok(micro) =\u003e micro,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as MICRO portion of tor version\",\n                                    micro\n                                )))\n                            }\n                        }\n                    } else {\n                        return Err(Error::ParseError(\n                            \"failed to find MICRO portion of tor version\".to_string(),\n                        ));\n                    };\n                    let patch_level: u32 = if let Some(patch_level) = tokens.next() {\n                        match patch_level.parse() {\n                            Ok(patch_level) =\u003e patch_level,\n                            Err(_) =\u003e {\n                                return Err(Error::ParseError(format!(\n                                    \"failed to parse '{}' as PATCHLEVEL portion of tor version\",\n                                    patch_level\n                                )))\n                            }\n                        }\n                    } else {\n                        0u32\n                    };\n                    (major, minor, micro, patch_level)\n                } else {\n                    // if there were '-' the previous next() would have returned the enire string\n                    unreachable!();\n                };\n                let status_tag = tokens.next().map(|status_tag| status_tag.to_string());\n\n                (major, minor, micro, patch_level, status_tag)\n            } else {\n                // if there were no ' ' character the previou snext() would have returned the enire string\n                unreachable!();\n            };\n        for extra_info in tokens {\n            if !extra_info.starts_with('(') || !extra_info.ends_with(')') {\n                return Err(Error::ParseError(format!(\n                    \"failed to parse '{}' as [ (EXTRA_INFO)]\",\n                    extra_info\n                )));\n            }\n        }\n        LegacyTorVersion::new(\n            major,\n            minor,\n            micro,\n            Some(patch_level),\n            status_tag.as_deref(),\n        )\n    }\n}\n\nimpl ToString for LegacyTorVersion {\n    fn to_string(\u0026self) -\u003e String {\n        match \u0026self.status_tag {\n            Some(status_tag) =\u003e format!(\n                \"{}.{}.{}.{}-{}\",\n                self.major, self.minor, self.micro, self.patch_level, status_tag\n            ),\n            None =\u003e format!(\n                \"{}.{}.{}.{}\",\n                self.major, self.minor, self.micro, self.patch_level\n            ),\n        }\n    }\n}\n\nimpl PartialEq for LegacyTorVersion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.major == other.major\n            \u0026\u0026 self.minor == other.minor\n            \u0026\u0026 self.micro == other.micro\n            \u0026\u0026 self.patch_level == other.patch_level\n            \u0026\u0026 self.status_tag == other.status_tag\n    }\n}\n\nimpl PartialOrd for LegacyTorVersion {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        if let Some(order) = self.major.partial_cmp(\u0026other.major) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.minor.partial_cmp(\u0026other.minor) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.micro.partial_cmp(\u0026other.micro) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        if let Some(order) = self.patch_level.partial_cmp(\u0026other.patch_level) {\n            if order != Ordering::Equal {\n                return Some(order);\n            }\n        }\n\n        // version-spect.txt *does* say that we should compare tags lexicgraphically\n        // if all of the version numbers are the same when comparing, but we are\n        // going to diverge here and say we can only compare tags for equality.\n        //\n        // In practice we will be comparing tor daemon tags against tagless (stable)\n        // versions so this shouldn't be an issue\n\n        if self.status_tag == other.status_tag {\n            return Some(Ordering::Equal);\n        }\n\n        None\n    }\n}\n\n#[test]\nfn test_version() -\u003e anyhow::Result\u003c()\u003e {\n    assert!(LegacyTorVersion::from_str(\"1.2.3\")? == LegacyTorVersion::new(1, 2, 3, None, None)?);\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4\")? == LegacyTorVersion::new(1, 2, 3, Some(4), None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3-test\")?\n            == LegacyTorVersion::new(1, 2, 3, None, Some(\"test\"))?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-test\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"test\"))?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3 (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, None, None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4 (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), None)?\n    );\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-tag (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"tag\"))?\n    );\n\n    assert!(\n        LegacyTorVersion::from_str(\"1.2.3.4-tag (extra_info) (extra_info)\")?\n            == LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"tag\"))?\n    );\n\n    assert!(LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"spaced tag\")).is_err());\n    assert!(LegacyTorVersion::new(1, 2, 3, Some(4), Some(\"\" /* empty tag */)).is_err());\n    assert!(LegacyTorVersion::from_str(\"\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2-foo\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo bar\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo bar (extra_info)\").is_err());\n    assert!(LegacyTorVersion::from_str(\"1.2.3.4-foo (extra_info) badtext\").is_err());\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(1, 0, 0, Some(0), None)?\n    );\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(0, 1, 0, Some(0), None)?\n    );\n    assert!(\n        LegacyTorVersion::new(0, 0, 0, Some(0), None)?\n            \u003c LegacyTorVersion::new(0, 0, 1, Some(0), None)?\n    );\n\n    // ensure status tags make comparison between equal versions (apart from\n    // tags) unknowable\n    let zero_version = LegacyTorVersion::new(0, 0, 0, Some(0), None)?;\n    let zero_version_tag = LegacyTorVersion::new(0, 0, 0, Some(0), Some(\"tag\"))?;\n\n    assert!(!(zero_version \u003c zero_version_tag));\n    assert!(!(zero_version \u003c= zero_version_tag));\n    assert!(!(zero_version \u003e zero_version_tag));\n    assert!(!(zero_version \u003e= zero_version_tag));\n\n    Ok(())\n}\n","traces":[{"line":25,"address":[3662080],"length":1,"stats":{"Line":1}},{"line":26,"address":[3662103],"length":1,"stats":{"Line":1}},{"line":27,"address":[3662150],"length":1,"stats":{"Line":1}},{"line":30,"address":[3662203,3662121,3662157],"length":1,"stats":{"Line":3}},{"line":31,"address":[3662211],"length":1,"stats":{"Line":1}},{"line":32,"address":[3662236],"length":1,"stats":{"Line":1}},{"line":35,"address":[3662196],"length":1,"stats":{"Line":1}},{"line":39,"address":[3662256,3662874],"length":1,"stats":{"Line":3}},{"line":46,"address":[3662450,3662634,3662358],"length":1,"stats":{"Line":7}},{"line":47,"address":[3662420],"length":1,"stats":{"Line":1}},{"line":48,"address":[3662594],"length":1,"stats":{"Line":1}},{"line":50,"address":[3662485],"length":1,"stats":{"Line":1}},{"line":51,"address":[3662455],"length":1,"stats":{"Line":1}},{"line":55,"address":[3662435],"length":1,"stats":{"Line":3}},{"line":58,"address":[3662775],"length":1,"stats":{"Line":3}},{"line":62,"address":[3662657],"length":1,"stats":{"Line":3}},{"line":63,"address":[3662736],"length":1,"stats":{"Line":3}},{"line":71,"address":[3662896,3666690],"length":1,"stats":{"Line":3}},{"line":73,"address":[3662929],"length":1,"stats":{"Line":3}},{"line":74,"address":[3662945],"length":1,"stats":{"Line":3}},{"line":76,"address":[3663033],"length":1,"stats":{"Line":3}},{"line":77,"address":[3665575,3663052,3663144],"length":1,"stats":{"Line":9}},{"line":78,"address":[3663176],"length":1,"stats":{"Line":3}},{"line":79,"address":[3663287,3663195],"length":1,"stats":{"Line":6}},{"line":80,"address":[3663319],"length":1,"stats":{"Line":3}},{"line":81,"address":[3663524],"length":1,"stats":{"Line":3}},{"line":83,"address":[3663704],"length":1,"stats":{"Line":1}},{"line":90,"address":[3663422],"length":1,"stats":{"Line":0}},{"line":91,"address":[3663392],"length":1,"stats":{"Line":0}},{"line":94,"address":[3663893,3663542],"length":1,"stats":{"Line":6}},{"line":95,"address":[3663925],"length":1,"stats":{"Line":3}},{"line":96,"address":[3664130],"length":1,"stats":{"Line":3}},{"line":98,"address":[3664310],"length":1,"stats":{"Line":0}},{"line":105,"address":[3664028],"length":1,"stats":{"Line":0}},{"line":106,"address":[3663998],"length":1,"stats":{"Line":0}},{"line":109,"address":[3664148,3664499],"length":1,"stats":{"Line":6}},{"line":110,"address":[3664531],"length":1,"stats":{"Line":3}},{"line":111,"address":[3664736],"length":1,"stats":{"Line":3}},{"line":113,"address":[3664916],"length":1,"stats":{"Line":0}},{"line":120,"address":[3664634],"length":1,"stats":{"Line":1}},{"line":121,"address":[3664604],"length":1,"stats":{"Line":1}},{"line":124,"address":[3664754,3665105,3665214,3665240],"length":1,"stats":{"Line":10}},{"line":125,"address":[3665137],"length":1,"stats":{"Line":3}},{"line":126,"address":[3665219],"length":1,"stats":{"Line":3}},{"line":128,"address":[3665339],"length":1,"stats":{"Line":0}},{"line":135,"address":[3665203],"length":1,"stats":{"Line":1}},{"line":137,"address":[3665540],"length":1,"stats":{"Line":3}},{"line":142,"address":[3593478,3593456],"length":1,"stats":{"Line":5}},{"line":144,"address":[3665700],"length":1,"stats":{"Line":3}},{"line":149,"address":[3665864,3666025,3666186],"length":1,"stats":{"Line":7}},{"line":150,"address":[3666443,3666218,3666341],"length":1,"stats":{"Line":3}},{"line":151,"address":[3666496],"length":1,"stats":{"Line":1}},{"line":161,"address":[3666139],"length":1,"stats":{"Line":3}},{"line":162,"address":[3666157],"length":1,"stats":{"Line":3}},{"line":168,"address":[3666720],"length":1,"stats":{"Line":0}},{"line":169,"address":[3666749],"length":1,"stats":{"Line":0}},{"line":170,"address":[3667526,3667441,3667351,3667611,3667781],"length":1,"stats":{"Line":0}},{"line":174,"address":[3666957,3667124,3666872,3667042,3666787],"length":1,"stats":{"Line":0}},{"line":183,"address":[3668016],"length":1,"stats":{"Line":1}},{"line":184,"address":[3668039],"length":1,"stats":{"Line":1}},{"line":185,"address":[3668063],"length":1,"stats":{"Line":1}},{"line":186,"address":[3668080],"length":1,"stats":{"Line":1}},{"line":187,"address":[3668097],"length":1,"stats":{"Line":1}},{"line":188,"address":[3668114],"length":1,"stats":{"Line":1}},{"line":193,"address":[3668144],"length":1,"stats":{"Line":3}},{"line":194,"address":[3668168],"length":1,"stats":{"Line":3}},{"line":195,"address":[3668215],"length":1,"stats":{"Line":3}},{"line":196,"address":[3668288],"length":1,"stats":{"Line":1}},{"line":200,"address":[3668247,3668305],"length":1,"stats":{"Line":6}},{"line":201,"address":[3668313],"length":1,"stats":{"Line":3}},{"line":202,"address":[3668386],"length":1,"stats":{"Line":1}},{"line":206,"address":[3668396,3668345],"length":1,"stats":{"Line":6}},{"line":207,"address":[3668404],"length":1,"stats":{"Line":3}},{"line":208,"address":[3668477],"length":1,"stats":{"Line":1}},{"line":212,"address":[3668436,3668490],"length":1,"stats":{"Line":6}},{"line":213,"address":[3668498],"length":1,"stats":{"Line":3}},{"line":214,"address":[3668542],"length":1,"stats":{"Line":2}},{"line":225,"address":[3668530],"length":1,"stats":{"Line":1}},{"line":226,"address":[3668565],"length":1,"stats":{"Line":0}},{"line":229,"address":[3668555],"length":1,"stats":{"Line":1}}],"covered":68,"coverable":80},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","lib.rs"],"content":"#![doc = include_str!(\"../README.md\")]\n\n/// Implementation of an in-process [`arti-client`](https://crates.io/crates/arti-client)-based `TorProvider`\n#[cfg(feature = \"arti-client-tor-provider\")]\npub mod arti_client_tor_client;\n#[cfg(feature = \"legacy-tor-provider\")]\n/// Censorship circumvention configuration for pluggable-transports and bridge settings\npub mod censorship_circumvention;\n/// Implementation of an out-of-process legacy [c-tor daemon](https://gitlab.torproject.org/tpo/core/tor)-based `TorProvider`\n#[cfg(feature = \"legacy-tor-provider\")]\npub mod legacy_tor_client;\n#[cfg(feature = \"legacy-tor-provider\")]\nmod legacy_tor_control_stream;\n#[cfg(feature = \"legacy-tor-provider\")]\nmod legacy_tor_controller;\n#[cfg(feature = \"legacy-tor-provider\")]\nmod legacy_tor_process;\n/// Legacy c-tor daemon version.\n#[cfg(feature = \"legacy-tor-provider\")]\npub mod legacy_tor_version;\n/// Implementation of a local, in-process, mock `TorProvider` for testing.\n#[cfg(feature = \"mock-tor-provider\")]\npub mod mock_tor_client;\n#[cfg(feature = \"legacy-tor-provider\")]\n/// Proxy settings\npub mod proxy;\n/// Tor-specific cryptographic primitives, operations, and conversion functions.\npub mod tor_crypto;\n/// Traits and types for connecting to the Tor Network.\npub mod tor_provider;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","mock_tor_client.rs"],"content":"// standard\nuse std::collections::BTreeMap;\nuse std::net::{SocketAddr, TcpListener, TcpStream};\nuse std::sync::{atomic, Arc, Mutex};\n\n// internal crates\nuse crate::tor_crypto::*;\nuse crate::tor_provider;\nuse crate::tor_provider::*;\n\n\n/// [`MockTorClient`]-specific error type\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"client not bootstrapped\")]\n    ClientNotBootstrapped(),\n\n    #[error(\"client already bootstrapped\")]\n    ClientAlreadyBootstrapped(),\n\n    #[error(\"onion service not found: {}\", .0)]\n    OnionServiceNotFound(OnionAddr),\n\n    #[error(\"onion service not published: {}\", .0)]\n    OnionServiceNotPublished(OnionAddr),\n\n    #[error(\"onion service requires onion auth\")]\n    OnionServiceRequiresOnionAuth(),\n\n    #[error(\"provided onion auth key invalid\")]\n    OnionServiceAuthInvalid(),\n\n    #[error(\"unable to bind TCP listener\")]\n    TcpListenerBindFailed(#[source] std::io::Error),\n\n    #[error(\"unable to get TCP listener's local adress\")]\n    TcpListenerLocalAddrFailed(#[source] std::io::Error),\n\n    #[error(\"unable to connect to {}\", .0)]\n    ConnectFailed(TargetAddr),\n\n    #[error(\"not implemented\")]\n    NotImplemented(),\n}\n\nimpl From\u003cError\u003e for crate::tor_provider::Error {\n    fn from(error: Error) -\u003e Self {\n        crate::tor_provider::Error::Generic(error.to_string())\n    }\n}\n\nstruct MockTorNetwork {\n    onion_services: Option\u003cBTreeMap\u003cOnionAddr, (Vec\u003cX25519PublicKey\u003e, SocketAddr)\u003e\u003e,\n}\n\nimpl MockTorNetwork {\n    const fn new() -\u003e MockTorNetwork {\n        MockTorNetwork {\n            onion_services: None,\n        }\n    }\n\n    fn connect_to_onion(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        virt_port: u16,\n        client_auth: Option\u003c\u0026X25519PublicKey\u003e,\n    ) -\u003e Result\u003cOnionStream, Error\u003e {\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id.clone(), virt_port));\n\n        match \u0026mut self.onion_services {\n            Some(onion_services) =\u003e {\n                if let Some((client_auth_keys, socket_addr)) = onion_services.get(\u0026onion_addr) {\n                    match (client_auth_keys.len(), client_auth) {\n                        (0, None) =\u003e (),\n                        (_, None) =\u003e return Err(Error::OnionServiceRequiresOnionAuth()),\n                        (0, Some(_)) =\u003e return Err(Error::OnionServiceAuthInvalid()),\n                        (_, Some(client_auth)) =\u003e {\n                            if !client_auth_keys.contains(client_auth) {\n                                return Err(Error::OnionServiceAuthInvalid());\n                            }\n                        }\n                    }\n\n                    if let Ok(stream) = TcpStream::connect(socket_addr) {\n                        Ok(OnionStream {\n                            stream,\n                            local_addr: None,\n                            peer_addr: Some(TargetAddr::OnionService(onion_addr)),\n                        })\n                    } else {\n                        Err(Error::OnionServiceNotFound(onion_addr))\n                    }\n                } else {\n                    Err(Error::OnionServiceNotPublished(onion_addr))\n                }\n            }\n            None =\u003e Err(Error::OnionServiceNotPublished(onion_addr)),\n        }\n    }\n\n    fn start_onion(\n        \u0026mut self,\n        service_id: V3OnionServiceId,\n        virt_port: u16,\n        client_auth_keys: Vec\u003cX25519PublicKey\u003e,\n        address: SocketAddr,\n    ) {\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id, virt_port));\n        match \u0026mut self.onion_services {\n            Some(onion_services) =\u003e {\n                onion_services.insert(onion_addr, (client_auth_keys, address));\n            }\n            None =\u003e {\n                let mut onion_services = BTreeMap::new();\n                onion_services.insert(onion_addr, (client_auth_keys, address));\n                self.onion_services = Some(onion_services);\n            }\n        }\n    }\n\n    fn stop_onion(\u0026mut self, onion_addr: \u0026OnionAddr) {\n        if let Some(onion_services) = \u0026mut self.onion_services {\n            onion_services.remove(onion_addr);\n        }\n    }\n}\n\nstatic MOCK_TOR_NETWORK: Mutex\u003cMockTorNetwork\u003e = Mutex::new(MockTorNetwork::new());\n\n/// A mock `TorProvider` implementation for testing.\n///\n/// `MockTorClient` implements the [`TorProvider`] trait. It creates a fake, in-process Tor Network using local socekts and listeners. No actual traffic ever leaves the local host.\n///\n/// Mock onion-services can be created, connected to, and communiccated with. Connecting to clearnet targets always succeeds by connecting to single local endpoint, but will never send any traffic to connecting clients.\npub struct MockTorClient {\n    events: Vec\u003cTorEvent\u003e,\n    bootstrapped: bool,\n    client_auth_keys: BTreeMap\u003cV3OnionServiceId, X25519PublicKey\u003e,\n    onion_services: Vec\u003c(OnionAddr, Arc\u003catomic::AtomicBool\u003e)\u003e,\n    loopback: TcpListener,\n}\n\nimpl MockTorClient {\n    /// Construt a new `MockTorClient`.\n    pub fn new() -\u003e MockTorClient {\n        let mut events: Vec\u003cTorEvent\u003e = Default::default();\n        let line = \"[notice] MockTorClient running\".to_string();\n        events.push(TorEvent::LogReceived { line });\n\n        let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n        let listener = TcpListener::bind(socket_addr).expect(\"tcplistener bind failed\");\n\n        MockTorClient {\n            events,\n            bootstrapped: false,\n            client_auth_keys: Default::default(),\n            onion_services: Default::default(),\n            loopback: listener,\n        }\n    }\n}\n\nimpl Default for MockTorClient {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl TorProvider for MockTorClient {\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, tor_provider::Error\u003e {\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                let mut i = 0;\n                while i \u003c self.onion_services.len() {\n                    // remove onion services with no active listeners\n                    if !self.onion_services[i].1.load(atomic::Ordering::Relaxed) {\n                        let entry = self.onion_services.swap_remove(i);\n                        let onion_addr = entry.0;\n                        mock_tor_network.stop_onion(\u0026onion_addr);\n                    } else {\n                        i += 1;\n                    }\n                }\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n\n        Ok(std::mem::take(\u0026mut self.events))\n    }\n\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        if self.bootstrapped {\n            Err(Error::ClientAlreadyBootstrapped())?\n        } else {\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 0u32,\n                tag: \"start\".to_string(),\n                summary: \"bootstrapping started\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 50u32,\n                tag: \"middle\".to_string(),\n                summary: \"bootstrapping continues\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapStatus {\n                progress: 100u32,\n                tag: \"finished\".to_string(),\n                summary: \"bootstrapping completed\".to_string(),\n            });\n            self.events.push(TorEvent::BootstrapComplete);\n            self.bootstrapped = true;\n            Ok(())\n        }\n    }\n\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        let client_auth_public = X25519PublicKey::from_private_key(client_auth);\n        if let Some(key) = self.client_auth_keys.get_mut(service_id) {\n            *key = client_auth_public;\n        } else {\n            self.client_auth_keys\n                .insert(service_id.clone(), client_auth_public);\n        }\n        Ok(())\n    }\n\n    fn remove_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n    ) -\u003e Result\u003c(), tor_provider::Error\u003e {\n        self.client_auth_keys.remove(service_id);\n        Ok(())\n    }\n\n    fn connect(\n        \u0026mut self,\n        target: TargetAddr,\n        _circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, tor_provider::Error\u003e {\n        let (service_id, virt_port) = match target {\n            TargetAddr::OnionService(OnionAddr::V3(OnionAddrV3 {\n                service_id,\n                virt_port,\n            })) =\u003e (service_id, virt_port),\n            target_address =\u003e {\n                if let Ok(stream) = TcpStream::connect(\n                    self.loopback\n                        .local_addr()\n                        .expect(\"loopback local_addr failed\"),\n                ) {\n                    return Ok(OnionStream {\n                        stream,\n                        local_addr: None,\n                        peer_addr: Some(target_address),\n                    });\n                } else {\n                    return Err(Error::ConnectFailed(target_address).into());\n                }\n            }\n        };\n        let client_auth = self.client_auth_keys.get(\u0026service_id);\n\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                Ok(mock_tor_network.connect_to_onion(\u0026service_id, virt_port, client_auth)?)\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n    }\n\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorized_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, tor_provider::Error\u003e {\n        // convert inputs to relevant types\n        let service_id = V3OnionServiceId::from_private_key(private_key);\n        let onion_addr = OnionAddr::V3(OnionAddrV3::new(service_id.clone(), virt_port));\n        let authorized_clients: Vec\u003cX25519PublicKey\u003e = match authorized_clients {\n            Some(keys) =\u003e keys.into(),\n            None =\u003e Default::default(),\n        };\n\n        // try to bind to a local address, let OS pick our port\n        let socket_addr = SocketAddr::from(([127, 0, 0, 1], 0u16));\n        let listener = TcpListener::bind(socket_addr).map_err(Error::TcpListenerBindFailed)?;\n        let socket_addr = listener\n            .local_addr()\n            .map_err(Error::TcpListenerLocalAddrFailed)?;\n\n        // register the onion service with the mock tor network\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e mock_tor_network.start_onion(\n                service_id.clone(),\n                virt_port,\n                authorized_clients,\n                socket_addr,\n            ),\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n\n        // init flag for signaling when listener goes out of scope so we can tear down onion service\n        let is_active = Arc::new(atomic::AtomicBool::new(true));\n        self.onion_services\n            .push((onion_addr.clone(), Arc::clone(\u0026is_active)));\n\n        // onion service published event\n        self.events\n            .push(TorEvent::OnionServicePublished { service_id });\n\n\n        Ok(OnionListener::new(listener, onion_addr, is_active, |is_active| {\n            is_active.store(false, atomic::Ordering::Relaxed);\n        }))\n    }\n\n    fn generate_token(\u0026mut self) -\u003e CircuitToken {\n        0usize\n    }\n\n    fn release_token(\u0026mut self, _token: CircuitToken) {}\n}\n\nimpl Drop for MockTorClient {\n    fn drop(\u0026mut self) {\n        // remove all our onion services\n        match MOCK_TOR_NETWORK.lock() {\n            Ok(mut mock_tor_network) =\u003e {\n                for entry in self.onion_services.iter() {\n                    let onion_addr = \u0026entry.0;\n                    mock_tor_network.stop_onion(onion_addr);\n                }\n            }\n            Err(_) =\u003e unreachable!(\"another thread panicked while holding mock tor network's lock\"),\n        }\n    }\n}\n","traces":[{"line":47,"address":[3672789,3672656],"length":1,"stats":{"Line":1}},{"line":48,"address":[3672675,3672733],"length":1,"stats":{"Line":2}},{"line":57,"address":[3504816],"length":1,"stats":{"Line":0}},{"line":63,"address":[3504864],"length":1,"stats":{"Line":2}},{"line":69,"address":[3504943],"length":1,"stats":{"Line":2}},{"line":71,"address":[3505022],"length":1,"stats":{"Line":2}},{"line":72,"address":[3505106],"length":1,"stats":{"Line":2}},{"line":73,"address":[3505181,3505979,3505341,3505118],"length":1,"stats":{"Line":6}},{"line":74,"address":[3505346,3505504,3505227],"length":1,"stats":{"Line":6}},{"line":76,"address":[3505460],"length":1,"stats":{"Line":1}},{"line":77,"address":[3505520],"length":1,"stats":{"Line":0}},{"line":78,"address":[3505569],"length":1,"stats":{"Line":2}},{"line":79,"address":[3505590],"length":1,"stats":{"Line":2}},{"line":80,"address":[3505626],"length":1,"stats":{"Line":0}},{"line":85,"address":[3505411,3505670,3505859],"length":1,"stats":{"Line":6}},{"line":86,"address":[3505773],"length":1,"stats":{"Line":2}},{"line":88,"address":[3505696],"length":1,"stats":{"Line":2}},{"line":89,"address":[3505706],"length":1,"stats":{"Line":2}},{"line":92,"address":[3505861],"length":1,"stats":{"Line":0}},{"line":95,"address":[3505270],"length":1,"stats":{"Line":0}},{"line":98,"address":[3505028],"length":1,"stats":{"Line":0}},{"line":102,"address":[3506843,3506016,3506815],"length":1,"stats":{"Line":2}},{"line":109,"address":[3506057,3506141],"length":1,"stats":{"Line":4}},{"line":110,"address":[3506166],"length":1,"stats":{"Line":2}},{"line":111,"address":[3506209],"length":1,"stats":{"Line":2}},{"line":112,"address":[3506221,3506824],"length":1,"stats":{"Line":4}},{"line":115,"address":[3506172],"length":1,"stats":{"Line":2}},{"line":116,"address":[3506352,3506527],"length":1,"stats":{"Line":4}},{"line":117,"address":[3506551],"length":1,"stats":{"Line":2}},{"line":122,"address":[3506880],"length":1,"stats":{"Line":2}},{"line":123,"address":[3506904],"length":1,"stats":{"Line":2}},{"line":124,"address":[3506929],"length":1,"stats":{"Line":2}},{"line":146,"address":[3506960,3507693,3507662],"length":1,"stats":{"Line":2}},{"line":147,"address":[3506977],"length":1,"stats":{"Line":2}},{"line":148,"address":[3507007],"length":1,"stats":{"Line":2}},{"line":149,"address":[3507072],"length":1,"stats":{"Line":2}},{"line":151,"address":[3507118],"length":1,"stats":{"Line":2}},{"line":152,"address":[3507246],"length":1,"stats":{"Line":2}},{"line":157,"address":[3507392],"length":1,"stats":{"Line":2}},{"line":158,"address":[3507455],"length":1,"stats":{"Line":2}},{"line":165,"address":[3507728],"length":1,"stats":{"Line":1}},{"line":166,"address":[3507736],"length":1,"stats":{"Line":1}},{"line":171,"address":[3508439,3508543,3507760],"length":1,"stats":{"Line":2}},{"line":172,"address":[3507790],"length":1,"stats":{"Line":2}},{"line":173,"address":[3507816],"length":1,"stats":{"Line":2}},{"line":174,"address":[3507836],"length":1,"stats":{"Line":2}},{"line":175,"address":[3507845,3507857,3507935],"length":1,"stats":{"Line":6}},{"line":177,"address":[3508458,3507961,3508147],"length":1,"stats":{"Line":6}},{"line":178,"address":[3508214],"length":1,"stats":{"Line":0}},{"line":179,"address":[3508270],"length":1,"stats":{"Line":0}},{"line":180,"address":[3508334,3508410],"length":1,"stats":{"Line":0}},{"line":182,"address":[3508453,3508242,3508463],"length":1,"stats":{"Line":4}},{"line":189,"address":[3508048],"length":1,"stats":{"Line":2}},{"line":192,"address":[3508576,3509393],"length":1,"stats":{"Line":2}},{"line":193,"address":[3509465,3508606],"length":1,"stats":{"Line":2}},{"line":194,"address":[3509415,3508664,3509467],"length":1,"stats":{"Line":0}},{"line":196,"address":[3508794],"length":1,"stats":{"Line":2}},{"line":198,"address":[3508612],"length":1,"stats":{"Line":2}},{"line":199,"address":[3508637],"length":1,"stats":{"Line":2}},{"line":201,"address":[3508995],"length":1,"stats":{"Line":2}},{"line":203,"address":[3508894],"length":1,"stats":{"Line":2}},{"line":204,"address":[3508919],"length":1,"stats":{"Line":2}},{"line":206,"address":[3509196],"length":1,"stats":{"Line":2}},{"line":208,"address":[3509095],"length":1,"stats":{"Line":2}},{"line":209,"address":[3509120],"length":1,"stats":{"Line":2}},{"line":211,"address":[3509330],"length":1,"stats":{"Line":2}},{"line":212,"address":[3509362],"length":1,"stats":{"Line":2}},{"line":213,"address":[3509366],"length":1,"stats":{"Line":2}},{"line":217,"address":[3509536],"length":1,"stats":{"Line":2}},{"line":222,"address":[3509600],"length":1,"stats":{"Line":2}},{"line":223,"address":[3509710,3509621],"length":1,"stats":{"Line":2}},{"line":224,"address":[3509675],"length":1,"stats":{"Line":0}},{"line":226,"address":[3509722,3509747],"length":1,"stats":{"Line":4}},{"line":227,"address":[3509730],"length":1,"stats":{"Line":2}},{"line":229,"address":[3509781],"length":1,"stats":{"Line":2}},{"line":232,"address":[3509808],"length":1,"stats":{"Line":1}},{"line":236,"address":[3509831],"length":1,"stats":{"Line":1}},{"line":237,"address":[3509855],"length":1,"stats":{"Line":1}},{"line":240,"address":[3511128,3509888,3511949],"length":1,"stats":{"Line":2}},{"line":245,"address":[3510126,3509939],"length":1,"stats":{"Line":4}},{"line":246,"address":[3510054],"length":1,"stats":{"Line":2}},{"line":250,"address":[3510237],"length":1,"stats":{"Line":0}},{"line":252,"address":[3510300,3511262],"length":1,"stats":{"Line":0}},{"line":256,"address":[3511460],"length":1,"stats":{"Line":0}},{"line":258,"address":[3511386],"length":1,"stats":{"Line":0}},{"line":259,"address":[3511396],"length":1,"stats":{"Line":0}},{"line":262,"address":[3511785,3511551],"length":1,"stats":{"Line":0}},{"line":266,"address":[3510199,3510372],"length":1,"stats":{"Line":4}},{"line":268,"address":[3510380],"length":1,"stats":{"Line":2}},{"line":269,"address":[3510417],"length":1,"stats":{"Line":2}},{"line":270,"address":[3510449,3510872,3510537],"length":1,"stats":{"Line":5}},{"line":276,"address":[3514073,3512000,3513902],"length":1,"stats":{"Line":2}},{"line":283,"address":[3512076],"length":1,"stats":{"Line":2}},{"line":284,"address":[3512111],"length":1,"stats":{"Line":2}},{"line":285,"address":[3512185],"length":1,"stats":{"Line":2}},{"line":286,"address":[3512235],"length":1,"stats":{"Line":2}},{"line":287,"address":[3512211],"length":1,"stats":{"Line":2}},{"line":291,"address":[3512290],"length":1,"stats":{"Line":2}},{"line":292,"address":[3512459,3514071,3512662],"length":1,"stats":{"Line":2}},{"line":293,"address":[3512796,3513003,3512627],"length":1,"stats":{"Line":4}},{"line":295,"address":[3512939],"length":1,"stats":{"Line":0}},{"line":298,"address":[3512908,3513032],"length":1,"stats":{"Line":4}},{"line":299,"address":[3513043,3513218],"length":1,"stats":{"Line":4}},{"line":300,"address":[3513161],"length":1,"stats":{"Line":2}},{"line":302,"address":[3513178],"length":1,"stats":{"Line":2}},{"line":309,"address":[3513395,3513361],"length":1,"stats":{"Line":4}},{"line":310,"address":[3513657,3513480],"length":1,"stats":{"Line":4}},{"line":311,"address":[3513505,3513553],"length":1,"stats":{"Line":4}},{"line":314,"address":[3513747],"length":1,"stats":{"Line":2}},{"line":315,"address":[3513681],"length":1,"stats":{"Line":2}},{"line":318,"address":[3187440,3187547],"length":1,"stats":{"Line":4}},{"line":319,"address":[3187512,3187454],"length":1,"stats":{"Line":4}},{"line":323,"address":[3514112],"length":1,"stats":{"Line":0}},{"line":327,"address":[3514138,3514128],"length":1,"stats":{"Line":0}},{"line":331,"address":[3220000,3220523,3220452],"length":1,"stats":{"Line":2}},{"line":333,"address":[3220020],"length":1,"stats":{"Line":2}},{"line":334,"address":[3220051],"length":1,"stats":{"Line":2}},{"line":335,"address":[3220312,3220152,3220071],"length":1,"stats":{"Line":6}},{"line":336,"address":[3220333],"length":1,"stats":{"Line":2}},{"line":337,"address":[3220341,3220440],"length":1,"stats":{"Line":4}}],"covered":100,"coverable":120},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","proxy.rs"],"content":"// internal crates\nuse crate::tor_provider::TargetAddr;\n\n#[derive(thiserror::Error, Debug)]\n/// Error type for the proxy module\npub enum ProxyConfigError {\n    #[error(\"{0}\")]\n    /// An error returned when constructing a proxy configuration with invalid parameters\n    Generic(String),\n}\n\n#[derive(Clone, Debug)]\n/// Configuration for a SOCKS4 proxy\npub struct Socks4ProxyConfig {\n    pub(crate) address: TargetAddr,\n}\n\nimpl Socks4ProxyConfig {\n    /// Construct a new `Socks4ProxyConfig`. The `address` argument must not be a [`crate::tor_provider::TargetAddr::OnionService`] and its port must not be 0.\n    pub fn new(address: TargetAddr) -\u003e Result\u003cSelf, ProxyConfigError\u003e {\n        let port = match \u0026address {\n            TargetAddr::Socket(addr) =\u003e addr.port(),\n            TargetAddr::Domain(addr) =\u003e addr.port(),\n            TargetAddr::OnionService(_) =\u003e {\n                return Err(ProxyConfigError::Generic(\n                    \"proxy address may not be onion service\".to_string(),\n                ))\n            }\n        };\n        if port == 0 {\n            return Err(ProxyConfigError::Generic(\"proxy port not be 0\".to_string()));\n        }\n\n        Ok(Self { address })\n    }\n}\n\n#[derive(Clone, Debug)]\n/// Configuration for a SOCKS5 proxy\npub struct Socks5ProxyConfig {\n    pub(crate) address: TargetAddr,\n    pub(crate) username: Option\u003cString\u003e,\n    pub(crate) password: Option\u003cString\u003e,\n}\n\nimpl Socks5ProxyConfig {\n    /// Construct a new `Socks5ProxyConfig`. The `address` argument must not be a  [`crate::tor_provider::TargetAddr::OnionService`] and its port must not be 0. The `username` and `password` arguments, if present, must each be less than 256 bytes long.\n    pub fn new(\n        address: TargetAddr,\n        username: Option\u003cString\u003e,\n        password: Option\u003cString\u003e,\n    ) -\u003e Result\u003cSelf, ProxyConfigError\u003e {\n        let port = match \u0026address {\n            TargetAddr::Socket(addr) =\u003e addr.port(),\n            TargetAddr::Domain(addr) =\u003e addr.port(),\n            TargetAddr::OnionService(_) =\u003e {\n                return Err(ProxyConfigError::Generic(\n                    \"proxy address may not be onion service\".to_string(),\n                ))\n            }\n        };\n        if port == 0 {\n            return Err(ProxyConfigError::Generic(\"proxy port not be 0\".to_string()));\n        }\n\n        // username must be less than 255 bytes\n        if let Some(username) = \u0026username {\n            if username.len() \u003e 255 {\n                return Err(ProxyConfigError::Generic(\n                    \"socks5 username must be \u003c= 255 bytes\".to_string(),\n                ));\n            }\n        }\n        // password must be less than 255 bytes\n        if let Some(password) = \u0026password {\n            if password.len() \u003e 255 {\n                return Err(ProxyConfigError::Generic(\n                    \"socks5 password must be \u003c= 255 bytes\".to_string(),\n                ));\n            }\n        }\n\n        Ok(Self {\n            address,\n            username,\n            password,\n        })\n    }\n}\n\n#[derive(Clone, Debug)]\n/// Configuration for an HTTP CONNECT proxy (`HTTPSProxy` in c-tor torrc configuration)\npub struct HttpsProxyConfig {\n    pub(crate) address: TargetAddr,\n    pub(crate) username: Option\u003cString\u003e,\n    pub(crate) password: Option\u003cString\u003e,\n}\n\nimpl HttpsProxyConfig {\n    /// Construct a new `HttpsProxyConfig`. The `address` argument must not be a [`crate::tor_provider::TargetAddr::OnionService`] and its port must not be 0. The `username` argument, if present, must not contain the `:` (colon) character.\n    pub fn new(\n        address: TargetAddr,\n        username: Option\u003cString\u003e,\n        password: Option\u003cString\u003e,\n    ) -\u003e Result\u003cSelf, ProxyConfigError\u003e {\n        let port = match \u0026address {\n            TargetAddr::Socket(addr) =\u003e addr.port(),\n            TargetAddr::Domain(addr) =\u003e addr.port(),\n            TargetAddr::OnionService(_) =\u003e {\n                return Err(ProxyConfigError::Generic(\n                    \"proxy address may not be onion service\".to_string(),\n                ))\n            }\n        };\n        if port == 0 {\n            return Err(ProxyConfigError::Generic(\"proxy port not be 0\".to_string()));\n        }\n\n        // username may not contain ':' character (per RFC 2617)\n        if let Some(username) = \u0026username {\n            if username.contains(':') {\n                return Err(ProxyConfigError::Generic(\n                    \"username may not contain ':' character\".to_string(),\n                ));\n            }\n        }\n\n        Ok(Self {\n            address,\n            username,\n            password,\n        })\n    }\n}\n\n#[derive(Clone, Debug)]\n/// An enum representing a possible proxy server configuration with address and possible credentials.\npub enum ProxyConfig {\n    /// A SOCKS4 proxy\n    Socks4(Socks4ProxyConfig),\n    /// A SOCKS5 proxy\n    Socks5(Socks5ProxyConfig),\n    /// An HTTP CONNECT proxy\n    Https(HttpsProxyConfig),\n}\n\nimpl From\u003cSocks4ProxyConfig\u003e for ProxyConfig {\n    fn from(config: Socks4ProxyConfig) -\u003e Self {\n        ProxyConfig::Socks4(config)\n    }\n}\n\nimpl From\u003cSocks5ProxyConfig\u003e for ProxyConfig {\n    fn from(config: Socks5ProxyConfig) -\u003e Self {\n        ProxyConfig::Socks5(config)\n    }\n}\n\nimpl From\u003cHttpsProxyConfig\u003e for ProxyConfig {\n    fn from(config: HttpsProxyConfig) -\u003e Self {\n        ProxyConfig::Https(config)\n    }\n}\n","traces":[{"line":20,"address":[3756832,3757326],"length":1,"stats":{"Line":0}},{"line":21,"address":[3756854],"length":1,"stats":{"Line":0}},{"line":22,"address":[3756891,3757021],"length":1,"stats":{"Line":0}},{"line":23,"address":[3757124,3756944],"length":1,"stats":{"Line":0}},{"line":25,"address":[3757041],"length":1,"stats":{"Line":0}},{"line":26,"address":[3756915],"length":1,"stats":{"Line":0}},{"line":30,"address":[3757026],"length":1,"stats":{"Line":0}},{"line":31,"address":[3757131,3757237],"length":1,"stats":{"Line":0}},{"line":34,"address":[3757163],"length":1,"stats":{"Line":0}},{"line":48,"address":[3757360,3758628],"length":1,"stats":{"Line":0}},{"line":53,"address":[3757392],"length":1,"stats":{"Line":0}},{"line":54,"address":[3757429,3757559],"length":1,"stats":{"Line":0}},{"line":55,"address":[3757482,3757679],"length":1,"stats":{"Line":0}},{"line":57,"address":[3757582],"length":1,"stats":{"Line":0}},{"line":58,"address":[3757453],"length":1,"stats":{"Line":0}},{"line":62,"address":[3757564],"length":1,"stats":{"Line":0}},{"line":63,"address":[3757686,3757758],"length":1,"stats":{"Line":0}},{"line":67,"address":[3757865,3757718],"length":1,"stats":{"Line":0}},{"line":68,"address":[3757934,3757873],"length":1,"stats":{"Line":0}},{"line":69,"address":[3757974],"length":1,"stats":{"Line":0}},{"line":70,"address":[3757942],"length":1,"stats":{"Line":0}},{"line":75,"address":[3758081,3757890],"length":1,"stats":{"Line":0}},{"line":76,"address":[3758089,3758366],"length":1,"stats":{"Line":0}},{"line":77,"address":[3758410],"length":1,"stats":{"Line":0}},{"line":78,"address":[3758378],"length":1,"stats":{"Line":0}},{"line":83,"address":[3758207],"length":1,"stats":{"Line":0}},{"line":84,"address":[3758109],"length":1,"stats":{"Line":0}},{"line":85,"address":[3758137],"length":1,"stats":{"Line":0}},{"line":86,"address":[3758172],"length":1,"stats":{"Line":0}},{"line":101,"address":[3758656,3759742],"length":1,"stats":{"Line":0}},{"line":106,"address":[3758688],"length":1,"stats":{"Line":0}},{"line":107,"address":[3758725,3758855],"length":1,"stats":{"Line":0}},{"line":108,"address":[3758778,3758978],"length":1,"stats":{"Line":0}},{"line":110,"address":[3758878],"length":1,"stats":{"Line":0}},{"line":111,"address":[3758749],"length":1,"stats":{"Line":0}},{"line":115,"address":[3758860],"length":1,"stats":{"Line":0}},{"line":116,"address":[3759057,3758985],"length":1,"stats":{"Line":0}},{"line":120,"address":[3759164,3759017],"length":1,"stats":{"Line":0}},{"line":121,"address":[3759172,3759459],"length":1,"stats":{"Line":0}},{"line":122,"address":[3759524],"length":1,"stats":{"Line":0}},{"line":123,"address":[3759492],"length":1,"stats":{"Line":0}},{"line":128,"address":[3759295],"length":1,"stats":{"Line":0}},{"line":129,"address":[3759197],"length":1,"stats":{"Line":0}},{"line":130,"address":[3759225],"length":1,"stats":{"Line":0}},{"line":131,"address":[3759260],"length":1,"stats":{"Line":0}},{"line":148,"address":[3759776],"length":1,"stats":{"Line":0}},{"line":149,"address":[3759793],"length":1,"stats":{"Line":0}},{"line":154,"address":[3759840],"length":1,"stats":{"Line":0}},{"line":155,"address":[3759857],"length":1,"stats":{"Line":0}},{"line":160,"address":[3759904],"length":1,"stats":{"Line":0}},{"line":161,"address":[3759921],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":51},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","tor_crypto.rs"],"content":"// standard\nuse std::convert::TryInto;\nuse std::str;\n\n// extern crates\nuse curve25519_dalek::Scalar;\nuse data_encoding::{BASE32_NOPAD, BASE64};\nuse data_encoding_macro::new_encoding;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse rand::distributions::Alphanumeric;\nuse rand::rngs::OsRng;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse rand::Rng;\nuse sha3::{Digest, Sha3_256};\nuse static_assertions::const_assert_eq;\nuse tor_llcrypto::pk::keymanip::*;\nuse tor_llcrypto::*;\n\n/// Represents various errors that can occur in the tor_crypto module.\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    /// A error encountered converting a String to a tor_crypto type\n    #[error(\"{0}\")]\n    ParseError(String),\n\n    /// An error encountered converting between tor_crypto types\n    #[error(\"{0}\")]\n    ConversionError(String),\n\n    /// An error encountered converting from a raw byte representation\n    #[error(\"invalid key\")]\n    KeyInvalid,\n}\n\n/// The number of bytes in an ed25519 secret key\n/// cbindgen:ignore\npub const ED25519_PRIVATE_KEY_SIZE: usize = 64;\n/// The number of bytes in an ed25519 public key\n/// cbindgen:ignore\npub const ED25519_PUBLIC_KEY_SIZE: usize = 32;\n/// The number of bytes in an ed25519 signature\n/// cbindgen:ignore\npub const ED25519_SIGNATURE_SIZE: usize = 64;\n/// The number of bytes needed to store onion service id as an ASCII c-string (not including null-terminator)\npub const V3_ONION_SERVICE_ID_STRING_LENGTH: usize = 56;\n/// The number of bytes needed to store onion service id as an ASCII c-string (including null-terminator)\npub const V3_ONION_SERVICE_ID_STRING_SIZE: usize = 57;\nconst_assert_eq!(\n    V3_ONION_SERVICE_ID_STRING_SIZE,\n    V3_ONION_SERVICE_ID_STRING_LENGTH + 1\n);\n/// The number of bytes needed to store base64 encoded ed25519 private key as an ASCII c-string (not including null-terminator)\npub const ED25519_PRIVATE_KEYBLOB_BASE64_LENGTH: usize = 88;\n/// key klob header string\nconst ED25519_PRIVATE_KEY_KEYBLOB_HEADER: \u0026str = \"ED25519-V3:\";\n/// The number of bytes needed to store the keyblob header\npub const ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH: usize = 11;\nconst_assert_eq!(\n    ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH,\n    ED25519_PRIVATE_KEY_KEYBLOB_HEADER.len()\n);\n/// The number of bytes needed to store ed25519 private keyblob as an ASCII c-string (not including a null terminator)\npub const ED25519_PRIVATE_KEY_KEYBLOB_LENGTH: usize = 99;\nconst_assert_eq!(\n    ED25519_PRIVATE_KEY_KEYBLOB_LENGTH,\n    ED25519_PRIVATE_KEY_KEYBLOB_HEADER_LENGTH + ED25519_PRIVATE_KEYBLOB_BASE64_LENGTH\n);\n/// The number of bytes needed to store ed25519 private keyblob as an ASCII c-string (including a null terminator)\npub const ED25519_PRIVATE_KEY_KEYBLOB_SIZE: usize = 100;\nconst_assert_eq!(\n    ED25519_PRIVATE_KEY_KEYBLOB_SIZE,\n    ED25519_PRIVATE_KEY_KEYBLOB_LENGTH + 1\n);\n// number of bytes in an onion service id after base32 decode\nconst V3_ONION_SERVICE_ID_RAW_SIZE: usize = 35;\n// byte index of the start of the public key checksum\nconst V3_ONION_SERVICE_ID_CHECKSUM_OFFSET: usize = 32;\n// byte index of the v3 onion service version\nconst V3_ONION_SERVICE_ID_VERSION_OFFSET: usize = 34;\n/// The number of bytes in a v3 service id's truncated checksum\nconst TRUNCATED_CHECKSUM_SIZE: usize = 2;\n/// The number of bytes in an x25519 private key\n/// cbindgen:ignore\npub const X25519_PRIVATE_KEY_SIZE: usize = 32;\n/// The number of bytes in an x25519 publickey\n/// cbindgen:ignore\npub const X25519_PUBLIC_KEY_SIZE: usize = 32;\n/// The number of bytes needed to store base64 encoded x25519 private key as an ASCII c-string (not including null-terminator)\npub const X25519_PRIVATE_KEY_BASE64_LENGTH: usize = 44;\n/// The number of bytes needed to store base64 encoded x25519 private key as an ASCII c-string (including a null terminator)\npub const X25519_PRIVATE_KEY_BASE64_SIZE: usize = 45;\nconst_assert_eq!(\n    X25519_PRIVATE_KEY_BASE64_SIZE,\n    X25519_PRIVATE_KEY_BASE64_LENGTH + 1\n);\n/// The number of bytes needed to store base32 encoded x25519 public key as an ASCII c-string (not including null-terminator)\npub const X25519_PUBLIC_KEY_BASE32_LENGTH: usize = 52;\n/// The number of bytes needed to store base32 encoded x25519 public key as an ASCII c-string (including a null terminator)\npub const X25519_PUBLIC_KEY_BASE32_SIZE: usize = 53;\nconst_assert_eq!(\n    X25519_PUBLIC_KEY_BASE32_SIZE,\n    X25519_PUBLIC_KEY_BASE32_LENGTH + 1\n);\n\nconst ONION_BASE32: data_encoding::Encoding = new_encoding! {\n    symbols: \"abcdefghijklmnopqrstuvwxyz234567\",\n    padding: '=',\n};\n\n// Free functions\n\n// securely generate password using OsRng\n#[cfg(feature = \"legacy-tor-provider\")]\npub(crate) fn generate_password(length: usize) -\u003e String {\n    let password: String = std::iter::repeat(())\n        .map(|()| OsRng.sample(Alphanumeric))\n        .map(char::from)\n        .take(length)\n        .collect();\n\n    password\n}\n\n// Struct deinitions\n\n/// An ed25519 private key.\n///\n/// This key type is used with [`crate::tor_provider::TorProvider`] trait for hosting onion-services and can be convertd to an [`Ed25519PublicKey`]. It can also be used to sign messages and create an [`Ed25519Signature`].\npub struct Ed25519PrivateKey {\n    expanded_keypair: pk::ed25519::ExpandedKeypair,\n}\n\n/// An ed25519 public key.\n///\n/// This key type is derived from [`Ed25519PrivateKey`] and can be converted to a [`V3OnionServiceId`]. It can also be used to verify a [`Ed25519Signature`].\n#[derive(Clone)]\npub struct Ed25519PublicKey {\n    public_key: pk::ed25519::PublicKey,\n}\n\n/// An ed25519 cryptographic signature\n#[derive(Clone)]\npub struct Ed25519Signature {\n    signature: pk::ed25519::Signature,\n}\n\n/// An x25519 private key\n#[derive(Clone)]\npub struct X25519PrivateKey {\n    secret_key: pk::curve25519::StaticSecret,\n}\n\n/// An x25519 public key\n#[derive(Clone, PartialEq, Eq, Hash)]\npub struct X25519PublicKey {\n    public_key: pk::curve25519::PublicKey,\n}\n\n/// A v3 onion-service id\n#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct V3OnionServiceId {\n    data: [u8; V3_ONION_SERVICE_ID_STRING_LENGTH],\n}\n\n/// An enum representing a single bit\n#[derive(Clone, Copy)]\npub enum SignBit {\n    Zero,\n    One,\n}\n\nimpl From\u003cSignBit\u003e for u8 {\n    fn from(signbit: SignBit) -\u003e Self {\n        match signbit {\n            SignBit::Zero =\u003e 0u8,\n            SignBit::One =\u003e 1u8,\n        }\n    }\n}\n\nimpl From\u003cSignBit\u003e for bool {\n    fn from(signbit: SignBit) -\u003e Self {\n        match signbit {\n            SignBit::Zero =\u003e false,\n            SignBit::One =\u003e true,\n        }\n    }\n}\n\nimpl From\u003cbool\u003e for SignBit {\n    fn from(signbit: bool) -\u003e Self {\n        if signbit {\n            SignBit::One\n        } else {\n            SignBit::Zero\n        }\n    }\n}\n\n// which validation method to use when constructing an ed25519 expanded key from\n// a byte array\nenum FromRawValidationMethod {\n    // expanded ed25519 keys coming from legacy c-tor daemon; the scalar portion\n    // is clamped, but not reduced\n    #[cfg(feature = \"legacy-tor-provider\")]\n    LegacyCTor,\n    // expanded ed25519 keys coming from ed25519-dalek crate; the scalar portion\n    // has been clamped AND reduced\n    Ed25519Dalek,\n}\n\n/// A wrapper around `tor_llcrypto::pk::ed25519::ExpandedKeypair`.\nimpl Ed25519PrivateKey {\n    /// Securely generate a new `Ed25519PrivateKey`.\n    pub fn generate() -\u003e Ed25519PrivateKey {\n        let csprng = \u0026mut OsRng;\n        let keypair = pk::ed25519::Keypair::generate(csprng);\n\n        Ed25519PrivateKey {\n            expanded_keypair: pk::ed25519::ExpandedKeypair::from(\u0026keypair),\n        }\n    }\n\n    fn from_raw_impl(\n        raw: \u0026[u8; ED25519_PRIVATE_KEY_SIZE],\n        method: FromRawValidationMethod,\n    ) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        // see: https://gitlab.torproject.org/tpo/core/arti/-/issues/1343\n        match method {\n            #[cfg(feature = \"legacy-tor-provider\")]\n            FromRawValidationMethod::LegacyCTor =\u003e {\n                // Verify the scalar portion of the expanded key has been clamped\n                // see: https://gitlab.torproject.org/tpo/core/arti/-/issues/1021\n                if !(raw[0] == raw[0] \u0026 248 \u0026\u0026 raw[31] == (raw[31] \u0026 63) | 64) {\n                    return Err(Error::KeyInvalid);\n                }\n            }\n            FromRawValidationMethod::Ed25519Dalek =\u003e {\n                // Verify the scalar is non-zero and it has been reduced\n                let scalar: [u8; 32] = raw[..32].try_into().unwrap();\n                if scalar.iter().all(|\u0026x| x == 0x00u8) {\n                    return Err(Error::KeyInvalid);\n                }\n                let reduced_scalar = Scalar::from_bytes_mod_order(scalar).to_bytes();\n                if scalar != reduced_scalar {\n                    return Err(Error::KeyInvalid);\n                }\n            }\n        }\n\n        if let Some(expanded_keypair) = pk::ed25519::ExpandedKeypair::from_secret_key_bytes(*raw) {\n            Ok(Ed25519PrivateKey { expanded_keypair })\n        } else {\n            Err(Error::KeyInvalid)\n        }\n    }\n\n    /// Attempt to create an `Ed25519PrivateKey` from an array of bytes. Not all byte buffers of the required size can create a valid `Ed25519PrivateKey`. Only buffers derived from [`Ed25519PrivateKey::to_bytes()`] are required to convert correctly.\n    ///\n    /// To securely generate a valid `Ed25519PrivateKey`, use [`Ed25519PrivateKey::generate()`].\n    pub fn from_raw(raw: \u0026[u8; ED25519_PRIVATE_KEY_SIZE]) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_raw_impl(raw, FromRawValidationMethod::Ed25519Dalek)\n    }\n\n    fn from_key_blob_impl(\n        key_blob: \u0026str,\n        method: FromRawValidationMethod,\n    ) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        if key_blob.len() != ED25519_PRIVATE_KEY_KEYBLOB_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received string with length '{}'\",\n                ED25519_PRIVATE_KEY_KEYBLOB_LENGTH,\n                key_blob.len()\n            )));\n        }\n\n        if !key_blob.starts_with(ED25519_PRIVATE_KEY_KEYBLOB_HEADER) {\n            return Err(Error::ParseError(format!(\n                \"expects string that begins with '{}'; received '{}'\",\n                \u0026ED25519_PRIVATE_KEY_KEYBLOB_HEADER, \u0026key_blob\n            )));\n        }\n\n        let base64_key: \u0026str = \u0026key_blob[ED25519_PRIVATE_KEY_KEYBLOB_HEADER.len()..];\n        let private_key_data = match BASE64.decode(base64_key.as_bytes()) {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"could not parse '{}' as base64\",\n                    base64_key\n                )))\n            }\n        };\n        let private_key_data_len = private_key_data.len();\n        let private_key_data_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = match private_key_data.try_into()\n        {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded private key length '{}'; actual '{}'\",\n                    ED25519_PRIVATE_KEY_SIZE, private_key_data_len\n                )))\n            }\n        };\n\n        Ed25519PrivateKey::from_raw_impl(\u0026private_key_data_raw, method)\n    }\n\n    #[cfg(feature = \"legacy-tor-provider\")]\n    pub(crate) fn from_key_blob_legacy(key_blob: \u0026str) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_key_blob_impl(key_blob, FromRawValidationMethod::LegacyCTor)\n    }\n\n    /// Create an `Ed25519PrivateKey` from a [`String`] in the legacy c-tor daemon key blob format used in the `ADD_ONION` control-port command. From the c-tor control [specification](https://spec.torproject.org/control-spec/commands.html#add_onion):\n    /// \u003e For a \"ED25519-V3\" key is the Base64 encoding of the concatenation of the 32-byte ed25519 secret scalar in little-endian and the 32-byte ed25519 PRF secret.\n    ///\n    /// Only key blob strings derived from [`Ed25519PrivateKey::to_key_blob()`] are required to convert correctly.\n    pub fn from_key_blob(key_blob: \u0026str) -\u003e Result\u003cEd25519PrivateKey, Error\u003e {\n        Self::from_key_blob_impl(key_blob, FromRawValidationMethod::Ed25519Dalek)\n    }\n\n    /// Construct an `Ed25519PrivateKEy` from an [`X25519PrivateKey`].\n    pub fn from_private_x25519(\n        x25519_private: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(Ed25519PrivateKey, SignBit), Error\u003e {\n        if let Some((result, signbit)) =\n            convert_curve25519_to_ed25519_private(\u0026x25519_private.secret_key)\n        {\n            Ok((\n                Ed25519PrivateKey {\n                    expanded_keypair: result,\n                },\n                match signbit {\n                    0u8 =\u003e SignBit::Zero,\n                    1u8 =\u003e SignBit::One,\n                    invalid_signbit =\u003e {\n                        return Err(Error::ConversionError(format!(\n                            \"convert_curve25519_to_ed25519_private() returned invalid signbit: {}\",\n                            invalid_signbit\n                        )))\n                    }\n                },\n            ))\n        } else {\n            Err(Error::ConversionError(\n                \"could not convert x25519 private key to ed25519 private key\".to_string(),\n            ))\n        }\n    }\n\n    /// Write `Ed25519PrivateKey` to a c-tor key blob formatted [`String`].\n    pub fn to_key_blob(\u0026self) -\u003e String {\n        let mut key_blob = ED25519_PRIVATE_KEY_KEYBLOB_HEADER.to_string();\n        key_blob.push_str(\u0026BASE64.encode(\u0026self.expanded_keypair.to_secret_key_bytes()));\n\n        key_blob\n    }\n\n    /// Sign the provided message and return an [`Ed25519Signature`].\n    /// ##  Warning \n    ///Only ever sign messages the private key owner controls the contents of!\n    pub fn sign_message(\u0026self, message: \u0026[u8]) -\u003e Ed25519Signature {\n        let signature = self.expanded_keypair.sign(message);\n        Ed25519Signature { signature }\n    }\n\n    /// Convert this private key to an array of bytes.\n    pub fn to_bytes(\u0026self) -\u003e [u8; ED25519_PRIVATE_KEY_SIZE] {\n        self.expanded_keypair.to_secret_key_bytes()\n    }\n\n    #[cfg(feature = \"arti-client-tor-provider\")]\n    pub(crate) fn inner(\u0026self) -\u003e \u0026pk::ed25519::ExpandedKeypair {\n        \u0026self.expanded_keypair\n    }\n}\n\nimpl PartialEq for Ed25519PrivateKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.to_bytes().eq(\u0026other.to_bytes())\n    }\n}\n\nimpl Clone for Ed25519PrivateKey {\n    fn clone(\u0026self) -\u003e Ed25519PrivateKey {\n        match Ed25519PrivateKey::from_raw(\u0026self.to_bytes()) {\n            Ok(ed25519_private_key) =\u003e ed25519_private_key,\n            Err(_) =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl std::fmt::Debug for Ed25519PrivateKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"--- ed25519 private key ---\")\n    }\n}\n\n/// A wrapper around `tor_llcrypto::pk::ed25519::PublicKey`\nimpl Ed25519PublicKey {\n    /// Construct an `Ed25519PublicKey` from an array of bytes. Not all byte buffers of the required size can create a valid `Ed25519PublicKey`. Only buffers derived from [`Ed25519PublicKey::as_bytes()`] are required to convert correctly.\n    pub fn from_raw(raw: \u0026[u8; ED25519_PUBLIC_KEY_SIZE]) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        Ok(Ed25519PublicKey {\n            public_key: match pk::ed25519::PublicKey::from_bytes(raw) {\n                Ok(public_key) =\u003e public_key,\n                Err(_) =\u003e return Err(Error::KeyInvalid),\n            },\n        })\n    }\n\n    /// Construct an `Ed25519PublicKey` from a [`V3OnionServiceId`].\n    pub fn from_service_id(service_id: \u0026V3OnionServiceId) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        // decode base32 encoded service id\n        let mut decoded_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n        let decoded_byte_count =\n            match ONION_BASE32.decode_mut(service_id.as_bytes(), \u0026mut decoded_service_id) {\n                Ok(decoded_byte_count) =\u003e decoded_byte_count,\n                Err(_) =\u003e {\n                    return Err(Error::ConversionError(format!(\n                        \"failed to decode '{}' as V3OnionServiceId\",\n                        service_id\n                    )))\n                }\n            };\n        if decoded_byte_count != V3_ONION_SERVICE_ID_RAW_SIZE {\n            return Err(Error::ConversionError(format!(\n                \"decoded byte count is '{}', expected '{}'\",\n                decoded_byte_count, V3_ONION_SERVICE_ID_RAW_SIZE\n            )));\n        }\n\n        Ed25519PublicKey::from_raw(\n            decoded_service_id[0..ED25519_PUBLIC_KEY_SIZE]\n                .try_into()\n                .unwrap(),\n        )\n    }\n\n    /// Construct an `Ed25519PublicKey` from an [`Ed25519PrivateKey`].\n    pub fn from_private_key(private_key: \u0026Ed25519PrivateKey) -\u003e Ed25519PublicKey {\n        Ed25519PublicKey {\n            public_key: *private_key.expanded_keypair.public(),\n        }\n    }\n\n    fn from_public_x25519(\n        public_x25519: \u0026X25519PublicKey,\n        signbit: SignBit,\n    ) -\u003e Result\u003cEd25519PublicKey, Error\u003e {\n        match convert_curve25519_to_ed25519_public(\u0026public_x25519.public_key, signbit.into()) {\n            Some(public_key) =\u003e Ok(Ed25519PublicKey { public_key }),\n            None =\u003e Err(Error::ConversionError(\n                \"failed to create ed25519 public key from x25519 public key and signbit\"\n                    .to_string(),\n            )),\n        }\n    }\n\n    /// View this public key as an array of bytes\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; ED25519_PUBLIC_KEY_SIZE] {\n        self.public_key.as_bytes()\n    }\n}\n\nimpl PartialEq for Ed25519PublicKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.public_key.eq(\u0026other.public_key)\n    }\n}\n\nimpl std::fmt::Debug for Ed25519PublicKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.public_key.fmt(f)\n    }\n}\n\n\n/// A wrapper around `tor_llcrypto::pk::ed25519::Signature`\nimpl Ed25519Signature {\n    /// Construct an `Ed25519Signature` from an array of bytes.\n    pub fn from_raw(raw: \u0026[u8; ED25519_SIGNATURE_SIZE]) -\u003e Result\u003cEd25519Signature, Error\u003e {\n        // todo: message cannot fail so should not return a Result\u003c\u003e\n        Ok(Ed25519Signature {\n            signature: pk::ed25519::Signature::from_bytes(raw),\n        })\n    }\n\n    /// Verify this `Ed25519Signature` for the given message and [`Ed25519PublicKey`].\n    pub fn verify(\u0026self, message: \u0026[u8], public_key: \u0026Ed25519PublicKey) -\u003e bool {\n        if let Ok(()) = public_key\n            .public_key\n            .verify_strict(message, \u0026self.signature)\n        {\n            return true;\n        }\n        false\n    }\n\n    /// Verify this `Ed25519Signature` for the given message, [`X25519PublicKey`], and [`SignBit`]. This signature must have been created by first converting an [`X25519PrivateKey`] to a [`Ed25519PrivateKey`] and [`SignBit`], and then signing the message using this [`Ed25519PrivateKey`]. This method verifies the signature using the [`Ed25519PublicKey`] derived from the provided  [`X25519PublicKey`] and [`SignBit`].\n    pub fn verify_x25519(\n        \u0026self,\n        message: \u0026[u8],\n        public_key: \u0026X25519PublicKey,\n        signbit: SignBit,\n    ) -\u003e bool {\n        if let Ok(public_key) = Ed25519PublicKey::from_public_x25519(public_key, signbit) {\n            return self.verify(message, \u0026public_key);\n        }\n        false\n    }\n\n    /// Convert this signature to an array of bytes\n    pub fn to_bytes(\u0026self) -\u003e [u8; ED25519_SIGNATURE_SIZE] {\n        self.signature.to_bytes()\n    }\n}\n\nimpl PartialEq for Ed25519Signature {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.signature.eq(\u0026other.signature)\n    }\n}\n\nimpl std::fmt::Debug for Ed25519Signature {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        self.signature.fmt(f)\n    }\n}\n\n/// A wrapper around `tor_llcrypto::pk::curve25519::StaticSecret`\nimpl X25519PrivateKey {\n    /// Securely generate a new `X25519PrivateKey`\n    pub fn generate() -\u003e X25519PrivateKey {\n        let csprng = \u0026mut OsRng;\n        X25519PrivateKey {\n            secret_key: pk::curve25519::StaticSecret::random_from_rng(csprng),\n        }\n    }\n\n    /// Attempt to create an `X25519PrivateKey` from an array of bytes. Not all byte buffers of the required size can create a valid `X25519PrivateKey`. Only buffers derived from [`X25519PrivateKey::to_bytes()`] are required to convert correctly.\n    ///\n    /// To securely generate a valid `X25519PrivateKey`, use [`X25519PrivateKey::generate()`].\n    pub fn from_raw(raw: \u0026[u8; X25519_PRIVATE_KEY_SIZE]) -\u003e Result\u003cX25519PrivateKey, Error\u003e {\n        // see: https://docs.rs/x25519-dalek/2.0.0-pre.1/src/x25519_dalek/x25519.rs.html#197\n        if raw[0] == raw[0] \u0026 240 \u0026\u0026 raw[31] == (raw[31] \u0026 127) | 64 {\n            Ok(X25519PrivateKey {\n                secret_key: pk::curve25519::StaticSecret::from(*raw),\n            })\n        } else {\n            Err(Error::KeyInvalid)\n        }\n    }\n\n    /// Create an `X25519PrivateKey` from a [`String`] in the legacy c-tor daemon key blob format used in the `ONION_CLIENT_AUTH_ADD` control-port command. From the c-tor control [specification](https://spec.torproject.org/control-spec/commands.html#onion_client_auth_add):\n    /// \u003e ```text\n    /// \u003e PrivateKeyBlob = base64 encoding of x25519 key\n    /// \u003e ```\n    ///\n    /// Only key blob strings derived from [`X25519PrivateKey::to_base64()`] are required to convert correctly.\n    pub fn from_base64(base64: \u0026str) -\u003e Result\u003cX25519PrivateKey, Error\u003e {\n        // todo: see if this should be from/to key blob like with ed25519 rather than base64\n        if base64.len() != X25519_PRIVATE_KEY_BASE64_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received string with length '{}'\",\n                X25519_PRIVATE_KEY_BASE64_LENGTH,\n                base64.len()\n            )));\n        }\n\n        let private_key_data = match BASE64.decode(base64.as_bytes()) {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"could not parse '{}' as base64\",\n                    base64\n                )))\n            }\n        };\n        let private_key_data_len = private_key_data.len();\n        let private_key_data_raw: [u8; X25519_PRIVATE_KEY_SIZE] = match private_key_data.try_into()\n        {\n            Ok(private_key_data) =\u003e private_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded private key length '{}'; actual '{}'\",\n                    X25519_PRIVATE_KEY_SIZE, private_key_data_len\n                )))\n            }\n        };\n\n        X25519PrivateKey::from_raw(\u0026private_key_data_raw)\n    }\n\n    /// Sign the provided message and return an [`Ed25519Signature`] and [`SignBit`].\n    ///\n    /// This method first converts this `X25519PrivateKey` to an [`Ed25519PrivateKey`] and [`SignBit`]. Then, the message is signed using the derived [`Ed25519PrivateKey`]. To verify the signature, both the [`X25519PublicKey`] and this calculated [`SignBit`] are required.\n    ///\n    /// ##  Warning \n    ///Only ever sign messages the private key owner controls the contents of!\n    pub fn sign_message(\u0026self, message: \u0026[u8]) -\u003e Result\u003c(Ed25519Signature, SignBit), Error\u003e {\n        let (ed25519_private, signbit) = Ed25519PrivateKey::from_private_x25519(self)?;\n        Ok((ed25519_private.sign_message(message), signbit))\n    }\n\n    /// Write `X25519PrivateKey` to a base64 encocded [`String`].\n    pub fn to_base64(\u0026self) -\u003e String {\n        BASE64.encode(\u0026self.secret_key.to_bytes())\n    }\n\n    /// Convert this private key to an array of bytes.\n    pub fn to_bytes(\u0026self) -\u003e [u8; X25519_PRIVATE_KEY_SIZE] {\n        self.secret_key.to_bytes()\n    }\n}\n\nimpl PartialEq for X25519PrivateKey {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.secret_key.to_bytes() == other.secret_key.to_bytes()\n    }\n}\n\nimpl std::fmt::Debug for X25519PrivateKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"--- x25519 private key ---\")\n    }\n}\n\n/// A wrapper around `tor_llcrypto::pk::curve25519::PublicKey`\nimpl X25519PublicKey {\n    /// Construct an `X25519PublicKey` from an [`X25519PrivateKey`].\n    pub fn from_private_key(private_key: \u0026X25519PrivateKey) -\u003e X25519PublicKey {\n        X25519PublicKey {\n            public_key: pk::curve25519::PublicKey::from(\u0026private_key.secret_key),\n        }\n    }\n\n    /// Construct an `X25519PublicKey` from an array of bytes.\n    pub fn from_raw(raw: \u0026[u8; X25519_PUBLIC_KEY_SIZE]) -\u003e X25519PublicKey {\n        X25519PublicKey {\n            public_key: pk::curve25519::PublicKey::from(*raw),\n        }\n    }\n\n    /// Create an `X25519PublicKey` from a [`String`] in the legacy c-tor daemon key base32 format used in the `ADD_ONION` control-port command. From the c-tor control [specification](https://spec.torproject.org/control-spec/commands.html#add_onion):\n    /// \u003e ```text\n    /// \u003e V3Key = The client's base32-encoded x25519 public key, using only the key\n    /// \u003e         part of rend-spec-v3.txt section G.1.2 (v3 only).\n    /// \u003e ```\n    ///\n    /// Only key base32 strings derived from [`X25519PublicKey::to_base32()`] are required to convert correctly.\n    pub fn from_base32(base32: \u0026str) -\u003e Result\u003cX25519PublicKey, Error\u003e {\n        if base32.len() != X25519_PUBLIC_KEY_BASE32_LENGTH {\n            return Err(Error::ParseError(format!(\n                \"expects string of length '{}'; received '{}' with length '{}'\",\n                X25519_PUBLIC_KEY_BASE32_LENGTH,\n                base32,\n                base32.len()\n            )));\n        }\n\n        let public_key_data = match BASE32_NOPAD.decode(base32.as_bytes()) {\n            Ok(public_key_data) =\u003e public_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"failed to decode '{}' as X25519PublicKey\",\n                    base32\n                )))\n            }\n        };\n        let public_key_data_len = public_key_data.len();\n        let public_key_data_raw: [u8; X25519_PUBLIC_KEY_SIZE] = match public_key_data.try_into() {\n            Ok(public_key_data) =\u003e public_key_data,\n            Err(_) =\u003e {\n                return Err(Error::ParseError(format!(\n                    \"expects decoded public key length '{}'; actual '{}'\",\n                    X25519_PUBLIC_KEY_SIZE, public_key_data_len\n                )))\n            }\n        };\n\n        Ok(X25519PublicKey::from_raw(\u0026public_key_data_raw))\n    }\n\n    /// Write `X25519PublicKey` to a base32 encocded [`String`].\n    pub fn to_base32(\u0026self) -\u003e String {\n        BASE32_NOPAD.encode(self.public_key.as_bytes())\n    }\n\n    /// View this public key as an array of bytes\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; X25519_PUBLIC_KEY_SIZE] {\n        self.public_key.as_bytes()\n    }\n}\n\nimpl std::fmt::Debug for X25519PublicKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.to_base32())\n    }\n}\n\n/// Strongly-typed representation of a v3 onion-service id\nimpl V3OnionServiceId {\n    // see https://github.com/torproject/torspec/blob/main/rend-spec-v3.txt#L2143\n    fn calc_truncated_checksum(\n        public_key: \u0026[u8; ED25519_PUBLIC_KEY_SIZE],\n    ) -\u003e [u8; TRUNCATED_CHECKSUM_SIZE] {\n        let mut hasher = Sha3_256::new();\n\n        // calculate checksum\n        hasher.update(b\".onion checksum\");\n        hasher.update(public_key);\n        hasher.update([0x03u8]);\n        let hash_bytes = hasher.finalize();\n\n        [hash_bytes[0], hash_bytes[1]]\n    }\n\n    /// Create a `V3OnionServiceId` from a [`String`] in the version 3 onion service digest format. From the tor address [specification](https://spec.torproject.org/address-spec.html#onion):\n    /// \u003e ```text\n    /// \u003e onion_address = base32(PUBKEY | CHECKSUM | VERSION)\n    /// \u003e CHECKSUM = H(\".onion checksum\" | PUBKEY | VERSION)[:2]\n    /// \u003e\n    /// \u003e where:\n    /// \u003e - PUBKEY is the 32 bytes ed25519 master pubkey of the onion service.\n    /// \u003e - VERSION is a one byte version field (default value '\\x03')\n    /// \u003e - \".onion checksum\" is a constant string\n    /// \u003e - H is SHA3-256\n    /// \u003e - CHECKSUM is truncated to two bytes before inserting it in onion_address\n    /// \u003e ```\n    pub fn from_string(service_id: \u0026str) -\u003e Result\u003cV3OnionServiceId, Error\u003e {\n        if !V3OnionServiceId::is_valid(service_id) {\n            return Err(Error::ParseError(format!(\n                \"'{}' is not a valid v3 onion service id\",\n                service_id\n            )));\n        }\n        Ok(V3OnionServiceId {\n            data: service_id.as_bytes().try_into().unwrap(),\n        })\n    }\n\n    /// Create a `V3OnionServiceId` from an [`Ed25519PublicKey`].\n    pub fn from_public_key(public_key: \u0026Ed25519PublicKey) -\u003e V3OnionServiceId {\n        let mut raw_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n\n        raw_service_id[..ED25519_PUBLIC_KEY_SIZE].copy_from_slice(\u0026public_key.as_bytes()[..]);\n        let truncated_checksum = Self::calc_truncated_checksum(public_key.as_bytes());\n        raw_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET] = truncated_checksum[0];\n        raw_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET + 1] = truncated_checksum[1];\n        raw_service_id[V3_ONION_SERVICE_ID_VERSION_OFFSET] = 0x03u8;\n\n        let mut service_id = [0u8; V3_ONION_SERVICE_ID_STRING_LENGTH];\n        // panics on wrong buffer size, but given our constant buffer sizes should be fine\n        ONION_BASE32.encode_mut(\u0026raw_service_id, \u0026mut service_id);\n\n        V3OnionServiceId { data: service_id }\n    }\n\n    /// Create a `V3OnionServiceId` from an [`Ed25519PrivateKey`].\n    pub fn from_private_key(private_key: \u0026Ed25519PrivateKey) -\u003e V3OnionServiceId {\n        Self::from_public_key(\u0026Ed25519PublicKey::from_private_key(private_key))\n    }\n\n    /// Determine if the provided string is a valid representation of a `V3OnionServiceId`\n    pub fn is_valid(service_id: \u0026str) -\u003e bool {\n        if service_id.len() != V3_ONION_SERVICE_ID_STRING_LENGTH {\n            return false;\n        }\n\n        let mut decoded_service_id = [0u8; V3_ONION_SERVICE_ID_RAW_SIZE];\n        match ONION_BASE32.decode_mut(service_id.as_bytes(), \u0026mut decoded_service_id) {\n            Ok(decoded_byte_count) =\u003e {\n                // ensure right size\n                if decoded_byte_count != V3_ONION_SERVICE_ID_RAW_SIZE {\n                    return false;\n                }\n                // ensure correct version\n                if decoded_service_id[V3_ONION_SERVICE_ID_VERSION_OFFSET] != 0x03 {\n                    return false;\n                }\n                // copy public key into own buffer\n                let mut public_key = [0u8; ED25519_PUBLIC_KEY_SIZE];\n                public_key[..].copy_from_slice(\u0026decoded_service_id[..ED25519_PUBLIC_KEY_SIZE]);\n                // ensure checksum is correct\n                let truncated_checksum = Self::calc_truncated_checksum(\u0026public_key);\n                if truncated_checksum[0] != decoded_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET]\n                    || truncated_checksum[1]\n                        != decoded_service_id[V3_ONION_SERVICE_ID_CHECKSUM_OFFSET + 1]\n                {\n                    return false;\n                }\n                true\n            }\n            Err(_) =\u003e false,\n        }\n    }\n\n    /// View this service id as an array of bytes\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; V3_ONION_SERVICE_ID_STRING_LENGTH] {\n        \u0026self.data\n    }\n}\n\nimpl std::fmt::Display for V3OnionServiceId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        unsafe { write!(f, \"{}\", str::from_utf8_unchecked(\u0026self.data)) }\n    }\n}\n\nimpl std::fmt::Debug for V3OnionServiceId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        unsafe { write!(f, \"{}\", str::from_utf8_unchecked(\u0026self.data)) }\n    }\n}\n","traces":[{"line":114,"address":[3160624],"length":1,"stats":{"Line":3}},{"line":115,"address":[3160648],"length":1,"stats":{"Line":3}},{"line":116,"address":[3524976,3524985],"length":1,"stats":{"Line":6}},{"line":173,"address":[3160704],"length":1,"stats":{"Line":3}},{"line":174,"address":[3160713],"length":1,"stats":{"Line":3}},{"line":175,"address":[3160728],"length":1,"stats":{"Line":2}},{"line":176,"address":[3160735],"length":1,"stats":{"Line":3}},{"line":182,"address":[3160752],"length":1,"stats":{"Line":2}},{"line":183,"address":[3160761],"length":1,"stats":{"Line":2}},{"line":184,"address":[3160776],"length":1,"stats":{"Line":2}},{"line":185,"address":[3160783],"length":1,"stats":{"Line":2}},{"line":191,"address":[3160800],"length":1,"stats":{"Line":2}},{"line":192,"address":[3160812,3160821],"length":1,"stats":{"Line":4}},{"line":193,"address":[3160823],"length":1,"stats":{"Line":2}},{"line":195,"address":[3160816],"length":1,"stats":{"Line":2}},{"line":215,"address":[3160848,3161004],"length":1,"stats":{"Line":5}},{"line":216,"address":[3160869],"length":1,"stats":{"Line":5}},{"line":217,"address":[3160877],"length":1,"stats":{"Line":5}},{"line":220,"address":[3160901],"length":1,"stats":{"Line":5}},{"line":224,"address":[3161040],"length":1,"stats":{"Line":4}},{"line":229,"address":[3161077],"length":1,"stats":{"Line":4}},{"line":234,"address":[3161420,3161104],"length":1,"stats":{"Line":2}},{"line":235,"address":[3161362],"length":1,"stats":{"Line":0}},{"line":240,"address":[3161128],"length":1,"stats":{"Line":3}},{"line":241,"address":[3161298],"length":1,"stats":{"Line":9}},{"line":242,"address":[3161650],"length":1,"stats":{"Line":0}},{"line":244,"address":[3161521],"length":1,"stats":{"Line":3}},{"line":245,"address":[3161617],"length":1,"stats":{"Line":3}},{"line":246,"address":[3161727],"length":1,"stats":{"Line":1}},{"line":251,"address":[3161440,3161902,3161799],"length":1,"stats":{"Line":12}},{"line":252,"address":[3161837],"length":1,"stats":{"Line":4}},{"line":254,"address":[3161909],"length":1,"stats":{"Line":0}},{"line":261,"address":[3162032],"length":1,"stats":{"Line":3}},{"line":262,"address":[3162048],"length":1,"stats":{"Line":3}},{"line":265,"address":[3164346,3162080],"length":1,"stats":{"Line":2}},{"line":269,"address":[3162122],"length":1,"stats":{"Line":2}},{"line":270,"address":[3162401],"length":1,"stats":{"Line":0}},{"line":273,"address":[3162284],"length":1,"stats":{"Line":0}},{"line":277,"address":[3162151],"length":1,"stats":{"Line":2}},{"line":278,"address":[3162797],"length":1,"stats":{"Line":0}},{"line":280,"address":[3162690],"length":1,"stats":{"Line":0}},{"line":284,"address":[3163036],"length":1,"stats":{"Line":2}},{"line":285,"address":[3163130,3163303],"length":1,"stats":{"Line":4}},{"line":286,"address":[3163365],"length":1,"stats":{"Line":2}},{"line":288,"address":[3164387],"length":1,"stats":{"Line":0}},{"line":294,"address":[3163599],"length":1,"stats":{"Line":2}},{"line":295,"address":[3163634],"length":1,"stats":{"Line":2}},{"line":297,"address":[3163723],"length":1,"stats":{"Line":2}},{"line":299,"address":[3164145],"length":1,"stats":{"Line":0}},{"line":306,"address":[3163973],"length":1,"stats":{"Line":2}},{"line":310,"address":[3164608],"length":1,"stats":{"Line":1}},{"line":311,"address":[3164630],"length":1,"stats":{"Line":1}},{"line":318,"address":[3164672],"length":1,"stats":{"Line":1}},{"line":319,"address":[3164694],"length":1,"stats":{"Line":1}},{"line":323,"address":[3165615,3165432,3164736],"length":1,"stats":{"Line":3}},{"line":326,"address":[3164761],"length":1,"stats":{"Line":3}},{"line":329,"address":[3165075],"length":1,"stats":{"Line":3}},{"line":330,"address":[3164887],"length":1,"stats":{"Line":3}},{"line":333,"address":[3164893],"length":1,"stats":{"Line":3}},{"line":334,"address":[3165057],"length":1,"stats":{"Line":2}},{"line":335,"address":[3165067],"length":1,"stats":{"Line":3}},{"line":336,"address":[3164951],"length":1,"stats":{"Line":0}},{"line":337,"address":[3165201],"length":1,"stats":{"Line":0}},{"line":345,"address":[3165446],"length":1,"stats":{"Line":0}},{"line":346,"address":[3164917],"length":1,"stats":{"Line":0}},{"line":352,"address":[3165648,3166019],"length":1,"stats":{"Line":4}},{"line":353,"address":[3165678],"length":1,"stats":{"Line":4}},{"line":354,"address":[3165705],"length":1,"stats":{"Line":4}},{"line":356,"address":[3165985],"length":1,"stats":{"Line":4}},{"line":362,"address":[3166048],"length":1,"stats":{"Line":3}},{"line":363,"address":[3166076],"length":1,"stats":{"Line":3}},{"line":368,"address":[3166128],"length":1,"stats":{"Line":3}},{"line":369,"address":[3166145],"length":1,"stats":{"Line":3}},{"line":379,"address":[3166176],"length":1,"stats":{"Line":1}},{"line":380,"address":[3166209],"length":1,"stats":{"Line":1}},{"line":385,"address":[3166272,3166491,3166462],"length":1,"stats":{"Line":2}},{"line":386,"address":[3166297],"length":1,"stats":{"Line":2}},{"line":387,"address":[3166343],"length":1,"stats":{"Line":2}},{"line":394,"address":[3166512],"length":1,"stats":{"Line":0}},{"line":395,"address":[3166530],"length":1,"stats":{"Line":0}},{"line":402,"address":[3166576],"length":1,"stats":{"Line":3}},{"line":403,"address":[3166655],"length":1,"stats":{"Line":3}},{"line":404,"address":[3166601],"length":1,"stats":{"Line":3}},{"line":405,"address":[3166625],"length":1,"stats":{"Line":3}},{"line":406,"address":[3166735],"length":1,"stats":{"Line":0}},{"line":412,"address":[3166832,3168032],"length":1,"stats":{"Line":3}},{"line":414,"address":[3166854],"length":1,"stats":{"Line":3}},{"line":415,"address":[3166875,3166975],"length":1,"stats":{"Line":6}},{"line":417,"address":[3167037],"length":1,"stats":{"Line":3}},{"line":419,"address":[3167820],"length":1,"stats":{"Line":0}},{"line":425,"address":[3167077],"length":1,"stats":{"Line":3}},{"line":426,"address":[3167573],"length":1,"stats":{"Line":0}},{"line":433,"address":[3167200],"length":1,"stats":{"Line":3}},{"line":440,"address":[3168064],"length":1,"stats":{"Line":4}},{"line":442,"address":[3168102],"length":1,"stats":{"Line":5}},{"line":446,"address":[3168160],"length":1,"stats":{"Line":3}},{"line":450,"address":[3168203],"length":1,"stats":{"Line":3}},{"line":451,"address":[3168402],"length":1,"stats":{"Line":3}},{"line":452,"address":[3168285],"length":1,"stats":{"Line":0}},{"line":453,"address":[3168256],"length":1,"stats":{"Line":0}},{"line":460,"address":[3168512],"length":1,"stats":{"Line":5}},{"line":461,"address":[3168517],"length":1,"stats":{"Line":5}},{"line":466,"address":[3168528],"length":1,"stats":{"Line":1}},{"line":467,"address":[3168542],"length":1,"stats":{"Line":1}},{"line":472,"address":[3168560],"length":1,"stats":{"Line":0}},{"line":473,"address":[3168574],"length":1,"stats":{"Line":0}},{"line":481,"address":[3168592],"length":1,"stats":{"Line":3}},{"line":483,"address":[3168627],"length":1,"stats":{"Line":3}},{"line":484,"address":[3168616],"length":1,"stats":{"Line":3}},{"line":489,"address":[3168704],"length":1,"stats":{"Line":3}},{"line":490,"address":[3168745],"length":1,"stats":{"Line":3}},{"line":494,"address":[3168764],"length":1,"stats":{"Line":3}},{"line":496,"address":[3168793],"length":1,"stats":{"Line":1}},{"line":500,"address":[3168816,3169081],"length":1,"stats":{"Line":3}},{"line":506,"address":[3168898],"length":1,"stats":{"Line":3}},{"line":507,"address":[3169047,3168972],"length":1,"stats":{"Line":6}},{"line":509,"address":[3168998],"length":1,"stats":{"Line":0}},{"line":513,"address":[3169104],"length":1,"stats":{"Line":2}},{"line":514,"address":[3169121],"length":1,"stats":{"Line":2}},{"line":519,"address":[3169152],"length":1,"stats":{"Line":1}},{"line":520,"address":[3169166],"length":1,"stats":{"Line":1}},{"line":525,"address":[3169184],"length":1,"stats":{"Line":0}},{"line":526,"address":[3169198],"length":1,"stats":{"Line":0}},{"line":533,"address":[3169216],"length":1,"stats":{"Line":3}},{"line":534,"address":[3169230],"length":1,"stats":{"Line":3}},{"line":536,"address":[3169240],"length":1,"stats":{"Line":3}},{"line":543,"address":[3169312],"length":1,"stats":{"Line":1}},{"line":545,"address":[3169342,3169421],"length":1,"stats":{"Line":1}},{"line":546,"address":[3169508],"length":1,"stats":{"Line":1}},{"line":547,"address":[3169452],"length":1,"stats":{"Line":1}},{"line":550,"address":[3169358],"length":1,"stats":{"Line":0}},{"line":560,"address":[3169600,3171152],"length":1,"stats":{"Line":1}},{"line":562,"address":[3169627],"length":1,"stats":{"Line":1}},{"line":563,"address":[3169936],"length":1,"stats":{"Line":0}},{"line":566,"address":[3169819],"length":1,"stats":{"Line":0}},{"line":570,"address":[3170183,3169656],"length":1,"stats":{"Line":2}},{"line":571,"address":[3170245],"length":1,"stats":{"Line":1}},{"line":573,"address":[3171193],"length":1,"stats":{"Line":0}},{"line":579,"address":[3170473],"length":1,"stats":{"Line":1}},{"line":580,"address":[3170510],"length":1,"stats":{"Line":1}},{"line":582,"address":[3170595],"length":1,"stats":{"Line":1}},{"line":584,"address":[3170955],"length":1,"stats":{"Line":0}},{"line":591,"address":[3170777],"length":1,"stats":{"Line":1}},{"line":600,"address":[3171408,3171875],"length":1,"stats":{"Line":1}},{"line":601,"address":[3171459,3171649],"length":1,"stats":{"Line":1}},{"line":602,"address":[3171777,3171622],"length":1,"stats":{"Line":2}},{"line":606,"address":[3171904,3172041],"length":1,"stats":{"Line":3}},{"line":607,"address":[3171922,3171994],"length":1,"stats":{"Line":6}},{"line":611,"address":[3172064],"length":1,"stats":{"Line":0}},{"line":612,"address":[3172081],"length":1,"stats":{"Line":0}},{"line":617,"address":[3172096],"length":1,"stats":{"Line":0}},{"line":618,"address":[3172120],"length":1,"stats":{"Line":0}},{"line":623,"address":[3172176],"length":1,"stats":{"Line":0}},{"line":624,"address":[3172194],"length":1,"stats":{"Line":0}},{"line":631,"address":[3172240],"length":1,"stats":{"Line":4}},{"line":633,"address":[3172258],"length":1,"stats":{"Line":4}},{"line":638,"address":[3172320],"length":1,"stats":{"Line":3}},{"line":640,"address":[3172338],"length":1,"stats":{"Line":3}},{"line":651,"address":[3172448,3174182],"length":1,"stats":{"Line":1}},{"line":652,"address":[3172475],"length":1,"stats":{"Line":1}},{"line":653,"address":[3172872],"length":1,"stats":{"Line":0}},{"line":657,"address":[3172755],"length":1,"stats":{"Line":0}},{"line":661,"address":[3172504,3173151],"length":1,"stats":{"Line":2}},{"line":662,"address":[3173213],"length":1,"stats":{"Line":1}},{"line":664,"address":[3174223],"length":1,"stats":{"Line":0}},{"line":670,"address":[3173441],"length":1,"stats":{"Line":1}},{"line":671,"address":[3173478],"length":1,"stats":{"Line":1}},{"line":672,"address":[3173563],"length":1,"stats":{"Line":1}},{"line":674,"address":[3173985],"length":1,"stats":{"Line":0}},{"line":681,"address":[3173743],"length":1,"stats":{"Line":1}},{"line":685,"address":[3174582,3174432],"length":1,"stats":{"Line":3}},{"line":686,"address":[3174462,3174540],"length":1,"stats":{"Line":6}},{"line":690,"address":[3174608],"length":1,"stats":{"Line":2}},{"line":691,"address":[3174613],"length":1,"stats":{"Line":2}},{"line":696,"address":[3174624,3174875],"length":1,"stats":{"Line":0}},{"line":697,"address":[3174788,3174655],"length":1,"stats":{"Line":0}},{"line":704,"address":[3174912],"length":1,"stats":{"Line":6}},{"line":707,"address":[3174932],"length":1,"stats":{"Line":6}},{"line":710,"address":[3174943],"length":1,"stats":{"Line":6}},{"line":711,"address":[3174966],"length":1,"stats":{"Line":6}},{"line":712,"address":[3174977],"length":1,"stats":{"Line":6}},{"line":713,"address":[3175018],"length":1,"stats":{"Line":6}},{"line":715,"address":[3175108,3175246,3175171],"length":1,"stats":{"Line":12}},{"line":730,"address":[3175280],"length":1,"stats":{"Line":5}},{"line":731,"address":[3175307],"length":1,"stats":{"Line":5}},{"line":732,"address":[3175419],"length":1,"stats":{"Line":1}},{"line":737,"address":[3175748],"length":1,"stats":{"Line":6}},{"line":738,"address":[3175580],"length":1,"stats":{"Line":6}},{"line":743,"address":[3176338,3175824],"length":1,"stats":{"Line":5}},{"line":744,"address":[3175854],"length":1,"stats":{"Line":5}},{"line":746,"address":[3175871],"length":1,"stats":{"Line":5}},{"line":747,"address":[3175972],"length":1,"stats":{"Line":5}},{"line":748,"address":[3176007],"length":1,"stats":{"Line":5}},{"line":749,"address":[3176203,3176015],"length":1,"stats":{"Line":5}},{"line":750,"address":[3176087],"length":1,"stats":{"Line":5}},{"line":752,"address":[3176092],"length":1,"stats":{"Line":5}},{"line":754,"address":[3176224,3176128],"length":1,"stats":{"Line":5}},{"line":760,"address":[3176368],"length":1,"stats":{"Line":3}},{"line":761,"address":[3176392],"length":1,"stats":{"Line":3}},{"line":765,"address":[3176432,3177160],"length":1,"stats":{"Line":5}},{"line":766,"address":[3176465],"length":1,"stats":{"Line":5}},{"line":767,"address":[3176571],"length":1,"stats":{"Line":1}},{"line":770,"address":[3176486],"length":1,"stats":{"Line":5}},{"line":771,"address":[3176513,3176635],"length":1,"stats":{"Line":11}},{"line":772,"address":[3176698],"length":1,"stats":{"Line":6}},{"line":774,"address":[3176714],"length":1,"stats":{"Line":6}},{"line":775,"address":[3176734],"length":1,"stats":{"Line":0}},{"line":778,"address":[3176744,3176732],"length":1,"stats":{"Line":12}},{"line":779,"address":[3176809],"length":1,"stats":{"Line":1}},{"line":782,"address":[3176754],"length":1,"stats":{"Line":6}},{"line":783,"address":[3176839,3176773],"length":1,"stats":{"Line":12}},{"line":785,"address":[3176923],"length":1,"stats":{"Line":6}},{"line":786,"address":[3176964],"length":1,"stats":{"Line":6}},{"line":787,"address":[3177072,3176988,3177000],"length":1,"stats":{"Line":18}},{"line":788,"address":[3177011,3177085],"length":1,"stats":{"Line":6}},{"line":790,"address":[3176990],"length":1,"stats":{"Line":0}},{"line":792,"address":[3177108],"length":1,"stats":{"Line":6}},{"line":794,"address":[3176722],"length":1,"stats":{"Line":1}},{"line":799,"address":[3177184],"length":1,"stats":{"Line":3}},{"line":805,"address":[3177200],"length":1,"stats":{"Line":4}},{"line":806,"address":[3177221,3177317],"length":1,"stats":{"Line":8}},{"line":811,"address":[3177392],"length":1,"stats":{"Line":0}},{"line":812,"address":[3177413,3177509],"length":1,"stats":{"Line":0}}],"covered":177,"coverable":223},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","src","tor_provider.rs"],"content":"// standard\nuse std::any::Any;\nuse std::boxed::Box;\nuse std::convert::TryFrom;\nuse std::io::{Read, Write};\nuse std::net::{SocketAddr, TcpListener, TcpStream};\nuse std::ops::{Deref, DerefMut};\nuse std::str::FromStr;\nuse std::sync::OnceLock;\n\n// extern crates\nuse domain::base::name::Name;\nuse idna::uts46::{Hyphens, Uts46};\nuse idna::{domain_to_ascii_cow, AsciiDenyList};\nuse regex::Regex;\n\n// internal crates\nuse crate::tor_crypto::*;\n\n\n/// Various `tor_provider` errors.\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"Failed to parse '{0}' as {1}\")]\n    /// Failure parsing some string into a type\n    ParseFailure(String, String),\n\n    #[error(\"{0}\")]\n    /// Other miscellaneous error\n    Generic(String),\n}\n\n//\n// OnionAddr\n//\n\n/// A version 3 onion service address.\n///\n/// Version 3 Onion Service addresses const of a [`crate::tor_crypto::V3OnionServiceId`] and a 16-bit port number.\n#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct OnionAddrV3 {\n    pub(crate) service_id: V3OnionServiceId,\n    pub(crate) virt_port: u16,\n}\n\nimpl OnionAddrV3 {\n    /// Create a new `OnionAddrV3` from a [`crate::tor_crypto::V3OnionServiceId`] and port number.\n    pub fn new(service_id: V3OnionServiceId, virt_port: u16) -\u003e OnionAddrV3 {\n        OnionAddrV3 {\n            service_id,\n            virt_port,\n        }\n    }\n\n    /// Return the service id associated with this onion address.\n    pub fn service_id(\u0026self) -\u003e \u0026V3OnionServiceId {\n        \u0026self.service_id\n    }\n\n    /// Return the port numebr associated with this onion address.\n    pub fn virt_port(\u0026self) -\u003e u16 {\n        self.virt_port\n    }\n}\n\nimpl std::fmt::Display for OnionAddrV3 {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}.onion:{}\", self.service_id, self.virt_port)\n    }\n}\n\n/// An onion service address analog to [`std::net::SocketAddr`]\n#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub enum OnionAddr {\n    V3(OnionAddrV3),\n}\n\nimpl FromStr for OnionAddr {\n    type Err = Error;\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        static ONION_SERVICE_PATTERN: OnceLock\u003cRegex\u003e = OnceLock::new();\n        let onion_service_pattern = ONION_SERVICE_PATTERN.get_or_init(|| {\n            Regex::new(r\"(?m)^(?P\u003cservice_id\u003e[a-z2-7]{56})\\.onion:(?P\u003cport\u003e[1-9][0-9]{0,4})$\")\n                .unwrap()\n        });\n\n        if let Some(caps) = onion_service_pattern.captures(s.to_lowercase().as_ref()) {\n            let service_id = caps\n                .name(\"service_id\")\n                .expect(\"missing service_id group\")\n                .as_str()\n                .to_lowercase();\n            let port = caps.name(\"port\").expect(\"missing port group\").as_str();\n            if let (Ok(service_id), Ok(port)) = (\n                V3OnionServiceId::from_string(service_id.as_ref()),\n                u16::from_str(port),\n            ) {\n                return Ok(OnionAddr::V3(OnionAddrV3::new(service_id, port)));\n            }\n        }\n        Err(Self::Err::ParseFailure(s.to_string(), \"OnionAddr\".to_string()))\n    }\n}\n\nimpl std::fmt::Display for OnionAddr {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            OnionAddr::V3(onion_addr) =\u003e onion_addr.fmt(f),\n        }\n    }\n}\n\n//\n// DomainAddr\n//\n\n/// A domain name analog to `std::net::SocketAddr`\n///\n/// A `DomainAddr` must not end in \".onion\"\n#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct DomainAddr {\n    domain: String,\n    port: u16,\n}\n\n/// A `DomainAddr` has a domain name (scuh as `www.example.com`) and a port\nimpl DomainAddr {\n    /// Returns the domain name associated with this domain address.\n    pub fn domain(\u0026self) -\u003e \u0026str {\n        self.domain.as_ref()\n    }\n\n    /// Returns the port number associated with this domain address.\n    pub fn port(\u0026self) -\u003e u16 {\n        self.port\n    }\n}\n\nimpl std::fmt::Display for DomainAddr {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let uts46: Uts46 = Default::default();\n        let (ui_str, _err) = uts46.to_user_interface(\n            self.domain.as_str().as_bytes(),\n            AsciiDenyList::URL,\n            Hyphens::Allow,\n            |_, _, _| -\u003e bool { false },\n        );\n        write!(f, \"{}:{}\", ui_str, self.port)\n    }\n}\n\nimpl TryFrom\u003c(String, u16)\u003e for DomainAddr {\n    type Error = Error;\n\n    fn try_from(value: (String, u16)) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let (domain, port) = (\u0026value.0, value.1);\n        if let Ok(domain) = domain_to_ascii_cow(domain.as_bytes(), AsciiDenyList::URL) {\n            let domain = domain.to_string();\n            if let Ok(domain) = Name::\u003cVec\u003cu8\u003e\u003e::from_str(domain.as_ref()) {\n                let domain = domain.to_string();\n                if !domain.ends_with(\".onion\") {\n                    return Ok(Self {\n                        domain,\n                        port,\n                    });\n                }\n            }\n        }\n        Err(Self::Error::ParseFailure(format!(\n            \"{}:{}\",\n            domain, port\n        ), \"DomainAddr\".to_string()))\n    }\n}\n\nimpl FromStr for DomainAddr {\n    type Err = Error;\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        static DOMAIN_PATTERN: OnceLock\u003cRegex\u003e = OnceLock::new();\n        let domain_pattern = DOMAIN_PATTERN\n            .get_or_init(|| Regex::new(r\"(?m)^(?P\u003cdomain\u003e.*):(?P\u003cport\u003e[1-9][0-9]{0,4})$\").unwrap());\n        if let Some(caps) = domain_pattern.captures(s) {\n            let domain = caps\n                .name(\"domain\")\n                .expect(\"missing domain group\")\n                .as_str()\n                .to_string();\n            let port = caps.name(\"port\").expect(\"missing port group\").as_str();\n            if let Ok(port) = u16::from_str(port) {\n                return Self::try_from((domain, port));\n            }\n        }\n        Err(Self::Err::ParseFailure(s.to_string(), \"DomainAddr\".to_string()))\n    }\n}\n\n//\n// TargetAddr\n//\n\n/// An enum representing the various types of addresses a [`TorProvider`] implementation may connect to.\n#[derive(Clone, Debug)]\npub enum TargetAddr {\n    /// An ip address and port\n    Socket(std::net::SocketAddr),\n    /// An onion-service id and virtual port\n    OnionService(OnionAddr),\n    /// A domain name and port\n    Domain(DomainAddr),\n}\n\nimpl From\u003c(V3OnionServiceId, u16)\u003e for TargetAddr {\n    fn from(target_tuple: (V3OnionServiceId, u16)) -\u003e Self {\n        TargetAddr::OnionService(OnionAddr::V3(OnionAddrV3::new(\n            target_tuple.0,\n            target_tuple.1,\n        )))\n    }\n}\n\nimpl FromStr for TargetAddr {\n    type Err = Error;\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if let Ok(socket_addr) = SocketAddr::from_str(s) {\n            return Ok(TargetAddr::Socket(socket_addr));\n        } else if let Ok(onion_addr) = OnionAddr::from_str(s) {\n            return Ok(TargetAddr::OnionService(onion_addr));\n        } else if let Ok(domain_addr) = DomainAddr::from_str(s) {\n            return Ok(TargetAddr::Domain(domain_addr));\n        }\n        Err(Self::Err::ParseFailure(s.to_string(), \"TargetAddr\".to_string()))\n    }\n}\n\nimpl std::fmt::Display for TargetAddr {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            TargetAddr::Socket(socket_addr) =\u003e socket_addr.fmt(f),\n            TargetAddr::OnionService(onion_addr) =\u003e onion_addr.fmt(f),\n            TargetAddr::Domain(domain_addr) =\u003e domain_addr.fmt(f),\n        }\n    }\n}\n\n/// Various events possibly returned by a [`TorProvider`] implementation's `update()` method.\n#[derive(Debug)]\npub enum TorEvent {\n    /// A status update received connecting to the Tor Network.\n    BootstrapStatus {\n        /// A number from 0 to 100 for how through the bootstrap process the `TorProvider` is.\n        progress: u32,\n        /// A short string to identify the current phase of the bootstrap process.\n        tag: String,\n        /// A longer string with a summary of the current phase of the bootstrap process.\n        summary: String,\n    },\n    /// Indicates successful connection to the Tor Network. The [`TorProvider::connect()`] and [`TorProvider::listener()`] methods may now be used.\n    BootstrapComplete,\n    /// Messages which may be useful for troubleshooting.\n    LogReceived {\n        /// A message\n        line: String,\n    },\n    /// An onion-service has been published to the Tor Network and may now be reachable by clients.\n    OnionServicePublished {\n        /// The service-id of the onion-service which has been published.\n        service_id: V3OnionServiceId,\n    },\n}\n\n/// A `CircuitToken` is used to specify circuits used to connect to clearnet services.\npub type CircuitToken = usize;\n\n//\n// Onion Stream\n//\n\n/// A wrapper around a [`std::net::TcpStream`] with some Tor-specific customisations\n///\n/// An onion-listener can be constructed using the [`TorProvider::connect()`] method.\npub struct OnionStream {\n    pub(crate) stream: TcpStream,\n    pub(crate) local_addr: Option\u003cOnionAddr\u003e,\n    pub(crate) peer_addr: Option\u003cTargetAddr\u003e,\n}\n\nimpl Deref for OnionStream {\n    type Target = TcpStream;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.stream\n    }\n}\n\nimpl DerefMut for OnionStream {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.stream\n    }\n}\n\nimpl From\u003cOnionStream\u003e for TcpStream {\n    fn from(onion_stream: OnionStream) -\u003e Self {\n        onion_stream.stream\n    }\n}\n\nimpl Read for OnionStream {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.stream.read(buf)\n    }\n}\n\nimpl Write for OnionStream {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        self.stream.write(buf)\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.stream.flush()\n    }\n}\n\nimpl OnionStream {\n    /// Returns the target address of the remote peer of this onion connection.\n    pub fn peer_addr(\u0026self) -\u003e Option\u003cTargetAddr\u003e {\n        self.peer_addr.clone()\n    }\n\n    /// Returns the onion address of the local connection for an incoming onion-service connection. Returns `None` for outgoing connections.\n    pub fn local_addr(\u0026self) -\u003e Option\u003cOnionAddr\u003e {\n        self.local_addr.clone()\n    }\n\n    /// Tries to clone the underlying connection and data. A simple pass-through to [`std::net::TcpStream::try_clone()`].\n    pub fn try_clone(\u0026self) -\u003e Result\u003cSelf, std::io::Error\u003e {\n        Ok(Self {\n            stream: self.stream.try_clone()?,\n            local_addr: self.local_addr.clone(),\n            peer_addr: self.peer_addr.clone(),\n        })\n    }\n}\n\n//\n// Onion Listener\n//\n\n/// A wrapper around a [`std::net::TcpListener`] with some Tor-specific customisations.\n///\n/// An onion-listener can be constructed using the [`TorProvider::listener()`] method.\npub struct OnionListener {\n    pub(crate) listener: TcpListener,\n    pub(crate) onion_addr: OnionAddr,\n    pub(crate) data: Option\u003cBox\u003cdyn Any + Send\u003e\u003e,\n    pub(crate) drop: Option\u003cBox\u003cdyn FnMut(Box\u003cdyn Any\u003e) + Send\u003e\u003e,\n}\n\nimpl OnionListener {\n    /// Construct an `OnionListener`. The `data` and `drop` parameters are to allow custom `TorProvider` implementations their own data and cleanup procedures.\n    pub(crate) fn new\u003cT: 'static + Send\u003e(\n        listener: TcpListener,\n        onion_addr: OnionAddr,\n        data: T,\n        mut drop: impl FnMut(T) + 'static + Send) -\u003e Self {\n        // marshall our data into an Any\n        let data: Option\u003cBox\u003cdyn Any + Send\u003e\u003e = Some(Box::new(data));\n        // marhsall our drop into a function which takes an Any\n        let drop: Option\u003cBox\u003cdyn FnMut(Box\u003cdyn Any\u003e) + Send\u003e\u003e  = Some(Box::new(move |data: Box\u003cdyn std::any::Any\u003e| {\n            // encapsulate extracting our data from the Any\n            if let Ok(data) = data.downcast::\u003cT\u003e() {\n                // and call our provided drop\n                drop(*data);\n            }\n        }));\n\n        Self{\n            listener,\n            onion_addr,\n            data,\n            drop,\n        }\n    }\n\n    /// Moves the underlying `TcpListener` into or out of nonblocking mode.\n    pub fn set_nonblocking(\u0026self, nonblocking: bool) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.listener.set_nonblocking(nonblocking)\n    }\n\n    /// Accept a new incoming connection from this listener.\n    pub fn accept(\u0026self) -\u003e Result\u003cOption\u003cOnionStream\u003e, std::io::Error\u003e {\n        match self.listener.accept() {\n            Ok((stream, _socket_addr)) =\u003e Ok(Some(OnionStream {\n                stream,\n                local_addr: Some(self.onion_addr.clone()),\n                peer_addr: None,\n            })),\n            Err(err) =\u003e {\n                if err.kind() == std::io::ErrorKind::WouldBlock {\n                    Ok(None)\n                } else {\n                    Err(err)\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for OnionListener {\n    fn drop(\u0026mut self) {\n        if let (Some(data), Some(mut drop)) = (self.data.take(), self.drop.take()) {\n            drop(data)\n        }\n    }\n}\n\n/// The `TorProvider` trait allows for high-level Tor Network functionality. Implementations ay connect to the Tor Network, anonymously connect to both clearnet and onion-service endpoints, and host onion-services.\npub trait TorProvider: Send {\n    /// Process and return `TorEvent`s handled by this `TorProvider`.\n    fn update(\u0026mut self) -\u003e Result\u003cVec\u003cTorEvent\u003e, Error\u003e;\n    /// Begin connecting to the Tor Network.\n    fn bootstrap(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    /// Add v3 onion-service authorisation credentials, allowing this `TorProvider` to connect to an onion-service whose service-descriptor is encrypted using the assocciated x25519 public key.\n    fn add_client_auth(\n        \u0026mut self,\n        service_id: \u0026V3OnionServiceId,\n        client_auth: \u0026X25519PrivateKey,\n    ) -\u003e Result\u003c(), Error\u003e;\n    /// Remove a previously added client authorisation credential. This `TorProvider` will be unable to connect to the onion-service associated with the removed credentail.\n    fn remove_client_auth(\u0026mut self, service_id: \u0026V3OnionServiceId) -\u003e Result\u003c(), Error\u003e;\n    /// Anonymously connect to the address specified by `target` over the Tor Network and return the associated [`OnionStream`].\n    ///\n    /// When conecting to clearnet targets, an optional [`CircuitToken`] may be used to enforce usage of different circuits through the Tor Network. If `circuit` is `None`, the default circuit is used.\n    ///\n    ///Connections made with different `CircuitToken`s are required to use different circuits through the Tor Network. However, connections made with identical `CircuitToken`s are *not* required to use identical circuits through the Tor Network.\n    ///\n    /// Specifying a circuit token when connecting to an onion-service has no effect on the resulting circuit.\n    fn connect(\n        \u0026mut self,\n        target: TargetAddr,\n        circuit: Option\u003cCircuitToken\u003e,\n    ) -\u003e Result\u003cOnionStream, Error\u003e;\n    /// Anonymously start an onion-service and return the associated [`OnionListener`].\n    ///\n    ///The resulting onion-service will not be reachable by clients until [`TorProvider::update()`] returns a [`TorEvent::OnionServicePublished`] event. The optional `authorised_clients` parameter may be used to require client authorisation keys to connect to resulting onion-service. For further information, see the Tor Project's onion-services [client-auth documentation](https://community.torproject.org/onion-services/advanced/client-auth).\n    fn listener(\n        \u0026mut self,\n        private_key: \u0026Ed25519PrivateKey,\n        virt_port: u16,\n        authorised_clients: Option\u003c\u0026[X25519PublicKey]\u003e,\n    ) -\u003e Result\u003cOnionListener, Error\u003e;\n    /// Create a new [`CircuitToken`].\n    fn generate_token(\u0026mut self) -\u003e CircuitToken;\n    /// Releaes a previously generated [`CircuitToken`].\n    fn release_token(\u0026mut self, token: CircuitToken);\n}\n","traces":[{"line":48,"address":[3672816],"length":1,"stats":{"Line":2}},{"line":56,"address":[3672880],"length":1,"stats":{"Line":0}},{"line":61,"address":[3672896],"length":1,"stats":{"Line":0}},{"line":62,"address":[3672901],"length":1,"stats":{"Line":0}},{"line":67,"address":[3672912],"length":1,"stats":{"Line":1}},{"line":68,"address":[3673084,3673008],"length":1,"stats":{"Line":2}},{"line":80,"address":[3674929,3674593,3673184],"length":1,"stats":{"Line":1}},{"line":82,"address":[3673227],"length":1,"stats":{"Line":2}},{"line":83,"address":[3184558],"length":1,"stats":{"Line":1}},{"line":87,"address":[3673400,3673277],"length":1,"stats":{"Line":2}},{"line":88,"address":[3673643,3673529],"length":1,"stats":{"Line":2}},{"line":93,"address":[3673822,3673743],"length":1,"stats":{"Line":2}},{"line":94,"address":[3674181,3674083,3674253],"length":1,"stats":{"Line":3}},{"line":95,"address":[3673943],"length":1,"stats":{"Line":1}},{"line":96,"address":[3673999,3674062],"length":1,"stats":{"Line":2}},{"line":98,"address":[3674264,3674245,3674340],"length":1,"stats":{"Line":3}},{"line":101,"address":[3674747,3674696],"length":1,"stats":{"Line":1}},{"line":106,"address":[3674944],"length":1,"stats":{"Line":1}},{"line":108,"address":[3674957],"length":1,"stats":{"Line":1}},{"line":129,"address":[3674992],"length":1,"stats":{"Line":0}},{"line":130,"address":[3674997],"length":1,"stats":{"Line":0}},{"line":134,"address":[3675008],"length":1,"stats":{"Line":0}},{"line":135,"address":[3675013],"length":1,"stats":{"Line":0}},{"line":140,"address":[3675024,3675663],"length":1,"stats":{"Line":1}},{"line":141,"address":[3675057],"length":1,"stats":{"Line":1}},{"line":142,"address":[3675178],"length":1,"stats":{"Line":1}},{"line":143,"address":[3675076],"length":1,"stats":{"Line":1}},{"line":145,"address":[3675170],"length":1,"stats":{"Line":1}},{"line":146,"address":[3184784,3184818],"length":1,"stats":{"Line":2}},{"line":148,"address":[3675444,3675526],"length":1,"stats":{"Line":2}},{"line":155,"address":[3675696,3676788,3677482],"length":1,"stats":{"Line":1}},{"line":156,"address":[3675718],"length":1,"stats":{"Line":1}},{"line":157,"address":[3675748,3675821],"length":1,"stats":{"Line":2}},{"line":158,"address":[3675947],"length":1,"stats":{"Line":1}},{"line":159,"address":[3676115,3676047],"length":1,"stats":{"Line":2}},{"line":160,"address":[3676217],"length":1,"stats":{"Line":1}},{"line":161,"address":[3676318,3676386],"length":1,"stats":{"Line":2}},{"line":162,"address":[3676464],"length":1,"stats":{"Line":1}},{"line":163,"address":[3676432],"length":1,"stats":{"Line":1}},{"line":169,"address":[3677139,3677336],"length":1,"stats":{"Line":2}},{"line":172,"address":[3677260],"length":1,"stats":{"Line":1}},{"line":178,"address":[3677504,3678391],"length":1,"stats":{"Line":1}},{"line":180,"address":[3677547],"length":1,"stats":{"Line":1}},{"line":181,"address":[3184832,3184846,3185053],"length":1,"stats":{"Line":3}},{"line":182,"address":[3677597],"length":1,"stats":{"Line":1}},{"line":183,"address":[3677825,3677714],"length":1,"stats":{"Line":2}},{"line":188,"address":[3677929,3678005],"length":1,"stats":{"Line":2}},{"line":189,"address":[3678102],"length":1,"stats":{"Line":1}},{"line":190,"address":[3678181],"length":1,"stats":{"Line":1}},{"line":193,"address":[3678494,3678449],"length":1,"stats":{"Line":1}},{"line":213,"address":[3678688],"length":1,"stats":{"Line":2}},{"line":214,"address":[3678731],"length":1,"stats":{"Line":2}},{"line":215,"address":[3678709],"length":1,"stats":{"Line":2}},{"line":223,"address":[3679737,3678832],"length":1,"stats":{"Line":1}},{"line":224,"address":[3678874],"length":1,"stats":{"Line":1}},{"line":225,"address":[3678953],"length":1,"stats":{"Line":1}},{"line":226,"address":[3679026,3679069],"length":1,"stats":{"Line":2}},{"line":227,"address":[3679099],"length":1,"stats":{"Line":1}},{"line":228,"address":[3679255,3679173],"length":1,"stats":{"Line":2}},{"line":229,"address":[3679339],"length":1,"stats":{"Line":1}},{"line":231,"address":[3679523],"length":1,"stats":{"Line":1}},{"line":236,"address":[3679760],"length":1,"stats":{"Line":0}},{"line":237,"address":[3679783],"length":1,"stats":{"Line":0}},{"line":238,"address":[3679824],"length":1,"stats":{"Line":0}},{"line":239,"address":[3679856],"length":1,"stats":{"Line":0}},{"line":240,"address":[3679888],"length":1,"stats":{"Line":0}},{"line":289,"address":[3679936],"length":1,"stats":{"Line":0}},{"line":290,"address":[3679944],"length":1,"stats":{"Line":0}},{"line":295,"address":[3679952],"length":1,"stats":{"Line":0}},{"line":296,"address":[3679960],"length":1,"stats":{"Line":0}},{"line":301,"address":[3489728],"length":1,"stats":{"Line":1}},{"line":302,"address":[3489729],"length":1,"stats":{"Line":1}},{"line":307,"address":[3679968],"length":1,"stats":{"Line":1}},{"line":308,"address":[3679986],"length":1,"stats":{"Line":1}},{"line":313,"address":[3680016],"length":1,"stats":{"Line":1}},{"line":314,"address":[3680034],"length":1,"stats":{"Line":1}},{"line":317,"address":[3680064],"length":1,"stats":{"Line":1}},{"line":318,"address":[3680069],"length":1,"stats":{"Line":1}},{"line":324,"address":[3680080],"length":1,"stats":{"Line":0}},{"line":325,"address":[3680097],"length":1,"stats":{"Line":0}},{"line":329,"address":[3680128],"length":1,"stats":{"Line":0}},{"line":330,"address":[3680145],"length":1,"stats":{"Line":0}},{"line":334,"address":[3680506,3680176],"length":1,"stats":{"Line":0}},{"line":335,"address":[3680412],"length":1,"stats":{"Line":0}},{"line":336,"address":[3680311,3680205],"length":1,"stats":{"Line":0}},{"line":337,"address":[3680283],"length":1,"stats":{"Line":0}},{"line":338,"address":[3680393],"length":1,"stats":{"Line":0}},{"line":359,"address":[3185590,3185072,3185616,3186107,3186134,3185563],"length":1,"stats":{"Line":4}},{"line":365,"address":[],"length":0,"stats":{"Line":8}},{"line":367,"address":[],"length":0,"stats":{"Line":12}},{"line":369,"address":[],"length":0,"stats":{"Line":4}},{"line":371,"address":[],"length":0,"stats":{"Line":8}},{"line":384,"address":[3680528],"length":1,"stats":{"Line":1}},{"line":385,"address":[3680549],"length":1,"stats":{"Line":1}},{"line":389,"address":[3680576,3680970],"length":1,"stats":{"Line":2}},{"line":390,"address":[3680606],"length":1,"stats":{"Line":2}},{"line":391,"address":[3680644,3680838],"length":1,"stats":{"Line":4}},{"line":392,"address":[3680675],"length":1,"stats":{"Line":2}},{"line":393,"address":[3680788,3680682],"length":1,"stats":{"Line":4}},{"line":394,"address":[3680828],"length":1,"stats":{"Line":2}},{"line":396,"address":[3680701],"length":1,"stats":{"Line":1}},{"line":397,"address":[3681110,3680730,3681037],"length":1,"stats":{"Line":2}},{"line":398,"address":[3681117],"length":1,"stats":{"Line":1}},{"line":400,"address":[3681085],"length":1,"stats":{"Line":0}},{"line":408,"address":[3220923,3220560],"length":1,"stats":{"Line":2}},{"line":409,"address":[3220576,3220806],"length":1,"stats":{"Line":4}},{"line":410,"address":[3220859],"length":1,"stats":{"Line":2}}],"covered":81,"coverable":107},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","tests","tor_crypto.rs"],"content":"// internal crates\nuse tor_interface::tor_crypto::*;\n\n#[test]\nfn test_crypto_ed25519() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let private_key_blob = \"ED25519-V3:rP3u8mZaKohap0lKsB8Z8qXbXqK456JKKGONDBhV+gPBVKa2mHVQqnRTVuFXe3inU3YW6qvc7glYEwe9rK0LhQ==\";\n    let private_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = [\n        0xacu8, 0xfdu8, 0xeeu8, 0xf2u8, 0x66u8, 0x5au8, 0x2au8, 0x88u8, 0x5au8, 0xa7u8, 0x49u8,\n        0x4au8, 0xb0u8, 0x1fu8, 0x19u8, 0xf2u8, 0xa5u8, 0xdbu8, 0x5eu8, 0xa2u8, 0xb8u8, 0xe7u8,\n        0xa2u8, 0x4au8, 0x28u8, 0x63u8, 0x8du8, 0x0cu8, 0x18u8, 0x55u8, 0xfau8, 0x03u8, 0xc1u8,\n        0x54u8, 0xa6u8, 0xb6u8, 0x98u8, 0x75u8, 0x50u8, 0xaau8, 0x74u8, 0x53u8, 0x56u8, 0xe1u8,\n        0x57u8, 0x7bu8, 0x78u8, 0xa7u8, 0x53u8, 0x76u8, 0x16u8, 0xeau8, 0xabu8, 0xdcu8, 0xeeu8,\n        0x09u8, 0x58u8, 0x13u8, 0x07u8, 0xbdu8, 0xacu8, 0xadu8, 0x0bu8, 0x85u8,\n    ];\n    let public_raw: [u8; ED25519_PUBLIC_KEY_SIZE] = [\n        0xf2u8, 0xfdu8, 0xa2u8, 0xdbu8, 0xf3u8, 0x80u8, 0xa6u8, 0xbau8, 0x74u8, 0xa4u8, 0x90u8,\n        0xe1u8, 0x45u8, 0x55u8, 0xeeu8, 0xb9u8, 0x32u8, 0xa0u8, 0x5cu8, 0x39u8, 0x5au8, 0xe2u8,\n        0x02u8, 0x83u8, 0x55u8, 0x27u8, 0x89u8, 0x6au8, 0x1fu8, 0x2fu8, 0x3du8, 0xc5u8,\n    ];\n    let service_id_string = \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd\";\n    assert!(V3OnionServiceId::is_valid(\u0026service_id_string));\n\n    let mut message = [0x00u8; 256];\n    let null_message = [0x00u8; 256];\n    for (i, ptr) in message.iter_mut().enumerate() {\n        *ptr = i as u8;\n    }\n    let signature_raw: [u8; ED25519_SIGNATURE_SIZE] = [\n        0xa6u8, 0xd6u8, 0xc6u8, 0x1au8, 0x03u8, 0xbcu8, 0x43u8, 0x6fu8, 0x38u8, 0x53u8, 0x94u8,\n        0xcdu8, 0xdcu8, 0x86u8, 0x0au8, 0x88u8, 0x64u8, 0x43u8, 0x1du8, 0x18u8, 0x84u8, 0x30u8,\n        0x2fu8, 0xcdu8, 0xa6u8, 0x79u8, 0xcau8, 0x87u8, 0xd0u8, 0x29u8, 0xe7u8, 0x2bu8, 0x32u8,\n        0x9bu8, 0xa2u8, 0xa4u8, 0x3cu8, 0x74u8, 0x6au8, 0x08u8, 0x67u8, 0x0eu8, 0x63u8, 0x60u8,\n        0xcbu8, 0x46u8, 0x22u8, 0x55u8, 0x43u8, 0x5bu8, 0x84u8, 0x68u8, 0x0fu8, 0x47u8, 0xceu8,\n        0x6cu8, 0xd2u8, 0xb8u8, 0xebu8, 0xfeu8, 0xf6u8, 0x9eu8, 0x97u8, 0x0au8,\n    ];\n\n    // test the golden path first\n    let service_id = V3OnionServiceId::from_string(\u0026service_id_string)?;\n\n    let private_key = Ed25519PrivateKey::from_raw(\u0026private_raw)?;\n    assert_eq!(\n        private_key,\n        Ed25519PrivateKey::from_key_blob(\u0026private_key_blob)?\n    );\n    assert_eq!(private_key_blob, private_key.to_key_blob());\n\n    let public_key = Ed25519PublicKey::from_raw(\u0026public_raw)?;\n    assert_eq!(public_key, Ed25519PublicKey::from_service_id(\u0026service_id)?);\n    assert_eq!(public_key, Ed25519PublicKey::from_private_key(\u0026private_key));\n    assert_eq!(service_id, V3OnionServiceId::from_public_key(\u0026public_key));\n\n    let signature = private_key.sign_message(\u0026message);\n    assert_eq!(signature, Ed25519Signature::from_raw(\u0026signature_raw)?);\n    assert!(signature.verify(\u0026message, \u0026public_key));\n    assert!(!signature.verify(\u0026null_message, \u0026public_key));\n\n    // some invalid service ids\n    assert!(!V3OnionServiceId::is_valid(\"\"));\n    assert!(!V3OnionServiceId::is_valid(\n        \"\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n    ));\n    assert!(!V3OnionServiceId::is_valid(\n        \"6L62FW7TQCTLU5FESDQUKVPOXEZKAXBZLLRAFA2VE6EWUHZPHXCZSJYD\"\n    ));\n\n    // generate a new key, get the public key and sign/verify a message\n    let private_key = Ed25519PrivateKey::generate();\n    let public_key = Ed25519PublicKey::from_private_key(\u0026private_key);\n    let signature = private_key.sign_message(\u0026message);\n    assert!(signature.verify(\u0026message, \u0026public_key));\n\n    // test invalid private key blob returns an error\n    // https://gitlab.torproject.org/tpo/core/arti/-/issues/1021\n    let private_raw: [u8; ED25519_PRIVATE_KEY_SIZE] = [\n        0x2eu8, 0x26u8, 0x0au8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x0au8, 0x77u8, 0x77u8,\n        0x77u8, 0x77u8, 0x5du8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8,\n        0x82u8, 0xb4u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8,\n        0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0xffu8,\n        0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8, 0xffu8,\n        0xffu8, 0xffu8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x77u8, 0x82u8, 0x88u8,\n    ];\n    match Ed25519PrivateKey::from_raw(\u0026private_raw) {\n        Ok(_) =\u003e panic!(\"invalid key accepted\"),\n        Err(tor_interface::tor_crypto::Error::KeyInvalid) =\u003e (),\n        Err(err) =\u003e panic!(\"unexpected error: {:?}\", err),\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_crypto_x25519() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // private/public key pair\n    const SECRET_BASE64: \u0026str = \"0GeSReJXdNcgvWRQdnDXhJGdu5UiwP2fefgT93/oqn0=\";\n    const SECRET_RAW: [u8; X25519_PRIVATE_KEY_SIZE] = [\n        0xd0u8, 0x67u8, 0x92u8, 0x45u8, 0xe2u8, 0x57u8, 0x74u8, 0xd7u8, 0x20u8, 0xbdu8, 0x64u8,\n        0x50u8, 0x76u8, 0x70u8, 0xd7u8, 0x84u8, 0x91u8, 0x9du8, 0xbbu8, 0x95u8, 0x22u8, 0xc0u8,\n        0xfdu8, 0x9fu8, 0x79u8, 0xf8u8, 0x13u8, 0xf7u8, 0x7fu8, 0xe8u8, 0xaau8, 0x7du8,\n    ];\n    const PUBLIC_BASE32: \u0026str = \"AEXCBCEDJ5KU34YGGMZ7PVHVDEA7D7YB7VQAPJTMTZGRJLN3JASA\";\n    const PUBLIC_RAW: [u8; X25519_PUBLIC_KEY_SIZE] = [\n        0x01u8, 0x2eu8, 0x20u8, 0x88u8, 0x83u8, 0x4fu8, 0x55u8, 0x4du8, 0xf3u8, 0x06u8, 0x33u8,\n        0x33u8, 0xf7u8, 0xd4u8, 0xf5u8, 0x19u8, 0x01u8, 0xf1u8, 0xffu8, 0x01u8, 0xfdu8, 0x60u8,\n        0x07u8, 0xa6u8, 0x6cu8, 0x9eu8, 0x4du8, 0x14u8, 0xadu8, 0xbbu8, 0x48u8, 0x24u8,\n    ];\n\n    // ensure we can convert from raw as expected\n    assert_eq!(\n        \u0026X25519PrivateKey::from_raw(\u0026SECRET_RAW)?.to_base64(),\n        SECRET_BASE64\n    );\n    assert_eq!(\n        \u0026X25519PublicKey::from_raw(\u0026PUBLIC_RAW).to_base32(),\n        PUBLIC_BASE32\n    );\n\n    // ensure we can round-trip as expected\n    assert_eq!(\n        \u0026X25519PrivateKey::from_base64(\u0026SECRET_BASE64)?.to_base64(),\n        SECRET_BASE64\n    );\n    assert_eq!(\n        \u0026X25519PublicKey::from_base32(\u0026PUBLIC_BASE32)?.to_base32(),\n        PUBLIC_BASE32\n    );\n\n    // ensure we generate the expected public key from private key\n    let private_key = X25519PrivateKey::from_base64(\u0026SECRET_BASE64)?;\n    let public_key = X25519PublicKey::from_private_key(\u0026private_key);\n    assert_eq!(public_key.to_base32(), PUBLIC_BASE32);\n\n    let message = b\"All around me are familiar faces\";\n\n    let (signature, signbit) = private_key.sign_message(message)?;\n    assert!(signature.verify_x25519(message, \u0026public_key, signbit));\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gosling","gosling","source","gosling","crates","tor-interface","tests","tor_provider.rs"],"content":"// stanndard\n#[cfg(feature = \"legacy-tor-provider\")]\nuse std::fs::File;\nuse std::io::{Read, Write};\n#[cfg(feature = \"legacy-tor-provider\")]\nuse std::process;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse std::process::{Child, Command, Stdio};\nuse std::str::FromStr;\n#[cfg(feature = \"arti-client-tor-provider\")]\nuse std::sync::Arc;\n\n// extern crates\nuse serial_test::serial;\n#[cfg(feature = \"arti-client-tor-provider\")]\nuse tokio::runtime;\n\n// internal crates\n#[cfg(feature = \"arti-client-tor-provider\")]\nuse tor_interface::arti_client_tor_client::*;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse tor_interface::censorship_circumvention::*;\n#[cfg(feature = \"legacy-tor-provider\")]\nuse tor_interface::legacy_tor_client::*;\n#[cfg(feature = \"mock-tor-provider\")]\nuse tor_interface::mock_tor_client::*;\nuse tor_interface::tor_crypto::*;\nuse tor_interface::tor_provider::*;\n\npub(crate) fn bootstrap_test(mut tor: Box\u003cdyn TorProvider\u003e) -\u003e anyhow::Result\u003c()\u003e {\n    tor.bootstrap()?;\n\n    let mut received_log = false;\n    let mut bootstrap_complete = false;\n    while !bootstrap_complete {\n        for event in tor.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Bootstrap Complete!\");\n                    bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    received_log = true;\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n    assert!(\n        received_log,\n        \"should have received a log line from tor provider\"\n    );\n\n    Ok(())\n}\n\npub(crate) fn basic_onion_service_test(\n    mut server_provider: Box\u003cdyn TorProvider\u003e,\n    mut client_provider: Box\u003cdyn TorProvider\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    server_provider.bootstrap()?;\n    client_provider.bootstrap()?;\n\n    let mut server_provider_bootstrap_complete = false;\n    let mut client_provider_bootstrap_complete = false;\n\n    while !server_provider_bootstrap_complete || !client_provider_bootstrap_complete {\n        for event in server_provider.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Server Provider BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Server Provider Bootstrap Complete!\");\n                    server_provider_bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n\n        for event in client_provider.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Client Provider BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Client Provider Bootstrap Complete!\");\n                    client_provider_bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // vanilla V3 onion service\n    {\n        let tor = \u0026mut server_provider;\n\n        // create an onion service for this test\n        let private_key = Ed25519PrivateKey::generate();\n\n        println!(\"Starting and listening to onion service\");\n        const VIRT_PORT: u16 = 42069u16;\n        let listener = tor.listener(\u0026private_key, VIRT_PORT, None)?;\n\n        let mut onion_published = false;\n        while !onion_published {\n            for event in tor.update()?.iter() {\n                match event {\n                    TorEvent::LogReceived { line } =\u003e {\n                        println!(\"--- {}\", line);\n                    }\n                    TorEvent::OnionServicePublished { service_id } =\u003e {\n                        let expected_service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n                        if expected_service_id == *service_id {\n                            println!(\"Onion Service {} published\", service_id.to_string());\n                            onion_published = true;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        const MESSAGE: \u0026str = \"Hello World!\";\n\n        {\n            let tor = \u0026mut client_provider;\n            let service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n\n            println!(\"Connecting to onion service\");\n            let mut attempt_count = 0;\n            let mut client = loop {\n                match tor.connect((service_id.clone(), VIRT_PORT).into(), None) {\n                    Ok(client) =\u003e break client,\n                    Err(err) =\u003e {\n                        println!(\"connect error: {:?}\", err);\n                        attempt_count += 1;\n                        if attempt_count == 3 {\n                            panic!(\"failed to connect :(\");\n                        }\n                    }\n                }\n            };\n            println!(\"Client writing message: '{}'\", MESSAGE);\n            client.write_all(MESSAGE.as_bytes())?;\n            client.flush()?;\n            println!(\"End of client scope\");\n        }\n\n        if let Some(mut server) = listener.accept()? {\n            println!(\"Server reading message\");\n            let mut buffer = Vec::new();\n            server.read_to_end(\u0026mut buffer)?;\n            let msg = String::from_utf8(buffer)?;\n\n            assert_eq!(MESSAGE, msg);\n            println!(\"Message received: '{}'\", msg);\n        } else {\n            panic!(\"no listener\");\n        }\n    }\n    Ok(())\n}\n\npub(crate) fn authenticated_onion_service_test(\n    mut server_provider: Box\u003cdyn TorProvider\u003e,\n    mut client_provider: Box\u003cdyn TorProvider\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    server_provider.bootstrap()?;\n    client_provider.bootstrap()?;\n\n    let mut server_provider_bootstrap_complete = false;\n    let mut client_provider_bootstrap_complete = false;\n\n    while !server_provider_bootstrap_complete || !client_provider_bootstrap_complete {\n        for event in server_provider.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Server Provider BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Server Provider Bootstrap Complete!\");\n                    server_provider_bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n\n        for event in client_provider.update()?.iter() {\n            match event {\n                TorEvent::BootstrapStatus {\n                    progress,\n                    tag,\n                    summary,\n                } =\u003e println!(\n                    \"Client Provider BootstrapStatus: {{ progress: {}, tag: {}, summary: '{}' }}\",\n                    progress, tag, summary\n                ),\n                TorEvent::BootstrapComplete =\u003e {\n                    println!(\"Client Provider Bootstrap Complete!\");\n                    client_provider_bootstrap_complete = true;\n                }\n                TorEvent::LogReceived { line } =\u003e {\n                    println!(\"--- {}\", line);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // authenticated onion service\n    {\n        // create an onion service for this test\n        let private_key = Ed25519PrivateKey::generate();\n\n        let private_auth_key = X25519PrivateKey::generate();\n        let public_auth_key = X25519PublicKey::from_private_key(\u0026private_auth_key);\n\n        println!(\"Starting and listening to authenticated onion service\");\n        const VIRT_PORT: u16 = 42069u16;\n        let listener =\n            server_provider.listener(\u0026private_key, VIRT_PORT, Some(\u0026[public_auth_key]))?;\n\n        let mut onion_published = false;\n        while !onion_published {\n            for event in server_provider.update()?.iter() {\n                match event {\n                    TorEvent::LogReceived { line } =\u003e {\n                        println!(\"--- {}\", line);\n                    }\n                    TorEvent::OnionServicePublished { service_id } =\u003e {\n                        let expected_service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n                        if expected_service_id == *service_id {\n                            println!(\n                                \"Authenticated Onion Service {} published\",\n                                service_id.to_string()\n                            );\n                            onion_published = true;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        const MESSAGE: \u0026str = \"Hello World!\";\n\n        {\n            let service_id = V3OnionServiceId::from_private_key(\u0026private_key);\n\n            println!(\"Connecting to onion service (should fail)\");\n            assert!(\n                client_provider\n                    .connect((service_id.clone(), VIRT_PORT).into(), None)\n                    .is_err(),\n                \"should not able to connect to an authenticated onion service without auth key\"\n            );\n\n            println!(\"Add auth key for onion service\");\n            client_provider.add_client_auth(\u0026service_id, \u0026private_auth_key)?;\n\n            println!(\"Connecting to onion service with authentication\");\n            let mut client =\n                client_provider.connect((service_id.clone(), VIRT_PORT).into(), None)?;\n\n            println!(\"Client writing message: '{}'\", MESSAGE);\n            client.write_all(MESSAGE.as_bytes())?;\n            client.flush()?;\n            println!(\"End of client scope\");\n\n            println!(\"Remove auth key for onion service\");\n            client_provider.remove_client_auth(\u0026service_id)?;\n        }\n\n        if let Some(mut server) = listener.accept()? {\n            println!(\"Server reading message\");\n            let mut buffer = Vec::new();\n            server.read_to_end(\u0026mut buffer)?;\n            let msg = String::from_utf8(buffer)?;\n\n            assert!(MESSAGE == msg);\n            println!(\"Message received: '{}'\", msg);\n        } else {\n            panic!(\"no listener\");\n        }\n    }\n    Ok(())\n}\n\n//\n// Mock TorProvider tests\n//\n\n#[test]\n#[cfg(feature = \"mock-tor-provider\")]\nfn test_mock_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n    bootstrap_test(Box::new(MockTorClient::new()))\n}\n\n#[test]\n#[cfg(feature = \"mock-tor-provider\")]\nfn test_mock_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let server_provider = Box::new(MockTorClient::new());\n    let client_provider = Box::new(MockTorClient::new());\n    basic_onion_service_test(server_provider, client_provider)\n}\n\n#[test]\n#[cfg(feature = \"mock-tor-provider\")]\nfn test_mock_authenticated_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let server_provider = Box::new(MockTorClient::new());\n    let client_provider = Box::new(MockTorClient::new());\n    authenticated_onion_service_test(server_provider, client_provider)\n}\n\n//\n// Legacy TorProvider tests\n//\n\n#[test]\n#[serial]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn test_legacy_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_bootstrap\");\n\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path,\n        data_directory: data_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n\n    bootstrap_test(Box::new(LegacyTorClient::new(tor_config)?))\n}\n\n#[test]\n#[serial]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn test_legacy_pluggable_transport_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_pluggable_transport_bootstrap\");\n\n    // find the lyrebird bin\n    let teb_path = std::env::var(\"TEB_PATH\")?;\n    if teb_path.is_empty() {\n        println!(\"TEB_PATH environment variable empty, so skipping test_legacy_pluggable_transport_bootstrap()\");\n        return Ok(());\n    }\n    let mut lyrebird_path = std::path::PathBuf::from(\u0026teb_path);\n    let lyrebird_bin = format!(\"lyrebird{}\", std::env::consts::EXE_SUFFIX);\n    lyrebird_path.push(lyrebird_bin.clone());\n    assert!(std::path::Path::exists(\u0026lyrebird_path));\n    assert!(std::path::Path::is_file(\u0026lyrebird_path));\n\n    // configure lyrebird pluggable transport\n    let pluggable_transport =\n        PluggableTransportConfig::new(vec![\"obfs4\".to_string()], lyrebird_path)?;\n\n    // obfs4 bridgeline\n    let bridge_line = BridgeLine::from_str(\"obfs4 207.172.185.193:22223 F34AC0CDBC06918E54292A474578C99834A58893 cert=MjqosoyVylLQuLo4LH+eQ5hS7Z44s2CaMfQbIjJtn4bGRnvLv8ldSvSED5JpvWSxm09XXg iat-mode=0\")?;\n\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path,\n        data_directory: data_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: Some(vec![pluggable_transport]),\n        bridge_lines: Some(vec![bridge_line]),\n    };\n\n    bootstrap_test(Box::new(LegacyTorClient::new(tor_config)?))\n}\n\n#[test]\n#[serial]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn test_legacy_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_onion_service_server\");\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path.clone(),\n        data_directory: data_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n    let server_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_onion_service_cient\");\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path,\n        data_directory: data_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n    let client_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    basic_onion_service_test(server_provider, client_provider)\n}\n\n#[test]\n#[serial]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn test_legacy_authenticated_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_authenticated_onion_service_server\");\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path.clone(),\n        data_directory: data_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n    let server_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_authenticated_onion_service_cient\");\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path,\n        data_directory: data_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n    let client_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    authenticated_onion_service_test(server_provider, client_provider)\n}\n\n//\n// System Legacy TorProvider tests\n//\n\n#[cfg(test)]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn start_system_tor_daemon(\n    tor_path: \u0026std::ffi::OsStr,\n    name: \u0026str,\n    control_port: u16,\n    socks_port: u16,\n) -\u003e anyhow::Result\u003cChild\u003e {\n    let mut data_path = std::env::temp_dir();\n    data_path.push(name);\n    std::fs::create_dir_all(\u0026data_path)?;\n    let default_torrc = data_path.join(\"default_torrc\");\n    {\n        let _ = File::create(\u0026default_torrc)?;\n    }\n    let torrc = data_path.join(\"torrc\");\n    {\n        let _ = File::create(\u0026torrc)?;\n    }\n\n    let tor_daemon = Command::new(tor_path)\n        .stdout(Stdio::null())\n        .stdin(Stdio::null())\n        .stderr(Stdio::null())\n        // point to our above written torrc file\n        .arg(\"--defaults-torrc\")\n        .arg(default_torrc)\n        // location of torrc\n        .arg(\"--torrc-file\")\n        .arg(torrc)\n        // enable networking\n        .arg(\"DisableNetwork\")\n        .arg(\"0\")\n        // root data directory\n        .arg(\"DataDirectory\")\n        .arg(data_path)\n        // daemon will assign us a port, and we will\n        // read it from the control port file\n        .arg(\"ControlPort\")\n        .arg(control_port.to_string())\n        // password: foobar1\n        .arg(\"HashedControlPassword\")\n        .arg(\"16:E807DCE69AFE9979600760C9758B95ADB2F95E8740478AEA5356C95358\")\n        // socks port\n        .arg(\"SocksPort\")\n        .arg(socks_port.to_string())\n        // tor process will shut down after this process shuts down\n        // to avoid orphaned tor daemon\n        .arg(\"__OwningControllerProcess\")\n        .arg(process::id().to_string())\n        .spawn()?;\n\n    Ok(tor_daemon)\n}\n\n#[test]\n#[serial]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn test_system_legacy_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n\n    let mut server_tor_daemon = start_system_tor_daemon(\n        tor_path.as_os_str(),\n        \"test_system_legacy_onion_service_server\",\n        9251u16,\n        9250u16,\n    )?;\n    let mut client_tor_daemon = start_system_tor_daemon(\n        tor_path.as_os_str(),\n        \"test_system_legacy_onion_service_client\",\n        9351u16,\n        9350u16,\n    )?;\n\n    // give daemons time to start\n    std::thread::sleep(std::time::Duration::from_secs(5));\n\n    let tor_config = LegacyTorClientConfig::SystemTor {\n        tor_socks_addr: std::net::SocketAddr::from_str(\"127.0.0.1:9250\")?,\n        tor_control_addr: std::net::SocketAddr::from_str(\"127.0.0.1:9251\")?,\n        tor_control_passwd: \"password\".to_string(),\n    };\n    let server_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    let tor_config = LegacyTorClientConfig::SystemTor {\n        tor_socks_addr: std::net::SocketAddr::from_str(\"127.0.0.1:9350\")?,\n        tor_control_addr: std::net::SocketAddr::from_str(\"127.0.0.1:9351\")?,\n        tor_control_passwd: \"password\".to_string(),\n    };\n    let client_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    basic_onion_service_test(server_provider, client_provider)?;\n\n    server_tor_daemon.kill()?;\n    client_tor_daemon.kill()?;\n\n    Ok(())\n}\n\n#[test]\n#[serial]\n#[cfg(feature = \"legacy-tor-provider\")]\nfn test_system_legacy_authenticated_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n\n    let mut server_tor_daemon = start_system_tor_daemon(\n        tor_path.as_os_str(),\n        \"test_system_legacy_authenticated_onion_service_server\",\n        9251u16,\n        9250u16,\n    )?;\n    let mut client_tor_daemon = start_system_tor_daemon(\n        tor_path.as_os_str(),\n        \"test_system_legacy_authenticated_onion_service_client\",\n        9351u16,\n        9350u16,\n    )?;\n\n    // give daemons time to start\n    std::thread::sleep(std::time::Duration::from_secs(5));\n\n    let tor_config = LegacyTorClientConfig::SystemTor {\n        tor_socks_addr: std::net::SocketAddr::from_str(\"127.0.0.1:9250\")?,\n        tor_control_addr: std::net::SocketAddr::from_str(\"127.0.0.1:9251\")?,\n        tor_control_passwd: \"password\".to_string(),\n    };\n    let server_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    let tor_config = LegacyTorClientConfig::SystemTor {\n        tor_socks_addr: std::net::SocketAddr::from_str(\"127.0.0.1:9350\")?,\n        tor_control_addr: std::net::SocketAddr::from_str(\"127.0.0.1:9351\")?,\n        tor_control_passwd: \"password\".to_string(),\n    };\n    let client_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    authenticated_onion_service_test(server_provider, client_provider)?;\n\n    server_tor_daemon.kill()?;\n    client_tor_daemon.kill()?;\n\n    Ok(())\n}\n\n//\n// Arti TorProvider tests\n//\n\n#[test]\n#[serial]\n#[cfg(feature = \"arti-client-tor-provider\")]\nfn test_arti_client_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n    let runtime: Arc\u003cruntime::Runtime\u003e = Arc::new(runtime::Runtime::new().unwrap());\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_arti_bootstrap\");\n    let tor_provider = Box::new(ArtiClientTorClient::new(runtime, \u0026data_path).unwrap());\n\n    bootstrap_test(tor_provider)\n}\n\n#[test]\n#[cfg(feature = \"arti-client-tor-provider\")]\nfn test_arti_client_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let runtime: Arc\u003cruntime::Runtime\u003e = Arc::new(runtime::Runtime::new().unwrap());\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_arti_basic_onion_service_server\");\n    let server_provider = Box::new(ArtiClientTorClient::new(runtime.clone(), \u0026data_path).unwrap());\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_arti_basic_onion_service_client\");\n    let client_provider = Box::new(ArtiClientTorClient::new(runtime.clone(), \u0026data_path).unwrap());\n\n    basic_onion_service_test(server_provider, client_provider)\n}\n\n/*\nTODO: re-enable once client-auth is available in arti\n#[test]\n#[serial]\n#[cfg(feature = \"arti-client-tor-provider\")]\nfn test_arti_authenticated_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let runtime: Arc\u003cruntime::Runtime\u003e = Arc::new(runtime::Runtime::new().unwrap());\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_arti_basic_onion_service_server\");\n    let server_provider = Box::new(ArtiClientTorClient::new(runtime.clone(), \u0026data_path).unwrap());\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_arti_basic_onion_service_client\");\n    let client_provider = Box::new(ArtiClientTorClient::new(runtime.clone(), \u0026data_path).unwrap());\n\n    authenticated_onion_service_test(server_provider, client_provider)\n}\n*/\n\n//\n// Mixed Arti/Legacy TorProvider tests\n//\n\n#[test]\n#[serial]\n#[cfg(all(feature = \"arti-client-tor-provider\", feature = \"legacy-tor-provider\"))]\nfn test_mixed_arti_client_legacy_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let runtime: Arc\u003cruntime::Runtime\u003e = Arc::new(runtime::Runtime::new().unwrap());\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_arti_legacy_basic_onion_service_server\");\n    let server_provider = Box::new(ArtiClientTorClient::new(runtime, \u0026data_path)?);\n\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_arti_legacy_basic_onion_service_client\");\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path,\n        data_directory: data_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n    let client_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    basic_onion_service_test(server_provider, client_provider)\n}\n\n#[test]\n#[serial]\n#[cfg(all(feature = \"arti-client-tor-provider\", feature = \"legacy-tor-provider\"))]\nfn test_mixed_legacy_arti_client_onion_service() -\u003e anyhow::Result\u003c()\u003e {\n    let tor_path = which::which(format!(\"tor{}\", std::env::consts::EXE_SUFFIX))?;\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_arty_basic_onion_service_client\");\n    let tor_config = LegacyTorClientConfig::BundledTor {\n        tor_bin_path: tor_path,\n        data_directory: data_path,\n        proxy_settings: None,\n        allowed_ports: None,\n        pluggable_transports: None,\n        bridge_lines: None,\n    };\n    let server_provider = Box::new(LegacyTorClient::new(tor_config)?);\n\n    let runtime: Arc\u003cruntime::Runtime\u003e = Arc::new(runtime::Runtime::new().unwrap());\n\n    let mut data_path = std::env::temp_dir();\n    data_path.push(\"test_legacy_arti_basic_onion_service_server\");\n    let client_provider = Box::new(ArtiClientTorClient::new(runtime, \u0026data_path)?);\n\n    basic_onion_service_test(server_provider, client_provider)\n}\n\n//\n// Misc Utils\n//\n\n#[test]\nfn test_tor_provider_target_addr() -\u003e anyhow::Result\u003c()\u003e {\n    let valid_ip_addr: \u0026[\u0026str] = \u0026[\n        \"192.168.1.1:80\",\n        \"10.0.0.1:443\",\n        \"172.16.0.1:8080\",\n        \"8.8.8.8:53\",\n        \"255.255.255.255:65535\",\n        \"0.0.0.0:22\",\n        \"192.168.0.254:21\",\n        \"127.0.0.1:3306\",\n        \"1.1.1.1:123\",\n        \"224.0.0.1:554\",\n        \"169.254.0.1:179\",\n        \"203.0.113.1:80\",\n        \"198.51.100.1:443\",\n        \"100.64.0.1:8080\",\n        \"192.0.2.1:53\",\n        \"192.88.99.1:22\",\n        \"192.0.0.1:21\",\n        \"240.0.0.1:3306\",\n        \"198.18.0.1:123\",\n        \"233.252.0.1:554\",\n        \"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80\",\n        \"[2001:db8:85a3::8a2e:370:7334]:443\",\n        \"[::1]:8080\",\n        \"[::ffff:192.168.1.1]:53\",\n        \"[2001:0db8::1]:22\",\n        \"[fe80::1ff:fe23:4567:890a]:21\",\n        \"[2001:db8::1:0:0:1]:3306\",\n        \"[2001:0db8:0000:0042:0000:8a2e:0370:7334]:123\",\n        \"[ff02::1]:554\",\n        \"[fe80::abcd:ef01:2345:6789]:179\",\n        \"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80\",\n        \"[2001:db8:85a3::8a2e:370:7334]:443\",\n        \"[::1]:8080\",\n        \"[::ffff:c0a8:101]:53\",\n        \"[2001:db8::1:0:0:1]:22\",\n        \"[fe80::1ff:fe23:4567:890a]:21\",\n        \"[2001:db8:0000:0042:0000:8a2e:0370:7334]:3306\",\n        \"[ff02::1]:123\",\n        \"[fe80::abcd:ef01:2345:6789]:554\",\n        \"[2001:db8::1]:179\",\n    ];\n\n    for target_addr_str in valid_ip_addr {\n        match TargetAddr::from_str(target_addr_str) {\n            Ok(TargetAddr::Socket(socket_addr)) =\u003e println!(\"{} =\u003e {}\", target_addr_str, socket_addr),\n            Ok(TargetAddr::OnionService(onion_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e OnionService({})\",\n                target_addr_str, onion_addr\n            ),\n            Ok(TargetAddr::Domain(domain_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e DomainAddr({})\",\n                target_addr_str, domain_addr\n            ),\n            Err(err) =\u003e Err(err)?,\n        }\n    }\n\n    let valid_onion_addr: \u0026[\u0026str] = \u0026[\n        \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd.onion:65535\",\n        \"6L62FW7TQCTLU5FESDQUKVPOXEZKAXBZLLRAFA2VE6EWUHZPHXCZSJYD.onion:1\",\n    ];\n\n    for target_addr_str in valid_onion_addr {\n        match TargetAddr::from_str(target_addr_str) {\n            Ok(TargetAddr::Socket(socket_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e Ip({})\",\n                target_addr_str, socket_addr\n            ),\n            Ok(TargetAddr::OnionService(onion_addr)) =\u003e {\n                println!(\"{} =\u003e {}\", target_addr_str, onion_addr)\n            }\n            Ok(TargetAddr::Domain(domain_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e DomainAddr({})\",\n                target_addr_str, domain_addr\n            ),\n            Err(err) =\u003e Err(err)?,\n        }\n    }\n\n    let valid_domain_addr: \u0026[\u0026str] = \u0026[\n        \"example.com:80\",\n        \"subdomain.example.com:443\",\n        \"xn--e1afmkfd.xn--p1ai:8080\",       // domain in Punycode for \".\"\n        \"xn--fsqu00a.xn--0zwm56d:53\",       // domain in Punycode for \".\"\n        \"mnich.com:22\",                    // domain with UTF-8 characters\n        \"xn--mnich-kva.com:21\",             // Punycode for \"mnich.com\"\n        \"exmple.com:3306\",                 // domain with UTF-8 characters\n        \"xn--exmple-cua.com:123\",           // Punycode for \"exmple.com\"\n        \".com:554\",                      // domain with UTF-8 characters\n        \"xn--fsqu00a.com:179\",              // Punycode for \".com\"\n        \"tst.de:80\",                       // domain with UTF-8 characters\n        \"xn--tst-qla.de:443\",               // Punycode for \"tst.de\"\n        \"xn--fiqs8s:80\",                    // Punycode for \"\"\n        \"xn--wgbh1c:8080\",                  // Punycode for \"\"\n        \"mnster.de:22\",                    // domain with UTF-8 characters\n        \"xn--mnster-3ya.de:21\",             // Punycode for \"mnster.de\"\n        \"bcher.com:3306\",                  // domain with UTF-8 characters\n        \"xn--bcher-kva.com:123\",            // Punycode for \"bcher.com\"\n        \"xn--vermgensberatung-pwb.com:554\", // Punycode for \"vermgensberatung.com\"\n        // Max Length\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd:65535\"\n    ];\n\n    for target_addr_str in valid_domain_addr {\n        match TargetAddr::from_str(target_addr_str) {\n            Ok(TargetAddr::Socket(socket_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e SocketAddr({})\",\n                target_addr_str, socket_addr\n            ),\n            Ok(TargetAddr::OnionService(onion_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e OnionService({})\",\n                target_addr_str, onion_addr\n            ),\n            Ok(TargetAddr::Domain(domain_addr)) =\u003e {\n                println!(\"{} =\u003e {}\", target_addr_str, domain_addr)\n            }\n            Err(err) =\u003e Err(err)?,\n        }\n    }\n\n    let invalid_target_addr: \u0026[\u0026str] = \u0026[\n        // ipv4-ish\n        \"192.168.1.1:99999\", // Port number out of range\n        \"192.168.1.1:abc\",   // Invalid port number\n        \"192.168.1.1:\",      // Missing port number\n        \"192.168.1.1: 80\",   // Space in port number\n        \"192.168.1.1:80a\",   // Non-numeric characters in port number\n        // ipv6-ish\n        \"[2001:db8:::1]:80\",                            // Triple colons\n        \"[2001:db8:85a3::8a2e:370:7334:1234::abcd]:80\", // Too many groups\n        \"[2001:db8:85a3::8a2e:370g:7334]:80\",           // Invalid character in group\n        \"[2001:db8:85a3::8a2e:370:7334]:99999\",         // Port number out of range\n        \"[2001:db8:85a3:8a2e:370:7334]:80\",             // Missing double colons\n        \"[::12345]:80\",                                 // Excessive leading zeroes\n        \"[2001:db8:85a3::8a2e:370:7334:]:80\",           // Trailing colon\n        \"[2001:db8:85a3::8a2e:370:7334]\",               // Missing port number\n        \"2001:db8:85a3::8a2e:370:7334:80\",              // Missing square brackets\n        \"[2001:db8:85a3::8a2e:370:7334]: 80\",           // Space in port number\n        \"[2001:db8:85a3::8a2e:370:7334]:80a\",           // Non-numeric characters in port number\n        // onion service-ish\n        \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd234567.onion:80\", // Too long for v3\n        \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxcz.onion:443\", // Too short for v3\n        \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd.onion:99999\", // Port number out of range\n        \"abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrst.onion:21\", // Invalid characters\n        \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd.onion:abc\", // Invalid port number\n        \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd.onion: 80\", // Space in port number\n        \"6l62fw7tqctlu5fesdqukvpoxezkaxbzllrafa2ve6ewuhzphxczsjyd.onion:80a\", // Non-numeric characters in port number\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.onion:80\",  // Invalid service id\n        // domain-ish\n        \"example..com:80\",        // Double dots\n        \"exa mple.com:53\",        // Space in domain\n        \"example.com:99999\",      // Port number out of range\n        \"exaample.com:abc\",       // Invalid port number\n        \"exaample.com:\",          // Missing port number\n        \"exaample.com: 80\",       // Space in port number\n        \"ex@mple.com:80\",         // Special character in domain\n        \"example.com:80a\",        // Non-numeric characters in port number\n        \"exmple..com:80\",        // UTF-8 with double dot\n        \"xn--exmple-cua.com: 80\", // Punycode with space in port number\n        \"xn--exmple-cua.com:80a\", // Punycode with non-numeric port\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.com:65535\", // Label too long\n    ];\n\n    for target_addr_str in invalid_target_addr {\n        match TargetAddr::from_str(target_addr_str) {\n            Ok(TargetAddr::Socket(socket_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e SocketAddr({})\",\n                target_addr_str, socket_addr\n            ),\n            Ok(TargetAddr::OnionService(onion_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e OnionService({})\",\n                target_addr_str, onion_addr\n            ),\n            Ok(TargetAddr::Domain(domain_addr)) =\u003e panic!(\n                \"unexpected conversion: {} =\u003e DomainAddr({})\",\n                target_addr_str, domain_addr\n            ),\n            Err(_) =\u003e (),\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":30,"address":[1439044,1438913,1437440],"length":1,"stats":{"Line":1}},{"line":31,"address":[1437536,1437447,1437596,1438212,1439037],"length":1,"stats":{"Line":2}},{"line":33,"address":[1437578],"length":1,"stats":{"Line":1}},{"line":34,"address":[1437586],"length":1,"stats":{"Line":1}},{"line":35,"address":[1437674,1437594],"length":1,"stats":{"Line":2}},{"line":36,"address":[1438162,1438927,1437745,1438008,1437684],"length":1,"stats":{"Line":4}},{"line":37,"address":[1438183],"length":1,"stats":{"Line":1}},{"line":38,"address":[1438249],"length":1,"stats":{"Line":1}},{"line":46,"address":[1438834],"length":1,"stats":{"Line":1}},{"line":47,"address":[1438807,1438360],"length":1,"stats":{"Line":2}},{"line":48,"address":[1438826],"length":1,"stats":{"Line":1}},{"line":50,"address":[1438394],"length":1,"stats":{"Line":1}},{"line":51,"address":[1438406],"length":1,"stats":{"Line":1}},{"line":52,"address":[1438839],"length":1,"stats":{"Line":1}},{"line":58,"address":[1437710],"length":1,"stats":{"Line":1}},{"line":63,"address":[1438970],"length":1,"stats":{"Line":1}},{"line":66,"address":[1441434,1447239,1439072],"length":1,"stats":{"Line":1}},{"line":70,"address":[1440735,1439126,1439304,1439230,1447208],"length":1,"stats":{"Line":2}},{"line":71,"address":[1439272,1439461,1439401,1447187],"length":1,"stats":{"Line":2}},{"line":73,"address":[1439443],"length":1,"stats":{"Line":1}},{"line":74,"address":[1439451],"length":1,"stats":{"Line":1}},{"line":76,"address":[1439584,1439542,1439459],"length":1,"stats":{"Line":3}},{"line":77,"address":[1442182,1440107,1439648,1439552,1439926],"length":1,"stats":{"Line":4}},{"line":78,"address":[1440131],"length":1,"stats":{"Line":1}},{"line":79,"address":[1441515],"length":1,"stats":{"Line":1}},{"line":87,"address":[1442095],"length":1,"stats":{"Line":1}},{"line":88,"address":[1441626,1442068],"length":1,"stats":{"Line":2}},{"line":89,"address":[1442087],"length":1,"stats":{"Line":1}},{"line":91,"address":[1441663],"length":1,"stats":{"Line":1}},{"line":92,"address":[1442100],"length":1,"stats":{"Line":1}},{"line":98,"address":[1441451,1440492,1440166,1440676],"length":1,"stats":{"Line":3}},{"line":99,"address":[1440700],"length":1,"stats":{"Line":1}},{"line":100,"address":[1440775],"length":1,"stats":{"Line":1}},{"line":108,"address":[1441355],"length":1,"stats":{"Line":1}},{"line":109,"address":[1440886,1441328],"length":1,"stats":{"Line":2}},{"line":110,"address":[1441347],"length":1,"stats":{"Line":1}},{"line":112,"address":[1440923],"length":1,"stats":{"Line":1}},{"line":113,"address":[1441360],"length":1,"stats":{"Line":1}},{"line":122,"address":[1439602],"length":1,"stats":{"Line":1}},{"line":125,"address":[1439610],"length":1,"stats":{"Line":1}},{"line":127,"address":[1442195,1442265],"length":1,"stats":{"Line":2}},{"line":129,"address":[1442467,1442284,1447166],"length":1,"stats":{"Line":1}},{"line":131,"address":[1442457],"length":1,"stats":{"Line":1}},{"line":132,"address":[1442465,1442548],"length":1,"stats":{"Line":2}},{"line":133,"address":[1442696,1442974,1442558,1443158,1443786],"length":1,"stats":{"Line":4}},{"line":134,"address":[1443182],"length":1,"stats":{"Line":1}},{"line":135,"address":[1443228],"length":1,"stats":{"Line":0}},{"line":136,"address":[1443390],"length":1,"stats":{"Line":0}},{"line":138,"address":[1443344],"length":1,"stats":{"Line":1}},{"line":139,"address":[1443363],"length":1,"stats":{"Line":1}},{"line":140,"address":[1443773,1443480],"length":1,"stats":{"Line":2}},{"line":141,"address":[1443518,1443633],"length":1,"stats":{"Line":1}},{"line":142,"address":[1443765],"length":1,"stats":{"Line":1}},{"line":153,"address":[1442598],"length":1,"stats":{"Line":1}},{"line":154,"address":[1442606],"length":1,"stats":{"Line":1}},{"line":156,"address":[1443816],"length":1,"stats":{"Line":1}},{"line":157,"address":[1443861],"length":1,"stats":{"Line":1}},{"line":159,"address":[1443872],"length":1,"stats":{"Line":1}},{"line":160,"address":[1444123],"length":1,"stats":{"Line":1}},{"line":161,"address":[1444272],"length":1,"stats":{"Line":0}},{"line":162,"address":[1446950],"length":1,"stats":{"Line":0}},{"line":163,"address":[1447060,1447019],"length":1,"stats":{"Line":0}},{"line":164,"address":[1447048],"length":1,"stats":{"Line":0}},{"line":165,"address":[1447081,1447129],"length":1,"stats":{"Line":0}},{"line":170,"address":[1444441],"length":1,"stats":{"Line":1}},{"line":171,"address":[1444537,1444660,1446874],"length":1,"stats":{"Line":1}},{"line":172,"address":[1446839,1439094,1444703,1444787,1444636],"length":1,"stats":{"Line":3}},{"line":173,"address":[1444761,1444825],"length":1,"stats":{"Line":2}},{"line":176,"address":[1446741,1444863],"length":1,"stats":{"Line":1}},{"line":177,"address":[1445204,1445303],"length":1,"stats":{"Line":2}},{"line":178,"address":[1445322],"length":1,"stats":{"Line":1}},{"line":179,"address":[1446501,1445341,1445437,1445574],"length":1,"stats":{"Line":2}},{"line":180,"address":[1445780,1445612,1446476,1445511],"length":1,"stats":{"Line":2}},{"line":182,"address":[1445906,1445738],"length":1,"stats":{"Line":2}},{"line":183,"address":[1446075],"length":1,"stats":{"Line":1}},{"line":185,"address":[1446630,1445230],"length":1,"stats":{"Line":0}},{"line":188,"address":[1446375],"length":1,"stats":{"Line":1}},{"line":191,"address":[1447264,1449610,1456297],"length":1,"stats":{"Line":1}},{"line":195,"address":[1447422,1447496,1456266,1447318,1448911],"length":1,"stats":{"Line":2}},{"line":196,"address":[1456245,1447653,1447593,1447464],"length":1,"stats":{"Line":2}},{"line":198,"address":[1447635],"length":1,"stats":{"Line":1}},{"line":199,"address":[1447643],"length":1,"stats":{"Line":1}},{"line":201,"address":[1447776,1447651,1447734],"length":1,"stats":{"Line":3}},{"line":202,"address":[1447744,1447824,1448283,1450358,1448102],"length":1,"stats":{"Line":4}},{"line":203,"address":[1448307],"length":1,"stats":{"Line":1}},{"line":204,"address":[1450138],"length":1,"stats":{"Line":1}},{"line":212,"address":[1450271],"length":1,"stats":{"Line":1}},{"line":213,"address":[1449802,1450244],"length":1,"stats":{"Line":2}},{"line":214,"address":[1450263],"length":1,"stats":{"Line":1}},{"line":216,"address":[1449839],"length":1,"stats":{"Line":1}},{"line":217,"address":[1450276],"length":1,"stats":{"Line":1}},{"line":223,"address":[1449627,1448342,1448668,1448852],"length":1,"stats":{"Line":3}},{"line":224,"address":[1448876],"length":1,"stats":{"Line":1}},{"line":225,"address":[1448951],"length":1,"stats":{"Line":1}},{"line":233,"address":[1449531],"length":1,"stats":{"Line":1}},{"line":234,"address":[1449504,1449062],"length":1,"stats":{"Line":2}},{"line":235,"address":[1449523],"length":1,"stats":{"Line":1}},{"line":237,"address":[1449099],"length":1,"stats":{"Line":1}},{"line":238,"address":[1449536],"length":1,"stats":{"Line":1}},{"line":248,"address":[1447786],"length":1,"stats":{"Line":1}},{"line":250,"address":[1450371],"length":1,"stats":{"Line":1}},{"line":251,"address":[1450434],"length":1,"stats":{"Line":1}},{"line":253,"address":[1450502],"length":1,"stats":{"Line":1}},{"line":255,"address":[1450778,1456205,1450547],"length":1,"stats":{"Line":1}},{"line":258,"address":[1450768],"length":1,"stats":{"Line":1}},{"line":259,"address":[1450776,1450859],"length":1,"stats":{"Line":2}},{"line":260,"address":[1450869,1451269,1452081,1450991,1451453],"length":1,"stats":{"Line":4}},{"line":261,"address":[1451477],"length":1,"stats":{"Line":1}},{"line":262,"address":[1451523],"length":1,"stats":{"Line":0}},{"line":263,"address":[1451685],"length":1,"stats":{"Line":0}},{"line":265,"address":[1451639],"length":1,"stats":{"Line":1}},{"line":266,"address":[1451658],"length":1,"stats":{"Line":1}},{"line":267,"address":[1451775,1452068],"length":1,"stats":{"Line":2}},{"line":268,"address":[1451813],"length":1,"stats":{"Line":1}},{"line":272,"address":[1452060],"length":1,"stats":{"Line":1}},{"line":283,"address":[1450901],"length":1,"stats":{"Line":1}},{"line":285,"address":[1452111],"length":1,"stats":{"Line":1}},{"line":286,"address":[1452466,1452413],"length":1,"stats":{"Line":0}},{"line":293,"address":[1452542],"length":1,"stats":{"Line":1}},{"line":294,"address":[1452719,1456165,1452587],"length":1,"stats":{"Line":1}},{"line":296,"address":[1452800,1452693],"length":1,"stats":{"Line":2}},{"line":297,"address":[1453245,1452819,1456144],"length":1,"stats":{"Line":1}},{"line":300,"address":[1453370],"length":1,"stats":{"Line":1}},{"line":301,"address":[1453466,1456126,1453589],"length":1,"stats":{"Line":1}},{"line":302,"address":[1456111,1453716,1453632,1453565],"length":1,"stats":{"Line":2}},{"line":303,"address":[1453690,1453754],"length":1,"stats":{"Line":2}},{"line":305,"address":[1453773],"length":1,"stats":{"Line":1}},{"line":306,"address":[1453818,1456076,1447286,1453935],"length":1,"stats":{"Line":2}},{"line":309,"address":[1455918,1454013],"length":1,"stats":{"Line":1}},{"line":310,"address":[1454354,1454453],"length":1,"stats":{"Line":2}},{"line":311,"address":[1454472],"length":1,"stats":{"Line":1}},{"line":312,"address":[1455659,1454724,1454491,1454587],"length":1,"stats":{"Line":2}},{"line":313,"address":[1455634,1454762,1454661,1454914],"length":1,"stats":{"Line":2}},{"line":315,"address":[1455040,1454888],"length":1,"stats":{"Line":2}},{"line":316,"address":[1455173],"length":1,"stats":{"Line":1}},{"line":318,"address":[1455807,1454380],"length":1,"stats":{"Line":0}},{"line":321,"address":[1455533],"length":1,"stats":{"Line":1}},{"line":485,"address":[1456320,1458633,1458834],"length":1,"stats":{"Line":1}},{"line":491,"address":[1456427],"length":1,"stats":{"Line":1}},{"line":492,"address":[1456508],"length":1,"stats":{"Line":1}},{"line":493,"address":[1458803,1456694,1456387,1456568],"length":1,"stats":{"Line":2}},{"line":494,"address":[1456663,1456743],"length":1,"stats":{"Line":2}},{"line":496,"address":[1456783,1458738,1456867],"length":1,"stats":{"Line":2}},{"line":498,"address":[1456976],"length":1,"stats":{"Line":1}},{"line":500,"address":[1457055,1458673,1457139],"length":1,"stats":{"Line":2}},{"line":503,"address":[1458219,1457700,1457256,1457486,1457592,1457868,1457953,1457354,1458104,1458410,1457424],"length":1,"stats":{"Line":10}},{"line":504,"address":[1457275],"length":1,"stats":{"Line":1}},{"line":505,"address":[1457381],"length":1,"stats":{"Line":1}},{"line":506,"address":[1457443],"length":1,"stats":{"Line":1}},{"line":509,"address":[1457552],"length":1,"stats":{"Line":1}},{"line":512,"address":[1457660],"length":1,"stats":{"Line":1}},{"line":518,"address":[1457828],"length":1,"stats":{"Line":1}},{"line":522,"address":[1457941],"length":1,"stats":{"Line":1}},{"line":528,"address":[1458092],"length":1,"stats":{"Line":1}},{"line":532,"address":[1458161],"length":1,"stats":{"Line":1}},{"line":535,"address":[1458479],"length":1,"stats":{"Line":1}}],"covered":144,"coverable":156}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>